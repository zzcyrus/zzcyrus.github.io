{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":1,"renderable":0},{"_id":"source/google56eca6eee2792f06.html","path":"google56eca6eee2792f06.html","modified":1,"renderable":0},{"_id":"themes/maupassant/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/donate.css","path":"css/donate.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/default.css","path":"css/default.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/donate/index.html","path":"donate/index.html","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/AliPayQR.png","path":"img/AliPayQR.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/BTCQR.png","path":"img/BTCQR.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/alipay.svg","path":"img/alipay.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/github.svg","path":"img/github.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/bitcoin.svg","path":"img/bitcoin.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/WeChatQR.png","path":"img/WeChatQR.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/paypal.svg","path":"img/paypal.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/like.svg","path":"img/like.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/wechat.svg","path":"img/wechat.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/donate.js","path":"js/donate.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/gitment.browser.js","path":"js/gitment.browser.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"70643c718cb37d38c76538362733dd69f1ced96a","modified":1548833343648},{"_id":"source/.DS_Store","hash":"b48c4f7d61a5928be717d4bd654481ff1eab36ee","modified":1552392158818},{"_id":"source/robots.txt","hash":"fbc461c7d26b20c1da0d2e479947ebe76e839d8f","modified":1561689639368},{"_id":"themes/maupassant/.gitignore","hash":"16945417d10c15c950306794dbb0d970b5a199fe","modified":1576660280434},{"_id":"source/google56eca6eee2792f06.html","hash":"1a362462d2e6419a55873168085e6403c0ac265b","modified":1548833343654},{"_id":"themes/maupassant/LICENSE","hash":"f0ac2f92770650c9835183f79010c0d307b34acd","modified":1576660280435},{"_id":"themes/maupassant/README.md","hash":"1e45ec576bcb84881717dd8e1c28d6f7c251542b","modified":1576660280435},{"_id":"themes/maupassant/.travis.yml","hash":"0339959f29deddc365e8fe8bd85da524410b9a23","modified":1576660280435},{"_id":"themes/maupassant/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1577027314576},{"_id":"themes/maupassant/_config.yml","hash":"9dba08a0a9b1a8d1af685d8492610cc921cc83b4","modified":1589705039035},{"_id":"themes/maupassant/package.json","hash":"f092433469eb87362e831326425a6a5c3c9fea0d","modified":1576660280441},{"_id":"source/_posts/.DS_Store","hash":"9b52df4fb81b91b7d8767a2e73f3df9ae21c060e","modified":1552392176581},{"_id":"source/categories/index.md","hash":"498172edabec6245e809f4cacd923b611f1ddaf4","modified":1548833343654},{"_id":"source/tags/index.md","hash":"4230d358e4bac33c4ef402453064f9623ba41b55","modified":1548833343654},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"5d3556a885e355a8c2da65ef3e7b3ee36a628bfa","modified":1576660280436},{"_id":"themes/maupassant/languages/en.yml","hash":"c3fb5c155560a00889a75882c680afe1197ebf1a","modified":1576660280436},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1576660280436},{"_id":"themes/maupassant/languages/ru.yml","hash":"2476a631f4d3c668de04af85a6c2c97ba2a57e96","modified":1576660280436},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1576660280436},{"_id":"themes/maupassant/languages/ko.yml","hash":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1576660280436},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"d23c90d3c1c064fe062dad8047e919de097080ca","modified":1577026777800},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"209e8bf9f17a4c483e9912f5a42b54435abd741b","modified":1577026767225},{"_id":"themes/maupassant/layout/archive.pug","hash":"2fe2cff144c9b7b509b7b6cb1b3acba27aa1d132","modified":1576660280440},{"_id":"themes/maupassant/layout/base-without-sidebar.pug","hash":"16c4d1079450f801b5ac079d3cc101856d8f387c","modified":1576660280440},{"_id":"themes/maupassant/layout/base.pug","hash":"a4e32bcb580b76af9ad0582d9d3f0107e34509ed","modified":1576660280440},{"_id":"themes/maupassant/layout/page.pug","hash":"8cfd307b13cad8be34a1e75c4566f96c1722e08e","modified":1576660280440},{"_id":"themes/maupassant/layout/post.pug","hash":"564d18da309a3102d88e76df6fe67201297bf21b","modified":1577026634931},{"_id":"themes/maupassant/layout/index.pug","hash":"0435a4e5f5c6976e05b3079d335453c246f5ba6e","modified":1576660280440},{"_id":"themes/maupassant/layout/single-column.pug","hash":"0593f261dc208bb0b5c4232eb41eff597a291bd9","modified":1576660280440},{"_id":"themes/maupassant/layout/timeline.pug","hash":"84fbfc92ccdf291b491140d89557553141a5d3f9","modified":1576660280441},{"_id":"themes/maupassant/layout/tagcloud.pug","hash":"195cde32be65817fd4ed03590c71522913f1e1b8","modified":1576660280441},{"_id":"themes/maupassant/source/.DS_Store","hash":"93c279492c121bc69b2814db7c0759061b824f00","modified":1577024382116},{"_id":"themes/maupassant/source/favicon.ico","hash":"46701792b80cabc9ab9851fd00735abe180381c3","modified":1577024413709},{"_id":"source/_posts/2018/Vue-Parent-and-Child-lifecycle-hooks.md","hash":"800ffe1fff67232b425e092a4d1ac8e88920b7c1","modified":1561701326943},{"_id":"source/_posts/2017/basemap.md","hash":"d20c9bd23b53f22970aa5a4a77979c8981676006","modified":1589703696035},{"_id":"source/_posts/2017/openlayers-canvas-typhoon.md","hash":"fe57a3c6d234395b22b7b2a771250eac8cae34b4","modified":1589703696006},{"_id":"source/_posts/2020/radar-vector-tile-try.md","hash":"d8d9212404671070895e9502751c6489b7baaca6","modified":1592895611492},{"_id":"source/_posts/2017/vue-dialog-nested.md","hash":"aed35b6655fd4774c42b53a1071ae626e3879e03","modified":1561701401472},{"_id":"source/_posts/2017/plugins.md","hash":"b923ed86f0c8cd0759c41367969c7b8bc26346bc","modified":1589703696011},{"_id":"source/_posts/2017/vector-tile-openlayers-try.md","hash":"11c1841dd13c26bd8428930f07ef897fc4325142","modified":1589703695998},{"_id":"source/_posts/2020/web-grid-data-render-1.md","hash":"e08959138c5e3907a8e1180647a058c143686cf5","modified":1589704386717},{"_id":"source/_posts/2019/openstreetmap-carto-map.md","hash":"950c8332c47cd2f5bcd99a295fa4590881913df4","modified":1577025053312},{"_id":"source/_posts/2019/mongoDB-geospatial.md","hash":"e0512853ef2e32430f53751a5a9e20e41a6a02f9","modified":1561701348716},{"_id":"source/_posts/2019/leaflet-canvas-marker.md","hash":"7afcc471b0837ebdd48ca7f13d951828b1e467cb","modified":1589703696012},{"_id":"source/_posts/2019/osm-PostGIS-setup.md","hash":"c4ccb09edf5e1d42842f214e9af7a0fa8c57f70c","modified":1561701388441},{"_id":"source/_posts/2019/tilestrata-dependency.md","hash":"becc432e582a2846d294161e5e0e4b567275cd00","modified":1562490243888},{"_id":"source/_posts/2019/tilestrata-disk.md","hash":"7d344b128240f9782daae057cdd895eba1679ee8","modified":1563198100872},{"_id":"source/_posts/2019/tilestrata-blend.md","hash":"45aab393a2b4e085dca7f77b924b6322d36f823b","modified":1562570593198},{"_id":"source/_posts/2019/osm-postgis-mvt.md","hash":"c629dbc54e6d6efe6b2e4cba764b39fa11833ffb","modified":1564654134927},{"_id":"source/_posts/2019/tilestrata-etag.md","hash":"659b3be29b0e08d8ebb7921d15b754e05af2e965","modified":1563198053156},{"_id":"source/_posts/2019/tilestrata-headers.md","hash":"93da9c621c628ebf94ce615042775754e7832169","modified":1561701388441},{"_id":"source/_posts/2019/tilestrata-gm.md","hash":"95bc4be17c45f024b7d50290087268164bfdc5a8","modified":1563109228449},{"_id":"source/_posts/2019/tilestrata-intro.md","hash":"41a461c509a1ee7d4e6db0fe559f761bbc8f2751","modified":1563445002601},{"_id":"source/_posts/2019/tilestrata-jsonp.md","hash":"0db4037986b4b2b239dc3b66a1b4c19f5e8b4841","modified":1561701388441},{"_id":"source/_posts/2019/tilestrata-mapnik.md","hash":"4a27ebb0f8f4f9edcd3bb5cf2a27e41470c816ac","modified":1561701388441},{"_id":"source/_posts/2019/tilestrata-lru.md","hash":"04f9aa2835955446d442781c30797d8404506039","modified":1562856767660},{"_id":"source/_posts/2019/tilestrata-plugin.md","hash":"b7092851354b32bdd047022b6e203869eeb448fd","modified":1563790726341},{"_id":"source/_posts/2019/tilestrata-postgismvt.md","hash":"9f6d1bf39c08a873da383de2abdcf3ba0b54e0dc","modified":1561701388441},{"_id":"source/_posts/2019/tilestrata-sharp.md","hash":"b3acbd0209e61709e28be382e7d3c97725cabfd1","modified":1563109139927},{"_id":"source/_posts/2019/tilestrata-underzoom.md","hash":"9cf6764c572e27613ac523e3fb608f5054d31487","modified":1562856599188},{"_id":"source/_posts/2019/tilestrata-postgis-geojson-tiles.md","hash":"45faae302a9f4ae053bea14599262b40ad279325","modified":1562075151353},{"_id":"themes/maupassant/layout/_partial/comments.pug","hash":"507fd8d2fde98df6216ed7c8f60ebea7cf77bfb2","modified":1576660280437},{"_id":"themes/maupassant/layout/_partial/after_footer.pug","hash":"64775b92675d45d9b76e99506ca63be0c0feea83","modified":1577026128243},{"_id":"source/_posts/2019/tilestrata-vtile-raster.md","hash":"52db933abebf2b0d780687f7260b00be15af2c69","modified":1562306936914},{"_id":"source/_posts/2019/tilestrata-vtile.md","hash":"7218777979725cf8d6896514d7fcee63a0d0e210","modified":1562233347139},{"_id":"source/_posts/2019/tilestrata-vtile-composite.md","hash":"0ebf0c01c96ea7f6033e006a8b5894cf3a078dee","modified":1562489900921},{"_id":"themes/maupassant/layout/_partial/footer.pug","hash":"650781b5bc8c632658ad6880ba663b1e3bfb5798","modified":1576660280437},{"_id":"themes/maupassant/layout/_partial/mathjax.pug","hash":"b54b56faff9e47ab3ca3cdd55056c73e60776f3c","modified":1576660280438},{"_id":"themes/maupassant/layout/_partial/helpers.pug","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1576660280438},{"_id":"themes/maupassant/layout/_partial/head.pug","hash":"8af6e452ea2a56b110b5079f79bf743b643f7d6c","modified":1576660280438},{"_id":"themes/maupassant/layout/_partial/post_nav.pug","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1576660280438},{"_id":"themes/maupassant/layout/_partial/mermaid.pug","hash":"64432e381b305a8ed2d7b3b6459604a4da18fbc1","modified":1577026236188},{"_id":"themes/maupassant/layout/_partial/paginator.pug","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1576660280438},{"_id":"themes/maupassant/layout/_partial/mathjax2.pug","hash":"d6ac5dc4e9c7a1b866f1f92d88988cfb35aded4c","modified":1576660280438},{"_id":"themes/maupassant/layout/_partial/tag.pug","hash":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1576660280438},{"_id":"themes/maupassant/layout/_partial/wordcount.pug","hash":"004c8a3edc19d428179b83a0f97eae3c1a6d3cfa","modified":1576660280439},{"_id":"themes/maupassant/layout/_partial/totop.pug","hash":"8225bbc3cdb9648bc2e6872e5c616a9a1e4def4f","modified":1576660280439},{"_id":"themes/maupassant/layout/_widget/category.pug","hash":"7c6aed762934ca51aa2669b886254da24b77bc14","modified":1576660280439},{"_id":"themes/maupassant/layout/_widget/recent_comments.pug","hash":"4102d446f13b02ff617f055c2a8f726bca12744a","modified":1576660280439},{"_id":"themes/maupassant/layout/_widget/links.pug","hash":"c45aa7ec00158579e58f1f8dfd890447bb5e5e54","modified":1576660280439},{"_id":"themes/maupassant/layout/_widget/recent_posts.pug","hash":"19431336d724d2118e46da43683bce9063176541","modified":1576660280439},{"_id":"themes/maupassant/layout/_widget/search.pug","hash":"6e8e4123cca38840c4607c1a056205972b82bb7b","modified":1576660280439},{"_id":"themes/maupassant/layout/_widget/tag.pug","hash":"132f049ce677d0e38f50073174c4ee4b825d4a06","modified":1576660280439},{"_id":"themes/maupassant/source/css/donate.css","hash":"f019876946aeb80e567ece250d54c1327c794583","modified":1576660280441},{"_id":"themes/maupassant/source/css/default.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1576660280441},{"_id":"themes/maupassant/source/donate/index.html","hash":"c42428765d48c8674ce28100ad95fdf4c7806a85","modified":1576660280442},{"_id":"themes/maupassant/source/css/style.scss","hash":"44c876b3b2f05d2639659590cfe533a277e166d7","modified":1576660280442},{"_id":"themes/maupassant/source/img/AliPayQR.png","hash":"7787b5d91cbf0e19a1260df24f7d949771c7d45b","modified":1576660280442},{"_id":"themes/maupassant/source/img/BTCQR.png","hash":"7d1c80f953bfb6f0a37d432b04c936ea165bfd97","modified":1576660280443},{"_id":"themes/maupassant/source/img/alipay.svg","hash":"46cc0552a9f6d700d618db3fcad25e1b8e697e36","modified":1576660280443},{"_id":"themes/maupassant/source/img/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1576660280443},{"_id":"themes/maupassant/source/img/bitcoin.svg","hash":"635f7cca5e675d192be2717788175c7a2146013a","modified":1576660280443},{"_id":"themes/maupassant/source/img/WeChatQR.png","hash":"8c41aca7883e5ff714c56556f5fff8e7e7c38093","modified":1576660280443},{"_id":"themes/maupassant/source/img/paypal.svg","hash":"92f3bc495f20a0190d3041be03345c46d6238c25","modified":1576660280444},{"_id":"themes/maupassant/source/img/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1576660280444},{"_id":"themes/maupassant/source/img/wechat.svg","hash":"330496ad42446a29f37a2b97fc388ebd77a8cb9f","modified":1576660280444},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1576660280445},{"_id":"themes/maupassant/source/js/donate.js","hash":"780beaaf44b1e6c057752bdbc085b1048937e5e7","modified":1576660280445},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1576660280445},{"_id":"themes/maupassant/source/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1576660280446},{"_id":"themes/maupassant/source/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1576660280446},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1576660280446},{"_id":"themes/maupassant/source/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1576660280446},{"_id":"source/_posts/2018/Vue-Parent-and-Child-lifecycle-hooks/parent-child-hooks.png","hash":"d60fd1f5961cb7afbd5fc0710507d4ba3314dabb","modified":1548833343651},{"_id":"source/_posts/2017/openlayers-canvas-typhoon/canvasSymbol.png","hash":"68cee9b60f04aa63d6ad864065e4ed5b65de0a93","modified":1548833343652},{"_id":"source/_posts/2017/openlayers-canvas-typhoon/goal.png","hash":"b299febc94934b1afa2e69eef9dd587e9cfc7b55","modified":1548833343652},{"_id":"themes/maupassant/source/js/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1576660280446},{"_id":"source/_posts/2017/vector-tile-openlayers-try/network.png","hash":"3c247aaf66bdbc8a21e4865748d6816ff717402b","modified":1548833343654},{"_id":"source/_posts/2017/plugins/tileWMS.png","hash":"ba3e69080062ee93f14f735bb9cc06e6cf93de1c","modified":1548833343653},{"_id":"source/_posts/2018/Vue-Parent-and-Child-lifecycle-hooks/lifecircle.png","hash":"ab511f99adcdfd840e6b40c08ec78409dbae5f31","modified":1548833343651},{"_id":"source/_posts/2019/osm-PostGIS-setup/distance.png","hash":"7d394bc25962a976dbfa3486737521b7329894b4","modified":1552392035270},{"_id":"source/_posts/2017/openlayers-canvas-typhoon/canvasLayer.png","hash":"f105722102cab4559d9c8e2652d8f91e6ea89c8f","modified":1548833343652},{"_id":"source/_posts/2019/osm-PostGIS-setup/polygon.png","hash":"e5488fc7a817abe192d859819372e7293a57f1ed","modified":1552391985618},{"_id":"source/_posts/2019/osm-PostGIS-setup/point.png","hash":"5374198300a2015738c9798c118f4c21b05944ef","modified":1552391957399}],"Category":[{"name":"前端","_id":"ckbrkxgub000xi83il2q9nw3t"},{"name":"WebGIS","_id":"ckbrkxguj000zi83ipu8stqwg"},{"name":"PostGIS","_id":"ckbrkxgup001di83iw0l6q6al"},{"name":"Node","_id":"ckbrkxgup001fi83iush7rrb0"},{"name":"TileStrata","_id":"ckbrkxgus001li83ig1vhqxv2"}],"Data":[],"Page":[{"title":"Categories","date":"2017-06-21T12:55:51.000Z","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: Categories\ndate: 2017-06-21 20:55:51\nlayout: \"categories\"\n---\n","updated":"2019-01-30T07:29:03.654Z","path":"categories/index.html","comments":1,"_id":"ckbrkxgmi0000i83iglfzd91p","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Tags","date":"2017-06-21T12:55:39.000Z","layout":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: Tags\ndate: 2017-06-21 20:55:39\nlayout: \"tags\"\ncomments: false\n---\n","updated":"2019-01-30T07:29:03.654Z","path":"tags/index.html","_id":"ckbrkxgml0001i83i90hfhdy3","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"【译】Vue中父子组件的生命周期函数","date":"2018-06-29T07:42:41.000Z","_content":"\n&nbsp;&nbsp;最近项目中遇到了\u001d地图模块挂载到DOM节点并进行初始化的问题，背后其实就是Vue中父子组件初始化的顺序问题，发现这篇文章的例子通俗易懂，遂翻译一下，如果错误还请指正。\n\n<!-- more -->\n\n[原文链接](https://medium.com/@brockreece/vue-parent-and-child-lifecycle-hooks-5d6236bd561f)\n\n\n如果你在项目中使用\bVue，那么我肯定你很熟悉组件生命周期内的钩子函数，但是你未必清楚父子组件内生命周期钩子触发的顺序和对属性（props）的影响\n\n<p style=\"text-align:center;\"><img src=\"lifecircle.png\" width=\"50%\" height=\"50%\"></p>\n\n## 父/子组件内的生命周期钩子\n\n下面的例子\b在父子组件的**Mounted**和**Created**两个钩子触发时会给出相应的提示。如你所见，**Created**是正常的先父后子的顺序触发，但**Mounted**钩子则正好相反\n\n<iframe src=\"https://codesandbox.io/embed/j38wnqjy65\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n一开始这可能很难很难理解，但如果我们通过逻辑的角度去遵循组件初始化工作流程，就能理解这种顺序。我们只要记住，父组件在其挂载template到DOM之前必须等待\b所有的子组件都完成挂载（mounted）操作。\n\n\n<p style=\"text-align:center;\"><img src=\"parent-child-hooks.png\" width=\"50%\" height=\"50%\"></p>\n\n若果你的组件通过属性（props）来通讯，以上钩子的执行顺序会很重要。\n\n## 属性（props）的响应式（reactivity）\n\n一个组件在**Created**钩子触发之前就可以是响应式的，这意味在其父组件的**Mounted**\b钩子触发之前它就能够开始追踪属性（props）的变化。如果你在父组件的**Mounted**钩子中去设置一些属性的值，你一定要牢记这一点。\n\n下面的例子展示了如果在父组件的**Created**和**Mounted**两个钩子中都去设置子组件的属性值会发生什么。如你所见，在子组件的**Mounted**钩子中我们监测到了两次对属性值的改变操作（个人补充：父组件\b**Mounted**\b之前的data里面对属性赋值触发了一次，父组件**Mounted**时候的改变属性值\b又让子组件触发了一次）\n\b\n<iframe src=\"https://codesandbox.io/embed/z2yonj9kq4\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n假设你的子组件在属性值改变的时候会进行一次Ajax请求，这样就会触发两次请求，甚至造成请求的未响应。\n\n## 总结\n\n如果你想深入的了解Vue的生命周期钩子，我强烈建议你读一下[这篇文章](https://alligator.io/vuejs/component-lifecycle/)。\n\n\n但通常来说，我建议如果你只在组件的**Mounted**钩子进行需要和DOM交互的操作，而其他的操作都放在**Created**钩子中\n\n\n### 个人总结\n\n从生命周期的角度来看： 父 Created - 子 Created - 子 Mounted - 父 Mounted\n对应过程Props的改变： 子 prop 改变 --------- 子 prop 改变 --------- 子 prop 改变  ","source":"_posts/2018/Vue-Parent-and-Child-lifecycle-hooks.md","raw":"---\ntitle: 【译】Vue中父子组件的生命周期函数\ndate: 2018-6-29 15:42:41\ntags: [FE,Vue]\ncategories: 前端\n---\n\n&nbsp;&nbsp;最近项目中遇到了\u001d地图模块挂载到DOM节点并进行初始化的问题，背后其实就是Vue中父子组件初始化的顺序问题，发现这篇文章的例子通俗易懂，遂翻译一下，如果错误还请指正。\n\n<!-- more -->\n\n[原文链接](https://medium.com/@brockreece/vue-parent-and-child-lifecycle-hooks-5d6236bd561f)\n\n\n如果你在项目中使用\bVue，那么我肯定你很熟悉组件生命周期内的钩子函数，但是你未必清楚父子组件内生命周期钩子触发的顺序和对属性（props）的影响\n\n<p style=\"text-align:center;\"><img src=\"lifecircle.png\" width=\"50%\" height=\"50%\"></p>\n\n## 父/子组件内的生命周期钩子\n\n下面的例子\b在父子组件的**Mounted**和**Created**两个钩子触发时会给出相应的提示。如你所见，**Created**是正常的先父后子的顺序触发，但**Mounted**钩子则正好相反\n\n<iframe src=\"https://codesandbox.io/embed/j38wnqjy65\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n一开始这可能很难很难理解，但如果我们通过逻辑的角度去遵循组件初始化工作流程，就能理解这种顺序。我们只要记住，父组件在其挂载template到DOM之前必须等待\b所有的子组件都完成挂载（mounted）操作。\n\n\n<p style=\"text-align:center;\"><img src=\"parent-child-hooks.png\" width=\"50%\" height=\"50%\"></p>\n\n若果你的组件通过属性（props）来通讯，以上钩子的执行顺序会很重要。\n\n## 属性（props）的响应式（reactivity）\n\n一个组件在**Created**钩子触发之前就可以是响应式的，这意味在其父组件的**Mounted**\b钩子触发之前它就能够开始追踪属性（props）的变化。如果你在父组件的**Mounted**钩子中去设置一些属性的值，你一定要牢记这一点。\n\n下面的例子展示了如果在父组件的**Created**和**Mounted**两个钩子中都去设置子组件的属性值会发生什么。如你所见，在子组件的**Mounted**钩子中我们监测到了两次对属性值的改变操作（个人补充：父组件\b**Mounted**\b之前的data里面对属性赋值触发了一次，父组件**Mounted**时候的改变属性值\b又让子组件触发了一次）\n\b\n<iframe src=\"https://codesandbox.io/embed/z2yonj9kq4\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n假设你的子组件在属性值改变的时候会进行一次Ajax请求，这样就会触发两次请求，甚至造成请求的未响应。\n\n## 总结\n\n如果你想深入的了解Vue的生命周期钩子，我强烈建议你读一下[这篇文章](https://alligator.io/vuejs/component-lifecycle/)。\n\n\n但通常来说，我建议如果你只在组件的**Mounted**钩子进行需要和DOM交互的操作，而其他的操作都放在**Created**钩子中\n\n\n### 个人总结\n\n从生命周期的角度来看： 父 Created - 子 Created - 子 Mounted - 父 Mounted\n对应过程Props的改变： 子 prop 改变 --------- 子 prop 改变 --------- 子 prop 改变  ","slug":"Vue-Parent-and-Child-lifecycle-hooks","published":1,"updated":"2019-06-28T05:55:26.943Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrkxgsp0002i83i043lelhl","content":"<p>&nbsp;&nbsp;最近项目中遇到了\u001d地图模块挂载到DOM节点并进行初始化的问题，背后其实就是Vue中父子组件初始化的顺序问题，发现这篇文章的例子通俗易懂，遂翻译一下，如果错误还请指正。</p>\n<a id=\"more\"></a>\n<p><a href=\"https://medium.com/@brockreece/vue-parent-and-child-lifecycle-hooks-5d6236bd561f\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<p>如果你在项目中使用\bVue，那么我肯定你很熟悉组件生命周期内的钩子函数，但是你未必清楚父子组件内生命周期钩子触发的顺序和对属性（props）的影响</p>\n<p style=\"text-align:center;\"><img src=\"lifecircle.png\" width=\"50%\" height=\"50%\"></p>\n\n<h2 id=\"父-子组件内的生命周期钩子\"><a href=\"#父-子组件内的生命周期钩子\" class=\"headerlink\" title=\"父/子组件内的生命周期钩子\"></a>父/子组件内的生命周期钩子</h2><p>下面的例子\b在父子组件的<strong>Mounted</strong>和<strong>Created</strong>两个钩子触发时会给出相应的提示。如你所见，<strong>Created</strong>是正常的先父后子的顺序触发，但<strong>Mounted</strong>钩子则正好相反</p>\n<iframe src=\"https://codesandbox.io/embed/j38wnqjy65\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n<p>一开始这可能很难很难理解，但如果我们通过逻辑的角度去遵循组件初始化工作流程，就能理解这种顺序。我们只要记住，父组件在其挂载template到DOM之前必须等待\b所有的子组件都完成挂载（mounted）操作。</p>\n<p style=\"text-align:center;\"><img src=\"parent-child-hooks.png\" width=\"50%\" height=\"50%\"></p>\n\n<p>若果你的组件通过属性（props）来通讯，以上钩子的执行顺序会很重要。</p>\n<h2 id=\"属性（props）的响应式（reactivity）\"><a href=\"#属性（props）的响应式（reactivity）\" class=\"headerlink\" title=\"属性（props）的响应式（reactivity）\"></a>属性（props）的响应式（reactivity）</h2><p>一个组件在<strong>Created</strong>钩子触发之前就可以是响应式的，这意味在其父组件的<strong>Mounted</strong>\b钩子触发之前它就能够开始追踪属性（props）的变化。如果你在父组件的<strong>Mounted</strong>钩子中去设置一些属性的值，你一定要牢记这一点。</p>\n<p>下面的例子展示了如果在父组件的<strong>Created</strong>和<strong>Mounted</strong>两个钩子中都去设置子组件的属性值会发生什么。如你所见，在子组件的<strong>Mounted</strong>钩子中我们监测到了两次对属性值的改变操作（个人补充：父组件\b<strong>Mounted</strong>\b之前的data里面对属性赋值触发了一次，父组件<strong>Mounted</strong>时候的改变属性值\b又让子组件触发了一次）<br>\b</p>\n<iframe src=\"https://codesandbox.io/embed/z2yonj9kq4\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n<p>假设你的子组件在属性值改变的时候会进行一次Ajax请求，这样就会触发两次请求，甚至造成请求的未响应。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>如果你想深入的了解Vue的生命周期钩子，我强烈建议你读一下<a href=\"https://alligator.io/vuejs/component-lifecycle/\" target=\"_blank\" rel=\"noopener\">这篇文章</a>。</p>\n<p>但通常来说，我建议如果你只在组件的<strong>Mounted</strong>钩子进行需要和DOM交互的操作，而其他的操作都放在<strong>Created</strong>钩子中</p>\n<h3 id=\"个人总结\"><a href=\"#个人总结\" class=\"headerlink\" title=\"个人总结\"></a>个人总结</h3><p>从生命周期的角度来看： 父 Created - 子 Created - 子 Mounted - 父 Mounted<br>对应过程Props的改变： 子 prop 改变 ——— 子 prop 改变 ——— 子 prop 改变  </p>\n","site":{"data":{}},"excerpt":"<p>&nbsp;&nbsp;最近项目中遇到了\u001d地图模块挂载到DOM节点并进行初始化的问题，背后其实就是Vue中父子组件初始化的顺序问题，发现这篇文章的例子通俗易懂，遂翻译一下，如果错误还请指正。</p>","more":"<p><a href=\"https://medium.com/@brockreece/vue-parent-and-child-lifecycle-hooks-5d6236bd561f\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<p>如果你在项目中使用\bVue，那么我肯定你很熟悉组件生命周期内的钩子函数，但是你未必清楚父子组件内生命周期钩子触发的顺序和对属性（props）的影响</p>\n<p style=\"text-align:center;\"><img src=\"lifecircle.png\" width=\"50%\" height=\"50%\"></p>\n\n<h2 id=\"父-子组件内的生命周期钩子\"><a href=\"#父-子组件内的生命周期钩子\" class=\"headerlink\" title=\"父/子组件内的生命周期钩子\"></a>父/子组件内的生命周期钩子</h2><p>下面的例子\b在父子组件的<strong>Mounted</strong>和<strong>Created</strong>两个钩子触发时会给出相应的提示。如你所见，<strong>Created</strong>是正常的先父后子的顺序触发，但<strong>Mounted</strong>钩子则正好相反</p>\n<iframe src=\"https://codesandbox.io/embed/j38wnqjy65\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n<p>一开始这可能很难很难理解，但如果我们通过逻辑的角度去遵循组件初始化工作流程，就能理解这种顺序。我们只要记住，父组件在其挂载template到DOM之前必须等待\b所有的子组件都完成挂载（mounted）操作。</p>\n<p style=\"text-align:center;\"><img src=\"parent-child-hooks.png\" width=\"50%\" height=\"50%\"></p>\n\n<p>若果你的组件通过属性（props）来通讯，以上钩子的执行顺序会很重要。</p>\n<h2 id=\"属性（props）的响应式（reactivity）\"><a href=\"#属性（props）的响应式（reactivity）\" class=\"headerlink\" title=\"属性（props）的响应式（reactivity）\"></a>属性（props）的响应式（reactivity）</h2><p>一个组件在<strong>Created</strong>钩子触发之前就可以是响应式的，这意味在其父组件的<strong>Mounted</strong>\b钩子触发之前它就能够开始追踪属性（props）的变化。如果你在父组件的<strong>Mounted</strong>钩子中去设置一些属性的值，你一定要牢记这一点。</p>\n<p>下面的例子展示了如果在父组件的<strong>Created</strong>和<strong>Mounted</strong>两个钩子中都去设置子组件的属性值会发生什么。如你所见，在子组件的<strong>Mounted</strong>钩子中我们监测到了两次对属性值的改变操作（个人补充：父组件\b<strong>Mounted</strong>\b之前的data里面对属性赋值触发了一次，父组件<strong>Mounted</strong>时候的改变属性值\b又让子组件触发了一次）<br>\b</p>\n<iframe src=\"https://codesandbox.io/embed/z2yonj9kq4\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n<p>假设你的子组件在属性值改变的时候会进行一次Ajax请求，这样就会触发两次请求，甚至造成请求的未响应。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>如果你想深入的了解Vue的生命周期钩子，我强烈建议你读一下<a href=\"https://alligator.io/vuejs/component-lifecycle/\" target=\"_blank\" rel=\"noopener\">这篇文章</a>。</p>\n<p>但通常来说，我建议如果你只在组件的<strong>Mounted</strong>钩子进行需要和DOM交互的操作，而其他的操作都放在<strong>Created</strong>钩子中</p>\n<h3 id=\"个人总结\"><a href=\"#个人总结\" class=\"headerlink\" title=\"个人总结\"></a>个人总结</h3><p>从生命周期的角度来看： 父 Created - 子 Created - 子 Mounted - 父 Mounted<br>对应过程Props的改变： 子 prop 改变 ——— 子 prop 改变 ——— 子 prop 改变  </p>"},{"title":"Leaflet多种基础图层加载","date":"2017-09-17T05:46:08.000Z","_content":"\n&nbsp;&nbsp;最近项目中有移动端的开发需求，自然就用到了最轻量级的 gis 组件——Leaflet，100 多 k 的体积，五脏俱全，丰富的第三方插件，虽然开发者数量上不及大哥级产品 Arcigs，但也基本够用，对于 esri 的自家系统支持好，svg 和 canvas 两种渲染方式，让数据量大的要素图层渲染也不是那么吃力。\n\n&nbsp;&nbsp;这里把自己对于 Leaflet 的一些探索研究记录一下，一方面便于自己后期回顾，另一方面也希望和大家一起探讨学习。\n\n<!-- more -->\n\n[Leaflet 系列地址](https://github.com/zzcyrus/Leaflet-demos)\n[本文 demo 地址](https://github.com/zzcyrus/Leaflet-demos/blob/master/0.basemap/basemap.html)\n\n# 基础图层的加载\n\n基础图层的加载都是通过`L.tileLayer`的方式，所以加载的难点不在于 api 的使用，是一些常用的基础瓦片的收集，这里给出一些常用的地址\n\n```js\nmapRadios: [\n  {\n    label: \"高德地图\",\n    value: \"1\",\n    url:\n      \"http://webrd01.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x={x}&y={y}&z={z}\",\n  },\n  {\n    label: \"Esri地图\",\n    value: \"2\",\n    url:\n      \"http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineCommunity/MapServer/tile/{z}/{y}/{x}\",\n  },\n  {\n    label: \"天地图道路\",\n    value: \"3\",\n    url: \"http://t0.tianditu.cn/DataServer?T=vec_w&X={x}&Y={y}&L={z}\",\n  },\n  {\n    label: \"天地图标注\",\n    value: \"4\",\n    url: \"http://t5.tianditu.cn/DataServer?T=cva_w&X={x}&Y={y}&L={z}\",\n  },\n  {\n    label: \"天地图影像\",\n    value: \"5\",\n    url:\n      \"http://t1.tianditu.cn/img_w/wmts?service=wmts&request=GetTile&version=1.0.0&LAYER=img&tileMatrixSet=w&TileMatrix={z}&TileRow={y}&TileCol={x}&style=default&format=tiles\",\n  },\n  {\n    label: \"谷歌地形\",\n    value: \"6\",\n    url:\n      \"http://mt3.google.cn/vt/lyrs=t@131&hl=zh-CN&gl=cn&x={x}&y={y}&z={z}&s=Ga\",\n  },\n  {\n    label: \"谷歌影像\",\n    value: \"7\",\n    url: \"http://mt3.google.cn/vt/lyrs=s&hl=zh-CN&gl=cn&x={x}&y={y}&z={z}\",\n  },\n  {\n    label: \"谷歌标注\",\n    value: \"8\",\n    url:\n      \"http://mt2.google.cn/vt/lyrs=m@167000000&hl=zh-CN&gl=cn&x={x}&y={y}&z={z}\",\n  },\n];\n```\n\n更多的瓦片地址可以在 demo 中找到，具体的使用效果也可以移步[demo](https://github.com/zzcyrus/Leaflet-demos/blob/master/0.basemap/basemap.html)\n","source":"_posts/2017/basemap.md","raw":"---\ntitle: Leaflet多种基础图层加载\ndate: 2017-09-17 13:46:08\ntags: [FE, GIS, Leaflet]\ncategories: WebGIS\n---\n\n&nbsp;&nbsp;最近项目中有移动端的开发需求，自然就用到了最轻量级的 gis 组件——Leaflet，100 多 k 的体积，五脏俱全，丰富的第三方插件，虽然开发者数量上不及大哥级产品 Arcigs，但也基本够用，对于 esri 的自家系统支持好，svg 和 canvas 两种渲染方式，让数据量大的要素图层渲染也不是那么吃力。\n\n&nbsp;&nbsp;这里把自己对于 Leaflet 的一些探索研究记录一下，一方面便于自己后期回顾，另一方面也希望和大家一起探讨学习。\n\n<!-- more -->\n\n[Leaflet 系列地址](https://github.com/zzcyrus/Leaflet-demos)\n[本文 demo 地址](https://github.com/zzcyrus/Leaflet-demos/blob/master/0.basemap/basemap.html)\n\n# 基础图层的加载\n\n基础图层的加载都是通过`L.tileLayer`的方式，所以加载的难点不在于 api 的使用，是一些常用的基础瓦片的收集，这里给出一些常用的地址\n\n```js\nmapRadios: [\n  {\n    label: \"高德地图\",\n    value: \"1\",\n    url:\n      \"http://webrd01.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x={x}&y={y}&z={z}\",\n  },\n  {\n    label: \"Esri地图\",\n    value: \"2\",\n    url:\n      \"http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineCommunity/MapServer/tile/{z}/{y}/{x}\",\n  },\n  {\n    label: \"天地图道路\",\n    value: \"3\",\n    url: \"http://t0.tianditu.cn/DataServer?T=vec_w&X={x}&Y={y}&L={z}\",\n  },\n  {\n    label: \"天地图标注\",\n    value: \"4\",\n    url: \"http://t5.tianditu.cn/DataServer?T=cva_w&X={x}&Y={y}&L={z}\",\n  },\n  {\n    label: \"天地图影像\",\n    value: \"5\",\n    url:\n      \"http://t1.tianditu.cn/img_w/wmts?service=wmts&request=GetTile&version=1.0.0&LAYER=img&tileMatrixSet=w&TileMatrix={z}&TileRow={y}&TileCol={x}&style=default&format=tiles\",\n  },\n  {\n    label: \"谷歌地形\",\n    value: \"6\",\n    url:\n      \"http://mt3.google.cn/vt/lyrs=t@131&hl=zh-CN&gl=cn&x={x}&y={y}&z={z}&s=Ga\",\n  },\n  {\n    label: \"谷歌影像\",\n    value: \"7\",\n    url: \"http://mt3.google.cn/vt/lyrs=s&hl=zh-CN&gl=cn&x={x}&y={y}&z={z}\",\n  },\n  {\n    label: \"谷歌标注\",\n    value: \"8\",\n    url:\n      \"http://mt2.google.cn/vt/lyrs=m@167000000&hl=zh-CN&gl=cn&x={x}&y={y}&z={z}\",\n  },\n];\n```\n\n更多的瓦片地址可以在 demo 中找到，具体的使用效果也可以移步[demo](https://github.com/zzcyrus/Leaflet-demos/blob/master/0.basemap/basemap.html)\n","slug":"basemap","published":1,"updated":"2020-05-17T08:21:36.035Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrkxgst0003i83iki074605","content":"<p>&nbsp;&nbsp;最近项目中有移动端的开发需求，自然就用到了最轻量级的 gis 组件——Leaflet，100 多 k 的体积，五脏俱全，丰富的第三方插件，虽然开发者数量上不及大哥级产品 Arcigs，但也基本够用，对于 esri 的自家系统支持好，svg 和 canvas 两种渲染方式，让数据量大的要素图层渲染也不是那么吃力。</p>\n<p>&nbsp;&nbsp;这里把自己对于 Leaflet 的一些探索研究记录一下，一方面便于自己后期回顾，另一方面也希望和大家一起探讨学习。</p>\n<a id=\"more\"></a>\n<p><a href=\"https://github.com/zzcyrus/Leaflet-demos\" target=\"_blank\" rel=\"noopener\">Leaflet 系列地址</a><br><a href=\"https://github.com/zzcyrus/Leaflet-demos/blob/master/0.basemap/basemap.html\" target=\"_blank\" rel=\"noopener\">本文 demo 地址</a></p>\n<h1 id=\"基础图层的加载\"><a href=\"#基础图层的加载\" class=\"headerlink\" title=\"基础图层的加载\"></a>基础图层的加载</h1><p>基础图层的加载都是通过<code>L.tileLayer</code>的方式，所以加载的难点不在于 api 的使用，是一些常用的基础瓦片的收集，这里给出一些常用的地址</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">mapRadios: [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    label: <span class=\"string\">\"高德地图\"</span>,</span><br><span class=\"line\">    value: <span class=\"string\">\"1\"</span>,</span><br><span class=\"line\">    url:</span><br><span class=\"line\">      <span class=\"string\">\"http://webrd01.is.autonavi.com/appmaptile?lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    label: <span class=\"string\">\"Esri地图\"</span>,</span><br><span class=\"line\">    value: <span class=\"string\">\"2\"</span>,</span><br><span class=\"line\">    url:</span><br><span class=\"line\">      <span class=\"string\">\"http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineCommunity/MapServer/tile/&#123;z&#125;/&#123;y&#125;/&#123;x&#125;\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    label: <span class=\"string\">\"天地图道路\"</span>,</span><br><span class=\"line\">    value: <span class=\"string\">\"3\"</span>,</span><br><span class=\"line\">    url: <span class=\"string\">\"http://t0.tianditu.cn/DataServer?T=vec_w&amp;X=&#123;x&#125;&amp;Y=&#123;y&#125;&amp;L=&#123;z&#125;\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    label: <span class=\"string\">\"天地图标注\"</span>,</span><br><span class=\"line\">    value: <span class=\"string\">\"4\"</span>,</span><br><span class=\"line\">    url: <span class=\"string\">\"http://t5.tianditu.cn/DataServer?T=cva_w&amp;X=&#123;x&#125;&amp;Y=&#123;y&#125;&amp;L=&#123;z&#125;\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    label: <span class=\"string\">\"天地图影像\"</span>,</span><br><span class=\"line\">    value: <span class=\"string\">\"5\"</span>,</span><br><span class=\"line\">    url:</span><br><span class=\"line\">      <span class=\"string\">\"http://t1.tianditu.cn/img_w/wmts?service=wmts&amp;request=GetTile&amp;version=1.0.0&amp;LAYER=img&amp;tileMatrixSet=w&amp;TileMatrix=&#123;z&#125;&amp;TileRow=&#123;y&#125;&amp;TileCol=&#123;x&#125;&amp;style=default&amp;format=tiles\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    label: <span class=\"string\">\"谷歌地形\"</span>,</span><br><span class=\"line\">    value: <span class=\"string\">\"6\"</span>,</span><br><span class=\"line\">    url:</span><br><span class=\"line\">      <span class=\"string\">\"http://mt3.google.cn/vt/lyrs=t@131&amp;hl=zh-CN&amp;gl=cn&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;&amp;s=Ga\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    label: <span class=\"string\">\"谷歌影像\"</span>,</span><br><span class=\"line\">    value: <span class=\"string\">\"7\"</span>,</span><br><span class=\"line\">    url: <span class=\"string\">\"http://mt3.google.cn/vt/lyrs=s&amp;hl=zh-CN&amp;gl=cn&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    label: <span class=\"string\">\"谷歌标注\"</span>,</span><br><span class=\"line\">    value: <span class=\"string\">\"8\"</span>,</span><br><span class=\"line\">    url:</span><br><span class=\"line\">      <span class=\"string\">\"http://mt2.google.cn/vt/lyrs=m@167000000&amp;hl=zh-CN&amp;gl=cn&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n<p>更多的瓦片地址可以在 demo 中找到，具体的使用效果也可以移步<a href=\"https://github.com/zzcyrus/Leaflet-demos/blob/master/0.basemap/basemap.html\" target=\"_blank\" rel=\"noopener\">demo</a></p>\n","site":{"data":{}},"excerpt":"<p>&nbsp;&nbsp;最近项目中有移动端的开发需求，自然就用到了最轻量级的 gis 组件——Leaflet，100 多 k 的体积，五脏俱全，丰富的第三方插件，虽然开发者数量上不及大哥级产品 Arcigs，但也基本够用，对于 esri 的自家系统支持好，svg 和 canvas 两种渲染方式，让数据量大的要素图层渲染也不是那么吃力。</p>\n<p>&nbsp;&nbsp;这里把自己对于 Leaflet 的一些探索研究记录一下，一方面便于自己后期回顾，另一方面也希望和大家一起探讨学习。</p>","more":"<p><a href=\"https://github.com/zzcyrus/Leaflet-demos\" target=\"_blank\" rel=\"noopener\">Leaflet 系列地址</a><br><a href=\"https://github.com/zzcyrus/Leaflet-demos/blob/master/0.basemap/basemap.html\" target=\"_blank\" rel=\"noopener\">本文 demo 地址</a></p>\n<h1 id=\"基础图层的加载\"><a href=\"#基础图层的加载\" class=\"headerlink\" title=\"基础图层的加载\"></a>基础图层的加载</h1><p>基础图层的加载都是通过<code>L.tileLayer</code>的方式，所以加载的难点不在于 api 的使用，是一些常用的基础瓦片的收集，这里给出一些常用的地址</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">mapRadios: [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    label: <span class=\"string\">\"高德地图\"</span>,</span><br><span class=\"line\">    value: <span class=\"string\">\"1\"</span>,</span><br><span class=\"line\">    url:</span><br><span class=\"line\">      <span class=\"string\">\"http://webrd01.is.autonavi.com/appmaptile?lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    label: <span class=\"string\">\"Esri地图\"</span>,</span><br><span class=\"line\">    value: <span class=\"string\">\"2\"</span>,</span><br><span class=\"line\">    url:</span><br><span class=\"line\">      <span class=\"string\">\"http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineCommunity/MapServer/tile/&#123;z&#125;/&#123;y&#125;/&#123;x&#125;\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    label: <span class=\"string\">\"天地图道路\"</span>,</span><br><span class=\"line\">    value: <span class=\"string\">\"3\"</span>,</span><br><span class=\"line\">    url: <span class=\"string\">\"http://t0.tianditu.cn/DataServer?T=vec_w&amp;X=&#123;x&#125;&amp;Y=&#123;y&#125;&amp;L=&#123;z&#125;\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    label: <span class=\"string\">\"天地图标注\"</span>,</span><br><span class=\"line\">    value: <span class=\"string\">\"4\"</span>,</span><br><span class=\"line\">    url: <span class=\"string\">\"http://t5.tianditu.cn/DataServer?T=cva_w&amp;X=&#123;x&#125;&amp;Y=&#123;y&#125;&amp;L=&#123;z&#125;\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    label: <span class=\"string\">\"天地图影像\"</span>,</span><br><span class=\"line\">    value: <span class=\"string\">\"5\"</span>,</span><br><span class=\"line\">    url:</span><br><span class=\"line\">      <span class=\"string\">\"http://t1.tianditu.cn/img_w/wmts?service=wmts&amp;request=GetTile&amp;version=1.0.0&amp;LAYER=img&amp;tileMatrixSet=w&amp;TileMatrix=&#123;z&#125;&amp;TileRow=&#123;y&#125;&amp;TileCol=&#123;x&#125;&amp;style=default&amp;format=tiles\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    label: <span class=\"string\">\"谷歌地形\"</span>,</span><br><span class=\"line\">    value: <span class=\"string\">\"6\"</span>,</span><br><span class=\"line\">    url:</span><br><span class=\"line\">      <span class=\"string\">\"http://mt3.google.cn/vt/lyrs=t@131&amp;hl=zh-CN&amp;gl=cn&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;&amp;s=Ga\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    label: <span class=\"string\">\"谷歌影像\"</span>,</span><br><span class=\"line\">    value: <span class=\"string\">\"7\"</span>,</span><br><span class=\"line\">    url: <span class=\"string\">\"http://mt3.google.cn/vt/lyrs=s&amp;hl=zh-CN&amp;gl=cn&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    label: <span class=\"string\">\"谷歌标注\"</span>,</span><br><span class=\"line\">    value: <span class=\"string\">\"8\"</span>,</span><br><span class=\"line\">    url:</span><br><span class=\"line\">      <span class=\"string\">\"http://mt2.google.cn/vt/lyrs=m@167000000&amp;hl=zh-CN&amp;gl=cn&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n<p>更多的瓦片地址可以在 demo 中找到，具体的使用效果也可以移步<a href=\"https://github.com/zzcyrus/Leaflet-demos/blob/master/0.basemap/basemap.html\" target=\"_blank\" rel=\"noopener\">demo</a></p>"},{"title":"openlayers 从台风风圈绘制到canvas样式和图层的应用","date":"2017-07-31T14:31:02.000Z","_content":"\n本文中所使用的数据来源于[温州台风网](http://www.wztf121.com/typhoon.html)，通过 F12 抓取，你可以在我的[GitHub](https://github.com/zzcyrus/openlayers-demos)上查看数据和本文源代码\n\n&nbsp;&nbsp;台风的风圈是一种不常见但算的上规则的图形，在上面的网站可以看到最终效果，简单的解剖下其实就是四个 1/4 圆\n\n![](goal.png)\n\n从数据结构上也可以看出来：\n\n```js\nvar radius_quad = {\n  ne: 250, //单位为KM\n  se: 250,\n  sw: 180,\n  nw: 150,\n};\n```\n\n在某个固定经纬度点上，以此点为圆心组合成了一个所谓的风圈形状，四个方向分别代表每个 1/4 圆的半径。刚开始是为了实现这种效果进行了研究，后来发现 openlayers 对于这种效果的支持还挺有意思，记录下来已做分享。\n\n<!-- more -->\n\n# 通过自定义 geometry 的实现\n\n&nbsp;&nbsp;最原始的思路也是最容易切入的点，就是去看 openlayers 中怎么实现圆形的画法，在 ol 中，有`createRegularPolygon`这个类，原理就是给定一些参数，用点去填充我们想要的形状，当填进去点达到一定密集度，自然就能得到一个近似的圆。\n&nbsp;&nbsp;通过这个思路我们可以计算台风风圈的每个 1/4 圆的坐标，用点去占位，最终实现绘制出想要的图形。\n\n具体代码可以去看某大牛的博客，这里只给出一个传送门，写的很详细了：\n[点我乘坐飞机](http://blog.csdn.net/gisshixisheng/article/details/76397068) **这个算法还有些不完善，就是在每个 1/4 圆结束时候少计算了一个点，导致看着有点不对劲**\n\n**特点:** 这种方式画出来的图形是一个图层中的一个 feature，好处自然不用多说，基本上 feature 支持的功能都能满足！\n\n# 通过 canvas 类型的 symbol 实现\n\n&nbsp;&nbsp;在点密集的情况下，用上面的方式其实效果已经很不错了，但是有些细（tiao）心（ci）的使用者，非要放大到一定程度，然后说你这个不够圆，那。。。。。\n\n&nbsp;&nbsp;那我们就用 canvas 画出来，openlayers 中，要素的样式是有这么一种方式`ol.style.Icon`来实现，我们可以把绘制好的元素作为`Icon`的参数\n\n```js\nvar style = new ol.style.Style({\n  image: new ol.style.Icon({\n    opacity: 0.3,\n    img: canvas,\n    imgSize: [canvas.width, canvas.height],\n  }),\n});\n```\n\ncanvans 绘制的方法：\n\n```js\nfunction createTyphoon(radius, radius_quad) {\n  var canvas = document.createElement(\"canvas\");\n  canvas.width = canvas.height = 2 * radius;\n  var context = canvas.getContext(\"2d\");\n  context.fillStyle = \"#0000ff\";\n  context.strokeStyle = \"#ff0000\";\n  context.lineWidth = 3;\n  context.beginPath();\n  context.arc(radius, radius, radius_quad.se, 0, 0.5 * Math.PI);\n  context.lineTo(radius, radius + radius_quad.sw);\n  context.arc(radius, radius, radius_quad.sw, 0.5 * Math.PI, Math.PI);\n  context.lineTo(radius - radius_quad.nw, radius);\n  context.arc(radius, radius, radius_quad.nw, Math.PI, 1.5 * Math.PI);\n  context.lineTo(radius, radius - radius_quad.ne);\n  context.arc(radius, radius, radius_quad.ne, 1.5 * Math.PI, 0);\n  context.lineTo(radius + radius_quad.se, radius);\n  context.fill();\n  context.stroke();\n  return canvas;\n}\n```\n\n效果如下图：\n![](canvasSymbol.png)\n\n[本方法完整代码](https://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasSymbol.html)\n\n**特点：** 这种方式，绘制出来的台风风圈其实只是一个 symbol 符号，需要把这个符号赋给一个具体的要素，比如一个点，一个圆之类的，而且根据分辨率还要去调整样式的缩放\n\n```js\nmap.getView().on(\"change:resolution\", function () {\n  var style = shape.getStyle();\n  // 重新设置图标的缩放率\n  style.getImage().setScale(this.getZoom() / 8);\n  shape.setStyle(style);\n});\n```\n\n# 通过 canvas 图层的方式实现\n\n&nbsp;&nbsp;再后来转念一想，既然支持 canvas 的 symbol，为何不直接使用 canvas 绘制固定元素呢，果然在 API 中找到了`ol.source.ImageCanvas`，直接把 canvas 要素当作图层来使用！\n\n`ol.source.ImageCanvas`的绘制有点需要特别注意的点，这里给出重要代码片段，完整 demo 可以去[GitHub](https://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasLayer.html)查看\n\n## 创建图层，在 canvasFunction 中写具体的绘图方法\n\n```js\nvar canvasLayer = new ol.layer.Image({\n  source: new ol.source.ImageCanvas({\n    canvasFunction: canvasFunction,\n    projection: \"EPSG:3857\",\n  }),\n});\n```\n\n## canvasFunction 中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小\n\n```js\n//计算画布和地图四至的偏移量\nvar mapExtent = map.getView().calculateExtent(map.getSize());\nvar canvasOrigin = map.getPixelFromCoordinate([extent[0], extent[3]]);\nvar mapOrigin = map.getPixelFromCoordinate([mapExtent[0], mapExtent[3]]);\nvar delta = [mapOrigin[0] - canvasOrigin[0], mapOrigin[1] - canvasOrigin[1]];\n```\n\n```js\n//在计算台风风圈的中心点时要补充计算偏移量\nvar point = ol.proj.transform(coordinate, \"EPSG:4326\", \"EPSG:3857\");\nvar pixel = map.getPixelFromCoordinate(point);\nvar cX = pixel[0] + delta[0],\n  cY = pixel[1] + delta[1];\n```\n\n```js\n//利用canvasFunction提供的默认参数分辨率，计算准确的坐标\nvar radius_quad = {\n  ne: 250000 / resolution,\n  se: 250000 / resolution,\n  sw: 180000 / resolution,\n  nw: 150000 / resolution,\n};\n```\n\n最终效果如下，我在同一图层中绘制了多个：\n![](canvasLayer.png)\n\n至于绘制 canvas 的方法和上面的 symbol 是一样的。具体代码还请移步[GitHub](https://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasLayer.html)(原谅我厚颜无耻的屡次打广告！)\n\n**特点：**这种方式可以在一个图层中添加多个风圈要素，同时图层支持的功能也比较多，基本满足需求，效果也还行\n\n&nbsp;&nbsp;这篇应用主要是从一个基本的需求所拓展开来的，canvas 图层的应用我想应该很强大，刚开始研究 openlyaers，相比于 arcgis，ol 很多功能可能要自己实现，但似乎效果上还是能让人满意的，欢迎大家讨论。\n","source":"_posts/2017/openlayers-canvas-typhoon.md","raw":"---\ntitle: openlayers 从台风风圈绘制到canvas样式和图层的应用\ndate: 2017-07-31 22:31:02\ntags: [FE, GIS, OpenLayers]\ncategories: WebGIS\n---\n\n本文中所使用的数据来源于[温州台风网](http://www.wztf121.com/typhoon.html)，通过 F12 抓取，你可以在我的[GitHub](https://github.com/zzcyrus/openlayers-demos)上查看数据和本文源代码\n\n&nbsp;&nbsp;台风的风圈是一种不常见但算的上规则的图形，在上面的网站可以看到最终效果，简单的解剖下其实就是四个 1/4 圆\n\n![](goal.png)\n\n从数据结构上也可以看出来：\n\n```js\nvar radius_quad = {\n  ne: 250, //单位为KM\n  se: 250,\n  sw: 180,\n  nw: 150,\n};\n```\n\n在某个固定经纬度点上，以此点为圆心组合成了一个所谓的风圈形状，四个方向分别代表每个 1/4 圆的半径。刚开始是为了实现这种效果进行了研究，后来发现 openlayers 对于这种效果的支持还挺有意思，记录下来已做分享。\n\n<!-- more -->\n\n# 通过自定义 geometry 的实现\n\n&nbsp;&nbsp;最原始的思路也是最容易切入的点，就是去看 openlayers 中怎么实现圆形的画法，在 ol 中，有`createRegularPolygon`这个类，原理就是给定一些参数，用点去填充我们想要的形状，当填进去点达到一定密集度，自然就能得到一个近似的圆。\n&nbsp;&nbsp;通过这个思路我们可以计算台风风圈的每个 1/4 圆的坐标，用点去占位，最终实现绘制出想要的图形。\n\n具体代码可以去看某大牛的博客，这里只给出一个传送门，写的很详细了：\n[点我乘坐飞机](http://blog.csdn.net/gisshixisheng/article/details/76397068) **这个算法还有些不完善，就是在每个 1/4 圆结束时候少计算了一个点，导致看着有点不对劲**\n\n**特点:** 这种方式画出来的图形是一个图层中的一个 feature，好处自然不用多说，基本上 feature 支持的功能都能满足！\n\n# 通过 canvas 类型的 symbol 实现\n\n&nbsp;&nbsp;在点密集的情况下，用上面的方式其实效果已经很不错了，但是有些细（tiao）心（ci）的使用者，非要放大到一定程度，然后说你这个不够圆，那。。。。。\n\n&nbsp;&nbsp;那我们就用 canvas 画出来，openlayers 中，要素的样式是有这么一种方式`ol.style.Icon`来实现，我们可以把绘制好的元素作为`Icon`的参数\n\n```js\nvar style = new ol.style.Style({\n  image: new ol.style.Icon({\n    opacity: 0.3,\n    img: canvas,\n    imgSize: [canvas.width, canvas.height],\n  }),\n});\n```\n\ncanvans 绘制的方法：\n\n```js\nfunction createTyphoon(radius, radius_quad) {\n  var canvas = document.createElement(\"canvas\");\n  canvas.width = canvas.height = 2 * radius;\n  var context = canvas.getContext(\"2d\");\n  context.fillStyle = \"#0000ff\";\n  context.strokeStyle = \"#ff0000\";\n  context.lineWidth = 3;\n  context.beginPath();\n  context.arc(radius, radius, radius_quad.se, 0, 0.5 * Math.PI);\n  context.lineTo(radius, radius + radius_quad.sw);\n  context.arc(radius, radius, radius_quad.sw, 0.5 * Math.PI, Math.PI);\n  context.lineTo(radius - radius_quad.nw, radius);\n  context.arc(radius, radius, radius_quad.nw, Math.PI, 1.5 * Math.PI);\n  context.lineTo(radius, radius - radius_quad.ne);\n  context.arc(radius, radius, radius_quad.ne, 1.5 * Math.PI, 0);\n  context.lineTo(radius + radius_quad.se, radius);\n  context.fill();\n  context.stroke();\n  return canvas;\n}\n```\n\n效果如下图：\n![](canvasSymbol.png)\n\n[本方法完整代码](https://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasSymbol.html)\n\n**特点：** 这种方式，绘制出来的台风风圈其实只是一个 symbol 符号，需要把这个符号赋给一个具体的要素，比如一个点，一个圆之类的，而且根据分辨率还要去调整样式的缩放\n\n```js\nmap.getView().on(\"change:resolution\", function () {\n  var style = shape.getStyle();\n  // 重新设置图标的缩放率\n  style.getImage().setScale(this.getZoom() / 8);\n  shape.setStyle(style);\n});\n```\n\n# 通过 canvas 图层的方式实现\n\n&nbsp;&nbsp;再后来转念一想，既然支持 canvas 的 symbol，为何不直接使用 canvas 绘制固定元素呢，果然在 API 中找到了`ol.source.ImageCanvas`，直接把 canvas 要素当作图层来使用！\n\n`ol.source.ImageCanvas`的绘制有点需要特别注意的点，这里给出重要代码片段，完整 demo 可以去[GitHub](https://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasLayer.html)查看\n\n## 创建图层，在 canvasFunction 中写具体的绘图方法\n\n```js\nvar canvasLayer = new ol.layer.Image({\n  source: new ol.source.ImageCanvas({\n    canvasFunction: canvasFunction,\n    projection: \"EPSG:3857\",\n  }),\n});\n```\n\n## canvasFunction 中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小\n\n```js\n//计算画布和地图四至的偏移量\nvar mapExtent = map.getView().calculateExtent(map.getSize());\nvar canvasOrigin = map.getPixelFromCoordinate([extent[0], extent[3]]);\nvar mapOrigin = map.getPixelFromCoordinate([mapExtent[0], mapExtent[3]]);\nvar delta = [mapOrigin[0] - canvasOrigin[0], mapOrigin[1] - canvasOrigin[1]];\n```\n\n```js\n//在计算台风风圈的中心点时要补充计算偏移量\nvar point = ol.proj.transform(coordinate, \"EPSG:4326\", \"EPSG:3857\");\nvar pixel = map.getPixelFromCoordinate(point);\nvar cX = pixel[0] + delta[0],\n  cY = pixel[1] + delta[1];\n```\n\n```js\n//利用canvasFunction提供的默认参数分辨率，计算准确的坐标\nvar radius_quad = {\n  ne: 250000 / resolution,\n  se: 250000 / resolution,\n  sw: 180000 / resolution,\n  nw: 150000 / resolution,\n};\n```\n\n最终效果如下，我在同一图层中绘制了多个：\n![](canvasLayer.png)\n\n至于绘制 canvas 的方法和上面的 symbol 是一样的。具体代码还请移步[GitHub](https://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasLayer.html)(原谅我厚颜无耻的屡次打广告！)\n\n**特点：**这种方式可以在一个图层中添加多个风圈要素，同时图层支持的功能也比较多，基本满足需求，效果也还行\n\n&nbsp;&nbsp;这篇应用主要是从一个基本的需求所拓展开来的，canvas 图层的应用我想应该很强大，刚开始研究 openlyaers，相比于 arcgis，ol 很多功能可能要自己实现，但似乎效果上还是能让人满意的，欢迎大家讨论。\n","slug":"openlayers-canvas-typhoon","published":1,"updated":"2020-05-17T08:21:36.006Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrkxgsu0004i83inomsfozp","content":"<p>本文中所使用的数据来源于<a href=\"http://www.wztf121.com/typhoon.html\" target=\"_blank\" rel=\"noopener\">温州台风网</a>，通过 F12 抓取，你可以在我的<a href=\"https://github.com/zzcyrus/openlayers-demos\" target=\"_blank\" rel=\"noopener\">GitHub</a>上查看数据和本文源代码</p>\n<p>&nbsp;&nbsp;台风的风圈是一种不常见但算的上规则的图形，在上面的网站可以看到最终效果，简单的解剖下其实就是四个 1/4 圆</p>\n<p><img src=\"goal.png\" alt></p>\n<p>从数据结构上也可以看出来：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> radius_quad = &#123;</span><br><span class=\"line\">  ne: <span class=\"number\">250</span>, <span class=\"comment\">//单位为KM</span></span><br><span class=\"line\">  se: <span class=\"number\">250</span>,</span><br><span class=\"line\">  sw: <span class=\"number\">180</span>,</span><br><span class=\"line\">  nw: <span class=\"number\">150</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在某个固定经纬度点上，以此点为圆心组合成了一个所谓的风圈形状，四个方向分别代表每个 1/4 圆的半径。刚开始是为了实现这种效果进行了研究，后来发现 openlayers 对于这种效果的支持还挺有意思，记录下来已做分享。</p>\n<a id=\"more\"></a>\n<h1 id=\"通过自定义-geometry-的实现\"><a href=\"#通过自定义-geometry-的实现\" class=\"headerlink\" title=\"通过自定义 geometry 的实现\"></a>通过自定义 geometry 的实现</h1><p>&nbsp;&nbsp;最原始的思路也是最容易切入的点，就是去看 openlayers 中怎么实现圆形的画法，在 ol 中，有<code>createRegularPolygon</code>这个类，原理就是给定一些参数，用点去填充我们想要的形状，当填进去点达到一定密集度，自然就能得到一个近似的圆。<br>&nbsp;&nbsp;通过这个思路我们可以计算台风风圈的每个 1/4 圆的坐标，用点去占位，最终实现绘制出想要的图形。</p>\n<p>具体代码可以去看某大牛的博客，这里只给出一个传送门，写的很详细了：<br><a href=\"http://blog.csdn.net/gisshixisheng/article/details/76397068\" target=\"_blank\" rel=\"noopener\">点我乘坐飞机</a> <strong>这个算法还有些不完善，就是在每个 1/4 圆结束时候少计算了一个点，导致看着有点不对劲</strong></p>\n<p><strong>特点:</strong> 这种方式画出来的图形是一个图层中的一个 feature，好处自然不用多说，基本上 feature 支持的功能都能满足！</p>\n<h1 id=\"通过-canvas-类型的-symbol-实现\"><a href=\"#通过-canvas-类型的-symbol-实现\" class=\"headerlink\" title=\"通过 canvas 类型的 symbol 实现\"></a>通过 canvas 类型的 symbol 实现</h1><p>&nbsp;&nbsp;在点密集的情况下，用上面的方式其实效果已经很不错了，但是有些细（tiao）心（ci）的使用者，非要放大到一定程度，然后说你这个不够圆，那。。。。。</p>\n<p>&nbsp;&nbsp;那我们就用 canvas 画出来，openlayers 中，要素的样式是有这么一种方式<code>ol.style.Icon</code>来实现，我们可以把绘制好的元素作为<code>Icon</code>的参数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> style = <span class=\"keyword\">new</span> ol.style.Style(&#123;</span><br><span class=\"line\">  image: <span class=\"keyword\">new</span> ol.style.Icon(&#123;</span><br><span class=\"line\">    opacity: <span class=\"number\">0.3</span>,</span><br><span class=\"line\">    img: canvas,</span><br><span class=\"line\">    imgSize: [canvas.width, canvas.height],</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>canvans 绘制的方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createTyphoon</span>(<span class=\"params\">radius, radius_quad</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> canvas = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"canvas\"</span>);</span><br><span class=\"line\">  canvas.width = canvas.height = <span class=\"number\">2</span> * radius;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> context = canvas.getContext(<span class=\"string\">\"2d\"</span>);</span><br><span class=\"line\">  context.fillStyle = <span class=\"string\">\"#0000ff\"</span>;</span><br><span class=\"line\">  context.strokeStyle = <span class=\"string\">\"#ff0000\"</span>;</span><br><span class=\"line\">  context.lineWidth = <span class=\"number\">3</span>;</span><br><span class=\"line\">  context.beginPath();</span><br><span class=\"line\">  context.arc(radius, radius, radius_quad.se, <span class=\"number\">0</span>, <span class=\"number\">0.5</span> * <span class=\"built_in\">Math</span>.PI);</span><br><span class=\"line\">  context.lineTo(radius, radius + radius_quad.sw);</span><br><span class=\"line\">  context.arc(radius, radius, radius_quad.sw, <span class=\"number\">0.5</span> * <span class=\"built_in\">Math</span>.PI, <span class=\"built_in\">Math</span>.PI);</span><br><span class=\"line\">  context.lineTo(radius - radius_quad.nw, radius);</span><br><span class=\"line\">  context.arc(radius, radius, radius_quad.nw, <span class=\"built_in\">Math</span>.PI, <span class=\"number\">1.5</span> * <span class=\"built_in\">Math</span>.PI);</span><br><span class=\"line\">  context.lineTo(radius, radius - radius_quad.ne);</span><br><span class=\"line\">  context.arc(radius, radius, radius_quad.ne, <span class=\"number\">1.5</span> * <span class=\"built_in\">Math</span>.PI, <span class=\"number\">0</span>);</span><br><span class=\"line\">  context.lineTo(radius + radius_quad.se, radius);</span><br><span class=\"line\">  context.fill();</span><br><span class=\"line\">  context.stroke();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> canvas;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>效果如下图：<br><img src=\"canvasSymbol.png\" alt></p>\n<p><a href=\"https://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasSymbol.html\" target=\"_blank\" rel=\"noopener\">本方法完整代码</a></p>\n<p><strong>特点：</strong> 这种方式，绘制出来的台风风圈其实只是一个 symbol 符号，需要把这个符号赋给一个具体的要素，比如一个点，一个圆之类的，而且根据分辨率还要去调整样式的缩放</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">map.getView().on(<span class=\"string\">\"change:resolution\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> style = shape.getStyle();</span><br><span class=\"line\">  <span class=\"comment\">// 重新设置图标的缩放率</span></span><br><span class=\"line\">  style.getImage().setScale(<span class=\"keyword\">this</span>.getZoom() / <span class=\"number\">8</span>);</span><br><span class=\"line\">  shape.setStyle(style);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h1 id=\"通过-canvas-图层的方式实现\"><a href=\"#通过-canvas-图层的方式实现\" class=\"headerlink\" title=\"通过 canvas 图层的方式实现\"></a>通过 canvas 图层的方式实现</h1><p>&nbsp;&nbsp;再后来转念一想，既然支持 canvas 的 symbol，为何不直接使用 canvas 绘制固定元素呢，果然在 API 中找到了<code>ol.source.ImageCanvas</code>，直接把 canvas 要素当作图层来使用！</p>\n<p><code>ol.source.ImageCanvas</code>的绘制有点需要特别注意的点，这里给出重要代码片段，完整 demo 可以去<a href=\"https://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasLayer.html\" target=\"_blank\" rel=\"noopener\">GitHub</a>查看</p>\n<h2 id=\"创建图层，在-canvasFunction-中写具体的绘图方法\"><a href=\"#创建图层，在-canvasFunction-中写具体的绘图方法\" class=\"headerlink\" title=\"创建图层，在 canvasFunction 中写具体的绘图方法\"></a>创建图层，在 canvasFunction 中写具体的绘图方法</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canvasLayer = <span class=\"keyword\">new</span> ol.layer.Image(&#123;</span><br><span class=\"line\">  source: <span class=\"keyword\">new</span> ol.source.ImageCanvas(&#123;</span><br><span class=\"line\">    canvasFunction: canvasFunction,</span><br><span class=\"line\">    projection: <span class=\"string\">\"EPSG:3857\"</span>,</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"canvasFunction-中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小\"><a href=\"#canvasFunction-中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小\" class=\"headerlink\" title=\"canvasFunction 中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小\"></a>canvasFunction 中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//计算画布和地图四至的偏移量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mapExtent = map.getView().calculateExtent(map.getSize());</span><br><span class=\"line\"><span class=\"keyword\">var</span> canvasOrigin = map.getPixelFromCoordinate([extent[<span class=\"number\">0</span>], extent[<span class=\"number\">3</span>]]);</span><br><span class=\"line\"><span class=\"keyword\">var</span> mapOrigin = map.getPixelFromCoordinate([mapExtent[<span class=\"number\">0</span>], mapExtent[<span class=\"number\">3</span>]]);</span><br><span class=\"line\"><span class=\"keyword\">var</span> delta = [mapOrigin[<span class=\"number\">0</span>] - canvasOrigin[<span class=\"number\">0</span>], mapOrigin[<span class=\"number\">1</span>] - canvasOrigin[<span class=\"number\">1</span>]];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在计算台风风圈的中心点时要补充计算偏移量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> point = ol.proj.transform(coordinate, <span class=\"string\">\"EPSG:4326\"</span>, <span class=\"string\">\"EPSG:3857\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> pixel = map.getPixelFromCoordinate(point);</span><br><span class=\"line\"><span class=\"keyword\">var</span> cX = pixel[<span class=\"number\">0</span>] + delta[<span class=\"number\">0</span>],</span><br><span class=\"line\">  cY = pixel[<span class=\"number\">1</span>] + delta[<span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//利用canvasFunction提供的默认参数分辨率，计算准确的坐标</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> radius_quad = &#123;</span><br><span class=\"line\">  ne: <span class=\"number\">250000</span> / resolution,</span><br><span class=\"line\">  se: <span class=\"number\">250000</span> / resolution,</span><br><span class=\"line\">  sw: <span class=\"number\">180000</span> / resolution,</span><br><span class=\"line\">  nw: <span class=\"number\">150000</span> / resolution,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>最终效果如下，我在同一图层中绘制了多个：<br><img src=\"canvasLayer.png\" alt></p>\n<p>至于绘制 canvas 的方法和上面的 symbol 是一样的。具体代码还请移步<a href=\"https://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasLayer.html\" target=\"_blank\" rel=\"noopener\">GitHub</a>(原谅我厚颜无耻的屡次打广告！)</p>\n<p><strong>特点：</strong>这种方式可以在一个图层中添加多个风圈要素，同时图层支持的功能也比较多，基本满足需求，效果也还行</p>\n<p>&nbsp;&nbsp;这篇应用主要是从一个基本的需求所拓展开来的，canvas 图层的应用我想应该很强大，刚开始研究 openlyaers，相比于 arcgis，ol 很多功能可能要自己实现，但似乎效果上还是能让人满意的，欢迎大家讨论。</p>\n","site":{"data":{}},"excerpt":"<p>本文中所使用的数据来源于<a href=\"http://www.wztf121.com/typhoon.html\" target=\"_blank\" rel=\"noopener\">温州台风网</a>，通过 F12 抓取，你可以在我的<a href=\"https://github.com/zzcyrus/openlayers-demos\" target=\"_blank\" rel=\"noopener\">GitHub</a>上查看数据和本文源代码</p>\n<p>&nbsp;&nbsp;台风的风圈是一种不常见但算的上规则的图形，在上面的网站可以看到最终效果，简单的解剖下其实就是四个 1/4 圆</p>\n<p><img src=\"goal.png\" alt></p>\n<p>从数据结构上也可以看出来：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> radius_quad = &#123;</span><br><span class=\"line\">  ne: <span class=\"number\">250</span>, <span class=\"comment\">//单位为KM</span></span><br><span class=\"line\">  se: <span class=\"number\">250</span>,</span><br><span class=\"line\">  sw: <span class=\"number\">180</span>,</span><br><span class=\"line\">  nw: <span class=\"number\">150</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在某个固定经纬度点上，以此点为圆心组合成了一个所谓的风圈形状，四个方向分别代表每个 1/4 圆的半径。刚开始是为了实现这种效果进行了研究，后来发现 openlayers 对于这种效果的支持还挺有意思，记录下来已做分享。</p>","more":"<h1 id=\"通过自定义-geometry-的实现\"><a href=\"#通过自定义-geometry-的实现\" class=\"headerlink\" title=\"通过自定义 geometry 的实现\"></a>通过自定义 geometry 的实现</h1><p>&nbsp;&nbsp;最原始的思路也是最容易切入的点，就是去看 openlayers 中怎么实现圆形的画法，在 ol 中，有<code>createRegularPolygon</code>这个类，原理就是给定一些参数，用点去填充我们想要的形状，当填进去点达到一定密集度，自然就能得到一个近似的圆。<br>&nbsp;&nbsp;通过这个思路我们可以计算台风风圈的每个 1/4 圆的坐标，用点去占位，最终实现绘制出想要的图形。</p>\n<p>具体代码可以去看某大牛的博客，这里只给出一个传送门，写的很详细了：<br><a href=\"http://blog.csdn.net/gisshixisheng/article/details/76397068\" target=\"_blank\" rel=\"noopener\">点我乘坐飞机</a> <strong>这个算法还有些不完善，就是在每个 1/4 圆结束时候少计算了一个点，导致看着有点不对劲</strong></p>\n<p><strong>特点:</strong> 这种方式画出来的图形是一个图层中的一个 feature，好处自然不用多说，基本上 feature 支持的功能都能满足！</p>\n<h1 id=\"通过-canvas-类型的-symbol-实现\"><a href=\"#通过-canvas-类型的-symbol-实现\" class=\"headerlink\" title=\"通过 canvas 类型的 symbol 实现\"></a>通过 canvas 类型的 symbol 实现</h1><p>&nbsp;&nbsp;在点密集的情况下，用上面的方式其实效果已经很不错了，但是有些细（tiao）心（ci）的使用者，非要放大到一定程度，然后说你这个不够圆，那。。。。。</p>\n<p>&nbsp;&nbsp;那我们就用 canvas 画出来，openlayers 中，要素的样式是有这么一种方式<code>ol.style.Icon</code>来实现，我们可以把绘制好的元素作为<code>Icon</code>的参数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> style = <span class=\"keyword\">new</span> ol.style.Style(&#123;</span><br><span class=\"line\">  image: <span class=\"keyword\">new</span> ol.style.Icon(&#123;</span><br><span class=\"line\">    opacity: <span class=\"number\">0.3</span>,</span><br><span class=\"line\">    img: canvas,</span><br><span class=\"line\">    imgSize: [canvas.width, canvas.height],</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>canvans 绘制的方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createTyphoon</span>(<span class=\"params\">radius, radius_quad</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> canvas = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"canvas\"</span>);</span><br><span class=\"line\">  canvas.width = canvas.height = <span class=\"number\">2</span> * radius;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> context = canvas.getContext(<span class=\"string\">\"2d\"</span>);</span><br><span class=\"line\">  context.fillStyle = <span class=\"string\">\"#0000ff\"</span>;</span><br><span class=\"line\">  context.strokeStyle = <span class=\"string\">\"#ff0000\"</span>;</span><br><span class=\"line\">  context.lineWidth = <span class=\"number\">3</span>;</span><br><span class=\"line\">  context.beginPath();</span><br><span class=\"line\">  context.arc(radius, radius, radius_quad.se, <span class=\"number\">0</span>, <span class=\"number\">0.5</span> * <span class=\"built_in\">Math</span>.PI);</span><br><span class=\"line\">  context.lineTo(radius, radius + radius_quad.sw);</span><br><span class=\"line\">  context.arc(radius, radius, radius_quad.sw, <span class=\"number\">0.5</span> * <span class=\"built_in\">Math</span>.PI, <span class=\"built_in\">Math</span>.PI);</span><br><span class=\"line\">  context.lineTo(radius - radius_quad.nw, radius);</span><br><span class=\"line\">  context.arc(radius, radius, radius_quad.nw, <span class=\"built_in\">Math</span>.PI, <span class=\"number\">1.5</span> * <span class=\"built_in\">Math</span>.PI);</span><br><span class=\"line\">  context.lineTo(radius, radius - radius_quad.ne);</span><br><span class=\"line\">  context.arc(radius, radius, radius_quad.ne, <span class=\"number\">1.5</span> * <span class=\"built_in\">Math</span>.PI, <span class=\"number\">0</span>);</span><br><span class=\"line\">  context.lineTo(radius + radius_quad.se, radius);</span><br><span class=\"line\">  context.fill();</span><br><span class=\"line\">  context.stroke();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> canvas;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>效果如下图：<br><img src=\"canvasSymbol.png\" alt></p>\n<p><a href=\"https://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasSymbol.html\" target=\"_blank\" rel=\"noopener\">本方法完整代码</a></p>\n<p><strong>特点：</strong> 这种方式，绘制出来的台风风圈其实只是一个 symbol 符号，需要把这个符号赋给一个具体的要素，比如一个点，一个圆之类的，而且根据分辨率还要去调整样式的缩放</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">map.getView().on(<span class=\"string\">\"change:resolution\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> style = shape.getStyle();</span><br><span class=\"line\">  <span class=\"comment\">// 重新设置图标的缩放率</span></span><br><span class=\"line\">  style.getImage().setScale(<span class=\"keyword\">this</span>.getZoom() / <span class=\"number\">8</span>);</span><br><span class=\"line\">  shape.setStyle(style);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h1 id=\"通过-canvas-图层的方式实现\"><a href=\"#通过-canvas-图层的方式实现\" class=\"headerlink\" title=\"通过 canvas 图层的方式实现\"></a>通过 canvas 图层的方式实现</h1><p>&nbsp;&nbsp;再后来转念一想，既然支持 canvas 的 symbol，为何不直接使用 canvas 绘制固定元素呢，果然在 API 中找到了<code>ol.source.ImageCanvas</code>，直接把 canvas 要素当作图层来使用！</p>\n<p><code>ol.source.ImageCanvas</code>的绘制有点需要特别注意的点，这里给出重要代码片段，完整 demo 可以去<a href=\"https://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasLayer.html\" target=\"_blank\" rel=\"noopener\">GitHub</a>查看</p>\n<h2 id=\"创建图层，在-canvasFunction-中写具体的绘图方法\"><a href=\"#创建图层，在-canvasFunction-中写具体的绘图方法\" class=\"headerlink\" title=\"创建图层，在 canvasFunction 中写具体的绘图方法\"></a>创建图层，在 canvasFunction 中写具体的绘图方法</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canvasLayer = <span class=\"keyword\">new</span> ol.layer.Image(&#123;</span><br><span class=\"line\">  source: <span class=\"keyword\">new</span> ol.source.ImageCanvas(&#123;</span><br><span class=\"line\">    canvasFunction: canvasFunction,</span><br><span class=\"line\">    projection: <span class=\"string\">\"EPSG:3857\"</span>,</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"canvasFunction-中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小\"><a href=\"#canvasFunction-中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小\" class=\"headerlink\" title=\"canvasFunction 中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小\"></a>canvasFunction 中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//计算画布和地图四至的偏移量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mapExtent = map.getView().calculateExtent(map.getSize());</span><br><span class=\"line\"><span class=\"keyword\">var</span> canvasOrigin = map.getPixelFromCoordinate([extent[<span class=\"number\">0</span>], extent[<span class=\"number\">3</span>]]);</span><br><span class=\"line\"><span class=\"keyword\">var</span> mapOrigin = map.getPixelFromCoordinate([mapExtent[<span class=\"number\">0</span>], mapExtent[<span class=\"number\">3</span>]]);</span><br><span class=\"line\"><span class=\"keyword\">var</span> delta = [mapOrigin[<span class=\"number\">0</span>] - canvasOrigin[<span class=\"number\">0</span>], mapOrigin[<span class=\"number\">1</span>] - canvasOrigin[<span class=\"number\">1</span>]];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在计算台风风圈的中心点时要补充计算偏移量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> point = ol.proj.transform(coordinate, <span class=\"string\">\"EPSG:4326\"</span>, <span class=\"string\">\"EPSG:3857\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> pixel = map.getPixelFromCoordinate(point);</span><br><span class=\"line\"><span class=\"keyword\">var</span> cX = pixel[<span class=\"number\">0</span>] + delta[<span class=\"number\">0</span>],</span><br><span class=\"line\">  cY = pixel[<span class=\"number\">1</span>] + delta[<span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//利用canvasFunction提供的默认参数分辨率，计算准确的坐标</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> radius_quad = &#123;</span><br><span class=\"line\">  ne: <span class=\"number\">250000</span> / resolution,</span><br><span class=\"line\">  se: <span class=\"number\">250000</span> / resolution,</span><br><span class=\"line\">  sw: <span class=\"number\">180000</span> / resolution,</span><br><span class=\"line\">  nw: <span class=\"number\">150000</span> / resolution,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>最终效果如下，我在同一图层中绘制了多个：<br><img src=\"canvasLayer.png\" alt></p>\n<p>至于绘制 canvas 的方法和上面的 symbol 是一样的。具体代码还请移步<a href=\"https://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasLayer.html\" target=\"_blank\" rel=\"noopener\">GitHub</a>(原谅我厚颜无耻的屡次打广告！)</p>\n<p><strong>特点：</strong>这种方式可以在一个图层中添加多个风圈要素，同时图层支持的功能也比较多，基本满足需求，效果也还行</p>\n<p>&nbsp;&nbsp;这篇应用主要是从一个基本的需求所拓展开来的，canvas 图层的应用我想应该很强大，刚开始研究 openlyaers，相比于 arcgis，ol 很多功能可能要自己实现，但似乎效果上还是能让人满意的，欢迎大家讨论。</p>"},{"title":"试着还原下墨迹mapbox合作的雷达图展示","date":"2020-06-23T06:58:12.000Z","_content":"\n在[四步走，墨迹天气雷达数据可视化指南](https://juejin.im/post/5d4e8572e51d453c12504dd4)这篇文章中，提到了用**矢量瓦片**代替传统传统栅格图像可视化方案，可以达到更流程的性能，更高清的数据展示，更灵活的样式表达。感觉挺有意思，同时也为了考察这么做的成本，就试着还原做了下。\n\n从文章来看整个过程总结起来就是准备数据`geojson`，切成`pbf`或者`mbtiles`在 mapbox 中展示。\n\n<!--more-->\n\n# 背景\n\n按惯例先解释下雷达数据。我之前通俗的把气象数据划分为了站点（散点）和格点两类，暂且不细说雷达数据到底属于哪类，但最终都可以通过比方说插值来得到一份格点数据。传统的`栅格图像`可视化方案是基于格点数据利用[matplotlib.pyplot.contourf](https://matplotlib.org/3.2.1/api/_as_gen/matplotlib.pyplot.contourf.html)这类工具，依据一定标准的图例，生成出来的一张等值面图，考虑到网络的传输，这种图片得体积小，分辨率就会下降，所以在缩放时候会失真，出现马赛克，矢量瓦片的出现就可以很自然的解决这个问题。\n\n我会用降水格点数据来代替雷达数据进行了测试，二者数据格式内容上来说都相差不大，且都能用来反映未来降水的趋势。\n\n# 开发\n\n选用了 10 个时次的降水格点数据，格点大小为`511*581`，经度范围为`113.2, 119.4`，纬度范围为`37.4, 42.7`。\n\n## 生成 geojson\n\n这一步其实有很多选择，文章里面也提到了一些，我都做了一些尝试，列一下尝试结果：\n\n- [d3-contour](https://github.com/d3/d3-contour)\n\n```js\nconst contour = require(\"d3-contour\").contours;\n\nconst levels = [\n  0.0,\n  0.0001,\n  0.5,\n  1.0,\n  2.0,\n  3.0,\n  5.0,\n  7.0,\n  10.0,\n  13.0,\n  16.0,\n  20.0,\n  25.0,\n  40.0,\n  9999.0,\n];\nconst lonRange = [113.2, 119.4];\nconst latRange = [37.4, 42.7];\n\n// 生成等值面，data为格点数据数组\nconst contours = contour().size([511, 581]).thresholds(levels)(data);\n\nconst geojson = [];\n// d3用的是平面坐标，需要转换成经纬度\nfor (let i = 0; i < contours.length; i++) {\n  const item = contours[i];\n  const { coordinates } = item;\n  if (coordinates.length === 0) {\n    continue;\n  }\n  const coords = coordinates.map((item) => {\n    return item.map((ele) => {\n      return ele.map((e) => {\n        const [x, y] = e;\n        return [\n          lonRange[0] + ((511 - x) * (lonRange[1] - lonRange[0])) / 511,\n          latRange[0] + ((581 - y) * (latRange[1] - latRange[0])) / 581,\n        ];\n      });\n    });\n  });\n  geojson.push({\n    type: \"Feature\",\n    geometry: {\n      type: item.type,\n      coordinates: coords,\n    },\n    properties: {\n      value: item.value,\n    },\n  });\n}\n\n// 最终结果\nconst isoFc = {\n  type: \"FeatureCollection\",\n  features: geojson,\n};\n```\n\n- [turf-isobands](http://turfjs.org/docs/#isobands)\n\n```js\nconst point = require(\"@turf/helpers\").point;\nconst featureCollection = require(\"@turf/helpers\").featureCollection;\nconst isobands = require(\"@turf/isobands\");\n\nconst levels = [\n  0.0,\n  0.0001,\n  0.5,\n  1.0,\n  2.0,\n  3.0,\n  5.0,\n  7.0,\n  10.0,\n  13.0,\n  16.0,\n  20.0,\n  25.0,\n  40.0,\n  9999.0,\n];\nconst lonRange = [113.2, 119.4];\nconst latRange = [37.4, 42.7];\n\n// 把格点数据数组转换成feature类型为point的数组\nconst pointArray = [];\nfor (let j = 0; j < 581; j++) {\n  for (let i = 0; i < 511; i++) {\n    const lon = lonRange[0] + ((511 - i) * (lonRange[1] - lonRange[0])) / 511;\n    const lat = latRange[0] + ((581 - j) * (latRange[1] - latRange[0])) / 581;\n    // data 是格点数据数组\n    const value = data[j * 511 + i];\n    pointArray.push(point([lon, lat], { value }));\n  }\n}\nconst gridFc = featureCollection(pointArray);\n\n// 生成等值面\nconst isoFc = isobands(gridFc, levels, {\n  zProperty: \"value\",\n});\n\n// isoFc 就是生成的geojson内容，保存成文件即可\n```\n\n上面两种方式生成的结果，偶尔会出现的不同级别等值面重叠的情况，这样在前端渲染的时候，由于颜色通道的叠加，会导致重叠部分数据渲染错误的情况，不知道是我使用时候生成方法的弄错还是渲染方法弄错了，效果不太满意。\n\n- **[geojsoncounter（建议）](https://github.com/bartromgens/geojsoncontour)**\n\n```python\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport geojsoncontour\n\nlevels = [0.0, 0.0001, 0.5, 1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 13.0, 16.0, 20.0, 25.0, 40.0, 9999.0]\nsize = [511, 581]\nlon_range = [113.2, 119.4]\nlat_range = [37.4, 42.7]\n\nlons = np.linspace(lon_range[0], lon_range[1], size[0])\nlats = np.linspace(lat_range[0], lat_range[1], size[1])\n\n# pre为格点数据数组\ndata = np.array(pre)\n# 生成等直面图\ncontour = plt.contourf(lons, lats, data, levels=levels)\ngeojson_filepath = 'output/'\n# 转换成geojson\ngeojsoncontour.contourf_to_geojson(contourf=contour, ndigits=20,geojson_filepath=geojson_filepath)\n```\n\n实践下来感觉这个方法生成的 geojson 效果会更好，我个人比较推荐使用。原理上就是先生成了传统等值面图片，把像素结果转换成了 geojson 数据。\n\n## 合并 geojson（可选）\n\n这一步很有趣，如果把每个时刻的降水数据做成单独的 geojson，在根据时序进行播放的时候就需要每次移除、加载图层，会有卡顿的效果，而看文章里面墨迹使用了 mapbox 的`setFilter`功能，所以猜测是对 geojson 进行了合并。\n\n在 QGIS 中打开了已经生成的 10 个 geojson 进行了合并，可以在属性表里面看到，每个图层的顺序是通过`layer`字段进行区分的，后面会用上。\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/merge-geojson-20200622155323.png)\n\n## 生成矢量瓦片\n\n使用[mapbox/tippecanoe](https://github.com/mapbox/tippecanoe)这个官方工具就好了。如果在上面选择了合并 geojson，那么只需要对合并后的单个文件切瓦片就好了，不然就是对每个时刻的数据单独执行以下切瓦片的命令。\n\n```bash\ntippecanoe -e /Downloads/pbf --no-tile-compression -zg --drop-densest-as-needed -l pre merge.geojson\n```\n\n> -e 是生成目录\n> --no-tile-compression 是不对生成的 pbf 进行压缩，否则加载时候会报错\n> -zg --drop-densest-as-needed 是自动去判断瓦片的最大最小级别\n> -l 是手动指定图层名字\n\n## 展示\n\n- 在 leaflet 加载使用插件[Leaflet.VectorGrid](https://github.com/Leaflet/Leaflet.VectorGrid)就好\n\n```js\nconst map = L.map(\"map\", {\n  center: [40.03193433735177, 118.03342979913123],\n  zoom: 6,\n});\n\nconst vectorTileOptions = {\n  rendererFactory: L.canvas.tile,\n  // 设置生成的pbf的最大zoom\n  maxNativeZoom: 7,\n  vectorTileLayerStyles: {\n    // pre 是 -l 参数的图层名称\n    pre: function (properties, zoom) {\n      // 找到属性中对应降水量的属性设置图例\n      const level = parseFloat(properties.title).toString();\n      let color = \"rgba(0, 0, 0, 0)\";\n      switch (level) {\n        case \"0.0001\":\n          color = \"rgba(153,255,153,255)\";\n          break;\n        case \"0.5\":\n          color = \"rgba(51,204,102,255)\";\n          break;\n        case \"1\":\n          color = \"rgba(51,153,0,255)\";\n          break;\n        // ......\n      }\n      return {\n        weight: 1,\n        color: color,\n        opacity: 1,\n        fillColor: color,\n        fill: true,\n        fillOpacity: 0.7,\n      };\n    },\n  },\n};\n\nnew L.vectorGrid.protobuf(\n  `http://localhost:8080/assets/pbf/{z}/{x}/{y}.pbf`,\n  vectorTileOptions\n).addTo(map);\n```\n\n- 在 mapbox 中加载直接定义一个自定义 source，并加载\n\n```js\nconst map = new mapboxgl.Map({\n  container: \"map\",\n  style: \"mapbox://styles/mapbox/light-v10\",\n  zoom: 6,\n  center: [118.03342979913123, 40.03193433735177],\n  antialias: true,\n});\n\nmap.on(\"load\", function () {\n  map.addSource(\"radar-pbf\", {\n    type: \"vector\",\n    tiles: [`http://localhost:8080/assets/collection/{z}/{x}/{y}.pbf`],\n    maxzoom: 7, // 设置生成的pbf的最大zoom\n  });\n\n  pbfMap.addLayer({\n    id: \"radar-pbf\",\n    type: \"fill\",\n    source: \"radar-pbf\",\n    filter: [\"==\", \"layer\", \"1\"], // 合并的话可以使用过滤\n    \"source-layer\": \"pre\", // pre 是 -l 参数的图层名称\n    layout: {\n      visibility: \"visible\",\n    },\n    paint: {\n      \"fill-opacity\": 0.7,\n      \"fill-color\": [\n        \"match\",\n        [\"get\", \"title\"],\n        [\"0.000100 \"],\n        \"rgba(153,255,153,255)\",\n        [\"0.500000 \"],\n        \"rgba(51,204,102,255)\",\n        [\"1.000000 \"],\n        \"rgba(51,153,0,255)\",\n        // ......\n        \"rgba(0, 0, 0, 0)\", // 默认color\n      ],\n    },\n  });\n});\n```\n\n# 待优化\n\n其实还有个工作没有尝试就是原文里面说的，对两个相邻间隔时间的数据做插值处理，以追求更加平滑的播放效果。个人感觉这个处理对于面向大众的场景比较实用，但在专业方面，有待使用更科学的方法进行处理。\n","source":"_posts/2020/radar-vector-tile-try.md","raw":"---\ntitle: 试着还原下墨迹mapbox合作的雷达图展示\ndate: 2020-06-23 14:58:12\ntags: [GIS]\ncategories: WebGIS\n---\n\n在[四步走，墨迹天气雷达数据可视化指南](https://juejin.im/post/5d4e8572e51d453c12504dd4)这篇文章中，提到了用**矢量瓦片**代替传统传统栅格图像可视化方案，可以达到更流程的性能，更高清的数据展示，更灵活的样式表达。感觉挺有意思，同时也为了考察这么做的成本，就试着还原做了下。\n\n从文章来看整个过程总结起来就是准备数据`geojson`，切成`pbf`或者`mbtiles`在 mapbox 中展示。\n\n<!--more-->\n\n# 背景\n\n按惯例先解释下雷达数据。我之前通俗的把气象数据划分为了站点（散点）和格点两类，暂且不细说雷达数据到底属于哪类，但最终都可以通过比方说插值来得到一份格点数据。传统的`栅格图像`可视化方案是基于格点数据利用[matplotlib.pyplot.contourf](https://matplotlib.org/3.2.1/api/_as_gen/matplotlib.pyplot.contourf.html)这类工具，依据一定标准的图例，生成出来的一张等值面图，考虑到网络的传输，这种图片得体积小，分辨率就会下降，所以在缩放时候会失真，出现马赛克，矢量瓦片的出现就可以很自然的解决这个问题。\n\n我会用降水格点数据来代替雷达数据进行了测试，二者数据格式内容上来说都相差不大，且都能用来反映未来降水的趋势。\n\n# 开发\n\n选用了 10 个时次的降水格点数据，格点大小为`511*581`，经度范围为`113.2, 119.4`，纬度范围为`37.4, 42.7`。\n\n## 生成 geojson\n\n这一步其实有很多选择，文章里面也提到了一些，我都做了一些尝试，列一下尝试结果：\n\n- [d3-contour](https://github.com/d3/d3-contour)\n\n```js\nconst contour = require(\"d3-contour\").contours;\n\nconst levels = [\n  0.0,\n  0.0001,\n  0.5,\n  1.0,\n  2.0,\n  3.0,\n  5.0,\n  7.0,\n  10.0,\n  13.0,\n  16.0,\n  20.0,\n  25.0,\n  40.0,\n  9999.0,\n];\nconst lonRange = [113.2, 119.4];\nconst latRange = [37.4, 42.7];\n\n// 生成等值面，data为格点数据数组\nconst contours = contour().size([511, 581]).thresholds(levels)(data);\n\nconst geojson = [];\n// d3用的是平面坐标，需要转换成经纬度\nfor (let i = 0; i < contours.length; i++) {\n  const item = contours[i];\n  const { coordinates } = item;\n  if (coordinates.length === 0) {\n    continue;\n  }\n  const coords = coordinates.map((item) => {\n    return item.map((ele) => {\n      return ele.map((e) => {\n        const [x, y] = e;\n        return [\n          lonRange[0] + ((511 - x) * (lonRange[1] - lonRange[0])) / 511,\n          latRange[0] + ((581 - y) * (latRange[1] - latRange[0])) / 581,\n        ];\n      });\n    });\n  });\n  geojson.push({\n    type: \"Feature\",\n    geometry: {\n      type: item.type,\n      coordinates: coords,\n    },\n    properties: {\n      value: item.value,\n    },\n  });\n}\n\n// 最终结果\nconst isoFc = {\n  type: \"FeatureCollection\",\n  features: geojson,\n};\n```\n\n- [turf-isobands](http://turfjs.org/docs/#isobands)\n\n```js\nconst point = require(\"@turf/helpers\").point;\nconst featureCollection = require(\"@turf/helpers\").featureCollection;\nconst isobands = require(\"@turf/isobands\");\n\nconst levels = [\n  0.0,\n  0.0001,\n  0.5,\n  1.0,\n  2.0,\n  3.0,\n  5.0,\n  7.0,\n  10.0,\n  13.0,\n  16.0,\n  20.0,\n  25.0,\n  40.0,\n  9999.0,\n];\nconst lonRange = [113.2, 119.4];\nconst latRange = [37.4, 42.7];\n\n// 把格点数据数组转换成feature类型为point的数组\nconst pointArray = [];\nfor (let j = 0; j < 581; j++) {\n  for (let i = 0; i < 511; i++) {\n    const lon = lonRange[0] + ((511 - i) * (lonRange[1] - lonRange[0])) / 511;\n    const lat = latRange[0] + ((581 - j) * (latRange[1] - latRange[0])) / 581;\n    // data 是格点数据数组\n    const value = data[j * 511 + i];\n    pointArray.push(point([lon, lat], { value }));\n  }\n}\nconst gridFc = featureCollection(pointArray);\n\n// 生成等值面\nconst isoFc = isobands(gridFc, levels, {\n  zProperty: \"value\",\n});\n\n// isoFc 就是生成的geojson内容，保存成文件即可\n```\n\n上面两种方式生成的结果，偶尔会出现的不同级别等值面重叠的情况，这样在前端渲染的时候，由于颜色通道的叠加，会导致重叠部分数据渲染错误的情况，不知道是我使用时候生成方法的弄错还是渲染方法弄错了，效果不太满意。\n\n- **[geojsoncounter（建议）](https://github.com/bartromgens/geojsoncontour)**\n\n```python\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport geojsoncontour\n\nlevels = [0.0, 0.0001, 0.5, 1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 13.0, 16.0, 20.0, 25.0, 40.0, 9999.0]\nsize = [511, 581]\nlon_range = [113.2, 119.4]\nlat_range = [37.4, 42.7]\n\nlons = np.linspace(lon_range[0], lon_range[1], size[0])\nlats = np.linspace(lat_range[0], lat_range[1], size[1])\n\n# pre为格点数据数组\ndata = np.array(pre)\n# 生成等直面图\ncontour = plt.contourf(lons, lats, data, levels=levels)\ngeojson_filepath = 'output/'\n# 转换成geojson\ngeojsoncontour.contourf_to_geojson(contourf=contour, ndigits=20,geojson_filepath=geojson_filepath)\n```\n\n实践下来感觉这个方法生成的 geojson 效果会更好，我个人比较推荐使用。原理上就是先生成了传统等值面图片，把像素结果转换成了 geojson 数据。\n\n## 合并 geojson（可选）\n\n这一步很有趣，如果把每个时刻的降水数据做成单独的 geojson，在根据时序进行播放的时候就需要每次移除、加载图层，会有卡顿的效果，而看文章里面墨迹使用了 mapbox 的`setFilter`功能，所以猜测是对 geojson 进行了合并。\n\n在 QGIS 中打开了已经生成的 10 个 geojson 进行了合并，可以在属性表里面看到，每个图层的顺序是通过`layer`字段进行区分的，后面会用上。\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/merge-geojson-20200622155323.png)\n\n## 生成矢量瓦片\n\n使用[mapbox/tippecanoe](https://github.com/mapbox/tippecanoe)这个官方工具就好了。如果在上面选择了合并 geojson，那么只需要对合并后的单个文件切瓦片就好了，不然就是对每个时刻的数据单独执行以下切瓦片的命令。\n\n```bash\ntippecanoe -e /Downloads/pbf --no-tile-compression -zg --drop-densest-as-needed -l pre merge.geojson\n```\n\n> -e 是生成目录\n> --no-tile-compression 是不对生成的 pbf 进行压缩，否则加载时候会报错\n> -zg --drop-densest-as-needed 是自动去判断瓦片的最大最小级别\n> -l 是手动指定图层名字\n\n## 展示\n\n- 在 leaflet 加载使用插件[Leaflet.VectorGrid](https://github.com/Leaflet/Leaflet.VectorGrid)就好\n\n```js\nconst map = L.map(\"map\", {\n  center: [40.03193433735177, 118.03342979913123],\n  zoom: 6,\n});\n\nconst vectorTileOptions = {\n  rendererFactory: L.canvas.tile,\n  // 设置生成的pbf的最大zoom\n  maxNativeZoom: 7,\n  vectorTileLayerStyles: {\n    // pre 是 -l 参数的图层名称\n    pre: function (properties, zoom) {\n      // 找到属性中对应降水量的属性设置图例\n      const level = parseFloat(properties.title).toString();\n      let color = \"rgba(0, 0, 0, 0)\";\n      switch (level) {\n        case \"0.0001\":\n          color = \"rgba(153,255,153,255)\";\n          break;\n        case \"0.5\":\n          color = \"rgba(51,204,102,255)\";\n          break;\n        case \"1\":\n          color = \"rgba(51,153,0,255)\";\n          break;\n        // ......\n      }\n      return {\n        weight: 1,\n        color: color,\n        opacity: 1,\n        fillColor: color,\n        fill: true,\n        fillOpacity: 0.7,\n      };\n    },\n  },\n};\n\nnew L.vectorGrid.protobuf(\n  `http://localhost:8080/assets/pbf/{z}/{x}/{y}.pbf`,\n  vectorTileOptions\n).addTo(map);\n```\n\n- 在 mapbox 中加载直接定义一个自定义 source，并加载\n\n```js\nconst map = new mapboxgl.Map({\n  container: \"map\",\n  style: \"mapbox://styles/mapbox/light-v10\",\n  zoom: 6,\n  center: [118.03342979913123, 40.03193433735177],\n  antialias: true,\n});\n\nmap.on(\"load\", function () {\n  map.addSource(\"radar-pbf\", {\n    type: \"vector\",\n    tiles: [`http://localhost:8080/assets/collection/{z}/{x}/{y}.pbf`],\n    maxzoom: 7, // 设置生成的pbf的最大zoom\n  });\n\n  pbfMap.addLayer({\n    id: \"radar-pbf\",\n    type: \"fill\",\n    source: \"radar-pbf\",\n    filter: [\"==\", \"layer\", \"1\"], // 合并的话可以使用过滤\n    \"source-layer\": \"pre\", // pre 是 -l 参数的图层名称\n    layout: {\n      visibility: \"visible\",\n    },\n    paint: {\n      \"fill-opacity\": 0.7,\n      \"fill-color\": [\n        \"match\",\n        [\"get\", \"title\"],\n        [\"0.000100 \"],\n        \"rgba(153,255,153,255)\",\n        [\"0.500000 \"],\n        \"rgba(51,204,102,255)\",\n        [\"1.000000 \"],\n        \"rgba(51,153,0,255)\",\n        // ......\n        \"rgba(0, 0, 0, 0)\", // 默认color\n      ],\n    },\n  });\n});\n```\n\n# 待优化\n\n其实还有个工作没有尝试就是原文里面说的，对两个相邻间隔时间的数据做插值处理，以追求更加平滑的播放效果。个人感觉这个处理对于面向大众的场景比较实用，但在专业方面，有待使用更科学的方法进行处理。\n","slug":"radar-vector-tile-try","published":1,"updated":"2020-06-23T07:00:11.492Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrkxgsv0005i83i7hxm9leo","content":"<p>在<a href=\"https://juejin.im/post/5d4e8572e51d453c12504dd4\" target=\"_blank\" rel=\"noopener\">四步走，墨迹天气雷达数据可视化指南</a>这篇文章中，提到了用<strong>矢量瓦片</strong>代替传统传统栅格图像可视化方案，可以达到更流程的性能，更高清的数据展示，更灵活的样式表达。感觉挺有意思，同时也为了考察这么做的成本，就试着还原做了下。</p>\n<p>从文章来看整个过程总结起来就是准备数据<code>geojson</code>，切成<code>pbf</code>或者<code>mbtiles</code>在 mapbox 中展示。</p>\n<a id=\"more\"></a>\n<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>按惯例先解释下雷达数据。我之前通俗的把气象数据划分为了站点（散点）和格点两类，暂且不细说雷达数据到底属于哪类，但最终都可以通过比方说插值来得到一份格点数据。传统的<code>栅格图像</code>可视化方案是基于格点数据利用<a href=\"https://matplotlib.org/3.2.1/api/_as_gen/matplotlib.pyplot.contourf.html\" target=\"_blank\" rel=\"noopener\">matplotlib.pyplot.contourf</a>这类工具，依据一定标准的图例，生成出来的一张等值面图，考虑到网络的传输，这种图片得体积小，分辨率就会下降，所以在缩放时候会失真，出现马赛克，矢量瓦片的出现就可以很自然的解决这个问题。</p>\n<p>我会用降水格点数据来代替雷达数据进行了测试，二者数据格式内容上来说都相差不大，且都能用来反映未来降水的趋势。</p>\n<h1 id=\"开发\"><a href=\"#开发\" class=\"headerlink\" title=\"开发\"></a>开发</h1><p>选用了 10 个时次的降水格点数据，格点大小为<code>511*581</code>，经度范围为<code>113.2, 119.4</code>，纬度范围为<code>37.4, 42.7</code>。</p>\n<h2 id=\"生成-geojson\"><a href=\"#生成-geojson\" class=\"headerlink\" title=\"生成 geojson\"></a>生成 geojson</h2><p>这一步其实有很多选择，文章里面也提到了一些，我都做了一些尝试，列一下尝试结果：</p>\n<ul>\n<li><a href=\"https://github.com/d3/d3-contour\" target=\"_blank\" rel=\"noopener\">d3-contour</a></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> contour = <span class=\"built_in\">require</span>(<span class=\"string\">\"d3-contour\"</span>).contours;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> levels = [</span><br><span class=\"line\">  <span class=\"number\">0.0</span>,</span><br><span class=\"line\">  <span class=\"number\">0.0001</span>,</span><br><span class=\"line\">  <span class=\"number\">0.5</span>,</span><br><span class=\"line\">  <span class=\"number\">1.0</span>,</span><br><span class=\"line\">  <span class=\"number\">2.0</span>,</span><br><span class=\"line\">  <span class=\"number\">3.0</span>,</span><br><span class=\"line\">  <span class=\"number\">5.0</span>,</span><br><span class=\"line\">  <span class=\"number\">7.0</span>,</span><br><span class=\"line\">  <span class=\"number\">10.0</span>,</span><br><span class=\"line\">  <span class=\"number\">13.0</span>,</span><br><span class=\"line\">  <span class=\"number\">16.0</span>,</span><br><span class=\"line\">  <span class=\"number\">20.0</span>,</span><br><span class=\"line\">  <span class=\"number\">25.0</span>,</span><br><span class=\"line\">  <span class=\"number\">40.0</span>,</span><br><span class=\"line\">  <span class=\"number\">9999.0</span>,</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"keyword\">const</span> lonRange = [<span class=\"number\">113.2</span>, <span class=\"number\">119.4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> latRange = [<span class=\"number\">37.4</span>, <span class=\"number\">42.7</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生成等值面，data为格点数据数组</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> contours = contour().size([<span class=\"number\">511</span>, <span class=\"number\">581</span>]).thresholds(levels)(data);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> geojson = [];</span><br><span class=\"line\"><span class=\"comment\">// d3用的是平面坐标，需要转换成经纬度</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; contours.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> item = contours[i];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; coordinates &#125; = item;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (coordinates.length === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> coords = coordinates.map(<span class=\"function\">(<span class=\"params\">item</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> item.map(<span class=\"function\">(<span class=\"params\">ele</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ele.map(<span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> [x, y] = e;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [</span><br><span class=\"line\">          lonRange[<span class=\"number\">0</span>] + ((<span class=\"number\">511</span> - x) * (lonRange[<span class=\"number\">1</span>] - lonRange[<span class=\"number\">0</span>])) / <span class=\"number\">511</span>,</span><br><span class=\"line\">          latRange[<span class=\"number\">0</span>] + ((<span class=\"number\">581</span> - y) * (latRange[<span class=\"number\">1</span>] - latRange[<span class=\"number\">0</span>])) / <span class=\"number\">581</span>,</span><br><span class=\"line\">        ];</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  geojson.push(&#123;</span><br><span class=\"line\">    type: <span class=\"string\">\"Feature\"</span>,</span><br><span class=\"line\">    geometry: &#123;</span><br><span class=\"line\">      type: item.type,</span><br><span class=\"line\">      coordinates: coords,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    properties: &#123;</span><br><span class=\"line\">      value: item.value,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 最终结果</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> isoFc = &#123;</span><br><span class=\"line\">  type: <span class=\"string\">\"FeatureCollection\"</span>,</span><br><span class=\"line\">  features: geojson,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><a href=\"http://turfjs.org/docs/#isobands\" target=\"_blank\" rel=\"noopener\">turf-isobands</a></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> point = <span class=\"built_in\">require</span>(<span class=\"string\">\"@turf/helpers\"</span>).point;</span><br><span class=\"line\"><span class=\"keyword\">const</span> featureCollection = <span class=\"built_in\">require</span>(<span class=\"string\">\"@turf/helpers\"</span>).featureCollection;</span><br><span class=\"line\"><span class=\"keyword\">const</span> isobands = <span class=\"built_in\">require</span>(<span class=\"string\">\"@turf/isobands\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> levels = [</span><br><span class=\"line\">  <span class=\"number\">0.0</span>,</span><br><span class=\"line\">  <span class=\"number\">0.0001</span>,</span><br><span class=\"line\">  <span class=\"number\">0.5</span>,</span><br><span class=\"line\">  <span class=\"number\">1.0</span>,</span><br><span class=\"line\">  <span class=\"number\">2.0</span>,</span><br><span class=\"line\">  <span class=\"number\">3.0</span>,</span><br><span class=\"line\">  <span class=\"number\">5.0</span>,</span><br><span class=\"line\">  <span class=\"number\">7.0</span>,</span><br><span class=\"line\">  <span class=\"number\">10.0</span>,</span><br><span class=\"line\">  <span class=\"number\">13.0</span>,</span><br><span class=\"line\">  <span class=\"number\">16.0</span>,</span><br><span class=\"line\">  <span class=\"number\">20.0</span>,</span><br><span class=\"line\">  <span class=\"number\">25.0</span>,</span><br><span class=\"line\">  <span class=\"number\">40.0</span>,</span><br><span class=\"line\">  <span class=\"number\">9999.0</span>,</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"keyword\">const</span> lonRange = [<span class=\"number\">113.2</span>, <span class=\"number\">119.4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> latRange = [<span class=\"number\">37.4</span>, <span class=\"number\">42.7</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 把格点数据数组转换成feature类型为point的数组</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> pointArray = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">581</span>; j++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">511</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> lon = lonRange[<span class=\"number\">0</span>] + ((<span class=\"number\">511</span> - i) * (lonRange[<span class=\"number\">1</span>] - lonRange[<span class=\"number\">0</span>])) / <span class=\"number\">511</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> lat = latRange[<span class=\"number\">0</span>] + ((<span class=\"number\">581</span> - j) * (latRange[<span class=\"number\">1</span>] - latRange[<span class=\"number\">0</span>])) / <span class=\"number\">581</span>;</span><br><span class=\"line\">    <span class=\"comment\">// data 是格点数据数组</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> value = data[j * <span class=\"number\">511</span> + i];</span><br><span class=\"line\">    pointArray.push(point([lon, lat], &#123; value &#125;));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> gridFc = featureCollection(pointArray);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生成等值面</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> isoFc = isobands(gridFc, levels, &#123;</span><br><span class=\"line\">  zProperty: <span class=\"string\">\"value\"</span>,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// isoFc 就是生成的geojson内容，保存成文件即可</span></span><br></pre></td></tr></table></figure>\n<p>上面两种方式生成的结果，偶尔会出现的不同级别等值面重叠的情况，这样在前端渲染的时候，由于颜色通道的叠加，会导致重叠部分数据渲染错误的情况，不知道是我使用时候生成方法的弄错还是渲染方法弄错了，效果不太满意。</p>\n<ul>\n<li><strong><a href=\"https://github.com/bartromgens/geojsoncontour\" target=\"_blank\" rel=\"noopener\">geojsoncounter（建议）</a></strong></li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> geojsoncontour</span><br><span class=\"line\"></span><br><span class=\"line\">levels = [<span class=\"number\">0.0</span>, <span class=\"number\">0.0001</span>, <span class=\"number\">0.5</span>, <span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">3.0</span>, <span class=\"number\">5.0</span>, <span class=\"number\">7.0</span>, <span class=\"number\">10.0</span>, <span class=\"number\">13.0</span>, <span class=\"number\">16.0</span>, <span class=\"number\">20.0</span>, <span class=\"number\">25.0</span>, <span class=\"number\">40.0</span>, <span class=\"number\">9999.0</span>]</span><br><span class=\"line\">size = [<span class=\"number\">511</span>, <span class=\"number\">581</span>]</span><br><span class=\"line\">lon_range = [<span class=\"number\">113.2</span>, <span class=\"number\">119.4</span>]</span><br><span class=\"line\">lat_range = [<span class=\"number\">37.4</span>, <span class=\"number\">42.7</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">lons = np.linspace(lon_range[<span class=\"number\">0</span>], lon_range[<span class=\"number\">1</span>], size[<span class=\"number\">0</span>])</span><br><span class=\"line\">lats = np.linspace(lat_range[<span class=\"number\">0</span>], lat_range[<span class=\"number\">1</span>], size[<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># pre为格点数据数组</span></span><br><span class=\"line\">data = np.array(pre)</span><br><span class=\"line\"><span class=\"comment\"># 生成等直面图</span></span><br><span class=\"line\">contour = plt.contourf(lons, lats, data, levels=levels)</span><br><span class=\"line\">geojson_filepath = <span class=\"string\">'output/'</span></span><br><span class=\"line\"><span class=\"comment\"># 转换成geojson</span></span><br><span class=\"line\">geojsoncontour.contourf_to_geojson(contourf=contour, ndigits=<span class=\"number\">20</span>,geojson_filepath=geojson_filepath)</span><br></pre></td></tr></table></figure>\n<p>实践下来感觉这个方法生成的 geojson 效果会更好，我个人比较推荐使用。原理上就是先生成了传统等值面图片，把像素结果转换成了 geojson 数据。</p>\n<h2 id=\"合并-geojson（可选）\"><a href=\"#合并-geojson（可选）\" class=\"headerlink\" title=\"合并 geojson（可选）\"></a>合并 geojson（可选）</h2><p>这一步很有趣，如果把每个时刻的降水数据做成单独的 geojson，在根据时序进行播放的时候就需要每次移除、加载图层，会有卡顿的效果，而看文章里面墨迹使用了 mapbox 的<code>setFilter</code>功能，所以猜测是对 geojson 进行了合并。</p>\n<p>在 QGIS 中打开了已经生成的 10 个 geojson 进行了合并，可以在属性表里面看到，每个图层的顺序是通过<code>layer</code>字段进行区分的，后面会用上。</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/merge-geojson-20200622155323.png\" alt></p>\n<h2 id=\"生成矢量瓦片\"><a href=\"#生成矢量瓦片\" class=\"headerlink\" title=\"生成矢量瓦片\"></a>生成矢量瓦片</h2><p>使用<a href=\"https://github.com/mapbox/tippecanoe\" target=\"_blank\" rel=\"noopener\">mapbox/tippecanoe</a>这个官方工具就好了。如果在上面选择了合并 geojson，那么只需要对合并后的单个文件切瓦片就好了，不然就是对每个时刻的数据单独执行以下切瓦片的命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">tippecanoe -e /Downloads/pbf --no-tile-compression -zg --drop-densest-as-needed -l pre merge.geojson</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>-e 是生成目录<br>–no-tile-compression 是不对生成的 pbf 进行压缩，否则加载时候会报错<br>-zg –drop-densest-as-needed 是自动去判断瓦片的最大最小级别<br>-l 是手动指定图层名字</p>\n</blockquote>\n<h2 id=\"展示\"><a href=\"#展示\" class=\"headerlink\" title=\"展示\"></a>展示</h2><ul>\n<li>在 leaflet 加载使用插件<a href=\"https://github.com/Leaflet/Leaflet.VectorGrid\" target=\"_blank\" rel=\"noopener\">Leaflet.VectorGrid</a>就好</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = L.map(<span class=\"string\">\"map\"</span>, &#123;</span><br><span class=\"line\">  center: [<span class=\"number\">40.03193433735177</span>, <span class=\"number\">118.03342979913123</span>],</span><br><span class=\"line\">  zoom: <span class=\"number\">6</span>,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> vectorTileOptions = &#123;</span><br><span class=\"line\">  rendererFactory: L.canvas.tile,</span><br><span class=\"line\">  <span class=\"comment\">// 设置生成的pbf的最大zoom</span></span><br><span class=\"line\">  maxNativeZoom: <span class=\"number\">7</span>,</span><br><span class=\"line\">  vectorTileLayerStyles: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// pre 是 -l 参数的图层名称</span></span><br><span class=\"line\">    pre: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">properties, zoom</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 找到属性中对应降水量的属性设置图例</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> level = <span class=\"built_in\">parseFloat</span>(properties.title).toString();</span><br><span class=\"line\">      <span class=\"keyword\">let</span> color = <span class=\"string\">\"rgba(0, 0, 0, 0)\"</span>;</span><br><span class=\"line\">      <span class=\"keyword\">switch</span> (level) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"0.0001\"</span>:</span><br><span class=\"line\">          color = <span class=\"string\">\"rgba(153,255,153,255)\"</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"0.5\"</span>:</span><br><span class=\"line\">          color = <span class=\"string\">\"rgba(51,204,102,255)\"</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"1\"</span>:</span><br><span class=\"line\">          color = <span class=\"string\">\"rgba(51,153,0,255)\"</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"comment\">// ......</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        weight: <span class=\"number\">1</span>,</span><br><span class=\"line\">        color: color,</span><br><span class=\"line\">        opacity: <span class=\"number\">1</span>,</span><br><span class=\"line\">        fillColor: color,</span><br><span class=\"line\">        fill: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        fillOpacity: <span class=\"number\">0.7</span>,</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> L.vectorGrid.protobuf(</span><br><span class=\"line\">  <span class=\"string\">`http://localhost:8080/assets/pbf/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.pbf`</span>,</span><br><span class=\"line\">  vectorTileOptions</span><br><span class=\"line\">).addTo(map);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在 mapbox 中加载直接定义一个自定义 source，并加载</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> mapboxgl.Map(&#123;</span><br><span class=\"line\">  container: <span class=\"string\">\"map\"</span>,</span><br><span class=\"line\">  style: <span class=\"string\">\"mapbox://styles/mapbox/light-v10\"</span>,</span><br><span class=\"line\">  zoom: <span class=\"number\">6</span>,</span><br><span class=\"line\">  center: [<span class=\"number\">118.03342979913123</span>, <span class=\"number\">40.03193433735177</span>],</span><br><span class=\"line\">  antialias: <span class=\"literal\">true</span>,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">map.on(<span class=\"string\">\"load\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  map.addSource(<span class=\"string\">\"radar-pbf\"</span>, &#123;</span><br><span class=\"line\">    type: <span class=\"string\">\"vector\"</span>,</span><br><span class=\"line\">    tiles: [<span class=\"string\">`http://localhost:8080/assets/collection/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.pbf`</span>],</span><br><span class=\"line\">    maxzoom: <span class=\"number\">7</span>, <span class=\"comment\">// 设置生成的pbf的最大zoom</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  pbfMap.addLayer(&#123;</span><br><span class=\"line\">    id: <span class=\"string\">\"radar-pbf\"</span>,</span><br><span class=\"line\">    type: <span class=\"string\">\"fill\"</span>,</span><br><span class=\"line\">    source: <span class=\"string\">\"radar-pbf\"</span>,</span><br><span class=\"line\">    filter: [<span class=\"string\">\"==\"</span>, <span class=\"string\">\"layer\"</span>, <span class=\"string\">\"1\"</span>], <span class=\"comment\">// 合并的话可以使用过滤</span></span><br><span class=\"line\">    <span class=\"string\">\"source-layer\"</span>: <span class=\"string\">\"pre\"</span>, <span class=\"comment\">// pre 是 -l 参数的图层名称</span></span><br><span class=\"line\">    layout: &#123;</span><br><span class=\"line\">      visibility: <span class=\"string\">\"visible\"</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    paint: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"fill-opacity\"</span>: <span class=\"number\">0.7</span>,</span><br><span class=\"line\">      <span class=\"string\">\"fill-color\"</span>: [</span><br><span class=\"line\">        <span class=\"string\">\"match\"</span>,</span><br><span class=\"line\">        [<span class=\"string\">\"get\"</span>, <span class=\"string\">\"title\"</span>],</span><br><span class=\"line\">        [<span class=\"string\">\"0.000100 \"</span>],</span><br><span class=\"line\">        <span class=\"string\">\"rgba(153,255,153,255)\"</span>,</span><br><span class=\"line\">        [<span class=\"string\">\"0.500000 \"</span>],</span><br><span class=\"line\">        <span class=\"string\">\"rgba(51,204,102,255)\"</span>,</span><br><span class=\"line\">        [<span class=\"string\">\"1.000000 \"</span>],</span><br><span class=\"line\">        <span class=\"string\">\"rgba(51,153,0,255)\"</span>,</span><br><span class=\"line\">        <span class=\"comment\">// ......</span></span><br><span class=\"line\">        <span class=\"string\">\"rgba(0, 0, 0, 0)\"</span>, <span class=\"comment\">// 默认color</span></span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h1 id=\"待优化\"><a href=\"#待优化\" class=\"headerlink\" title=\"待优化\"></a>待优化</h1><p>其实还有个工作没有尝试就是原文里面说的，对两个相邻间隔时间的数据做插值处理，以追求更加平滑的播放效果。个人感觉这个处理对于面向大众的场景比较实用，但在专业方面，有待使用更科学的方法进行处理。</p>\n","site":{"data":{}},"excerpt":"<p>在<a href=\"https://juejin.im/post/5d4e8572e51d453c12504dd4\" target=\"_blank\" rel=\"noopener\">四步走，墨迹天气雷达数据可视化指南</a>这篇文章中，提到了用<strong>矢量瓦片</strong>代替传统传统栅格图像可视化方案，可以达到更流程的性能，更高清的数据展示，更灵活的样式表达。感觉挺有意思，同时也为了考察这么做的成本，就试着还原做了下。</p>\n<p>从文章来看整个过程总结起来就是准备数据<code>geojson</code>，切成<code>pbf</code>或者<code>mbtiles</code>在 mapbox 中展示。</p>","more":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>按惯例先解释下雷达数据。我之前通俗的把气象数据划分为了站点（散点）和格点两类，暂且不细说雷达数据到底属于哪类，但最终都可以通过比方说插值来得到一份格点数据。传统的<code>栅格图像</code>可视化方案是基于格点数据利用<a href=\"https://matplotlib.org/3.2.1/api/_as_gen/matplotlib.pyplot.contourf.html\" target=\"_blank\" rel=\"noopener\">matplotlib.pyplot.contourf</a>这类工具，依据一定标准的图例，生成出来的一张等值面图，考虑到网络的传输，这种图片得体积小，分辨率就会下降，所以在缩放时候会失真，出现马赛克，矢量瓦片的出现就可以很自然的解决这个问题。</p>\n<p>我会用降水格点数据来代替雷达数据进行了测试，二者数据格式内容上来说都相差不大，且都能用来反映未来降水的趋势。</p>\n<h1 id=\"开发\"><a href=\"#开发\" class=\"headerlink\" title=\"开发\"></a>开发</h1><p>选用了 10 个时次的降水格点数据，格点大小为<code>511*581</code>，经度范围为<code>113.2, 119.4</code>，纬度范围为<code>37.4, 42.7</code>。</p>\n<h2 id=\"生成-geojson\"><a href=\"#生成-geojson\" class=\"headerlink\" title=\"生成 geojson\"></a>生成 geojson</h2><p>这一步其实有很多选择，文章里面也提到了一些，我都做了一些尝试，列一下尝试结果：</p>\n<ul>\n<li><a href=\"https://github.com/d3/d3-contour\" target=\"_blank\" rel=\"noopener\">d3-contour</a></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> contour = <span class=\"built_in\">require</span>(<span class=\"string\">\"d3-contour\"</span>).contours;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> levels = [</span><br><span class=\"line\">  <span class=\"number\">0.0</span>,</span><br><span class=\"line\">  <span class=\"number\">0.0001</span>,</span><br><span class=\"line\">  <span class=\"number\">0.5</span>,</span><br><span class=\"line\">  <span class=\"number\">1.0</span>,</span><br><span class=\"line\">  <span class=\"number\">2.0</span>,</span><br><span class=\"line\">  <span class=\"number\">3.0</span>,</span><br><span class=\"line\">  <span class=\"number\">5.0</span>,</span><br><span class=\"line\">  <span class=\"number\">7.0</span>,</span><br><span class=\"line\">  <span class=\"number\">10.0</span>,</span><br><span class=\"line\">  <span class=\"number\">13.0</span>,</span><br><span class=\"line\">  <span class=\"number\">16.0</span>,</span><br><span class=\"line\">  <span class=\"number\">20.0</span>,</span><br><span class=\"line\">  <span class=\"number\">25.0</span>,</span><br><span class=\"line\">  <span class=\"number\">40.0</span>,</span><br><span class=\"line\">  <span class=\"number\">9999.0</span>,</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"keyword\">const</span> lonRange = [<span class=\"number\">113.2</span>, <span class=\"number\">119.4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> latRange = [<span class=\"number\">37.4</span>, <span class=\"number\">42.7</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生成等值面，data为格点数据数组</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> contours = contour().size([<span class=\"number\">511</span>, <span class=\"number\">581</span>]).thresholds(levels)(data);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> geojson = [];</span><br><span class=\"line\"><span class=\"comment\">// d3用的是平面坐标，需要转换成经纬度</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; contours.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> item = contours[i];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; coordinates &#125; = item;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (coordinates.length === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> coords = coordinates.map(<span class=\"function\">(<span class=\"params\">item</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> item.map(<span class=\"function\">(<span class=\"params\">ele</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ele.map(<span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> [x, y] = e;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [</span><br><span class=\"line\">          lonRange[<span class=\"number\">0</span>] + ((<span class=\"number\">511</span> - x) * (lonRange[<span class=\"number\">1</span>] - lonRange[<span class=\"number\">0</span>])) / <span class=\"number\">511</span>,</span><br><span class=\"line\">          latRange[<span class=\"number\">0</span>] + ((<span class=\"number\">581</span> - y) * (latRange[<span class=\"number\">1</span>] - latRange[<span class=\"number\">0</span>])) / <span class=\"number\">581</span>,</span><br><span class=\"line\">        ];</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  geojson.push(&#123;</span><br><span class=\"line\">    type: <span class=\"string\">\"Feature\"</span>,</span><br><span class=\"line\">    geometry: &#123;</span><br><span class=\"line\">      type: item.type,</span><br><span class=\"line\">      coordinates: coords,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    properties: &#123;</span><br><span class=\"line\">      value: item.value,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 最终结果</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> isoFc = &#123;</span><br><span class=\"line\">  type: <span class=\"string\">\"FeatureCollection\"</span>,</span><br><span class=\"line\">  features: geojson,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><a href=\"http://turfjs.org/docs/#isobands\" target=\"_blank\" rel=\"noopener\">turf-isobands</a></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> point = <span class=\"built_in\">require</span>(<span class=\"string\">\"@turf/helpers\"</span>).point;</span><br><span class=\"line\"><span class=\"keyword\">const</span> featureCollection = <span class=\"built_in\">require</span>(<span class=\"string\">\"@turf/helpers\"</span>).featureCollection;</span><br><span class=\"line\"><span class=\"keyword\">const</span> isobands = <span class=\"built_in\">require</span>(<span class=\"string\">\"@turf/isobands\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> levels = [</span><br><span class=\"line\">  <span class=\"number\">0.0</span>,</span><br><span class=\"line\">  <span class=\"number\">0.0001</span>,</span><br><span class=\"line\">  <span class=\"number\">0.5</span>,</span><br><span class=\"line\">  <span class=\"number\">1.0</span>,</span><br><span class=\"line\">  <span class=\"number\">2.0</span>,</span><br><span class=\"line\">  <span class=\"number\">3.0</span>,</span><br><span class=\"line\">  <span class=\"number\">5.0</span>,</span><br><span class=\"line\">  <span class=\"number\">7.0</span>,</span><br><span class=\"line\">  <span class=\"number\">10.0</span>,</span><br><span class=\"line\">  <span class=\"number\">13.0</span>,</span><br><span class=\"line\">  <span class=\"number\">16.0</span>,</span><br><span class=\"line\">  <span class=\"number\">20.0</span>,</span><br><span class=\"line\">  <span class=\"number\">25.0</span>,</span><br><span class=\"line\">  <span class=\"number\">40.0</span>,</span><br><span class=\"line\">  <span class=\"number\">9999.0</span>,</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"keyword\">const</span> lonRange = [<span class=\"number\">113.2</span>, <span class=\"number\">119.4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> latRange = [<span class=\"number\">37.4</span>, <span class=\"number\">42.7</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 把格点数据数组转换成feature类型为point的数组</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> pointArray = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">581</span>; j++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">511</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> lon = lonRange[<span class=\"number\">0</span>] + ((<span class=\"number\">511</span> - i) * (lonRange[<span class=\"number\">1</span>] - lonRange[<span class=\"number\">0</span>])) / <span class=\"number\">511</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> lat = latRange[<span class=\"number\">0</span>] + ((<span class=\"number\">581</span> - j) * (latRange[<span class=\"number\">1</span>] - latRange[<span class=\"number\">0</span>])) / <span class=\"number\">581</span>;</span><br><span class=\"line\">    <span class=\"comment\">// data 是格点数据数组</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> value = data[j * <span class=\"number\">511</span> + i];</span><br><span class=\"line\">    pointArray.push(point([lon, lat], &#123; value &#125;));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> gridFc = featureCollection(pointArray);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生成等值面</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> isoFc = isobands(gridFc, levels, &#123;</span><br><span class=\"line\">  zProperty: <span class=\"string\">\"value\"</span>,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// isoFc 就是生成的geojson内容，保存成文件即可</span></span><br></pre></td></tr></table></figure>\n<p>上面两种方式生成的结果，偶尔会出现的不同级别等值面重叠的情况，这样在前端渲染的时候，由于颜色通道的叠加，会导致重叠部分数据渲染错误的情况，不知道是我使用时候生成方法的弄错还是渲染方法弄错了，效果不太满意。</p>\n<ul>\n<li><strong><a href=\"https://github.com/bartromgens/geojsoncontour\" target=\"_blank\" rel=\"noopener\">geojsoncounter（建议）</a></strong></li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> geojsoncontour</span><br><span class=\"line\"></span><br><span class=\"line\">levels = [<span class=\"number\">0.0</span>, <span class=\"number\">0.0001</span>, <span class=\"number\">0.5</span>, <span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">3.0</span>, <span class=\"number\">5.0</span>, <span class=\"number\">7.0</span>, <span class=\"number\">10.0</span>, <span class=\"number\">13.0</span>, <span class=\"number\">16.0</span>, <span class=\"number\">20.0</span>, <span class=\"number\">25.0</span>, <span class=\"number\">40.0</span>, <span class=\"number\">9999.0</span>]</span><br><span class=\"line\">size = [<span class=\"number\">511</span>, <span class=\"number\">581</span>]</span><br><span class=\"line\">lon_range = [<span class=\"number\">113.2</span>, <span class=\"number\">119.4</span>]</span><br><span class=\"line\">lat_range = [<span class=\"number\">37.4</span>, <span class=\"number\">42.7</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">lons = np.linspace(lon_range[<span class=\"number\">0</span>], lon_range[<span class=\"number\">1</span>], size[<span class=\"number\">0</span>])</span><br><span class=\"line\">lats = np.linspace(lat_range[<span class=\"number\">0</span>], lat_range[<span class=\"number\">1</span>], size[<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># pre为格点数据数组</span></span><br><span class=\"line\">data = np.array(pre)</span><br><span class=\"line\"><span class=\"comment\"># 生成等直面图</span></span><br><span class=\"line\">contour = plt.contourf(lons, lats, data, levels=levels)</span><br><span class=\"line\">geojson_filepath = <span class=\"string\">'output/'</span></span><br><span class=\"line\"><span class=\"comment\"># 转换成geojson</span></span><br><span class=\"line\">geojsoncontour.contourf_to_geojson(contourf=contour, ndigits=<span class=\"number\">20</span>,geojson_filepath=geojson_filepath)</span><br></pre></td></tr></table></figure>\n<p>实践下来感觉这个方法生成的 geojson 效果会更好，我个人比较推荐使用。原理上就是先生成了传统等值面图片，把像素结果转换成了 geojson 数据。</p>\n<h2 id=\"合并-geojson（可选）\"><a href=\"#合并-geojson（可选）\" class=\"headerlink\" title=\"合并 geojson（可选）\"></a>合并 geojson（可选）</h2><p>这一步很有趣，如果把每个时刻的降水数据做成单独的 geojson，在根据时序进行播放的时候就需要每次移除、加载图层，会有卡顿的效果，而看文章里面墨迹使用了 mapbox 的<code>setFilter</code>功能，所以猜测是对 geojson 进行了合并。</p>\n<p>在 QGIS 中打开了已经生成的 10 个 geojson 进行了合并，可以在属性表里面看到，每个图层的顺序是通过<code>layer</code>字段进行区分的，后面会用上。</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/merge-geojson-20200622155323.png\" alt></p>\n<h2 id=\"生成矢量瓦片\"><a href=\"#生成矢量瓦片\" class=\"headerlink\" title=\"生成矢量瓦片\"></a>生成矢量瓦片</h2><p>使用<a href=\"https://github.com/mapbox/tippecanoe\" target=\"_blank\" rel=\"noopener\">mapbox/tippecanoe</a>这个官方工具就好了。如果在上面选择了合并 geojson，那么只需要对合并后的单个文件切瓦片就好了，不然就是对每个时刻的数据单独执行以下切瓦片的命令。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">tippecanoe -e /Downloads/pbf --no-tile-compression -zg --drop-densest-as-needed -l pre merge.geojson</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>-e 是生成目录<br>–no-tile-compression 是不对生成的 pbf 进行压缩，否则加载时候会报错<br>-zg –drop-densest-as-needed 是自动去判断瓦片的最大最小级别<br>-l 是手动指定图层名字</p>\n</blockquote>\n<h2 id=\"展示\"><a href=\"#展示\" class=\"headerlink\" title=\"展示\"></a>展示</h2><ul>\n<li>在 leaflet 加载使用插件<a href=\"https://github.com/Leaflet/Leaflet.VectorGrid\" target=\"_blank\" rel=\"noopener\">Leaflet.VectorGrid</a>就好</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = L.map(<span class=\"string\">\"map\"</span>, &#123;</span><br><span class=\"line\">  center: [<span class=\"number\">40.03193433735177</span>, <span class=\"number\">118.03342979913123</span>],</span><br><span class=\"line\">  zoom: <span class=\"number\">6</span>,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> vectorTileOptions = &#123;</span><br><span class=\"line\">  rendererFactory: L.canvas.tile,</span><br><span class=\"line\">  <span class=\"comment\">// 设置生成的pbf的最大zoom</span></span><br><span class=\"line\">  maxNativeZoom: <span class=\"number\">7</span>,</span><br><span class=\"line\">  vectorTileLayerStyles: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// pre 是 -l 参数的图层名称</span></span><br><span class=\"line\">    pre: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">properties, zoom</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 找到属性中对应降水量的属性设置图例</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> level = <span class=\"built_in\">parseFloat</span>(properties.title).toString();</span><br><span class=\"line\">      <span class=\"keyword\">let</span> color = <span class=\"string\">\"rgba(0, 0, 0, 0)\"</span>;</span><br><span class=\"line\">      <span class=\"keyword\">switch</span> (level) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"0.0001\"</span>:</span><br><span class=\"line\">          color = <span class=\"string\">\"rgba(153,255,153,255)\"</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"0.5\"</span>:</span><br><span class=\"line\">          color = <span class=\"string\">\"rgba(51,204,102,255)\"</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"1\"</span>:</span><br><span class=\"line\">          color = <span class=\"string\">\"rgba(51,153,0,255)\"</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"comment\">// ......</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        weight: <span class=\"number\">1</span>,</span><br><span class=\"line\">        color: color,</span><br><span class=\"line\">        opacity: <span class=\"number\">1</span>,</span><br><span class=\"line\">        fillColor: color,</span><br><span class=\"line\">        fill: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        fillOpacity: <span class=\"number\">0.7</span>,</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> L.vectorGrid.protobuf(</span><br><span class=\"line\">  <span class=\"string\">`http://localhost:8080/assets/pbf/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.pbf`</span>,</span><br><span class=\"line\">  vectorTileOptions</span><br><span class=\"line\">).addTo(map);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在 mapbox 中加载直接定义一个自定义 source，并加载</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> mapboxgl.Map(&#123;</span><br><span class=\"line\">  container: <span class=\"string\">\"map\"</span>,</span><br><span class=\"line\">  style: <span class=\"string\">\"mapbox://styles/mapbox/light-v10\"</span>,</span><br><span class=\"line\">  zoom: <span class=\"number\">6</span>,</span><br><span class=\"line\">  center: [<span class=\"number\">118.03342979913123</span>, <span class=\"number\">40.03193433735177</span>],</span><br><span class=\"line\">  antialias: <span class=\"literal\">true</span>,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">map.on(<span class=\"string\">\"load\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  map.addSource(<span class=\"string\">\"radar-pbf\"</span>, &#123;</span><br><span class=\"line\">    type: <span class=\"string\">\"vector\"</span>,</span><br><span class=\"line\">    tiles: [<span class=\"string\">`http://localhost:8080/assets/collection/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.pbf`</span>],</span><br><span class=\"line\">    maxzoom: <span class=\"number\">7</span>, <span class=\"comment\">// 设置生成的pbf的最大zoom</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  pbfMap.addLayer(&#123;</span><br><span class=\"line\">    id: <span class=\"string\">\"radar-pbf\"</span>,</span><br><span class=\"line\">    type: <span class=\"string\">\"fill\"</span>,</span><br><span class=\"line\">    source: <span class=\"string\">\"radar-pbf\"</span>,</span><br><span class=\"line\">    filter: [<span class=\"string\">\"==\"</span>, <span class=\"string\">\"layer\"</span>, <span class=\"string\">\"1\"</span>], <span class=\"comment\">// 合并的话可以使用过滤</span></span><br><span class=\"line\">    <span class=\"string\">\"source-layer\"</span>: <span class=\"string\">\"pre\"</span>, <span class=\"comment\">// pre 是 -l 参数的图层名称</span></span><br><span class=\"line\">    layout: &#123;</span><br><span class=\"line\">      visibility: <span class=\"string\">\"visible\"</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    paint: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"fill-opacity\"</span>: <span class=\"number\">0.7</span>,</span><br><span class=\"line\">      <span class=\"string\">\"fill-color\"</span>: [</span><br><span class=\"line\">        <span class=\"string\">\"match\"</span>,</span><br><span class=\"line\">        [<span class=\"string\">\"get\"</span>, <span class=\"string\">\"title\"</span>],</span><br><span class=\"line\">        [<span class=\"string\">\"0.000100 \"</span>],</span><br><span class=\"line\">        <span class=\"string\">\"rgba(153,255,153,255)\"</span>,</span><br><span class=\"line\">        [<span class=\"string\">\"0.500000 \"</span>],</span><br><span class=\"line\">        <span class=\"string\">\"rgba(51,204,102,255)\"</span>,</span><br><span class=\"line\">        [<span class=\"string\">\"1.000000 \"</span>],</span><br><span class=\"line\">        <span class=\"string\">\"rgba(51,153,0,255)\"</span>,</span><br><span class=\"line\">        <span class=\"comment\">// ......</span></span><br><span class=\"line\">        <span class=\"string\">\"rgba(0, 0, 0, 0)\"</span>, <span class=\"comment\">// 默认color</span></span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h1 id=\"待优化\"><a href=\"#待优化\" class=\"headerlink\" title=\"待优化\"></a>待优化</h1><p>其实还有个工作没有尝试就是原文里面说的，对两个相邻间隔时间的数据做插值处理，以追求更加平滑的播放效果。个人感觉这个处理对于面向大众的场景比较实用，但在专业方面，有待使用更科学的方法进行处理。</p>"},{"title":"element dialog组件嵌套问题的临时方案","date":"2017-06-23T14:09:55.000Z","_content":"\n&emsp;&emsp;最近用 Vue+element 开发项目时，在dialog组件上嵌套使用dialog组件或是MessageBox这类弹框组件，发现会出现遮罩层重合之类的问题，导致很多人只能选择关闭遮罩层。GitHub上就此问题也出现过类似讨论。有几种解决方案：\n\n<!--more--> \n\n\n1. 按照官方所说，将多个dialog类组件全部移动至**<body**>标签下\n\n2. Github上某位大牛给出了不完全解决方案，基本思路仍然是将添加在**<el-dialog**>内的dom结构自动移动至**<body**>标签下。这个方式测试了下，似乎纯dialog嵌套问题不大，但是如果dialog内部包含了其他组件会有点问题，智者见智，自行探索了\n\n&emsp;&emsp;[附上连接](https://github.com/foolishchow/element-dialog2)\n\n3. 编写自己modal遮罩层，这里给出个不完全临时代码仅供参考\n\n```js\n    Vue.prototype.$Modal = {\n        open(element) {\n            var index = 1;\n            var wrapper = element.querySelector('.el-dialog__wrapper');\n            if (wrapper) {\n                index = wrapper.style.zIndex - 1;\n            }\n            var modalDom = document.createElement('div');\n            modalDom.className = 'v-modal';\n            element.appendChild(modalDom);\n            modalDom.style.zIndex = index;\n        },\n        close() {\n            var modal = document.getElementsByClassName('v-modal')[0;\n            modal.parentNode.removeChild(modal);\n        }\n    }\n\n```\n&emsp;&emsp;一般调用方法\n```js\n    mounted: function () {\n        var that = this;\n        this.$nextTick(function () {\n            //遮罩层\n            that.$nextTick(function () {\n                that.$Modal.open(that.$el);\n            });\n        });\n    },\n```\n\n&emsp;&emsp;主要想法就是在组件mounted完成的nextTick后，为页面中添加一个div，样式就直接采用element自己的了，因为遮罩层是添加在dialog组件下的，因此组件销毁后也会自己销毁，close方法也没用上，但也应该会遇到有用上的时候吧。\n","source":"_posts/2017/vue-dialog-nested.md","raw":"---\ntitle: element dialog组件嵌套问题的临时方案\ndate: 2017-06-23 22:09:55\ntags: [FE,Vue]\ncategories: 前端\n---\n\n&emsp;&emsp;最近用 Vue+element 开发项目时，在dialog组件上嵌套使用dialog组件或是MessageBox这类弹框组件，发现会出现遮罩层重合之类的问题，导致很多人只能选择关闭遮罩层。GitHub上就此问题也出现过类似讨论。有几种解决方案：\n\n<!--more--> \n\n\n1. 按照官方所说，将多个dialog类组件全部移动至**<body**>标签下\n\n2. Github上某位大牛给出了不完全解决方案，基本思路仍然是将添加在**<el-dialog**>内的dom结构自动移动至**<body**>标签下。这个方式测试了下，似乎纯dialog嵌套问题不大，但是如果dialog内部包含了其他组件会有点问题，智者见智，自行探索了\n\n&emsp;&emsp;[附上连接](https://github.com/foolishchow/element-dialog2)\n\n3. 编写自己modal遮罩层，这里给出个不完全临时代码仅供参考\n\n```js\n    Vue.prototype.$Modal = {\n        open(element) {\n            var index = 1;\n            var wrapper = element.querySelector('.el-dialog__wrapper');\n            if (wrapper) {\n                index = wrapper.style.zIndex - 1;\n            }\n            var modalDom = document.createElement('div');\n            modalDom.className = 'v-modal';\n            element.appendChild(modalDom);\n            modalDom.style.zIndex = index;\n        },\n        close() {\n            var modal = document.getElementsByClassName('v-modal')[0;\n            modal.parentNode.removeChild(modal);\n        }\n    }\n\n```\n&emsp;&emsp;一般调用方法\n```js\n    mounted: function () {\n        var that = this;\n        this.$nextTick(function () {\n            //遮罩层\n            that.$nextTick(function () {\n                that.$Modal.open(that.$el);\n            });\n        });\n    },\n```\n\n&emsp;&emsp;主要想法就是在组件mounted完成的nextTick后，为页面中添加一个div，样式就直接采用element自己的了，因为遮罩层是添加在dialog组件下的，因此组件销毁后也会自己销毁，close方法也没用上，但也应该会遇到有用上的时候吧。\n","slug":"vue-dialog-nested","published":1,"updated":"2019-06-28T05:56:41.472Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrkxgsv0006i83iju1d8m79","content":"<p>&emsp;&emsp;最近用 Vue+element 开发项目时，在dialog组件上嵌套使用dialog组件或是MessageBox这类弹框组件，发现会出现遮罩层重合之类的问题，导致很多人只能选择关闭遮罩层。GitHub上就此问题也出现过类似讨论。有几种解决方案：</p>\n<a id=\"more\"></a> \n<ol>\n<li><p>按照官方所说，将多个dialog类组件全部移动至<strong>&lt;body</strong>&gt;标签下</p>\n</li>\n<li><p>Github上某位大牛给出了不完全解决方案，基本思路仍然是将添加在<strong>&lt;el-dialog</strong>&gt;内的dom结构自动移动至<strong>&lt;body</strong>&gt;标签下。这个方式测试了下，似乎纯dialog嵌套问题不大，但是如果dialog内部包含了其他组件会有点问题，智者见智，自行探索了</p>\n</li>\n</ol>\n<p>&emsp;&emsp;<a href=\"https://github.com/foolishchow/element-dialog2\" target=\"_blank\" rel=\"noopener\">附上连接</a></p>\n<ol start=\"3\">\n<li>编写自己modal遮罩层，这里给出个不完全临时代码仅供参考</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">Vue.prototype.$Modal = &#123;</span><br><span class=\"line\">    open(element) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> index = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> wrapper = element.querySelector(<span class=\"string\">'.el-dialog__wrapper'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (wrapper) &#123;</span><br><span class=\"line\">            index = wrapper.style.zIndex - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> modalDom = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'div'</span>);</span><br><span class=\"line\">        modalDom.className = <span class=\"string\">'v-modal'</span>;</span><br><span class=\"line\">        element.appendChild(modalDom);</span><br><span class=\"line\">        modalDom.style.zIndex = index;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    close() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> modal = <span class=\"built_in\">document</span>.getElementsByClassName(<span class=\"string\">'v-modal'</span>)[<span class=\"number\">0</span>;</span><br><span class=\"line\">        modal.parentNode.removeChild(modal);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;一般调用方法<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">mounted: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//遮罩层</span></span><br><span class=\"line\">        that.$nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            that.$Modal.open(that.$el);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;主要想法就是在组件mounted完成的nextTick后，为页面中添加一个div，样式就直接采用element自己的了，因为遮罩层是添加在dialog组件下的，因此组件销毁后也会自己销毁，close方法也没用上，但也应该会遇到有用上的时候吧。</p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;最近用 Vue+element 开发项目时，在dialog组件上嵌套使用dialog组件或是MessageBox这类弹框组件，发现会出现遮罩层重合之类的问题，导致很多人只能选择关闭遮罩层。GitHub上就此问题也出现过类似讨论。有几种解决方案：</p>","more":"<ol>\n<li><p>按照官方所说，将多个dialog类组件全部移动至<strong>&lt;body</strong>&gt;标签下</p>\n</li>\n<li><p>Github上某位大牛给出了不完全解决方案，基本思路仍然是将添加在<strong>&lt;el-dialog</strong>&gt;内的dom结构自动移动至<strong>&lt;body</strong>&gt;标签下。这个方式测试了下，似乎纯dialog嵌套问题不大，但是如果dialog内部包含了其他组件会有点问题，智者见智，自行探索了</p>\n</li>\n</ol>\n<p>&emsp;&emsp;<a href=\"https://github.com/foolishchow/element-dialog2\" target=\"_blank\" rel=\"noopener\">附上连接</a></p>\n<ol start=\"3\">\n<li>编写自己modal遮罩层，这里给出个不完全临时代码仅供参考</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">Vue.prototype.$Modal = &#123;</span><br><span class=\"line\">    open(element) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> index = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> wrapper = element.querySelector(<span class=\"string\">'.el-dialog__wrapper'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (wrapper) &#123;</span><br><span class=\"line\">            index = wrapper.style.zIndex - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> modalDom = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'div'</span>);</span><br><span class=\"line\">        modalDom.className = <span class=\"string\">'v-modal'</span>;</span><br><span class=\"line\">        element.appendChild(modalDom);</span><br><span class=\"line\">        modalDom.style.zIndex = index;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    close() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> modal = <span class=\"built_in\">document</span>.getElementsByClassName(<span class=\"string\">'v-modal'</span>)[<span class=\"number\">0</span>;</span><br><span class=\"line\">        modal.parentNode.removeChild(modal);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;一般调用方法<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">mounted: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//遮罩层</span></span><br><span class=\"line\">        that.$nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            that.$Modal.open(that.$el);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;主要想法就是在组件mounted完成的nextTick后，为页面中添加一个div，样式就直接采用element自己的了，因为遮罩层是添加在dialog组件下的，因此组件销毁后也会自己销毁，close方法也没用上，但也应该会遇到有用上的时候吧。</p>"},{"title":"Leaflet常用的一些插件","date":"2017-09-17T05:48:15.000Z","_content":"\nLeaflet 中常用的 gis 功能可以满足一般使用，有些特殊需求，官方也有[插件系统](http://leafletjs.com/plugins.html)，本文会挑选一些常用的，经过测试可用的插件单独放出来使用方法和一些注意事项，希望能够帮助到同僚们。\n\n<!-- more -->\n\n[Leaflet 系列地址](https://github.com/zzcyrus/Leaflet-demos)\n[本文 demo 地址](https://github.com/zzcyrus/Leaflet-demos/blob/master/1.plugins/plugins.html)\n\n# ImageWMS\n\n&nbsp;&nbsp;在 openlayers 中，wms 图层的调用了提供了 IamgeWMS 和 tileWMS 两种方式，通常情况下，如果 wms 服务作为底图，由于数据量大，我们采用瓦片的方式加载十分有利，如果数据量小，我们采用单张 image 的方式无论从请求发送上和显示的效果上都更好。\n![](tileWMS.png)\n&nbsp;&nbsp;~~可以发现，瓦片会发出多次请求，每次请求都会包含该瓦片上涉及到的信息，数据量小十分没必要~~\n\n&nbsp;&nbsp;Leaflet 中只提供了 tile 瓦片的方式加载 WMS 图层，在使用了很多第三方解决方案后，我发现了这款插件[nonTiledLayer](https://github.com/ptv-logistics/Leaflet.NonTiledLayer)，使用之后的效果基本上可以达到 openlaysers 中的要求，更多情况可以点击链接进去了解。\n\n调用方式\n\n```js\nvar layer = L.nonTiledLayer\n  .wms(url, {\n    maxZoom: 19,\n    minZoom: 0,\n    opacity: 1.0,\n    layers: \"xmap-gravelpit-fg\",\n    format: \"image/png\",\n    transparent: true,\n    attribution: \"\",\n    pane: \"tilePane\",\n    zIndex: 3,\n  })\n  .addTo(map);\n```\n\n[nonTiledLayer](https://github.com/ptv-logistics/Leaflet.NonTiledLayer)调用方式基本沿用 Leaflet 自身的 wms 调用，提供的属性也很全面\n\n```\n    attribution - 图层数据来源.Default:'\n    opacity - 透明度.Default: 1\n    minZoom - 最小缩放. Default: 0\n    maxZoom - 最大缩放. Default: 18\n    bounds - 边界条件. Default: L.latLngBounds([-180, -85.05], [180, 85.05])\n    zIndex - 位置. Default: undefined\n    pane - 插入的div的名称. Default: 'overlayPane'\n    pointerEvents - 鼠标事件的样式. Default: null\n    errorImageUrl - 默认错误图层. Default: 1px transparent gif data:image/gif;base64,R0lGODlhAQABAHAAACH5BAUAAAAALAAAAAABAAEAAAICRAEAOw==\n    useCanvas - 渲染方式. Default: undefined\n```\n\n具体的使用效果可以移步 demo\n\n# WKT 数据插件\n\n&nbsp;&nbsp;wkt 作为 GIS 常用的一种地理数据格式，因为通用性需求度也很高,Leaflet 官方插件中提供了许多支持 wkt 的第三方解决方案，使用下来，发现 mapbox 出品的[leaflet-omnivore](https://github.com/mapbox/leaflet-omnivore)效果可以说是目前最满足要求的了。\n\n`omnivore`支持的功能比较强大\n\n```js\nomnivore.csv(\"a.csv\").addTo(map);\nomnivore.gpx(\"a.gpx\").addTo(map);\nomnivore.kml(\"a.kml\").addTo(map);\nomnivore.wkt(\"a.wkt\").addTo(map);\nomnivore.topojson(\"a.topojson\").addTo(map);\nomnivore.geojson(\"a.geojson\").addTo(map);\nomnivore.polyline(\"a.txt\").addTo(map);\n```\n\n其中对于 wkt 的加载有两种方式。\n其中，`customlayer`是通过`L.geojson`图层来为加载进来的 wkt 数据设置样式\n\n```js\nlet customLayer = L.geoJson(null, {\n  style: function () {\n    return { color: \"#0ff\" };\n  },\n});\n```\n\n- `omnivore.wkt(url, parser_options?, customLayer?)`: 通过 url 加载\n\n- `omnivore.wkt.parse(wktString，parser_options?, customLayer?)`: 通过转换 wkt 字符串加载\n\n具体的使用效果可以移步[demo](https://github.com/zzcyrus/Leaflet-demos/blob/master/1.plugins/plugins.html)\n","source":"_posts/2017/plugins.md","raw":"---\ntitle: Leaflet常用的一些插件\ndate: 2017-09-17 13:48:15\ntags: [FE, GIS, Leaflet]\ncategories: WebGIS\n---\n\nLeaflet 中常用的 gis 功能可以满足一般使用，有些特殊需求，官方也有[插件系统](http://leafletjs.com/plugins.html)，本文会挑选一些常用的，经过测试可用的插件单独放出来使用方法和一些注意事项，希望能够帮助到同僚们。\n\n<!-- more -->\n\n[Leaflet 系列地址](https://github.com/zzcyrus/Leaflet-demos)\n[本文 demo 地址](https://github.com/zzcyrus/Leaflet-demos/blob/master/1.plugins/plugins.html)\n\n# ImageWMS\n\n&nbsp;&nbsp;在 openlayers 中，wms 图层的调用了提供了 IamgeWMS 和 tileWMS 两种方式，通常情况下，如果 wms 服务作为底图，由于数据量大，我们采用瓦片的方式加载十分有利，如果数据量小，我们采用单张 image 的方式无论从请求发送上和显示的效果上都更好。\n![](tileWMS.png)\n&nbsp;&nbsp;~~可以发现，瓦片会发出多次请求，每次请求都会包含该瓦片上涉及到的信息，数据量小十分没必要~~\n\n&nbsp;&nbsp;Leaflet 中只提供了 tile 瓦片的方式加载 WMS 图层，在使用了很多第三方解决方案后，我发现了这款插件[nonTiledLayer](https://github.com/ptv-logistics/Leaflet.NonTiledLayer)，使用之后的效果基本上可以达到 openlaysers 中的要求，更多情况可以点击链接进去了解。\n\n调用方式\n\n```js\nvar layer = L.nonTiledLayer\n  .wms(url, {\n    maxZoom: 19,\n    minZoom: 0,\n    opacity: 1.0,\n    layers: \"xmap-gravelpit-fg\",\n    format: \"image/png\",\n    transparent: true,\n    attribution: \"\",\n    pane: \"tilePane\",\n    zIndex: 3,\n  })\n  .addTo(map);\n```\n\n[nonTiledLayer](https://github.com/ptv-logistics/Leaflet.NonTiledLayer)调用方式基本沿用 Leaflet 自身的 wms 调用，提供的属性也很全面\n\n```\n    attribution - 图层数据来源.Default:'\n    opacity - 透明度.Default: 1\n    minZoom - 最小缩放. Default: 0\n    maxZoom - 最大缩放. Default: 18\n    bounds - 边界条件. Default: L.latLngBounds([-180, -85.05], [180, 85.05])\n    zIndex - 位置. Default: undefined\n    pane - 插入的div的名称. Default: 'overlayPane'\n    pointerEvents - 鼠标事件的样式. Default: null\n    errorImageUrl - 默认错误图层. Default: 1px transparent gif data:image/gif;base64,R0lGODlhAQABAHAAACH5BAUAAAAALAAAAAABAAEAAAICRAEAOw==\n    useCanvas - 渲染方式. Default: undefined\n```\n\n具体的使用效果可以移步 demo\n\n# WKT 数据插件\n\n&nbsp;&nbsp;wkt 作为 GIS 常用的一种地理数据格式，因为通用性需求度也很高,Leaflet 官方插件中提供了许多支持 wkt 的第三方解决方案，使用下来，发现 mapbox 出品的[leaflet-omnivore](https://github.com/mapbox/leaflet-omnivore)效果可以说是目前最满足要求的了。\n\n`omnivore`支持的功能比较强大\n\n```js\nomnivore.csv(\"a.csv\").addTo(map);\nomnivore.gpx(\"a.gpx\").addTo(map);\nomnivore.kml(\"a.kml\").addTo(map);\nomnivore.wkt(\"a.wkt\").addTo(map);\nomnivore.topojson(\"a.topojson\").addTo(map);\nomnivore.geojson(\"a.geojson\").addTo(map);\nomnivore.polyline(\"a.txt\").addTo(map);\n```\n\n其中对于 wkt 的加载有两种方式。\n其中，`customlayer`是通过`L.geojson`图层来为加载进来的 wkt 数据设置样式\n\n```js\nlet customLayer = L.geoJson(null, {\n  style: function () {\n    return { color: \"#0ff\" };\n  },\n});\n```\n\n- `omnivore.wkt(url, parser_options?, customLayer?)`: 通过 url 加载\n\n- `omnivore.wkt.parse(wktString，parser_options?, customLayer?)`: 通过转换 wkt 字符串加载\n\n具体的使用效果可以移步[demo](https://github.com/zzcyrus/Leaflet-demos/blob/master/1.plugins/plugins.html)\n","slug":"plugins","published":1,"updated":"2020-05-17T08:21:36.011Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrkxgsw0007i83ie4ytvl72","content":"<p>Leaflet 中常用的 gis 功能可以满足一般使用，有些特殊需求，官方也有<a href=\"http://leafletjs.com/plugins.html\" target=\"_blank\" rel=\"noopener\">插件系统</a>，本文会挑选一些常用的，经过测试可用的插件单独放出来使用方法和一些注意事项，希望能够帮助到同僚们。</p>\n<a id=\"more\"></a>\n<p><a href=\"https://github.com/zzcyrus/Leaflet-demos\" target=\"_blank\" rel=\"noopener\">Leaflet 系列地址</a><br><a href=\"https://github.com/zzcyrus/Leaflet-demos/blob/master/1.plugins/plugins.html\" target=\"_blank\" rel=\"noopener\">本文 demo 地址</a></p>\n<h1 id=\"ImageWMS\"><a href=\"#ImageWMS\" class=\"headerlink\" title=\"ImageWMS\"></a>ImageWMS</h1><p>&nbsp;&nbsp;在 openlayers 中，wms 图层的调用了提供了 IamgeWMS 和 tileWMS 两种方式，通常情况下，如果 wms 服务作为底图，由于数据量大，我们采用瓦片的方式加载十分有利，如果数据量小，我们采用单张 image 的方式无论从请求发送上和显示的效果上都更好。<br><img src=\"tileWMS.png\" alt><br>&nbsp;&nbsp;<del>可以发现，瓦片会发出多次请求，每次请求都会包含该瓦片上涉及到的信息，数据量小十分没必要</del></p>\n<p>&nbsp;&nbsp;Leaflet 中只提供了 tile 瓦片的方式加载 WMS 图层，在使用了很多第三方解决方案后，我发现了这款插件<a href=\"https://github.com/ptv-logistics/Leaflet.NonTiledLayer\" target=\"_blank\" rel=\"noopener\">nonTiledLayer</a>，使用之后的效果基本上可以达到 openlaysers 中的要求，更多情况可以点击链接进去了解。</p>\n<p>调用方式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> layer = L.nonTiledLayer</span><br><span class=\"line\">  .wms(url, &#123;</span><br><span class=\"line\">    maxZoom: <span class=\"number\">19</span>,</span><br><span class=\"line\">    minZoom: <span class=\"number\">0</span>,</span><br><span class=\"line\">    opacity: <span class=\"number\">1.0</span>,</span><br><span class=\"line\">    layers: <span class=\"string\">\"xmap-gravelpit-fg\"</span>,</span><br><span class=\"line\">    format: <span class=\"string\">\"image/png\"</span>,</span><br><span class=\"line\">    transparent: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    attribution: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">    pane: <span class=\"string\">\"tilePane\"</span>,</span><br><span class=\"line\">    zIndex: <span class=\"number\">3</span>,</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .addTo(map);</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/ptv-logistics/Leaflet.NonTiledLayer\" target=\"_blank\" rel=\"noopener\">nonTiledLayer</a>调用方式基本沿用 Leaflet 自身的 wms 调用，提供的属性也很全面</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">attribution - 图层数据来源.Default:&apos;</span><br><span class=\"line\">opacity - 透明度.Default: 1</span><br><span class=\"line\">minZoom - 最小缩放. Default: 0</span><br><span class=\"line\">maxZoom - 最大缩放. Default: 18</span><br><span class=\"line\">bounds - 边界条件. Default: L.latLngBounds([-180, -85.05], [180, 85.05])</span><br><span class=\"line\">zIndex - 位置. Default: undefined</span><br><span class=\"line\">pane - 插入的div的名称. Default: &apos;overlayPane&apos;</span><br><span class=\"line\">pointerEvents - 鼠标事件的样式. Default: null</span><br><span class=\"line\">errorImageUrl - 默认错误图层. Default: 1px transparent gif data:image/gif;base64,R0lGODlhAQABAHAAACH5BAUAAAAALAAAAAABAAEAAAICRAEAOw==</span><br><span class=\"line\">useCanvas - 渲染方式. Default: undefined</span><br></pre></td></tr></table></figure>\n<p>具体的使用效果可以移步 demo</p>\n<h1 id=\"WKT-数据插件\"><a href=\"#WKT-数据插件\" class=\"headerlink\" title=\"WKT 数据插件\"></a>WKT 数据插件</h1><p>&nbsp;&nbsp;wkt 作为 GIS 常用的一种地理数据格式，因为通用性需求度也很高,Leaflet 官方插件中提供了许多支持 wkt 的第三方解决方案，使用下来，发现 mapbox 出品的<a href=\"https://github.com/mapbox/leaflet-omnivore\" target=\"_blank\" rel=\"noopener\">leaflet-omnivore</a>效果可以说是目前最满足要求的了。</p>\n<p><code>omnivore</code>支持的功能比较强大</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">omnivore.csv(<span class=\"string\">\"a.csv\"</span>).addTo(map);</span><br><span class=\"line\">omnivore.gpx(<span class=\"string\">\"a.gpx\"</span>).addTo(map);</span><br><span class=\"line\">omnivore.kml(<span class=\"string\">\"a.kml\"</span>).addTo(map);</span><br><span class=\"line\">omnivore.wkt(<span class=\"string\">\"a.wkt\"</span>).addTo(map);</span><br><span class=\"line\">omnivore.topojson(<span class=\"string\">\"a.topojson\"</span>).addTo(map);</span><br><span class=\"line\">omnivore.geojson(<span class=\"string\">\"a.geojson\"</span>).addTo(map);</span><br><span class=\"line\">omnivore.polyline(<span class=\"string\">\"a.txt\"</span>).addTo(map);</span><br></pre></td></tr></table></figure>\n<p>其中对于 wkt 的加载有两种方式。<br>其中，<code>customlayer</code>是通过<code>L.geojson</code>图层来为加载进来的 wkt 数据设置样式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> customLayer = L.geoJson(<span class=\"literal\">null</span>, &#123;</span><br><span class=\"line\">  style: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"attr\">color</span>: <span class=\"string\">\"#0ff\"</span> &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><code>omnivore.wkt(url, parser_options?, customLayer?)</code>: 通过 url 加载</p>\n</li>\n<li><p><code>omnivore.wkt.parse(wktString，parser_options?, customLayer?)</code>: 通过转换 wkt 字符串加载</p>\n</li>\n</ul>\n<p>具体的使用效果可以移步<a href=\"https://github.com/zzcyrus/Leaflet-demos/blob/master/1.plugins/plugins.html\" target=\"_blank\" rel=\"noopener\">demo</a></p>\n","site":{"data":{}},"excerpt":"<p>Leaflet 中常用的 gis 功能可以满足一般使用，有些特殊需求，官方也有<a href=\"http://leafletjs.com/plugins.html\" target=\"_blank\" rel=\"noopener\">插件系统</a>，本文会挑选一些常用的，经过测试可用的插件单独放出来使用方法和一些注意事项，希望能够帮助到同僚们。</p>","more":"<p><a href=\"https://github.com/zzcyrus/Leaflet-demos\" target=\"_blank\" rel=\"noopener\">Leaflet 系列地址</a><br><a href=\"https://github.com/zzcyrus/Leaflet-demos/blob/master/1.plugins/plugins.html\" target=\"_blank\" rel=\"noopener\">本文 demo 地址</a></p>\n<h1 id=\"ImageWMS\"><a href=\"#ImageWMS\" class=\"headerlink\" title=\"ImageWMS\"></a>ImageWMS</h1><p>&nbsp;&nbsp;在 openlayers 中，wms 图层的调用了提供了 IamgeWMS 和 tileWMS 两种方式，通常情况下，如果 wms 服务作为底图，由于数据量大，我们采用瓦片的方式加载十分有利，如果数据量小，我们采用单张 image 的方式无论从请求发送上和显示的效果上都更好。<br><img src=\"tileWMS.png\" alt><br>&nbsp;&nbsp;<del>可以发现，瓦片会发出多次请求，每次请求都会包含该瓦片上涉及到的信息，数据量小十分没必要</del></p>\n<p>&nbsp;&nbsp;Leaflet 中只提供了 tile 瓦片的方式加载 WMS 图层，在使用了很多第三方解决方案后，我发现了这款插件<a href=\"https://github.com/ptv-logistics/Leaflet.NonTiledLayer\" target=\"_blank\" rel=\"noopener\">nonTiledLayer</a>，使用之后的效果基本上可以达到 openlaysers 中的要求，更多情况可以点击链接进去了解。</p>\n<p>调用方式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> layer = L.nonTiledLayer</span><br><span class=\"line\">  .wms(url, &#123;</span><br><span class=\"line\">    maxZoom: <span class=\"number\">19</span>,</span><br><span class=\"line\">    minZoom: <span class=\"number\">0</span>,</span><br><span class=\"line\">    opacity: <span class=\"number\">1.0</span>,</span><br><span class=\"line\">    layers: <span class=\"string\">\"xmap-gravelpit-fg\"</span>,</span><br><span class=\"line\">    format: <span class=\"string\">\"image/png\"</span>,</span><br><span class=\"line\">    transparent: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    attribution: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">    pane: <span class=\"string\">\"tilePane\"</span>,</span><br><span class=\"line\">    zIndex: <span class=\"number\">3</span>,</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .addTo(map);</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/ptv-logistics/Leaflet.NonTiledLayer\" target=\"_blank\" rel=\"noopener\">nonTiledLayer</a>调用方式基本沿用 Leaflet 自身的 wms 调用，提供的属性也很全面</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">attribution - 图层数据来源.Default:&apos;</span><br><span class=\"line\">opacity - 透明度.Default: 1</span><br><span class=\"line\">minZoom - 最小缩放. Default: 0</span><br><span class=\"line\">maxZoom - 最大缩放. Default: 18</span><br><span class=\"line\">bounds - 边界条件. Default: L.latLngBounds([-180, -85.05], [180, 85.05])</span><br><span class=\"line\">zIndex - 位置. Default: undefined</span><br><span class=\"line\">pane - 插入的div的名称. Default: &apos;overlayPane&apos;</span><br><span class=\"line\">pointerEvents - 鼠标事件的样式. Default: null</span><br><span class=\"line\">errorImageUrl - 默认错误图层. Default: 1px transparent gif data:image/gif;base64,R0lGODlhAQABAHAAACH5BAUAAAAALAAAAAABAAEAAAICRAEAOw==</span><br><span class=\"line\">useCanvas - 渲染方式. Default: undefined</span><br></pre></td></tr></table></figure>\n<p>具体的使用效果可以移步 demo</p>\n<h1 id=\"WKT-数据插件\"><a href=\"#WKT-数据插件\" class=\"headerlink\" title=\"WKT 数据插件\"></a>WKT 数据插件</h1><p>&nbsp;&nbsp;wkt 作为 GIS 常用的一种地理数据格式，因为通用性需求度也很高,Leaflet 官方插件中提供了许多支持 wkt 的第三方解决方案，使用下来，发现 mapbox 出品的<a href=\"https://github.com/mapbox/leaflet-omnivore\" target=\"_blank\" rel=\"noopener\">leaflet-omnivore</a>效果可以说是目前最满足要求的了。</p>\n<p><code>omnivore</code>支持的功能比较强大</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">omnivore.csv(<span class=\"string\">\"a.csv\"</span>).addTo(map);</span><br><span class=\"line\">omnivore.gpx(<span class=\"string\">\"a.gpx\"</span>).addTo(map);</span><br><span class=\"line\">omnivore.kml(<span class=\"string\">\"a.kml\"</span>).addTo(map);</span><br><span class=\"line\">omnivore.wkt(<span class=\"string\">\"a.wkt\"</span>).addTo(map);</span><br><span class=\"line\">omnivore.topojson(<span class=\"string\">\"a.topojson\"</span>).addTo(map);</span><br><span class=\"line\">omnivore.geojson(<span class=\"string\">\"a.geojson\"</span>).addTo(map);</span><br><span class=\"line\">omnivore.polyline(<span class=\"string\">\"a.txt\"</span>).addTo(map);</span><br></pre></td></tr></table></figure>\n<p>其中对于 wkt 的加载有两种方式。<br>其中，<code>customlayer</code>是通过<code>L.geojson</code>图层来为加载进来的 wkt 数据设置样式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> customLayer = L.geoJson(<span class=\"literal\">null</span>, &#123;</span><br><span class=\"line\">  style: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"attr\">color</span>: <span class=\"string\">\"#0ff\"</span> &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><code>omnivore.wkt(url, parser_options?, customLayer?)</code>: 通过 url 加载</p>\n</li>\n<li><p><code>omnivore.wkt.parse(wktString，parser_options?, customLayer?)</code>: 通过转换 wkt 字符串加载</p>\n</li>\n</ul>\n<p>具体的使用效果可以移步<a href=\"https://github.com/zzcyrus/Leaflet-demos/blob/master/1.plugins/plugins.html\" target=\"_blank\" rel=\"noopener\">demo</a></p>"},{"title":"矢量切片的使用尝试1—openlayers应用","date":"2017-11-12T02:54:57.000Z","_content":"\n&nbsp;&nbsp;对于 GIS 行业来说，栅格切片已经处于垄断地位很长时间了，但随着 mapbox 的发展，矢量切片越来越勾引起大家探究的欲望，最近我也小小的观望了下，发现现在技术还是比较成熟了，使用上却不是很广泛，遂分享下自己瞎折腾的一些路，想着帮助大家少踩点坑，本文将介绍下服务端和网页端中 OpenLayers 对于矢量切片的一些应用。\n\n<!-- more -->\n\n&nbsp;&nbsp;在项目实际使用中还是建议大家首先了解下矢量和栅格切片的优缺点，网上能搜到的很多，水平有限，这里不献丑了。对于我个人来说吸引我的无非三点：1.支持大数据；2.自定义渲染；3.要素交互。\n\n&nbsp;&nbsp;不多说了进入主题吧，OpenLayers 中支持`ol.source.VectorTile`,对于我们来说想使用它无非就是创造这一类型的`source`，目前来说想要自定义矢量切片源我探索的有以下几种方式：\n\n# geoserver 中的 vectortiles-plugin 插件\n\n这种方式网上教程很多，是大家目前常用的，优点是支持的数据格式比较多，输出的数据格式也很多，geojson、topojson、mvt 都能做到，不做过多介绍\n\n# mapbox 开发的 geojson-vt 库\n\n这个库可能大家不去仔细关注都不会发现，mapbox 推出，[geojson-vt](https://github.com/mapbox/geojson-vt)，作用很简单，官方说明简单明了，把 geojson 转换成 mvt 格式的矢量数据源。\n\n翻译一下使用：\n\n```js\n// 通过geojson数据源构建切片索引\nvar tileIndex = geojsonvt(geoJSON);\n\n// 通过z,x,y来在切片索引中请求某个具体瓦片\nvar features = tileIndex.getTile(z, x, y).features;\n```\n\n拿到 features 后无非就是做样式调整之类的工作了。OpenLayers 官方也有一个 demo，叫做[geojson-vt integration](https://openlayers.org/en/latest/examples/geojson-vt.html)，详细介绍了怎么在 OpenLayers 中结合使用该库。\n\n我在实际使用中发现，这个库可以说很 imba 了，有测试 200M 以上的 geojson 源文件，都能流畅的展示出来。mapbox 官方对于这个库的说明是，把 geojson 切割成矢量切片在**浏览器端**使用，所以我觉得因为**网络传输**的不确定性，对于**小一点**的数据量，可以考虑直接在浏览器端使用这个库。\n\n# geojson-vt 的 nodejs 服务端实现\n\n(｡･∀･)ﾉﾞ嗨，既然是 js，那就意味着，我们可以用 nodejs 搭建服务端呀，在浏览到某个层级时候，只请求当前需要的瓦片，不就能解决大数据的传输问题了，nodejs 大法好！\n\n具体的代码可以移步[github](https://github.com/zzcyrus/openlayers-demos/tree/master/1.vector_tile)\n\n这里对一些主要部分做一些说明\n\n```js\n// 读取数据源文件，构建切片索引\nconst dataFile = \"./data/world.json\";\nconst dataSource = JSON.parse(fs.readFileSync(dataFile));\nconst tileIndex = geojsonvt(dataSource, {\n  extent: 4096,\n  debug: 1,\n});\n```\n\n```js\n// 从url中解析瓦片请求位置的x，y，z\napp.use(async (ctx, next) => {\n  let path = ctx.request.path.toString();\n  ctx.response.type = \"application/json\";\n  if (path.indexOf(\".vector\") !== -1) {\n    const pathArr = path.substring(1, path.indexOf(\".vector\")).split(\"/\");\n    const z = pathArr[pathArr.length - 3];\n    const x = pathArr[pathArr.length - 2];\n    const y = pathArr[pathArr.length - 1];\n    const data = tileIndex.getTile(Number(z), Number(x), Number(y));\n    const features = JSON.stringify(\n      {\n        type: \"FeatureCollection\",\n        features: data ? data.features : [],\n      },\n      replacer\n    ); // replacer 是geojson格式转换函数\n    ctx.response.body = features;\n    await next();\n  } else {\n    ctx.response.body = \"Error\";\n  }\n});\n```\n\n接下来是浏览器中的调用\n\n```js\nvar vectorSource = new ol.source.VectorTile({\n  // 因为转换函数是geojson格式，所以这里format为geojson\n  format: new ol.format.GeoJSON({\n    // 要定义数据源的坐标系为瓦片像素\n    defaultDataProjection: new ol.proj.Projection({\n      code: \"TILE_PIXELS\",\n      units: \"tile-pixels\",\n    }),\n  }),\n  // 调用时候要注意z，x，y 的位置，实际上是与服务端相对应的\n  url: \"http://localhost:3000/gettile/{z}/{x}/{y}.vector\",\n});\n```\n\n你可以在 [github](https://github.com/zzcyrus/openlayers-demos) 上看到 demo，执行安装启动\n\n```cl\ncd ./1.vector_tile\nnpm install\nnpm start\n```\n\n打开 vectortile.hmtl 可以在 network 中看到瓦片请求了。\n\n![](network.png)\n","source":"_posts/2017/vector-tile-openlayers-try.md","raw":"---\ntitle: 矢量切片的使用尝试1—openlayers应用\ndate: 2017-11-12 10:54:57\ntags: [GIS, OpenLayers]\ncategories: WebGIS\n---\n\n&nbsp;&nbsp;对于 GIS 行业来说，栅格切片已经处于垄断地位很长时间了，但随着 mapbox 的发展，矢量切片越来越勾引起大家探究的欲望，最近我也小小的观望了下，发现现在技术还是比较成熟了，使用上却不是很广泛，遂分享下自己瞎折腾的一些路，想着帮助大家少踩点坑，本文将介绍下服务端和网页端中 OpenLayers 对于矢量切片的一些应用。\n\n<!-- more -->\n\n&nbsp;&nbsp;在项目实际使用中还是建议大家首先了解下矢量和栅格切片的优缺点，网上能搜到的很多，水平有限，这里不献丑了。对于我个人来说吸引我的无非三点：1.支持大数据；2.自定义渲染；3.要素交互。\n\n&nbsp;&nbsp;不多说了进入主题吧，OpenLayers 中支持`ol.source.VectorTile`,对于我们来说想使用它无非就是创造这一类型的`source`，目前来说想要自定义矢量切片源我探索的有以下几种方式：\n\n# geoserver 中的 vectortiles-plugin 插件\n\n这种方式网上教程很多，是大家目前常用的，优点是支持的数据格式比较多，输出的数据格式也很多，geojson、topojson、mvt 都能做到，不做过多介绍\n\n# mapbox 开发的 geojson-vt 库\n\n这个库可能大家不去仔细关注都不会发现，mapbox 推出，[geojson-vt](https://github.com/mapbox/geojson-vt)，作用很简单，官方说明简单明了，把 geojson 转换成 mvt 格式的矢量数据源。\n\n翻译一下使用：\n\n```js\n// 通过geojson数据源构建切片索引\nvar tileIndex = geojsonvt(geoJSON);\n\n// 通过z,x,y来在切片索引中请求某个具体瓦片\nvar features = tileIndex.getTile(z, x, y).features;\n```\n\n拿到 features 后无非就是做样式调整之类的工作了。OpenLayers 官方也有一个 demo，叫做[geojson-vt integration](https://openlayers.org/en/latest/examples/geojson-vt.html)，详细介绍了怎么在 OpenLayers 中结合使用该库。\n\n我在实际使用中发现，这个库可以说很 imba 了，有测试 200M 以上的 geojson 源文件，都能流畅的展示出来。mapbox 官方对于这个库的说明是，把 geojson 切割成矢量切片在**浏览器端**使用，所以我觉得因为**网络传输**的不确定性，对于**小一点**的数据量，可以考虑直接在浏览器端使用这个库。\n\n# geojson-vt 的 nodejs 服务端实现\n\n(｡･∀･)ﾉﾞ嗨，既然是 js，那就意味着，我们可以用 nodejs 搭建服务端呀，在浏览到某个层级时候，只请求当前需要的瓦片，不就能解决大数据的传输问题了，nodejs 大法好！\n\n具体的代码可以移步[github](https://github.com/zzcyrus/openlayers-demos/tree/master/1.vector_tile)\n\n这里对一些主要部分做一些说明\n\n```js\n// 读取数据源文件，构建切片索引\nconst dataFile = \"./data/world.json\";\nconst dataSource = JSON.parse(fs.readFileSync(dataFile));\nconst tileIndex = geojsonvt(dataSource, {\n  extent: 4096,\n  debug: 1,\n});\n```\n\n```js\n// 从url中解析瓦片请求位置的x，y，z\napp.use(async (ctx, next) => {\n  let path = ctx.request.path.toString();\n  ctx.response.type = \"application/json\";\n  if (path.indexOf(\".vector\") !== -1) {\n    const pathArr = path.substring(1, path.indexOf(\".vector\")).split(\"/\");\n    const z = pathArr[pathArr.length - 3];\n    const x = pathArr[pathArr.length - 2];\n    const y = pathArr[pathArr.length - 1];\n    const data = tileIndex.getTile(Number(z), Number(x), Number(y));\n    const features = JSON.stringify(\n      {\n        type: \"FeatureCollection\",\n        features: data ? data.features : [],\n      },\n      replacer\n    ); // replacer 是geojson格式转换函数\n    ctx.response.body = features;\n    await next();\n  } else {\n    ctx.response.body = \"Error\";\n  }\n});\n```\n\n接下来是浏览器中的调用\n\n```js\nvar vectorSource = new ol.source.VectorTile({\n  // 因为转换函数是geojson格式，所以这里format为geojson\n  format: new ol.format.GeoJSON({\n    // 要定义数据源的坐标系为瓦片像素\n    defaultDataProjection: new ol.proj.Projection({\n      code: \"TILE_PIXELS\",\n      units: \"tile-pixels\",\n    }),\n  }),\n  // 调用时候要注意z，x，y 的位置，实际上是与服务端相对应的\n  url: \"http://localhost:3000/gettile/{z}/{x}/{y}.vector\",\n});\n```\n\n你可以在 [github](https://github.com/zzcyrus/openlayers-demos) 上看到 demo，执行安装启动\n\n```cl\ncd ./1.vector_tile\nnpm install\nnpm start\n```\n\n打开 vectortile.hmtl 可以在 network 中看到瓦片请求了。\n\n![](network.png)\n","slug":"vector-tile-openlayers-try","published":1,"updated":"2020-05-17T08:21:35.998Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrkxgsx0008i83idpjx5e8h","content":"<p>&nbsp;&nbsp;对于 GIS 行业来说，栅格切片已经处于垄断地位很长时间了，但随着 mapbox 的发展，矢量切片越来越勾引起大家探究的欲望，最近我也小小的观望了下，发现现在技术还是比较成熟了，使用上却不是很广泛，遂分享下自己瞎折腾的一些路，想着帮助大家少踩点坑，本文将介绍下服务端和网页端中 OpenLayers 对于矢量切片的一些应用。</p>\n<a id=\"more\"></a>\n<p>&nbsp;&nbsp;在项目实际使用中还是建议大家首先了解下矢量和栅格切片的优缺点，网上能搜到的很多，水平有限，这里不献丑了。对于我个人来说吸引我的无非三点：1.支持大数据；2.自定义渲染；3.要素交互。</p>\n<p>&nbsp;&nbsp;不多说了进入主题吧，OpenLayers 中支持<code>ol.source.VectorTile</code>,对于我们来说想使用它无非就是创造这一类型的<code>source</code>，目前来说想要自定义矢量切片源我探索的有以下几种方式：</p>\n<h1 id=\"geoserver-中的-vectortiles-plugin-插件\"><a href=\"#geoserver-中的-vectortiles-plugin-插件\" class=\"headerlink\" title=\"geoserver 中的 vectortiles-plugin 插件\"></a>geoserver 中的 vectortiles-plugin 插件</h1><p>这种方式网上教程很多，是大家目前常用的，优点是支持的数据格式比较多，输出的数据格式也很多，geojson、topojson、mvt 都能做到，不做过多介绍</p>\n<h1 id=\"mapbox-开发的-geojson-vt-库\"><a href=\"#mapbox-开发的-geojson-vt-库\" class=\"headerlink\" title=\"mapbox 开发的 geojson-vt 库\"></a>mapbox 开发的 geojson-vt 库</h1><p>这个库可能大家不去仔细关注都不会发现，mapbox 推出，<a href=\"https://github.com/mapbox/geojson-vt\" target=\"_blank\" rel=\"noopener\">geojson-vt</a>，作用很简单，官方说明简单明了，把 geojson 转换成 mvt 格式的矢量数据源。</p>\n<p>翻译一下使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过geojson数据源构建切片索引</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> tileIndex = geojsonvt(geoJSON);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过z,x,y来在切片索引中请求某个具体瓦片</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> features = tileIndex.getTile(z, x, y).features;</span><br></pre></td></tr></table></figure>\n<p>拿到 features 后无非就是做样式调整之类的工作了。OpenLayers 官方也有一个 demo，叫做<a href=\"https://openlayers.org/en/latest/examples/geojson-vt.html\" target=\"_blank\" rel=\"noopener\">geojson-vt integration</a>，详细介绍了怎么在 OpenLayers 中结合使用该库。</p>\n<p>我在实际使用中发现，这个库可以说很 imba 了，有测试 200M 以上的 geojson 源文件，都能流畅的展示出来。mapbox 官方对于这个库的说明是，把 geojson 切割成矢量切片在<strong>浏览器端</strong>使用，所以我觉得因为<strong>网络传输</strong>的不确定性，对于<strong>小一点</strong>的数据量，可以考虑直接在浏览器端使用这个库。</p>\n<h1 id=\"geojson-vt-的-nodejs-服务端实现\"><a href=\"#geojson-vt-的-nodejs-服务端实现\" class=\"headerlink\" title=\"geojson-vt 的 nodejs 服务端实现\"></a>geojson-vt 的 nodejs 服务端实现</h1><p>(｡･∀･)ﾉﾞ嗨，既然是 js，那就意味着，我们可以用 nodejs 搭建服务端呀，在浏览到某个层级时候，只请求当前需要的瓦片，不就能解决大数据的传输问题了，nodejs 大法好！</p>\n<p>具体的代码可以移步<a href=\"https://github.com/zzcyrus/openlayers-demos/tree/master/1.vector_tile\" target=\"_blank\" rel=\"noopener\">github</a></p>\n<p>这里对一些主要部分做一些说明</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 读取数据源文件，构建切片索引</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> dataFile = <span class=\"string\">\"./data/world.json\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> dataSource = <span class=\"built_in\">JSON</span>.parse(fs.readFileSync(dataFile));</span><br><span class=\"line\"><span class=\"keyword\">const</span> tileIndex = geojsonvt(dataSource, &#123;</span><br><span class=\"line\">  extent: <span class=\"number\">4096</span>,</span><br><span class=\"line\">  debug: <span class=\"number\">1</span>,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从url中解析瓦片请求位置的x，y，z</span></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> path = ctx.request.path.toString();</span><br><span class=\"line\">  ctx.response.type = <span class=\"string\">\"application/json\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (path.indexOf(<span class=\"string\">\".vector\"</span>) !== <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> pathArr = path.substring(<span class=\"number\">1</span>, path.indexOf(<span class=\"string\">\".vector\"</span>)).split(<span class=\"string\">\"/\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> z = pathArr[pathArr.length - <span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> x = pathArr[pathArr.length - <span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> y = pathArr[pathArr.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = tileIndex.getTile(<span class=\"built_in\">Number</span>(z), <span class=\"built_in\">Number</span>(x), <span class=\"built_in\">Number</span>(y));</span><br><span class=\"line\">    <span class=\"keyword\">const</span> features = <span class=\"built_in\">JSON</span>.stringify(</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        type: <span class=\"string\">\"FeatureCollection\"</span>,</span><br><span class=\"line\">        features: data ? data.features : [],</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      replacer</span><br><span class=\"line\">    ); <span class=\"comment\">// replacer 是geojson格式转换函数</span></span><br><span class=\"line\">    ctx.response.body = features;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    ctx.response.body = <span class=\"string\">\"Error\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>接下来是浏览器中的调用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vectorSource = <span class=\"keyword\">new</span> ol.source.VectorTile(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 因为转换函数是geojson格式，所以这里format为geojson</span></span><br><span class=\"line\">  format: <span class=\"keyword\">new</span> ol.format.GeoJSON(&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 要定义数据源的坐标系为瓦片像素</span></span><br><span class=\"line\">    defaultDataProjection: <span class=\"keyword\">new</span> ol.proj.Projection(&#123;</span><br><span class=\"line\">      code: <span class=\"string\">\"TILE_PIXELS\"</span>,</span><br><span class=\"line\">      units: <span class=\"string\">\"tile-pixels\"</span>,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">  <span class=\"comment\">// 调用时候要注意z，x，y 的位置，实际上是与服务端相对应的</span></span><br><span class=\"line\">  url: <span class=\"string\">\"http://localhost:3000/gettile/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.vector\"</span>,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>你可以在 <a href=\"https://github.com/zzcyrus/openlayers-demos\" target=\"_blank\" rel=\"noopener\">github</a> 上看到 demo，执行安装启动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd ./1.vector_tile</span><br><span class=\"line\">npm install</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<p>打开 vectortile.hmtl 可以在 network 中看到瓦片请求了。</p>\n<p><img src=\"network.png\" alt></p>\n","site":{"data":{}},"excerpt":"<p>&nbsp;&nbsp;对于 GIS 行业来说，栅格切片已经处于垄断地位很长时间了，但随着 mapbox 的发展，矢量切片越来越勾引起大家探究的欲望，最近我也小小的观望了下，发现现在技术还是比较成熟了，使用上却不是很广泛，遂分享下自己瞎折腾的一些路，想着帮助大家少踩点坑，本文将介绍下服务端和网页端中 OpenLayers 对于矢量切片的一些应用。</p>","more":"<p>&nbsp;&nbsp;在项目实际使用中还是建议大家首先了解下矢量和栅格切片的优缺点，网上能搜到的很多，水平有限，这里不献丑了。对于我个人来说吸引我的无非三点：1.支持大数据；2.自定义渲染；3.要素交互。</p>\n<p>&nbsp;&nbsp;不多说了进入主题吧，OpenLayers 中支持<code>ol.source.VectorTile</code>,对于我们来说想使用它无非就是创造这一类型的<code>source</code>，目前来说想要自定义矢量切片源我探索的有以下几种方式：</p>\n<h1 id=\"geoserver-中的-vectortiles-plugin-插件\"><a href=\"#geoserver-中的-vectortiles-plugin-插件\" class=\"headerlink\" title=\"geoserver 中的 vectortiles-plugin 插件\"></a>geoserver 中的 vectortiles-plugin 插件</h1><p>这种方式网上教程很多，是大家目前常用的，优点是支持的数据格式比较多，输出的数据格式也很多，geojson、topojson、mvt 都能做到，不做过多介绍</p>\n<h1 id=\"mapbox-开发的-geojson-vt-库\"><a href=\"#mapbox-开发的-geojson-vt-库\" class=\"headerlink\" title=\"mapbox 开发的 geojson-vt 库\"></a>mapbox 开发的 geojson-vt 库</h1><p>这个库可能大家不去仔细关注都不会发现，mapbox 推出，<a href=\"https://github.com/mapbox/geojson-vt\" target=\"_blank\" rel=\"noopener\">geojson-vt</a>，作用很简单，官方说明简单明了，把 geojson 转换成 mvt 格式的矢量数据源。</p>\n<p>翻译一下使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过geojson数据源构建切片索引</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> tileIndex = geojsonvt(geoJSON);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过z,x,y来在切片索引中请求某个具体瓦片</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> features = tileIndex.getTile(z, x, y).features;</span><br></pre></td></tr></table></figure>\n<p>拿到 features 后无非就是做样式调整之类的工作了。OpenLayers 官方也有一个 demo，叫做<a href=\"https://openlayers.org/en/latest/examples/geojson-vt.html\" target=\"_blank\" rel=\"noopener\">geojson-vt integration</a>，详细介绍了怎么在 OpenLayers 中结合使用该库。</p>\n<p>我在实际使用中发现，这个库可以说很 imba 了，有测试 200M 以上的 geojson 源文件，都能流畅的展示出来。mapbox 官方对于这个库的说明是，把 geojson 切割成矢量切片在<strong>浏览器端</strong>使用，所以我觉得因为<strong>网络传输</strong>的不确定性，对于<strong>小一点</strong>的数据量，可以考虑直接在浏览器端使用这个库。</p>\n<h1 id=\"geojson-vt-的-nodejs-服务端实现\"><a href=\"#geojson-vt-的-nodejs-服务端实现\" class=\"headerlink\" title=\"geojson-vt 的 nodejs 服务端实现\"></a>geojson-vt 的 nodejs 服务端实现</h1><p>(｡･∀･)ﾉﾞ嗨，既然是 js，那就意味着，我们可以用 nodejs 搭建服务端呀，在浏览到某个层级时候，只请求当前需要的瓦片，不就能解决大数据的传输问题了，nodejs 大法好！</p>\n<p>具体的代码可以移步<a href=\"https://github.com/zzcyrus/openlayers-demos/tree/master/1.vector_tile\" target=\"_blank\" rel=\"noopener\">github</a></p>\n<p>这里对一些主要部分做一些说明</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 读取数据源文件，构建切片索引</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> dataFile = <span class=\"string\">\"./data/world.json\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> dataSource = <span class=\"built_in\">JSON</span>.parse(fs.readFileSync(dataFile));</span><br><span class=\"line\"><span class=\"keyword\">const</span> tileIndex = geojsonvt(dataSource, &#123;</span><br><span class=\"line\">  extent: <span class=\"number\">4096</span>,</span><br><span class=\"line\">  debug: <span class=\"number\">1</span>,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从url中解析瓦片请求位置的x，y，z</span></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> path = ctx.request.path.toString();</span><br><span class=\"line\">  ctx.response.type = <span class=\"string\">\"application/json\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (path.indexOf(<span class=\"string\">\".vector\"</span>) !== <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> pathArr = path.substring(<span class=\"number\">1</span>, path.indexOf(<span class=\"string\">\".vector\"</span>)).split(<span class=\"string\">\"/\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> z = pathArr[pathArr.length - <span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> x = pathArr[pathArr.length - <span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> y = pathArr[pathArr.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = tileIndex.getTile(<span class=\"built_in\">Number</span>(z), <span class=\"built_in\">Number</span>(x), <span class=\"built_in\">Number</span>(y));</span><br><span class=\"line\">    <span class=\"keyword\">const</span> features = <span class=\"built_in\">JSON</span>.stringify(</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        type: <span class=\"string\">\"FeatureCollection\"</span>,</span><br><span class=\"line\">        features: data ? data.features : [],</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      replacer</span><br><span class=\"line\">    ); <span class=\"comment\">// replacer 是geojson格式转换函数</span></span><br><span class=\"line\">    ctx.response.body = features;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    ctx.response.body = <span class=\"string\">\"Error\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>接下来是浏览器中的调用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vectorSource = <span class=\"keyword\">new</span> ol.source.VectorTile(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 因为转换函数是geojson格式，所以这里format为geojson</span></span><br><span class=\"line\">  format: <span class=\"keyword\">new</span> ol.format.GeoJSON(&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 要定义数据源的坐标系为瓦片像素</span></span><br><span class=\"line\">    defaultDataProjection: <span class=\"keyword\">new</span> ol.proj.Projection(&#123;</span><br><span class=\"line\">      code: <span class=\"string\">\"TILE_PIXELS\"</span>,</span><br><span class=\"line\">      units: <span class=\"string\">\"tile-pixels\"</span>,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">  <span class=\"comment\">// 调用时候要注意z，x，y 的位置，实际上是与服务端相对应的</span></span><br><span class=\"line\">  url: <span class=\"string\">\"http://localhost:3000/gettile/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.vector\"</span>,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>你可以在 <a href=\"https://github.com/zzcyrus/openlayers-demos\" target=\"_blank\" rel=\"noopener\">github</a> 上看到 demo，执行安装启动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd ./1.vector_tile</span><br><span class=\"line\">npm install</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<p>打开 vectortile.hmtl 可以在 network 中看到瓦片请求了。</p>\n<p><img src=\"network.png\" alt></p>"},{"title":"在web中渲染格点数据探讨（1）","date":"2020-05-17T08:18:51.000Z","_content":"\n在地理信息行业中，我们常遇见的数据中有这么两类：\n\n- 一类是站点（散点）数据。地图上分布着位置不均匀的各种站点，比方说气象站，水文站，如果我们需要查看站点数值趋势，就可以通过等值线图等方式，比如[d3 的 contour](https://github.com/d3/d3-contour)，[turf 的 isolines](https://turfjs.org/docs/#isolines)，还可以通过插值方法将站点插值到网格上，转化成格点数据，后面我们也会讨论。\n- 也有一类是格点数据。这个在气象上就非常常见，气象预报数据通常是模式跑出来的，如同渔网一样的格点，这种数据提供了查询任意位置数值的作用，它的渲染也同样常见，传统的方法是在服务器端生成好对应图片，在浏览器上贴图，这里追求实现的是`前端渲染`。\n\n<!-- more -->\n\n太长不看可以直接[项目仓库](https://github.com/zzcyrus/Leaflet.Tile.PixelLayer)\n\n# 背景\n\n格点数据的特点往往是数据量大，蕴含的信息量大，不仅包含着某个点的数值，同时还有这个点的经纬度，时间维度信息，空间高度信息，所以我们通常会听见学气象的同学说某个数据有四个维度。随着计算机的发展，图形学的发展，想要全部展示这些时空数据变得越来越可能，我会在这个系列中逐步的提出一些我的探索，希望能给大家带来帮助。\n\n格点数据有很多格式，我们可能常接触到的一些格点数据文件比方说[GeoTIFF](https://en.wikipedia.org/wiki/GeoTIFF)，气象里面有[GRIB](https://en.wikipedia.org/wiki/GRIB)，nc 等等，甚至一张简单的 png 也可以是由格点数据转换成的，它会包含基本的**格点数量和值**，比方说在经度方向有 300 个点，纬度方向有 200 个点，那么整个文件包含了 6w 个格点的数值，还通常包含一些**经纬度信息**，比方说每个点的经纬度值，也有可能只是四个顶点的经纬度信息，所以 raster（栅格）图层也在我的讨论范围之内。\n\n# 思路\n\n我会以 Leaflet 为主要的实现手段，个人觉得它的灵活性比较强，功能虽然基础，但是利于拓展，所以各类图层插件也层出不穷。\n假设我想要在地图上渲染一组格点数据，数据长 300，宽 200，一共 60000 个点，从原理上分析无非就是把一个个的点钉在了地图上，我们可以清楚的**读取或者推算**出每个点的经纬度，要解决的就是点与点之间的空白怎么办，毕竟每个点从经纬度上来看即使只差了 1 度，算上比例尺，在地图上也是不等的像素点，所以我们需要通过**插值计算**来补齐点与点之间的空白。于是我就有了大致如下的想法：\n\n> 准备基础数据和图例等信息 => 准备 canvas 图层 => 找到初始点 => 根据数值和图例找到对应颜色 => 渲染颜色 => 循环直至画完所有的点\n\n# 开发\n\n按照上面的思路一步步开始，我已经准备好了一个[温度相关的数据](https://github.com/zzcyrus/Leaflet.Tile.PixelLayer/blob/master/demo/data.json)和图例信息，后面也会再讨论数据的生成和优化，所以直接从第二步开始，这里只说大致的流程，具体的算法可以去看[源代码](https://github.com/zzcyrus/Leaflet.Tile.PixelLayer/blob/master/src/index.js)\n\n> 创建 TilePixelLayer 图层并继承基础的`TileLayer`，需要重写`createTile`方法，每一个 tile 最终都返回一个我们自己绘制出来的 canvas\n\n```js\n\nL.TilePixelLayer = L.TileLayer.extend({\n    createTile: function(coords) {\n      var dom = L.DomUtil.create('canvas', 'leafvar-pixel-tile')\n      var ctx = dom.getContext('2d')\n      //  bounds为当前tile的一些边界信息，绘制时候要用到\n      this.interpolateTile(ctx,  'bounds')\n      return dom\n    }\n}\n```\n\n> 我们在每一个 tile 对应的 canvas 中，从 0 点开始，分别循环 256 像素的行和列，然后通过插值得到像素对应的数值，再找到数值对应的颜色，直至完成整个 canvas 的上色过程。\n\n```js\ninterpolateTile: function(ctx, bounds) {  // 逐像素绘制每一个tile\n  var x = bounds.x                 // x坐标为当前瓦片在地图上的初始像素x\n  var tileX = 0                       // tileX为当前瓦片canvas的坐标，在0~256之间循环\n  var gap = 4                        // 每隔四个点计算一次加快渲染速度，这个数值可以自己设置\n  var colorImageData = new ImageData(256, 256)  // 创建一个imageData接收颜色\n\n  // 循环行\n  var batchInterpolate = () => {\n    while (tileX < bounds.w) {\n      interpolateColumn(x, tileX)\n      x += gap\n      tileX += gap\n    }\n    ctx.putImageData(colorImageData, 0, 0)\n  }\n\n  // 循环列\n  var interpolateColumn = (x, tileX) => {\n   for (                                   // y坐标为当前瓦片在地图上的初始像素y\n      var defaultColor = [0, 0, 0, 1], y = bounds.y, height = 0;\n      height <= bounds.h;\n      y += gap, height += gap\n    ) {\n      // 把循环到的某个点的像素坐标转化为经纬度\n      var location = this.map.unproject(L.point(x, y), zoom)\n      var coord = [location.lng, location.lat]\n\n      // 找到经纬度对应的周围四个点的坐标，通过双线性插值算出一个近似值作为当前像素点的数值\n      var gridValue = this.gridInterpolate(coord)\n\n      // 用简单的线性插值通过图例得到数值对应的颜色\n      var color = this.gradient(gridValue)\n\n      // 因为设置了gap，gap范围内的每一个像素点都用这个颜色，如果gap设置为1，那么每个像素都独立参与了计算，性能有所慢，但是精度高\n      for (var i = 0; i < gap; i++) {\n        for (var j = 0; j < gap; j++) {\n          this.setColor(colorImageData, i, j, color)  // 上色\n        }\n      }\n    }\n  }\n\n  // 开始绘制\n  batchInterpolate()\n}\n```\n\n> 总结一下，每一个瓦片都对应了一个 canvas，每个 canvas 我们都逐像素处理，先把像素转化为经纬度，通过插值得到一个比较精确的对应格点数值，再通过图例进行了上色。最终就把所有的格点数据都渲染了出来。\n\n# 使用\n\n完整的代码可以在[github](https://github.com/zzcyrus/Leaflet.Tile.PixelLayer)上看到。`dist`目录下有编译好的 js 文件，在项目中引入就好。\n\n```js\nvar tilePixelLayer = L.tilePixelLayer({\n  data: data,\n  overlayAlpha: 230, // 透明度\n  gradient: [\n    [233.15, [56, 4, 45]],\n    [243.15, [48, 0, 106]],\n    [253.15, [0, 14, 134]],\n    [256.15, [3, 44, 144]],\n    // ......\n  ], // 准备一组图例\n  clickEvt: function (e, gridValue) {\n    alert(`该地点温度:${Math.round(gridValue - 273.15)}°`);\n  }, // 事件\n});\nmap.addLayer(tilePixelLayer); // 添加到地图上\n```\n\n效果：\n\n <iframe  \n height=400 \n width=100% \n src=\"https://kael.top/Leaflet.Tile.PixelLayer/demo/\"  \n frameborder=0  \n allowfullscreen>\n </iframe>\n\n[在线 demo](https://kael.top/Leaflet.Tile.PixelLayer/demo/)\n\n# 后续\n\n这样我们已经初步在浏览器上完成了一个前端完全可控的格点数据渲染，当然对整个过程是否有更好的优化方法，我们后面会继续展开讨论。\n","source":"_posts/2020/web-grid-data-render-1.md","raw":"---\ntitle: 在web中渲染格点数据探讨（1）\ndate: 2020-05-17 16:18:51\ntags: [GIS, Leaflet]\ncategories: WebGIS\n---\n\n在地理信息行业中，我们常遇见的数据中有这么两类：\n\n- 一类是站点（散点）数据。地图上分布着位置不均匀的各种站点，比方说气象站，水文站，如果我们需要查看站点数值趋势，就可以通过等值线图等方式，比如[d3 的 contour](https://github.com/d3/d3-contour)，[turf 的 isolines](https://turfjs.org/docs/#isolines)，还可以通过插值方法将站点插值到网格上，转化成格点数据，后面我们也会讨论。\n- 也有一类是格点数据。这个在气象上就非常常见，气象预报数据通常是模式跑出来的，如同渔网一样的格点，这种数据提供了查询任意位置数值的作用，它的渲染也同样常见，传统的方法是在服务器端生成好对应图片，在浏览器上贴图，这里追求实现的是`前端渲染`。\n\n<!-- more -->\n\n太长不看可以直接[项目仓库](https://github.com/zzcyrus/Leaflet.Tile.PixelLayer)\n\n# 背景\n\n格点数据的特点往往是数据量大，蕴含的信息量大，不仅包含着某个点的数值，同时还有这个点的经纬度，时间维度信息，空间高度信息，所以我们通常会听见学气象的同学说某个数据有四个维度。随着计算机的发展，图形学的发展，想要全部展示这些时空数据变得越来越可能，我会在这个系列中逐步的提出一些我的探索，希望能给大家带来帮助。\n\n格点数据有很多格式，我们可能常接触到的一些格点数据文件比方说[GeoTIFF](https://en.wikipedia.org/wiki/GeoTIFF)，气象里面有[GRIB](https://en.wikipedia.org/wiki/GRIB)，nc 等等，甚至一张简单的 png 也可以是由格点数据转换成的，它会包含基本的**格点数量和值**，比方说在经度方向有 300 个点，纬度方向有 200 个点，那么整个文件包含了 6w 个格点的数值，还通常包含一些**经纬度信息**，比方说每个点的经纬度值，也有可能只是四个顶点的经纬度信息，所以 raster（栅格）图层也在我的讨论范围之内。\n\n# 思路\n\n我会以 Leaflet 为主要的实现手段，个人觉得它的灵活性比较强，功能虽然基础，但是利于拓展，所以各类图层插件也层出不穷。\n假设我想要在地图上渲染一组格点数据，数据长 300，宽 200，一共 60000 个点，从原理上分析无非就是把一个个的点钉在了地图上，我们可以清楚的**读取或者推算**出每个点的经纬度，要解决的就是点与点之间的空白怎么办，毕竟每个点从经纬度上来看即使只差了 1 度，算上比例尺，在地图上也是不等的像素点，所以我们需要通过**插值计算**来补齐点与点之间的空白。于是我就有了大致如下的想法：\n\n> 准备基础数据和图例等信息 => 准备 canvas 图层 => 找到初始点 => 根据数值和图例找到对应颜色 => 渲染颜色 => 循环直至画完所有的点\n\n# 开发\n\n按照上面的思路一步步开始，我已经准备好了一个[温度相关的数据](https://github.com/zzcyrus/Leaflet.Tile.PixelLayer/blob/master/demo/data.json)和图例信息，后面也会再讨论数据的生成和优化，所以直接从第二步开始，这里只说大致的流程，具体的算法可以去看[源代码](https://github.com/zzcyrus/Leaflet.Tile.PixelLayer/blob/master/src/index.js)\n\n> 创建 TilePixelLayer 图层并继承基础的`TileLayer`，需要重写`createTile`方法，每一个 tile 最终都返回一个我们自己绘制出来的 canvas\n\n```js\n\nL.TilePixelLayer = L.TileLayer.extend({\n    createTile: function(coords) {\n      var dom = L.DomUtil.create('canvas', 'leafvar-pixel-tile')\n      var ctx = dom.getContext('2d')\n      //  bounds为当前tile的一些边界信息，绘制时候要用到\n      this.interpolateTile(ctx,  'bounds')\n      return dom\n    }\n}\n```\n\n> 我们在每一个 tile 对应的 canvas 中，从 0 点开始，分别循环 256 像素的行和列，然后通过插值得到像素对应的数值，再找到数值对应的颜色，直至完成整个 canvas 的上色过程。\n\n```js\ninterpolateTile: function(ctx, bounds) {  // 逐像素绘制每一个tile\n  var x = bounds.x                 // x坐标为当前瓦片在地图上的初始像素x\n  var tileX = 0                       // tileX为当前瓦片canvas的坐标，在0~256之间循环\n  var gap = 4                        // 每隔四个点计算一次加快渲染速度，这个数值可以自己设置\n  var colorImageData = new ImageData(256, 256)  // 创建一个imageData接收颜色\n\n  // 循环行\n  var batchInterpolate = () => {\n    while (tileX < bounds.w) {\n      interpolateColumn(x, tileX)\n      x += gap\n      tileX += gap\n    }\n    ctx.putImageData(colorImageData, 0, 0)\n  }\n\n  // 循环列\n  var interpolateColumn = (x, tileX) => {\n   for (                                   // y坐标为当前瓦片在地图上的初始像素y\n      var defaultColor = [0, 0, 0, 1], y = bounds.y, height = 0;\n      height <= bounds.h;\n      y += gap, height += gap\n    ) {\n      // 把循环到的某个点的像素坐标转化为经纬度\n      var location = this.map.unproject(L.point(x, y), zoom)\n      var coord = [location.lng, location.lat]\n\n      // 找到经纬度对应的周围四个点的坐标，通过双线性插值算出一个近似值作为当前像素点的数值\n      var gridValue = this.gridInterpolate(coord)\n\n      // 用简单的线性插值通过图例得到数值对应的颜色\n      var color = this.gradient(gridValue)\n\n      // 因为设置了gap，gap范围内的每一个像素点都用这个颜色，如果gap设置为1，那么每个像素都独立参与了计算，性能有所慢，但是精度高\n      for (var i = 0; i < gap; i++) {\n        for (var j = 0; j < gap; j++) {\n          this.setColor(colorImageData, i, j, color)  // 上色\n        }\n      }\n    }\n  }\n\n  // 开始绘制\n  batchInterpolate()\n}\n```\n\n> 总结一下，每一个瓦片都对应了一个 canvas，每个 canvas 我们都逐像素处理，先把像素转化为经纬度，通过插值得到一个比较精确的对应格点数值，再通过图例进行了上色。最终就把所有的格点数据都渲染了出来。\n\n# 使用\n\n完整的代码可以在[github](https://github.com/zzcyrus/Leaflet.Tile.PixelLayer)上看到。`dist`目录下有编译好的 js 文件，在项目中引入就好。\n\n```js\nvar tilePixelLayer = L.tilePixelLayer({\n  data: data,\n  overlayAlpha: 230, // 透明度\n  gradient: [\n    [233.15, [56, 4, 45]],\n    [243.15, [48, 0, 106]],\n    [253.15, [0, 14, 134]],\n    [256.15, [3, 44, 144]],\n    // ......\n  ], // 准备一组图例\n  clickEvt: function (e, gridValue) {\n    alert(`该地点温度:${Math.round(gridValue - 273.15)}°`);\n  }, // 事件\n});\nmap.addLayer(tilePixelLayer); // 添加到地图上\n```\n\n效果：\n\n <iframe  \n height=400 \n width=100% \n src=\"https://kael.top/Leaflet.Tile.PixelLayer/demo/\"  \n frameborder=0  \n allowfullscreen>\n </iframe>\n\n[在线 demo](https://kael.top/Leaflet.Tile.PixelLayer/demo/)\n\n# 后续\n\n这样我们已经初步在浏览器上完成了一个前端完全可控的格点数据渲染，当然对整个过程是否有更好的优化方法，我们后面会继续展开讨论。\n","slug":"web-grid-data-render-1","published":1,"updated":"2020-05-17T08:33:06.717Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrkxgsy0009i83iyzu3p2dj","content":"<p>在地理信息行业中，我们常遇见的数据中有这么两类：</p>\n<ul>\n<li>一类是站点（散点）数据。地图上分布着位置不均匀的各种站点，比方说气象站，水文站，如果我们需要查看站点数值趋势，就可以通过等值线图等方式，比如<a href=\"https://github.com/d3/d3-contour\" target=\"_blank\" rel=\"noopener\">d3 的 contour</a>，<a href=\"https://turfjs.org/docs/#isolines\" target=\"_blank\" rel=\"noopener\">turf 的 isolines</a>，还可以通过插值方法将站点插值到网格上，转化成格点数据，后面我们也会讨论。</li>\n<li>也有一类是格点数据。这个在气象上就非常常见，气象预报数据通常是模式跑出来的，如同渔网一样的格点，这种数据提供了查询任意位置数值的作用，它的渲染也同样常见，传统的方法是在服务器端生成好对应图片，在浏览器上贴图，这里追求实现的是<code>前端渲染</code>。</li>\n</ul>\n<a id=\"more\"></a>\n<p>太长不看可以直接<a href=\"https://github.com/zzcyrus/Leaflet.Tile.PixelLayer\" target=\"_blank\" rel=\"noopener\">项目仓库</a></p>\n<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>格点数据的特点往往是数据量大，蕴含的信息量大，不仅包含着某个点的数值，同时还有这个点的经纬度，时间维度信息，空间高度信息，所以我们通常会听见学气象的同学说某个数据有四个维度。随着计算机的发展，图形学的发展，想要全部展示这些时空数据变得越来越可能，我会在这个系列中逐步的提出一些我的探索，希望能给大家带来帮助。</p>\n<p>格点数据有很多格式，我们可能常接触到的一些格点数据文件比方说<a href=\"https://en.wikipedia.org/wiki/GeoTIFF\" target=\"_blank\" rel=\"noopener\">GeoTIFF</a>，气象里面有<a href=\"https://en.wikipedia.org/wiki/GRIB\" target=\"_blank\" rel=\"noopener\">GRIB</a>，nc 等等，甚至一张简单的 png 也可以是由格点数据转换成的，它会包含基本的<strong>格点数量和值</strong>，比方说在经度方向有 300 个点，纬度方向有 200 个点，那么整个文件包含了 6w 个格点的数值，还通常包含一些<strong>经纬度信息</strong>，比方说每个点的经纬度值，也有可能只是四个顶点的经纬度信息，所以 raster（栅格）图层也在我的讨论范围之内。</p>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>我会以 Leaflet 为主要的实现手段，个人觉得它的灵活性比较强，功能虽然基础，但是利于拓展，所以各类图层插件也层出不穷。<br>假设我想要在地图上渲染一组格点数据，数据长 300，宽 200，一共 60000 个点，从原理上分析无非就是把一个个的点钉在了地图上，我们可以清楚的<strong>读取或者推算</strong>出每个点的经纬度，要解决的就是点与点之间的空白怎么办，毕竟每个点从经纬度上来看即使只差了 1 度，算上比例尺，在地图上也是不等的像素点，所以我们需要通过<strong>插值计算</strong>来补齐点与点之间的空白。于是我就有了大致如下的想法：</p>\n<blockquote>\n<p>准备基础数据和图例等信息 =&gt; 准备 canvas 图层 =&gt; 找到初始点 =&gt; 根据数值和图例找到对应颜色 =&gt; 渲染颜色 =&gt; 循环直至画完所有的点</p>\n</blockquote>\n<h1 id=\"开发\"><a href=\"#开发\" class=\"headerlink\" title=\"开发\"></a>开发</h1><p>按照上面的思路一步步开始，我已经准备好了一个<a href=\"https://github.com/zzcyrus/Leaflet.Tile.PixelLayer/blob/master/demo/data.json\" target=\"_blank\" rel=\"noopener\">温度相关的数据</a>和图例信息，后面也会再讨论数据的生成和优化，所以直接从第二步开始，这里只说大致的流程，具体的算法可以去看<a href=\"https://github.com/zzcyrus/Leaflet.Tile.PixelLayer/blob/master/src/index.js\" target=\"_blank\" rel=\"noopener\">源代码</a></p>\n<blockquote>\n<p>创建 TilePixelLayer 图层并继承基础的<code>TileLayer</code>，需要重写<code>createTile</code>方法，每一个 tile 最终都返回一个我们自己绘制出来的 canvas</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">L.TilePixelLayer = L.TileLayer.extend(&#123;</span><br><span class=\"line\">    createTile: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">coords</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> dom = L.DomUtil.create(<span class=\"string\">'canvas'</span>, <span class=\"string\">'leafvar-pixel-tile'</span>)</span><br><span class=\"line\">      <span class=\"keyword\">var</span> ctx = dom.getContext(<span class=\"string\">'2d'</span>)</span><br><span class=\"line\">      <span class=\"comment\">//  bounds为当前tile的一些边界信息，绘制时候要用到</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.interpolateTile(ctx,  <span class=\"string\">'bounds'</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> dom</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>我们在每一个 tile 对应的 canvas 中，从 0 点开始，分别循环 256 像素的行和列，然后通过插值得到像素对应的数值，再找到数值对应的颜色，直至完成整个 canvas 的上色过程。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">interpolateTile: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ctx, bounds</span>) </span>&#123;  <span class=\"comment\">// 逐像素绘制每一个tile</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> x = bounds.x                 <span class=\"comment\">// x坐标为当前瓦片在地图上的初始像素x</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> tileX = <span class=\"number\">0</span>                       <span class=\"comment\">// tileX为当前瓦片canvas的坐标，在0~256之间循环</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> gap = <span class=\"number\">4</span>                        <span class=\"comment\">// 每隔四个点计算一次加快渲染速度，这个数值可以自己设置</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> colorImageData = <span class=\"keyword\">new</span> ImageData(<span class=\"number\">256</span>, <span class=\"number\">256</span>)  <span class=\"comment\">// 创建一个imageData接收颜色</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 循环行</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> batchInterpolate = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (tileX &lt; bounds.w) &#123;</span><br><span class=\"line\">      interpolateColumn(x, tileX)</span><br><span class=\"line\">      x += gap</span><br><span class=\"line\">      tileX += gap</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ctx.putImageData(colorImageData, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 循环列</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> interpolateColumn = <span class=\"function\">(<span class=\"params\">x, tileX</span>) =&gt;</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (                                   <span class=\"comment\">// y坐标为当前瓦片在地图上的初始像素y</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> defaultColor = [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>], y = bounds.y, height = <span class=\"number\">0</span>;</span><br><span class=\"line\">      height &lt;= bounds.h;</span><br><span class=\"line\">      y += gap, height += gap</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 把循环到的某个点的像素坐标转化为经纬度</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> location = <span class=\"keyword\">this</span>.map.unproject(L.point(x, y), zoom)</span><br><span class=\"line\">      <span class=\"keyword\">var</span> coord = [location.lng, location.lat]</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 找到经纬度对应的周围四个点的坐标，通过双线性插值算出一个近似值作为当前像素点的数值</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> gridValue = <span class=\"keyword\">this</span>.gridInterpolate(coord)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 用简单的线性插值通过图例得到数值对应的颜色</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> color = <span class=\"keyword\">this</span>.gradient(gridValue)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 因为设置了gap，gap范围内的每一个像素点都用这个颜色，如果gap设置为1，那么每个像素都独立参与了计算，性能有所慢，但是精度高</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; gap; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; gap; j++) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.setColor(colorImageData, i, j, color)  <span class=\"comment\">// 上色</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 开始绘制</span></span><br><span class=\"line\">  batchInterpolate()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>总结一下，每一个瓦片都对应了一个 canvas，每个 canvas 我们都逐像素处理，先把像素转化为经纬度，通过插值得到一个比较精确的对应格点数值，再通过图例进行了上色。最终就把所有的格点数据都渲染了出来。</p>\n</blockquote>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><p>完整的代码可以在<a href=\"https://github.com/zzcyrus/Leaflet.Tile.PixelLayer\" target=\"_blank\" rel=\"noopener\">github</a>上看到。<code>dist</code>目录下有编译好的 js 文件，在项目中引入就好。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tilePixelLayer = L.tilePixelLayer(&#123;</span><br><span class=\"line\">  data: data,</span><br><span class=\"line\">  overlayAlpha: <span class=\"number\">230</span>, <span class=\"comment\">// 透明度</span></span><br><span class=\"line\">  gradient: [</span><br><span class=\"line\">    [<span class=\"number\">233.15</span>, [<span class=\"number\">56</span>, <span class=\"number\">4</span>, <span class=\"number\">45</span>]],</span><br><span class=\"line\">    [<span class=\"number\">243.15</span>, [<span class=\"number\">48</span>, <span class=\"number\">0</span>, <span class=\"number\">106</span>]],</span><br><span class=\"line\">    [<span class=\"number\">253.15</span>, [<span class=\"number\">0</span>, <span class=\"number\">14</span>, <span class=\"number\">134</span>]],</span><br><span class=\"line\">    [<span class=\"number\">256.15</span>, [<span class=\"number\">3</span>, <span class=\"number\">44</span>, <span class=\"number\">144</span>]],</span><br><span class=\"line\">    <span class=\"comment\">// ......</span></span><br><span class=\"line\">  ], <span class=\"comment\">// 准备一组图例</span></span><br><span class=\"line\">  clickEvt: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e, gridValue</span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">`该地点温度:<span class=\"subst\">$&#123;<span class=\"built_in\">Math</span>.round(gridValue - <span class=\"number\">273.15</span>)&#125;</span>°`</span>);</span><br><span class=\"line\">  &#125;, <span class=\"comment\">// 事件</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">map.addLayer(tilePixelLayer); <span class=\"comment\">// 添加到地图上</span></span><br></pre></td></tr></table></figure>\n<p>效果：</p>\n <iframe height=\"400\" width=\"100%\" src=\"https://kael.top/Leaflet.Tile.PixelLayer/demo/\" frameborder=\"0\" allowfullscreen><br> </iframe>\n\n<p><a href=\"https://kael.top/Leaflet.Tile.PixelLayer/demo/\">在线 demo</a></p>\n<h1 id=\"后续\"><a href=\"#后续\" class=\"headerlink\" title=\"后续\"></a>后续</h1><p>这样我们已经初步在浏览器上完成了一个前端完全可控的格点数据渲染，当然对整个过程是否有更好的优化方法，我们后面会继续展开讨论。</p>\n","site":{"data":{}},"excerpt":"<p>在地理信息行业中，我们常遇见的数据中有这么两类：</p>\n<ul>\n<li>一类是站点（散点）数据。地图上分布着位置不均匀的各种站点，比方说气象站，水文站，如果我们需要查看站点数值趋势，就可以通过等值线图等方式，比如<a href=\"https://github.com/d3/d3-contour\" target=\"_blank\" rel=\"noopener\">d3 的 contour</a>，<a href=\"https://turfjs.org/docs/#isolines\" target=\"_blank\" rel=\"noopener\">turf 的 isolines</a>，还可以通过插值方法将站点插值到网格上，转化成格点数据，后面我们也会讨论。</li>\n<li>也有一类是格点数据。这个在气象上就非常常见，气象预报数据通常是模式跑出来的，如同渔网一样的格点，这种数据提供了查询任意位置数值的作用，它的渲染也同样常见，传统的方法是在服务器端生成好对应图片，在浏览器上贴图，这里追求实现的是<code>前端渲染</code>。</li>\n</ul>","more":"<p>太长不看可以直接<a href=\"https://github.com/zzcyrus/Leaflet.Tile.PixelLayer\" target=\"_blank\" rel=\"noopener\">项目仓库</a></p>\n<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>格点数据的特点往往是数据量大，蕴含的信息量大，不仅包含着某个点的数值，同时还有这个点的经纬度，时间维度信息，空间高度信息，所以我们通常会听见学气象的同学说某个数据有四个维度。随着计算机的发展，图形学的发展，想要全部展示这些时空数据变得越来越可能，我会在这个系列中逐步的提出一些我的探索，希望能给大家带来帮助。</p>\n<p>格点数据有很多格式，我们可能常接触到的一些格点数据文件比方说<a href=\"https://en.wikipedia.org/wiki/GeoTIFF\" target=\"_blank\" rel=\"noopener\">GeoTIFF</a>，气象里面有<a href=\"https://en.wikipedia.org/wiki/GRIB\" target=\"_blank\" rel=\"noopener\">GRIB</a>，nc 等等，甚至一张简单的 png 也可以是由格点数据转换成的，它会包含基本的<strong>格点数量和值</strong>，比方说在经度方向有 300 个点，纬度方向有 200 个点，那么整个文件包含了 6w 个格点的数值，还通常包含一些<strong>经纬度信息</strong>，比方说每个点的经纬度值，也有可能只是四个顶点的经纬度信息，所以 raster（栅格）图层也在我的讨论范围之内。</p>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>我会以 Leaflet 为主要的实现手段，个人觉得它的灵活性比较强，功能虽然基础，但是利于拓展，所以各类图层插件也层出不穷。<br>假设我想要在地图上渲染一组格点数据，数据长 300，宽 200，一共 60000 个点，从原理上分析无非就是把一个个的点钉在了地图上，我们可以清楚的<strong>读取或者推算</strong>出每个点的经纬度，要解决的就是点与点之间的空白怎么办，毕竟每个点从经纬度上来看即使只差了 1 度，算上比例尺，在地图上也是不等的像素点，所以我们需要通过<strong>插值计算</strong>来补齐点与点之间的空白。于是我就有了大致如下的想法：</p>\n<blockquote>\n<p>准备基础数据和图例等信息 =&gt; 准备 canvas 图层 =&gt; 找到初始点 =&gt; 根据数值和图例找到对应颜色 =&gt; 渲染颜色 =&gt; 循环直至画完所有的点</p>\n</blockquote>\n<h1 id=\"开发\"><a href=\"#开发\" class=\"headerlink\" title=\"开发\"></a>开发</h1><p>按照上面的思路一步步开始，我已经准备好了一个<a href=\"https://github.com/zzcyrus/Leaflet.Tile.PixelLayer/blob/master/demo/data.json\" target=\"_blank\" rel=\"noopener\">温度相关的数据</a>和图例信息，后面也会再讨论数据的生成和优化，所以直接从第二步开始，这里只说大致的流程，具体的算法可以去看<a href=\"https://github.com/zzcyrus/Leaflet.Tile.PixelLayer/blob/master/src/index.js\" target=\"_blank\" rel=\"noopener\">源代码</a></p>\n<blockquote>\n<p>创建 TilePixelLayer 图层并继承基础的<code>TileLayer</code>，需要重写<code>createTile</code>方法，每一个 tile 最终都返回一个我们自己绘制出来的 canvas</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">L.TilePixelLayer = L.TileLayer.extend(&#123;</span><br><span class=\"line\">    createTile: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">coords</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> dom = L.DomUtil.create(<span class=\"string\">'canvas'</span>, <span class=\"string\">'leafvar-pixel-tile'</span>)</span><br><span class=\"line\">      <span class=\"keyword\">var</span> ctx = dom.getContext(<span class=\"string\">'2d'</span>)</span><br><span class=\"line\">      <span class=\"comment\">//  bounds为当前tile的一些边界信息，绘制时候要用到</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.interpolateTile(ctx,  <span class=\"string\">'bounds'</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> dom</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>我们在每一个 tile 对应的 canvas 中，从 0 点开始，分别循环 256 像素的行和列，然后通过插值得到像素对应的数值，再找到数值对应的颜色，直至完成整个 canvas 的上色过程。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">interpolateTile: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ctx, bounds</span>) </span>&#123;  <span class=\"comment\">// 逐像素绘制每一个tile</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> x = bounds.x                 <span class=\"comment\">// x坐标为当前瓦片在地图上的初始像素x</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> tileX = <span class=\"number\">0</span>                       <span class=\"comment\">// tileX为当前瓦片canvas的坐标，在0~256之间循环</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> gap = <span class=\"number\">4</span>                        <span class=\"comment\">// 每隔四个点计算一次加快渲染速度，这个数值可以自己设置</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> colorImageData = <span class=\"keyword\">new</span> ImageData(<span class=\"number\">256</span>, <span class=\"number\">256</span>)  <span class=\"comment\">// 创建一个imageData接收颜色</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 循环行</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> batchInterpolate = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (tileX &lt; bounds.w) &#123;</span><br><span class=\"line\">      interpolateColumn(x, tileX)</span><br><span class=\"line\">      x += gap</span><br><span class=\"line\">      tileX += gap</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ctx.putImageData(colorImageData, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 循环列</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> interpolateColumn = <span class=\"function\">(<span class=\"params\">x, tileX</span>) =&gt;</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (                                   <span class=\"comment\">// y坐标为当前瓦片在地图上的初始像素y</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> defaultColor = [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>], y = bounds.y, height = <span class=\"number\">0</span>;</span><br><span class=\"line\">      height &lt;= bounds.h;</span><br><span class=\"line\">      y += gap, height += gap</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 把循环到的某个点的像素坐标转化为经纬度</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> location = <span class=\"keyword\">this</span>.map.unproject(L.point(x, y), zoom)</span><br><span class=\"line\">      <span class=\"keyword\">var</span> coord = [location.lng, location.lat]</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 找到经纬度对应的周围四个点的坐标，通过双线性插值算出一个近似值作为当前像素点的数值</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> gridValue = <span class=\"keyword\">this</span>.gridInterpolate(coord)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 用简单的线性插值通过图例得到数值对应的颜色</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> color = <span class=\"keyword\">this</span>.gradient(gridValue)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 因为设置了gap，gap范围内的每一个像素点都用这个颜色，如果gap设置为1，那么每个像素都独立参与了计算，性能有所慢，但是精度高</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; gap; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; gap; j++) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.setColor(colorImageData, i, j, color)  <span class=\"comment\">// 上色</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 开始绘制</span></span><br><span class=\"line\">  batchInterpolate()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>总结一下，每一个瓦片都对应了一个 canvas，每个 canvas 我们都逐像素处理，先把像素转化为经纬度，通过插值得到一个比较精确的对应格点数值，再通过图例进行了上色。最终就把所有的格点数据都渲染了出来。</p>\n</blockquote>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><p>完整的代码可以在<a href=\"https://github.com/zzcyrus/Leaflet.Tile.PixelLayer\" target=\"_blank\" rel=\"noopener\">github</a>上看到。<code>dist</code>目录下有编译好的 js 文件，在项目中引入就好。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tilePixelLayer = L.tilePixelLayer(&#123;</span><br><span class=\"line\">  data: data,</span><br><span class=\"line\">  overlayAlpha: <span class=\"number\">230</span>, <span class=\"comment\">// 透明度</span></span><br><span class=\"line\">  gradient: [</span><br><span class=\"line\">    [<span class=\"number\">233.15</span>, [<span class=\"number\">56</span>, <span class=\"number\">4</span>, <span class=\"number\">45</span>]],</span><br><span class=\"line\">    [<span class=\"number\">243.15</span>, [<span class=\"number\">48</span>, <span class=\"number\">0</span>, <span class=\"number\">106</span>]],</span><br><span class=\"line\">    [<span class=\"number\">253.15</span>, [<span class=\"number\">0</span>, <span class=\"number\">14</span>, <span class=\"number\">134</span>]],</span><br><span class=\"line\">    [<span class=\"number\">256.15</span>, [<span class=\"number\">3</span>, <span class=\"number\">44</span>, <span class=\"number\">144</span>]],</span><br><span class=\"line\">    <span class=\"comment\">// ......</span></span><br><span class=\"line\">  ], <span class=\"comment\">// 准备一组图例</span></span><br><span class=\"line\">  clickEvt: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e, gridValue</span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">`该地点温度:<span class=\"subst\">$&#123;<span class=\"built_in\">Math</span>.round(gridValue - <span class=\"number\">273.15</span>)&#125;</span>°`</span>);</span><br><span class=\"line\">  &#125;, <span class=\"comment\">// 事件</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">map.addLayer(tilePixelLayer); <span class=\"comment\">// 添加到地图上</span></span><br></pre></td></tr></table></figure>\n<p>效果：</p>\n <iframe height=\"400\" width=\"100%\" src=\"https://kael.top/Leaflet.Tile.PixelLayer/demo/\" frameborder=\"0\" allowfullscreen><br> </iframe>\n\n<p><a href=\"https://kael.top/Leaflet.Tile.PixelLayer/demo/\">在线 demo</a></p>\n<h1 id=\"后续\"><a href=\"#后续\" class=\"headerlink\" title=\"后续\"></a>后续</h1><p>这样我们已经初步在浏览器上完成了一个前端完全可控的格点数据渲染，当然对整个过程是否有更好的优化方法，我们后面会继续展开讨论。</p>"},{"title":"制作openstreetmap-carto风格离线瓦片地图","date":"2019-06-06T07:13:27.000Z","_content":"\n[openstreetmap-carto](https://github.com/gravitystorm/openstreetmap-carto)是[openstreetmap](https://www.openstreetmap.org)的默认地图风格，广受好评，各方面均衡，是离线地图的常用选择。\n\n<!-- more -->\n\n搭建的主要步骤基本围绕[使用 osm 数据做一个自己的 PostGIS 数据库](https://kael.top/2019/03/12/osm-PostGIS-setup/)这篇文章展开。\n\n我们完成**1、2、3**步骤后，再导入 osm 数据前要做一些修改\n\n# 4. 依据 openstreetmap-carto 样式导入数据\n\n仍然是安装好 osm2pgsql 工具，下载好中国区 pbf 数据，之后我们要准备样式包\n\n```bash\n# 下载openstreetmap-carto相关数据文件\ngit clone https://github.com/gravitystorm/openstreetmap-carto.git\n\n# 导入数据，手动指定carto样式文件\nosm2pgsql -c -d china -G --slim --hstore --style /home/openstreetmap-carto/openstreetmap-carto.style --tag-transform-script /home/openstreetmap-carto/openstreetmap-carto.lua -C 2000 -p china -r pbf /home/CN\n```\n\n# 5. 执行各种脚本\n\n进入 clone 下来的`openstreetmap-carto`文件夹\n\n## 5.1 索引\n\n首先是建立数据库索引，可以加快渲染访问的速度，这步是**可选**的\n\n```bash\npsql -d gis -f indexes.sql\n```\n\n## 5.2 下载 shapefile\n\n样式中用到了海岸线、水域等 shp 文件，需要手动下载，文件较大，`openstreetmap-carto`已经提供了下载脚本\n\n```bash\nscripts/get-shapefiles.py\n```\n\n如果下载出错，加上`-s`关闭 shapeindex\n\n```bash\nscripts/get-shapefiles.py -s\n```\n\n如果实在网络不行，可以根据[安装指南](https://github.com/gravitystorm/openstreetmap-carto/blob/master/INSTALL.md#manual-download)中说明手动下载这些文件，放在`openstreetmap-carto/data`目录下就好\n\n## 5.3 下载字体\n\n如果是用了 Ubuntu/Debian 服务器，可以直接安装\n\n```bash\nsudo apt-get install fonts-noto-cjk fonts-noto-hinted fonts-noto-unhinted fonts-hanazono ttf-unifont\n```\n\n其他系统也可以[手动下载字体文件并安装](https://github.com/gravitystorm/openstreetmap-carto/blob/master/INSTALL.md#installation-on-other-operation-systems)\n\n# 6. 渲染\n\n准备好`nodejs`环境，渲染工具使用 tilestrata 这个服务端工具，配合 tilestrata-mapnik 插件就可以生成供地图调用的瓦片。\n\n具体的 demo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n对应的文章可以看一下这篇[tilestrata-mapnik 使用](https://kael.top/2019/06/11/tilestrata-mapnik/)\n\n## 6.1 准备 mapnik 配置文件\n\n因为使用了 mapnik，要将`openstreetmap-carto`的[project.mml](https://github.com/gravitystorm/openstreetmap-carto/blob/master/project.mml)转换成 mapnik 可识别的 xml 文件\n\n打开文件夹下面的`project.mml`文件，找到如下字段，修改成你数据库的相关配置信息\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/carto_project_mml.png)\n\n安装`carto`工具包进行转换\n\n```\nsudo npm install -g carto\ncarto project.mml > osm.xml\n```\n\n## 6.2 准备服务端\n\nclone 项目[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)，将项目里面`/src/mapnik/`目录下[index.js](https://github.com/zzcyrus/tilestrata-sample-code/blob/master/src/mapnik/index.js)增加以下内容\n\n```\nserver\n  .layer('osm')\n  .route('tile.png')\n  .use(\n    mapnik({\n      pathname: 'style/osm.xml'\n    })\n  )\n```\n\n将`openstreetmap-carto`文件夹下面的`data，symbols，osm.xml（刚生成的）`三个文件（夹）拷贝到`tilestrata-sample-code`的`style`文件夹下，拷贝完成的目录结构如下所示：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/osm_mapnik_folder.png)\n\n安装相关依赖并启动项目\n\n```\nnpm install\nnpm start\n```\n\n将`/example/mapnik.html`文件里的 tileLayer 地址换成`\"http://127.0.0.1:9527/osm/{z}/{x}/{y}/tile.png\",`，打开文件即可看到效果\n\n# 7 对比结果\n\n官网\n![官网效果](http://blog-img-1255388623.cossh.myqcloud.com/osm.png)\n\n我们自己生成的\n![](http://blog-img-1255388623.cossh.myqcloud.com/osm_mapnik.png)\n","source":"_posts/2019/openstreetmap-carto-map.md","raw":"---\ntitle: 制作openstreetmap-carto风格离线瓦片地图\ndate: 2019-06-06 15:13:27\ntags: [GIS]\ncategories: PostGIS\n---\n\n[openstreetmap-carto](https://github.com/gravitystorm/openstreetmap-carto)是[openstreetmap](https://www.openstreetmap.org)的默认地图风格，广受好评，各方面均衡，是离线地图的常用选择。\n\n<!-- more -->\n\n搭建的主要步骤基本围绕[使用 osm 数据做一个自己的 PostGIS 数据库](https://kael.top/2019/03/12/osm-PostGIS-setup/)这篇文章展开。\n\n我们完成**1、2、3**步骤后，再导入 osm 数据前要做一些修改\n\n# 4. 依据 openstreetmap-carto 样式导入数据\n\n仍然是安装好 osm2pgsql 工具，下载好中国区 pbf 数据，之后我们要准备样式包\n\n```bash\n# 下载openstreetmap-carto相关数据文件\ngit clone https://github.com/gravitystorm/openstreetmap-carto.git\n\n# 导入数据，手动指定carto样式文件\nosm2pgsql -c -d china -G --slim --hstore --style /home/openstreetmap-carto/openstreetmap-carto.style --tag-transform-script /home/openstreetmap-carto/openstreetmap-carto.lua -C 2000 -p china -r pbf /home/CN\n```\n\n# 5. 执行各种脚本\n\n进入 clone 下来的`openstreetmap-carto`文件夹\n\n## 5.1 索引\n\n首先是建立数据库索引，可以加快渲染访问的速度，这步是**可选**的\n\n```bash\npsql -d gis -f indexes.sql\n```\n\n## 5.2 下载 shapefile\n\n样式中用到了海岸线、水域等 shp 文件，需要手动下载，文件较大，`openstreetmap-carto`已经提供了下载脚本\n\n```bash\nscripts/get-shapefiles.py\n```\n\n如果下载出错，加上`-s`关闭 shapeindex\n\n```bash\nscripts/get-shapefiles.py -s\n```\n\n如果实在网络不行，可以根据[安装指南](https://github.com/gravitystorm/openstreetmap-carto/blob/master/INSTALL.md#manual-download)中说明手动下载这些文件，放在`openstreetmap-carto/data`目录下就好\n\n## 5.3 下载字体\n\n如果是用了 Ubuntu/Debian 服务器，可以直接安装\n\n```bash\nsudo apt-get install fonts-noto-cjk fonts-noto-hinted fonts-noto-unhinted fonts-hanazono ttf-unifont\n```\n\n其他系统也可以[手动下载字体文件并安装](https://github.com/gravitystorm/openstreetmap-carto/blob/master/INSTALL.md#installation-on-other-operation-systems)\n\n# 6. 渲染\n\n准备好`nodejs`环境，渲染工具使用 tilestrata 这个服务端工具，配合 tilestrata-mapnik 插件就可以生成供地图调用的瓦片。\n\n具体的 demo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n对应的文章可以看一下这篇[tilestrata-mapnik 使用](https://kael.top/2019/06/11/tilestrata-mapnik/)\n\n## 6.1 准备 mapnik 配置文件\n\n因为使用了 mapnik，要将`openstreetmap-carto`的[project.mml](https://github.com/gravitystorm/openstreetmap-carto/blob/master/project.mml)转换成 mapnik 可识别的 xml 文件\n\n打开文件夹下面的`project.mml`文件，找到如下字段，修改成你数据库的相关配置信息\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/carto_project_mml.png)\n\n安装`carto`工具包进行转换\n\n```\nsudo npm install -g carto\ncarto project.mml > osm.xml\n```\n\n## 6.2 准备服务端\n\nclone 项目[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)，将项目里面`/src/mapnik/`目录下[index.js](https://github.com/zzcyrus/tilestrata-sample-code/blob/master/src/mapnik/index.js)增加以下内容\n\n```\nserver\n  .layer('osm')\n  .route('tile.png')\n  .use(\n    mapnik({\n      pathname: 'style/osm.xml'\n    })\n  )\n```\n\n将`openstreetmap-carto`文件夹下面的`data，symbols，osm.xml（刚生成的）`三个文件（夹）拷贝到`tilestrata-sample-code`的`style`文件夹下，拷贝完成的目录结构如下所示：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/osm_mapnik_folder.png)\n\n安装相关依赖并启动项目\n\n```\nnpm install\nnpm start\n```\n\n将`/example/mapnik.html`文件里的 tileLayer 地址换成`\"http://127.0.0.1:9527/osm/{z}/{x}/{y}/tile.png\",`，打开文件即可看到效果\n\n# 7 对比结果\n\n官网\n![官网效果](http://blog-img-1255388623.cossh.myqcloud.com/osm.png)\n\n我们自己生成的\n![](http://blog-img-1255388623.cossh.myqcloud.com/osm_mapnik.png)\n","slug":"openstreetmap-carto-map","published":1,"updated":"2019-12-22T14:30:53.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrkxgsz000ai83iilxncjoa","content":"<p><a href=\"https://github.com/gravitystorm/openstreetmap-carto\" target=\"_blank\" rel=\"noopener\">openstreetmap-carto</a>是<a href=\"https://www.openstreetmap.org\" target=\"_blank\" rel=\"noopener\">openstreetmap</a>的默认地图风格，广受好评，各方面均衡，是离线地图的常用选择。</p>\n<a id=\"more\"></a>\n<p>搭建的主要步骤基本围绕<a href=\"https://kael.top/2019/03/12/osm-PostGIS-setup/\">使用 osm 数据做一个自己的 PostGIS 数据库</a>这篇文章展开。</p>\n<p>我们完成<strong>1、2、3</strong>步骤后，再导入 osm 数据前要做一些修改</p>\n<h1 id=\"4-依据-openstreetmap-carto-样式导入数据\"><a href=\"#4-依据-openstreetmap-carto-样式导入数据\" class=\"headerlink\" title=\"4. 依据 openstreetmap-carto 样式导入数据\"></a>4. 依据 openstreetmap-carto 样式导入数据</h1><p>仍然是安装好 osm2pgsql 工具，下载好中国区 pbf 数据，之后我们要准备样式包</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载openstreetmap-carto相关数据文件</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/gravitystorm/openstreetmap-carto.git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 导入数据，手动指定carto样式文件</span></span><br><span class=\"line\">osm2pgsql -c -d china -G --slim --hstore --style /home/openstreetmap-carto/openstreetmap-carto.style --tag-transform-script /home/openstreetmap-carto/openstreetmap-carto.lua -C 2000 -p china -r pbf /home/CN</span><br></pre></td></tr></table></figure>\n<h1 id=\"5-执行各种脚本\"><a href=\"#5-执行各种脚本\" class=\"headerlink\" title=\"5. 执行各种脚本\"></a>5. 执行各种脚本</h1><p>进入 clone 下来的<code>openstreetmap-carto</code>文件夹</p>\n<h2 id=\"5-1-索引\"><a href=\"#5-1-索引\" class=\"headerlink\" title=\"5.1 索引\"></a>5.1 索引</h2><p>首先是建立数据库索引，可以加快渲染访问的速度，这步是<strong>可选</strong>的</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">psql -d gis -f indexes.sql</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-2-下载-shapefile\"><a href=\"#5-2-下载-shapefile\" class=\"headerlink\" title=\"5.2 下载 shapefile\"></a>5.2 下载 shapefile</h2><p>样式中用到了海岸线、水域等 shp 文件，需要手动下载，文件较大，<code>openstreetmap-carto</code>已经提供了下载脚本</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">scripts/get-shapefiles.py</span><br></pre></td></tr></table></figure>\n<p>如果下载出错，加上<code>-s</code>关闭 shapeindex</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">scripts/get-shapefiles.py -s</span><br></pre></td></tr></table></figure>\n<p>如果实在网络不行，可以根据<a href=\"https://github.com/gravitystorm/openstreetmap-carto/blob/master/INSTALL.md#manual-download\" target=\"_blank\" rel=\"noopener\">安装指南</a>中说明手动下载这些文件，放在<code>openstreetmap-carto/data</code>目录下就好</p>\n<h2 id=\"5-3-下载字体\"><a href=\"#5-3-下载字体\" class=\"headerlink\" title=\"5.3 下载字体\"></a>5.3 下载字体</h2><p>如果是用了 Ubuntu/Debian 服务器，可以直接安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get install fonts-noto-cjk fonts-noto-hinted fonts-noto-unhinted fonts-hanazono ttf-unifont</span><br></pre></td></tr></table></figure>\n<p>其他系统也可以<a href=\"https://github.com/gravitystorm/openstreetmap-carto/blob/master/INSTALL.md#installation-on-other-operation-systems\" target=\"_blank\" rel=\"noopener\">手动下载字体文件并安装</a></p>\n<h1 id=\"6-渲染\"><a href=\"#6-渲染\" class=\"headerlink\" title=\"6. 渲染\"></a>6. 渲染</h1><p>准备好<code>nodejs</code>环境，渲染工具使用 tilestrata 这个服务端工具，配合 tilestrata-mapnik 插件就可以生成供地图调用的瓦片。</p>\n<p>具体的 demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>对应的文章可以看一下这篇<a href=\"https://kael.top/2019/06/11/tilestrata-mapnik/\">tilestrata-mapnik 使用</a></p>\n<h2 id=\"6-1-准备-mapnik-配置文件\"><a href=\"#6-1-准备-mapnik-配置文件\" class=\"headerlink\" title=\"6.1 准备 mapnik 配置文件\"></a>6.1 准备 mapnik 配置文件</h2><p>因为使用了 mapnik，要将<code>openstreetmap-carto</code>的<a href=\"https://github.com/gravitystorm/openstreetmap-carto/blob/master/project.mml\" target=\"_blank\" rel=\"noopener\">project.mml</a>转换成 mapnik 可识别的 xml 文件</p>\n<p>打开文件夹下面的<code>project.mml</code>文件，找到如下字段，修改成你数据库的相关配置信息</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/carto_project_mml.png\" alt></p>\n<p>安装<code>carto</code>工具包进行转换</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo npm install -g carto</span><br><span class=\"line\">carto project.mml &gt; osm.xml</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-2-准备服务端\"><a href=\"#6-2-准备服务端\" class=\"headerlink\" title=\"6.2 准备服务端\"></a>6.2 准备服务端</h2><p>clone 项目<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a>，将项目里面<code>/src/mapnik/</code>目录下<a href=\"https://github.com/zzcyrus/tilestrata-sample-code/blob/master/src/mapnik/index.js\" target=\"_blank\" rel=\"noopener\">index.js</a>增加以下内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">server</span><br><span class=\"line\">  .layer(&apos;osm&apos;)</span><br><span class=\"line\">  .route(&apos;tile.png&apos;)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: &apos;style/osm.xml&apos;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br></pre></td></tr></table></figure>\n<p>将<code>openstreetmap-carto</code>文件夹下面的<code>data，symbols，osm.xml（刚生成的）</code>三个文件（夹）拷贝到<code>tilestrata-sample-code</code>的<code>style</code>文件夹下，拷贝完成的目录结构如下所示：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/osm_mapnik_folder.png\" alt></p>\n<p>安装相关依赖并启动项目</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<p>将<code>/example/mapnik.html</code>文件里的 tileLayer 地址换成<code>&quot;http://127.0.0.1:9527/osm/{z}/{x}/{y}/tile.png&quot;,</code>，打开文件即可看到效果</p>\n<h1 id=\"7-对比结果\"><a href=\"#7-对比结果\" class=\"headerlink\" title=\"7 对比结果\"></a>7 对比结果</h1><p>官网<br><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/osm.png\" alt=\"官网效果\"></p>\n<p>我们自己生成的<br><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/osm_mapnik.png\" alt></p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/gravitystorm/openstreetmap-carto\" target=\"_blank\" rel=\"noopener\">openstreetmap-carto</a>是<a href=\"https://www.openstreetmap.org\" target=\"_blank\" rel=\"noopener\">openstreetmap</a>的默认地图风格，广受好评，各方面均衡，是离线地图的常用选择。</p>","more":"<p>搭建的主要步骤基本围绕<a href=\"https://kael.top/2019/03/12/osm-PostGIS-setup/\">使用 osm 数据做一个自己的 PostGIS 数据库</a>这篇文章展开。</p>\n<p>我们完成<strong>1、2、3</strong>步骤后，再导入 osm 数据前要做一些修改</p>\n<h1 id=\"4-依据-openstreetmap-carto-样式导入数据\"><a href=\"#4-依据-openstreetmap-carto-样式导入数据\" class=\"headerlink\" title=\"4. 依据 openstreetmap-carto 样式导入数据\"></a>4. 依据 openstreetmap-carto 样式导入数据</h1><p>仍然是安装好 osm2pgsql 工具，下载好中国区 pbf 数据，之后我们要准备样式包</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载openstreetmap-carto相关数据文件</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/gravitystorm/openstreetmap-carto.git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 导入数据，手动指定carto样式文件</span></span><br><span class=\"line\">osm2pgsql -c -d china -G --slim --hstore --style /home/openstreetmap-carto/openstreetmap-carto.style --tag-transform-script /home/openstreetmap-carto/openstreetmap-carto.lua -C 2000 -p china -r pbf /home/CN</span><br></pre></td></tr></table></figure>\n<h1 id=\"5-执行各种脚本\"><a href=\"#5-执行各种脚本\" class=\"headerlink\" title=\"5. 执行各种脚本\"></a>5. 执行各种脚本</h1><p>进入 clone 下来的<code>openstreetmap-carto</code>文件夹</p>\n<h2 id=\"5-1-索引\"><a href=\"#5-1-索引\" class=\"headerlink\" title=\"5.1 索引\"></a>5.1 索引</h2><p>首先是建立数据库索引，可以加快渲染访问的速度，这步是<strong>可选</strong>的</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">psql -d gis -f indexes.sql</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-2-下载-shapefile\"><a href=\"#5-2-下载-shapefile\" class=\"headerlink\" title=\"5.2 下载 shapefile\"></a>5.2 下载 shapefile</h2><p>样式中用到了海岸线、水域等 shp 文件，需要手动下载，文件较大，<code>openstreetmap-carto</code>已经提供了下载脚本</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">scripts/get-shapefiles.py</span><br></pre></td></tr></table></figure>\n<p>如果下载出错，加上<code>-s</code>关闭 shapeindex</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">scripts/get-shapefiles.py -s</span><br></pre></td></tr></table></figure>\n<p>如果实在网络不行，可以根据<a href=\"https://github.com/gravitystorm/openstreetmap-carto/blob/master/INSTALL.md#manual-download\" target=\"_blank\" rel=\"noopener\">安装指南</a>中说明手动下载这些文件，放在<code>openstreetmap-carto/data</code>目录下就好</p>\n<h2 id=\"5-3-下载字体\"><a href=\"#5-3-下载字体\" class=\"headerlink\" title=\"5.3 下载字体\"></a>5.3 下载字体</h2><p>如果是用了 Ubuntu/Debian 服务器，可以直接安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get install fonts-noto-cjk fonts-noto-hinted fonts-noto-unhinted fonts-hanazono ttf-unifont</span><br></pre></td></tr></table></figure>\n<p>其他系统也可以<a href=\"https://github.com/gravitystorm/openstreetmap-carto/blob/master/INSTALL.md#installation-on-other-operation-systems\" target=\"_blank\" rel=\"noopener\">手动下载字体文件并安装</a></p>\n<h1 id=\"6-渲染\"><a href=\"#6-渲染\" class=\"headerlink\" title=\"6. 渲染\"></a>6. 渲染</h1><p>准备好<code>nodejs</code>环境，渲染工具使用 tilestrata 这个服务端工具，配合 tilestrata-mapnik 插件就可以生成供地图调用的瓦片。</p>\n<p>具体的 demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>对应的文章可以看一下这篇<a href=\"https://kael.top/2019/06/11/tilestrata-mapnik/\">tilestrata-mapnik 使用</a></p>\n<h2 id=\"6-1-准备-mapnik-配置文件\"><a href=\"#6-1-准备-mapnik-配置文件\" class=\"headerlink\" title=\"6.1 准备 mapnik 配置文件\"></a>6.1 准备 mapnik 配置文件</h2><p>因为使用了 mapnik，要将<code>openstreetmap-carto</code>的<a href=\"https://github.com/gravitystorm/openstreetmap-carto/blob/master/project.mml\" target=\"_blank\" rel=\"noopener\">project.mml</a>转换成 mapnik 可识别的 xml 文件</p>\n<p>打开文件夹下面的<code>project.mml</code>文件，找到如下字段，修改成你数据库的相关配置信息</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/carto_project_mml.png\" alt></p>\n<p>安装<code>carto</code>工具包进行转换</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo npm install -g carto</span><br><span class=\"line\">carto project.mml &gt; osm.xml</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-2-准备服务端\"><a href=\"#6-2-准备服务端\" class=\"headerlink\" title=\"6.2 准备服务端\"></a>6.2 准备服务端</h2><p>clone 项目<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a>，将项目里面<code>/src/mapnik/</code>目录下<a href=\"https://github.com/zzcyrus/tilestrata-sample-code/blob/master/src/mapnik/index.js\" target=\"_blank\" rel=\"noopener\">index.js</a>增加以下内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">server</span><br><span class=\"line\">  .layer(&apos;osm&apos;)</span><br><span class=\"line\">  .route(&apos;tile.png&apos;)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: &apos;style/osm.xml&apos;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br></pre></td></tr></table></figure>\n<p>将<code>openstreetmap-carto</code>文件夹下面的<code>data，symbols，osm.xml（刚生成的）</code>三个文件（夹）拷贝到<code>tilestrata-sample-code</code>的<code>style</code>文件夹下，拷贝完成的目录结构如下所示：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/osm_mapnik_folder.png\" alt></p>\n<p>安装相关依赖并启动项目</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<p>将<code>/example/mapnik.html</code>文件里的 tileLayer 地址换成<code>&quot;http://127.0.0.1:9527/osm/{z}/{x}/{y}/tile.png&quot;,</code>，打开文件即可看到效果</p>\n<h1 id=\"7-对比结果\"><a href=\"#7-对比结果\" class=\"headerlink\" title=\"7 对比结果\"></a>7 对比结果</h1><p>官网<br><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/osm.png\" alt=\"官网效果\"></p>\n<p>我们自己生成的<br><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/osm_mapnik.png\" alt></p>"},{"title":"mongoDB中地理空间查询指北","date":"2019-01-20T09:41:24.000Z","_content":"\n\n现在地理空间查询是越来越常见的一种需求，实现的方式也有很多种，相较于PostGIS，mongoDB既可以直接存储GeoJSON对象，又支持地理空间索引，可以满足高效的常见地理空间服务。\n\n<!-- more -->\n\n\n[一个可供参考的案例仓库](https://github.com/zzcyrus/mongoDB-geospatial-demos)\n\n\n## 索引方式介绍\n\n### 2d 索引\n\n[官方介绍](https://docs.mongodb.com/manual/core/2d/)\n\n2d index 通常用在2维平面上的点数据，如果你的MongoDB 版本小于2.2或者你不使用一些GeoJSON类型的数据，官方推荐你使用2d index。\n\n### 2dsphere 索引\n\n[官方介绍](https://docs.mongodb.com/manual/core/2dsphere/)\n\n2dsphere index 支持所有的mongoDB空间查询，支持类地球的球面上几何要素的查询，支持数据存储为GeoJSON或者是传统坐标。\n\n\n*所以如果你正在做一个现代化的GIS应用，建议直接采取2dsphere索引，这将会非常方便，GeoJSON格式的直接导入，配合WebGIS的直接查询或插入*\n\n\n## 查询方法介绍\n\n[官方介绍](https://docs.mongodb.com/manual/reference/operator/query-geospatial/)\n\n\n下面这个表格包含了一些个人的总结和官方的说明，具体查询的作用其实通过查询方法的名字就能猜测出来，所以不详细介绍了\n\n\n|查询方式|2d索引|sphere索引|几何类型（2d/sphere）|\n| --- | :-: | :-: | :-: | --- |\n|$near| ✅ | ✅ | 平面/球面 |\n|$nearSphere | ✅ | ✅ | 球面 |\n|$geoWithin:{$center:...}| ✅ | ⚠️ | 平面 |\n|$geoWithin:{$centerSphere:...} | ✅ | ✅ | 球面 |\n|$geoWithin:{$box:...}| ✅ | ⚠️ | 平面 |\n|$geoWithin:{$polygon:...}| ✅ | ⚠️ | 平面 |\n|$geoWithin:{$geometry:...}| ❎ | ✅ | 球面 |\n|$geoIntersects | ❎ | ✅ | 球面 |\n\n> 说明： ✅ 支持 ❎ 不支持 ⚠️ 官方文档说不支持，但测试发现可以使用\n\n\n## 使用注意事项\n\n1. 在2dsphere索引中使用$geometry去查询，如果自己构造$geometry，要注意geometry的coordinates必须是一个`闭合`的数组，首尾两项要一致。\n2. 与此同时，在使用$polygon去查询时，`不必`是一个闭合的坐标数组列，mongoDB会自动帮我们关闭这个图形\n3. 在使用$near或者$geoWithin之类的查询中会涉及到距离、半径定义，这里如果你使用经纬度作为坐标，使用m（米）作为距离、半径单位，那么要进行`转换`，具体的转换规则可以参考下面两段代码示例：\n\n\n```js\n/**\n * 1度大致对应111千米，所以需要/111000,具体可以细化\n * @param {*} meter 米\n */\nconst m2degree = (meter) => {\n  return meter / 111000\n}\n\nconst query = {\n  location: {\n    $geoWithin: {\n      $center: [[lon, lat], m2degree(radius)]\n    }\n  }\n}\n```\n\n```js\n/**\n * 米转换成弧度，需要除以地球半径，大约6378100米\n * @param {*} meter\n */\nconst m2rad = (meter) => {\n  return meter / 6378100\n}\n\nconst query = {\n  location: {\n    $nearSphere: [lon, lat],\n    $maxDistance: m2rad(maxDistance)\n  }\n}\n\n```\n\n## demo\n\n这里提供[一个可供参考的简单的案例仓库](https://github.com/zzcyrus/mongoDB-geospatial-demos)\n案例中使用了中国天气网上的749个气象站点温度数据作为数据源，分别建立两种类型的索引，对每种地理查询都做了接口化，你可以**自行运行探索**，或者为其增加一个WebGIS的界面，直接进行操作，体验一下mongoDB地理查询的快捷。\n","source":"_posts/2019/mongoDB-geospatial.md","raw":"---\ntitle: mongoDB中地理空间查询指北\ndate: 2019-01-20 17:41:24\ntags: [GIS]\ncategories: Node\n---\n\n\n现在地理空间查询是越来越常见的一种需求，实现的方式也有很多种，相较于PostGIS，mongoDB既可以直接存储GeoJSON对象，又支持地理空间索引，可以满足高效的常见地理空间服务。\n\n<!-- more -->\n\n\n[一个可供参考的案例仓库](https://github.com/zzcyrus/mongoDB-geospatial-demos)\n\n\n## 索引方式介绍\n\n### 2d 索引\n\n[官方介绍](https://docs.mongodb.com/manual/core/2d/)\n\n2d index 通常用在2维平面上的点数据，如果你的MongoDB 版本小于2.2或者你不使用一些GeoJSON类型的数据，官方推荐你使用2d index。\n\n### 2dsphere 索引\n\n[官方介绍](https://docs.mongodb.com/manual/core/2dsphere/)\n\n2dsphere index 支持所有的mongoDB空间查询，支持类地球的球面上几何要素的查询，支持数据存储为GeoJSON或者是传统坐标。\n\n\n*所以如果你正在做一个现代化的GIS应用，建议直接采取2dsphere索引，这将会非常方便，GeoJSON格式的直接导入，配合WebGIS的直接查询或插入*\n\n\n## 查询方法介绍\n\n[官方介绍](https://docs.mongodb.com/manual/reference/operator/query-geospatial/)\n\n\n下面这个表格包含了一些个人的总结和官方的说明，具体查询的作用其实通过查询方法的名字就能猜测出来，所以不详细介绍了\n\n\n|查询方式|2d索引|sphere索引|几何类型（2d/sphere）|\n| --- | :-: | :-: | :-: | --- |\n|$near| ✅ | ✅ | 平面/球面 |\n|$nearSphere | ✅ | ✅ | 球面 |\n|$geoWithin:{$center:...}| ✅ | ⚠️ | 平面 |\n|$geoWithin:{$centerSphere:...} | ✅ | ✅ | 球面 |\n|$geoWithin:{$box:...}| ✅ | ⚠️ | 平面 |\n|$geoWithin:{$polygon:...}| ✅ | ⚠️ | 平面 |\n|$geoWithin:{$geometry:...}| ❎ | ✅ | 球面 |\n|$geoIntersects | ❎ | ✅ | 球面 |\n\n> 说明： ✅ 支持 ❎ 不支持 ⚠️ 官方文档说不支持，但测试发现可以使用\n\n\n## 使用注意事项\n\n1. 在2dsphere索引中使用$geometry去查询，如果自己构造$geometry，要注意geometry的coordinates必须是一个`闭合`的数组，首尾两项要一致。\n2. 与此同时，在使用$polygon去查询时，`不必`是一个闭合的坐标数组列，mongoDB会自动帮我们关闭这个图形\n3. 在使用$near或者$geoWithin之类的查询中会涉及到距离、半径定义，这里如果你使用经纬度作为坐标，使用m（米）作为距离、半径单位，那么要进行`转换`，具体的转换规则可以参考下面两段代码示例：\n\n\n```js\n/**\n * 1度大致对应111千米，所以需要/111000,具体可以细化\n * @param {*} meter 米\n */\nconst m2degree = (meter) => {\n  return meter / 111000\n}\n\nconst query = {\n  location: {\n    $geoWithin: {\n      $center: [[lon, lat], m2degree(radius)]\n    }\n  }\n}\n```\n\n```js\n/**\n * 米转换成弧度，需要除以地球半径，大约6378100米\n * @param {*} meter\n */\nconst m2rad = (meter) => {\n  return meter / 6378100\n}\n\nconst query = {\n  location: {\n    $nearSphere: [lon, lat],\n    $maxDistance: m2rad(maxDistance)\n  }\n}\n\n```\n\n## demo\n\n这里提供[一个可供参考的简单的案例仓库](https://github.com/zzcyrus/mongoDB-geospatial-demos)\n案例中使用了中国天气网上的749个气象站点温度数据作为数据源，分别建立两种类型的索引，对每种地理查询都做了接口化，你可以**自行运行探索**，或者为其增加一个WebGIS的界面，直接进行操作，体验一下mongoDB地理查询的快捷。\n","slug":"mongoDB-geospatial","published":1,"updated":"2019-06-28T05:55:48.716Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrkxgt1000bi83ibrzw8t04","content":"<p>现在地理空间查询是越来越常见的一种需求，实现的方式也有很多种，相较于PostGIS，mongoDB既可以直接存储GeoJSON对象，又支持地理空间索引，可以满足高效的常见地理空间服务。</p>\n<a id=\"more\"></a>\n<p><a href=\"https://github.com/zzcyrus/mongoDB-geospatial-demos\" target=\"_blank\" rel=\"noopener\">一个可供参考的案例仓库</a></p>\n<h2 id=\"索引方式介绍\"><a href=\"#索引方式介绍\" class=\"headerlink\" title=\"索引方式介绍\"></a>索引方式介绍</h2><h3 id=\"2d-索引\"><a href=\"#2d-索引\" class=\"headerlink\" title=\"2d 索引\"></a>2d 索引</h3><p><a href=\"https://docs.mongodb.com/manual/core/2d/\" target=\"_blank\" rel=\"noopener\">官方介绍</a></p>\n<p>2d index 通常用在2维平面上的点数据，如果你的MongoDB 版本小于2.2或者你不使用一些GeoJSON类型的数据，官方推荐你使用2d index。</p>\n<h3 id=\"2dsphere-索引\"><a href=\"#2dsphere-索引\" class=\"headerlink\" title=\"2dsphere 索引\"></a>2dsphere 索引</h3><p><a href=\"https://docs.mongodb.com/manual/core/2dsphere/\" target=\"_blank\" rel=\"noopener\">官方介绍</a></p>\n<p>2dsphere index 支持所有的mongoDB空间查询，支持类地球的球面上几何要素的查询，支持数据存储为GeoJSON或者是传统坐标。</p>\n<p><em>所以如果你正在做一个现代化的GIS应用，建议直接采取2dsphere索引，这将会非常方便，GeoJSON格式的直接导入，配合WebGIS的直接查询或插入</em></p>\n<h2 id=\"查询方法介绍\"><a href=\"#查询方法介绍\" class=\"headerlink\" title=\"查询方法介绍\"></a>查询方法介绍</h2><p><a href=\"https://docs.mongodb.com/manual/reference/operator/query-geospatial/\" target=\"_blank\" rel=\"noopener\">官方介绍</a></p>\n<p>下面这个表格包含了一些个人的总结和官方的说明，具体查询的作用其实通过查询方法的名字就能猜测出来，所以不详细介绍了</p>\n<table>\n<thead>\n<tr>\n<th>查询方式</th>\n<th style=\"text-align:center\">2d索引</th>\n<th style=\"text-align:center\">sphere索引</th>\n<th style=\"text-align:center\">几何类型（2d/sphere）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$near</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">平面/球面</td>\n</tr>\n<tr>\n<td>$nearSphere</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">球面</td>\n</tr>\n<tr>\n<td>$geoWithin:{$center:…}</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">⚠️</td>\n<td style=\"text-align:center\">平面</td>\n</tr>\n<tr>\n<td>$geoWithin:{$centerSphere:…}</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">球面</td>\n</tr>\n<tr>\n<td>$geoWithin:{$box:…}</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">⚠️</td>\n<td style=\"text-align:center\">平面</td>\n</tr>\n<tr>\n<td>$geoWithin:{$polygon:…}</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">⚠️</td>\n<td style=\"text-align:center\">平面</td>\n</tr>\n<tr>\n<td>$geoWithin:{$geometry:…}</td>\n<td style=\"text-align:center\">❎</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">球面</td>\n</tr>\n<tr>\n<td>$geoIntersects</td>\n<td style=\"text-align:center\">❎</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">球面</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>说明： ✅ 支持 ❎ 不支持 ⚠️ 官方文档说不支持，但测试发现可以使用</p>\n</blockquote>\n<h2 id=\"使用注意事项\"><a href=\"#使用注意事项\" class=\"headerlink\" title=\"使用注意事项\"></a>使用注意事项</h2><ol>\n<li>在2dsphere索引中使用$geometry去查询，如果自己构造$geometry，要注意geometry的coordinates必须是一个<code>闭合</code>的数组，首尾两项要一致。</li>\n<li>与此同时，在使用$polygon去查询时，<code>不必</code>是一个闭合的坐标数组列，mongoDB会自动帮我们关闭这个图形</li>\n<li>在使用$near或者$geoWithin之类的查询中会涉及到距离、半径定义，这里如果你使用经纬度作为坐标，使用m（米）作为距离、半径单位，那么要进行<code>转换</code>，具体的转换规则可以参考下面两段代码示例：</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 1度大致对应111千米，所以需要/111000,具体可以细化</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> </span>meter 米</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> m2degree = <span class=\"function\">(<span class=\"params\">meter</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> meter / <span class=\"number\">111000</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> query = &#123;</span><br><span class=\"line\">  location: &#123;</span><br><span class=\"line\">    $geoWithin: &#123;</span><br><span class=\"line\">      $center: [[lon, lat], m2degree(radius)]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 米转换成弧度，需要除以地球半径，大约6378100米</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> <span class=\"variable\">meter</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> m2rad = <span class=\"function\">(<span class=\"params\">meter</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> meter / <span class=\"number\">6378100</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> query = &#123;</span><br><span class=\"line\">  location: &#123;</span><br><span class=\"line\">    $nearSphere: [lon, lat],</span><br><span class=\"line\">    $maxDistance: m2rad(maxDistance)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h2><p>这里提供<a href=\"https://github.com/zzcyrus/mongoDB-geospatial-demos\" target=\"_blank\" rel=\"noopener\">一个可供参考的简单的案例仓库</a><br>案例中使用了中国天气网上的749个气象站点温度数据作为数据源，分别建立两种类型的索引，对每种地理查询都做了接口化，你可以<strong>自行运行探索</strong>，或者为其增加一个WebGIS的界面，直接进行操作，体验一下mongoDB地理查询的快捷。</p>\n","site":{"data":{}},"excerpt":"<p>现在地理空间查询是越来越常见的一种需求，实现的方式也有很多种，相较于PostGIS，mongoDB既可以直接存储GeoJSON对象，又支持地理空间索引，可以满足高效的常见地理空间服务。</p>","more":"<p><a href=\"https://github.com/zzcyrus/mongoDB-geospatial-demos\" target=\"_blank\" rel=\"noopener\">一个可供参考的案例仓库</a></p>\n<h2 id=\"索引方式介绍\"><a href=\"#索引方式介绍\" class=\"headerlink\" title=\"索引方式介绍\"></a>索引方式介绍</h2><h3 id=\"2d-索引\"><a href=\"#2d-索引\" class=\"headerlink\" title=\"2d 索引\"></a>2d 索引</h3><p><a href=\"https://docs.mongodb.com/manual/core/2d/\" target=\"_blank\" rel=\"noopener\">官方介绍</a></p>\n<p>2d index 通常用在2维平面上的点数据，如果你的MongoDB 版本小于2.2或者你不使用一些GeoJSON类型的数据，官方推荐你使用2d index。</p>\n<h3 id=\"2dsphere-索引\"><a href=\"#2dsphere-索引\" class=\"headerlink\" title=\"2dsphere 索引\"></a>2dsphere 索引</h3><p><a href=\"https://docs.mongodb.com/manual/core/2dsphere/\" target=\"_blank\" rel=\"noopener\">官方介绍</a></p>\n<p>2dsphere index 支持所有的mongoDB空间查询，支持类地球的球面上几何要素的查询，支持数据存储为GeoJSON或者是传统坐标。</p>\n<p><em>所以如果你正在做一个现代化的GIS应用，建议直接采取2dsphere索引，这将会非常方便，GeoJSON格式的直接导入，配合WebGIS的直接查询或插入</em></p>\n<h2 id=\"查询方法介绍\"><a href=\"#查询方法介绍\" class=\"headerlink\" title=\"查询方法介绍\"></a>查询方法介绍</h2><p><a href=\"https://docs.mongodb.com/manual/reference/operator/query-geospatial/\" target=\"_blank\" rel=\"noopener\">官方介绍</a></p>\n<p>下面这个表格包含了一些个人的总结和官方的说明，具体查询的作用其实通过查询方法的名字就能猜测出来，所以不详细介绍了</p>\n<table>\n<thead>\n<tr>\n<th>查询方式</th>\n<th style=\"text-align:center\">2d索引</th>\n<th style=\"text-align:center\">sphere索引</th>\n<th style=\"text-align:center\">几何类型（2d/sphere）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$near</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">平面/球面</td>\n</tr>\n<tr>\n<td>$nearSphere</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">球面</td>\n</tr>\n<tr>\n<td>$geoWithin:{$center:…}</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">⚠️</td>\n<td style=\"text-align:center\">平面</td>\n</tr>\n<tr>\n<td>$geoWithin:{$centerSphere:…}</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">球面</td>\n</tr>\n<tr>\n<td>$geoWithin:{$box:…}</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">⚠️</td>\n<td style=\"text-align:center\">平面</td>\n</tr>\n<tr>\n<td>$geoWithin:{$polygon:…}</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">⚠️</td>\n<td style=\"text-align:center\">平面</td>\n</tr>\n<tr>\n<td>$geoWithin:{$geometry:…}</td>\n<td style=\"text-align:center\">❎</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">球面</td>\n</tr>\n<tr>\n<td>$geoIntersects</td>\n<td style=\"text-align:center\">❎</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">球面</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>说明： ✅ 支持 ❎ 不支持 ⚠️ 官方文档说不支持，但测试发现可以使用</p>\n</blockquote>\n<h2 id=\"使用注意事项\"><a href=\"#使用注意事项\" class=\"headerlink\" title=\"使用注意事项\"></a>使用注意事项</h2><ol>\n<li>在2dsphere索引中使用$geometry去查询，如果自己构造$geometry，要注意geometry的coordinates必须是一个<code>闭合</code>的数组，首尾两项要一致。</li>\n<li>与此同时，在使用$polygon去查询时，<code>不必</code>是一个闭合的坐标数组列，mongoDB会自动帮我们关闭这个图形</li>\n<li>在使用$near或者$geoWithin之类的查询中会涉及到距离、半径定义，这里如果你使用经纬度作为坐标，使用m（米）作为距离、半径单位，那么要进行<code>转换</code>，具体的转换规则可以参考下面两段代码示例：</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 1度大致对应111千米，所以需要/111000,具体可以细化</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> </span>meter 米</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> m2degree = <span class=\"function\">(<span class=\"params\">meter</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> meter / <span class=\"number\">111000</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> query = &#123;</span><br><span class=\"line\">  location: &#123;</span><br><span class=\"line\">    $geoWithin: &#123;</span><br><span class=\"line\">      $center: [[lon, lat], m2degree(radius)]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 米转换成弧度，需要除以地球半径，大约6378100米</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> <span class=\"variable\">meter</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> m2rad = <span class=\"function\">(<span class=\"params\">meter</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> meter / <span class=\"number\">6378100</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> query = &#123;</span><br><span class=\"line\">  location: &#123;</span><br><span class=\"line\">    $nearSphere: [lon, lat],</span><br><span class=\"line\">    $maxDistance: m2rad(maxDistance)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h2><p>这里提供<a href=\"https://github.com/zzcyrus/mongoDB-geospatial-demos\" target=\"_blank\" rel=\"noopener\">一个可供参考的简单的案例仓库</a><br>案例中使用了中国天气网上的749个气象站点温度数据作为数据源，分别建立两种类型的索引，对每种地理查询都做了接口化，你可以<strong>自行运行探索</strong>，或者为其增加一个WebGIS的界面，直接进行操作，体验一下mongoDB地理查询的快捷。</p>"},{"title":"Leaflet.Canvas-Marker-Layer 图层的诞生","date":"2019-11-18T08:49:18.000Z","_content":"\n之前写过一个基于 Leaflet 的标注点图层插件，[Leaflet.Canvas-Marker-Layer](https://github.com/zzcyrus/Leaflet.Canvas-Marker-Layer)，今天简单的说一下为什么需要用到它。在 Leaflet 中如果你需要渲染 marker，有两种方式：\n\n- 一种是基于 dom 的[UI-Marker](https://leafletjs.com/reference-1.6.0.html#marker)\n- 另一种是基于 canvas 的[CircleMarker](https://leafletjs.com/reference-1.6.0.html#circlemarker)。\n\n可想而知：\n\n- dom 提供了强大的自定义能力，我们可以通过 css 绘制出各种想要的效果，填充各种想要的数据内容，但问题在于 marker 过多就会导致页面特别的卡顿，当然官方也悉心的给出了许多[cluster 解决方案](https://leafletjs.com/plugins.html#clusteringdecluttering)，通过聚类或者碰撞检测，只展示一部分内容，根据缩放等级来调整展示内容的数量。\n- canvas 则提供了非常高的渲染性能，但不足的是`CircleMarker`仅仅是在地图上绘制了一个矢量图形，比如圆，矩形等，灵活性比较差，通常是通过点击事件或 popup 来展示具体的内容。\n\n# 起源\n\n那么如果我想两者兼得呢？实际上 canvas 本身的功能是很强大的，可以绘制各种图案，甚至各种颜色的文字，所以我们要做的其实就是拓展官方`CircleMarker`的功能，让它自定义程度更高，有点类似于[DivIcon](https://leafletjs.com/reference-1.6.0.html#divicon)的概念。\n\n在 github 上搜寻类似功能时候，我找到了[eJuke 的 Leaflet.Canvas-Markers](https://github.com/eJuke/Leaflet.Canvas-Markers)这个库，和我想要的功能基本类似，采用 canvas 来绘制大量的 maker，但是他只提供了图片类型的 marker，所以我们稍加改动就好。\n\n# 源码说明\n\n`ejuke`的库对于图层创建、事件处理已经比较完善，我们只要修改下`_drawMarker`方法就好：\n\n```js\n_drawMarker: function (marker, pointPos) {\n    const self = this\n\n    if (!this._imageLookup) this._imageLookup = {}\n    if (!pointPos) {\n      pointPos = self._map.latLngToContainerPoint(marker.getLatLng())\n    }\n\n    // 支持通过userDrawFunc返回layer（this）对象给用户\n    // 通过layer._context就可以画出任何自定义的marker\n    if (this.options.userDrawFunc && typeof (this.options.userDrawFunc) === 'function') {\n      const size = marker.options.icon.options.iconSize\n      this.options.userDrawFunc(this, marker, pointPos, size)\n    } else {\n      self._drawIcon(marker, pointPos)\n    }\n}\n```\n\n# 使用说明\n\n```js\n/** userDrawFunc提供的参数说明\n * @param layer      图层对象，layer._context即canvas的context\n * @param marker     当前marker上存储的信息\n * @param pointPos   当前marker的像素坐标\n * @param size       当前marker的大小\n */\n\n// 你可以简单的画一个圆\nvar layer = L.canvasMarkerLayer({\n  userDrawFunc: function (layer, marker, pointPos, size) {\n    var ctx = layer._context;\n    ctx.beginPath();\n    ctx.arc(pointPos.x, pointPos.y, size[0] / 2, 0, 2 * Math.PI);\n    ctx.fillStyle = \"rgba(255,12,0,0.4)\";\n    ctx.fill();\n    ctx.closePath();\n  },\n}).addTo(map);\n\n// 你也可以画一个矩形里面再配上文字\nconst ciLayer = L.canvasMarkerLayer({\n  userDrawFunc: function (layer, marker, pointPos, size) {\n    const ctx = layer._context;\n    const number = marker.properties.number;\n    ctx.beginPath();\n    ctx.fillStyle = \"rgba(255,0,0,0.8)\";\n    ctx.fillRect(\n      pointPos.x - size[0] / 2,\n      pointPos.y - size[1] / 2,\n      size[0],\n      size[1]\n    );\n    ctx.font = \"12px Helvetica Neue\";\n    ctx.fillStyle = \"#000\";\n    ctx.fillText(number, pointPos.x, pointPos.y + size[1] / 4);\n    ctx.textAlign = \"center\";\n    ctx.closePath();\n  },\n}).addTo(map);\n```\n\n[demo](https://kael.top/Leaflet.Canvas-Marker-Layer/example/text.html)\n\n通过这样在 canvas 上绘制大量 marker 的效果就大大改善了。\n\n[仓库](https://github.com/zzcyrus/Leaflet.Canvas-Marker-Layer)\n","source":"_posts/2019/leaflet-canvas-marker.md","raw":"---\ntitle: Leaflet.Canvas-Marker-Layer 图层的诞生\ndate: 2019-11-18 16:49:18\ntags: [GIS, Leaflet]\ncategories: WebGIS\n---\n\n之前写过一个基于 Leaflet 的标注点图层插件，[Leaflet.Canvas-Marker-Layer](https://github.com/zzcyrus/Leaflet.Canvas-Marker-Layer)，今天简单的说一下为什么需要用到它。在 Leaflet 中如果你需要渲染 marker，有两种方式：\n\n- 一种是基于 dom 的[UI-Marker](https://leafletjs.com/reference-1.6.0.html#marker)\n- 另一种是基于 canvas 的[CircleMarker](https://leafletjs.com/reference-1.6.0.html#circlemarker)。\n\n可想而知：\n\n- dom 提供了强大的自定义能力，我们可以通过 css 绘制出各种想要的效果，填充各种想要的数据内容，但问题在于 marker 过多就会导致页面特别的卡顿，当然官方也悉心的给出了许多[cluster 解决方案](https://leafletjs.com/plugins.html#clusteringdecluttering)，通过聚类或者碰撞检测，只展示一部分内容，根据缩放等级来调整展示内容的数量。\n- canvas 则提供了非常高的渲染性能，但不足的是`CircleMarker`仅仅是在地图上绘制了一个矢量图形，比如圆，矩形等，灵活性比较差，通常是通过点击事件或 popup 来展示具体的内容。\n\n# 起源\n\n那么如果我想两者兼得呢？实际上 canvas 本身的功能是很强大的，可以绘制各种图案，甚至各种颜色的文字，所以我们要做的其实就是拓展官方`CircleMarker`的功能，让它自定义程度更高，有点类似于[DivIcon](https://leafletjs.com/reference-1.6.0.html#divicon)的概念。\n\n在 github 上搜寻类似功能时候，我找到了[eJuke 的 Leaflet.Canvas-Markers](https://github.com/eJuke/Leaflet.Canvas-Markers)这个库，和我想要的功能基本类似，采用 canvas 来绘制大量的 maker，但是他只提供了图片类型的 marker，所以我们稍加改动就好。\n\n# 源码说明\n\n`ejuke`的库对于图层创建、事件处理已经比较完善，我们只要修改下`_drawMarker`方法就好：\n\n```js\n_drawMarker: function (marker, pointPos) {\n    const self = this\n\n    if (!this._imageLookup) this._imageLookup = {}\n    if (!pointPos) {\n      pointPos = self._map.latLngToContainerPoint(marker.getLatLng())\n    }\n\n    // 支持通过userDrawFunc返回layer（this）对象给用户\n    // 通过layer._context就可以画出任何自定义的marker\n    if (this.options.userDrawFunc && typeof (this.options.userDrawFunc) === 'function') {\n      const size = marker.options.icon.options.iconSize\n      this.options.userDrawFunc(this, marker, pointPos, size)\n    } else {\n      self._drawIcon(marker, pointPos)\n    }\n}\n```\n\n# 使用说明\n\n```js\n/** userDrawFunc提供的参数说明\n * @param layer      图层对象，layer._context即canvas的context\n * @param marker     当前marker上存储的信息\n * @param pointPos   当前marker的像素坐标\n * @param size       当前marker的大小\n */\n\n// 你可以简单的画一个圆\nvar layer = L.canvasMarkerLayer({\n  userDrawFunc: function (layer, marker, pointPos, size) {\n    var ctx = layer._context;\n    ctx.beginPath();\n    ctx.arc(pointPos.x, pointPos.y, size[0] / 2, 0, 2 * Math.PI);\n    ctx.fillStyle = \"rgba(255,12,0,0.4)\";\n    ctx.fill();\n    ctx.closePath();\n  },\n}).addTo(map);\n\n// 你也可以画一个矩形里面再配上文字\nconst ciLayer = L.canvasMarkerLayer({\n  userDrawFunc: function (layer, marker, pointPos, size) {\n    const ctx = layer._context;\n    const number = marker.properties.number;\n    ctx.beginPath();\n    ctx.fillStyle = \"rgba(255,0,0,0.8)\";\n    ctx.fillRect(\n      pointPos.x - size[0] / 2,\n      pointPos.y - size[1] / 2,\n      size[0],\n      size[1]\n    );\n    ctx.font = \"12px Helvetica Neue\";\n    ctx.fillStyle = \"#000\";\n    ctx.fillText(number, pointPos.x, pointPos.y + size[1] / 4);\n    ctx.textAlign = \"center\";\n    ctx.closePath();\n  },\n}).addTo(map);\n```\n\n[demo](https://kael.top/Leaflet.Canvas-Marker-Layer/example/text.html)\n\n通过这样在 canvas 上绘制大量 marker 的效果就大大改善了。\n\n[仓库](https://github.com/zzcyrus/Leaflet.Canvas-Marker-Layer)\n","slug":"leaflet-canvas-marker","published":1,"updated":"2020-05-17T08:21:36.012Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrkxgt2000ci83ig9f5qp1y","content":"<p>之前写过一个基于 Leaflet 的标注点图层插件，<a href=\"https://github.com/zzcyrus/Leaflet.Canvas-Marker-Layer\" target=\"_blank\" rel=\"noopener\">Leaflet.Canvas-Marker-Layer</a>，今天简单的说一下为什么需要用到它。在 Leaflet 中如果你需要渲染 marker，有两种方式：</p>\n<ul>\n<li>一种是基于 dom 的<a href=\"https://leafletjs.com/reference-1.6.0.html#marker\" target=\"_blank\" rel=\"noopener\">UI-Marker</a></li>\n<li>另一种是基于 canvas 的<a href=\"https://leafletjs.com/reference-1.6.0.html#circlemarker\" target=\"_blank\" rel=\"noopener\">CircleMarker</a>。</li>\n</ul>\n<p>可想而知：</p>\n<ul>\n<li>dom 提供了强大的自定义能力，我们可以通过 css 绘制出各种想要的效果，填充各种想要的数据内容，但问题在于 marker 过多就会导致页面特别的卡顿，当然官方也悉心的给出了许多<a href=\"https://leafletjs.com/plugins.html#clusteringdecluttering\" target=\"_blank\" rel=\"noopener\">cluster 解决方案</a>，通过聚类或者碰撞检测，只展示一部分内容，根据缩放等级来调整展示内容的数量。</li>\n<li>canvas 则提供了非常高的渲染性能，但不足的是<code>CircleMarker</code>仅仅是在地图上绘制了一个矢量图形，比如圆，矩形等，灵活性比较差，通常是通过点击事件或 popup 来展示具体的内容。</li>\n</ul>\n<h1 id=\"起源\"><a href=\"#起源\" class=\"headerlink\" title=\"起源\"></a>起源</h1><p>那么如果我想两者兼得呢？实际上 canvas 本身的功能是很强大的，可以绘制各种图案，甚至各种颜色的文字，所以我们要做的其实就是拓展官方<code>CircleMarker</code>的功能，让它自定义程度更高，有点类似于<a href=\"https://leafletjs.com/reference-1.6.0.html#divicon\" target=\"_blank\" rel=\"noopener\">DivIcon</a>的概念。</p>\n<p>在 github 上搜寻类似功能时候，我找到了<a href=\"https://github.com/eJuke/Leaflet.Canvas-Markers\" target=\"_blank\" rel=\"noopener\">eJuke 的 Leaflet.Canvas-Markers</a>这个库，和我想要的功能基本类似，采用 canvas 来绘制大量的 maker，但是他只提供了图片类型的 marker，所以我们稍加改动就好。</p>\n<h1 id=\"源码说明\"><a href=\"#源码说明\" class=\"headerlink\" title=\"源码说明\"></a>源码说明</h1><p><code>ejuke</code>的库对于图层创建、事件处理已经比较完善，我们只要修改下<code>_drawMarker</code>方法就好：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">_drawMarker: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">marker, pointPos</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>._imageLookup) <span class=\"keyword\">this</span>._imageLookup = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!pointPos) &#123;</span><br><span class=\"line\">      pointPos = self._map.latLngToContainerPoint(marker.getLatLng())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 支持通过userDrawFunc返回layer（this）对象给用户</span></span><br><span class=\"line\">    <span class=\"comment\">// 通过layer._context就可以画出任何自定义的marker</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.options.userDrawFunc &amp;&amp; <span class=\"keyword\">typeof</span> (<span class=\"keyword\">this</span>.options.userDrawFunc) === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> size = marker.options.icon.options.iconSize</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.options.userDrawFunc(<span class=\"keyword\">this</span>, marker, pointPos, size)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      self._drawIcon(marker, pointPos)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"使用说明\"><a href=\"#使用说明\" class=\"headerlink\" title=\"使用说明\"></a>使用说明</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** userDrawFunc提供的参数说明</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>layer      图层对象，layer._context即canvas的context</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>marker     当前marker上存储的信息</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>pointPos   当前marker的像素坐标</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>size       当前marker的大小</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 你可以简单的画一个圆</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> layer = L.canvasMarkerLayer(&#123;</span><br><span class=\"line\">  userDrawFunc: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">layer, marker, pointPos, size</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ctx = layer._context;</span><br><span class=\"line\">    ctx.beginPath();</span><br><span class=\"line\">    ctx.arc(pointPos.x, pointPos.y, size[<span class=\"number\">0</span>] / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span> * <span class=\"built_in\">Math</span>.PI);</span><br><span class=\"line\">    ctx.fillStyle = <span class=\"string\">\"rgba(255,12,0,0.4)\"</span>;</span><br><span class=\"line\">    ctx.fill();</span><br><span class=\"line\">    ctx.closePath();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;).addTo(map);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 你也可以画一个矩形里面再配上文字</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> ciLayer = L.canvasMarkerLayer(&#123;</span><br><span class=\"line\">  userDrawFunc: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">layer, marker, pointPos, size</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> ctx = layer._context;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> number = marker.properties.number;</span><br><span class=\"line\">    ctx.beginPath();</span><br><span class=\"line\">    ctx.fillStyle = <span class=\"string\">\"rgba(255,0,0,0.8)\"</span>;</span><br><span class=\"line\">    ctx.fillRect(</span><br><span class=\"line\">      pointPos.x - size[<span class=\"number\">0</span>] / <span class=\"number\">2</span>,</span><br><span class=\"line\">      pointPos.y - size[<span class=\"number\">1</span>] / <span class=\"number\">2</span>,</span><br><span class=\"line\">      size[<span class=\"number\">0</span>],</span><br><span class=\"line\">      size[<span class=\"number\">1</span>]</span><br><span class=\"line\">    );</span><br><span class=\"line\">    ctx.font = <span class=\"string\">\"12px Helvetica Neue\"</span>;</span><br><span class=\"line\">    ctx.fillStyle = <span class=\"string\">\"#000\"</span>;</span><br><span class=\"line\">    ctx.fillText(number, pointPos.x, pointPos.y + size[<span class=\"number\">1</span>] / <span class=\"number\">4</span>);</span><br><span class=\"line\">    ctx.textAlign = <span class=\"string\">\"center\"</span>;</span><br><span class=\"line\">    ctx.closePath();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;).addTo(map);</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://kael.top/Leaflet.Canvas-Marker-Layer/example/text.html\">demo</a></p>\n<p>通过这样在 canvas 上绘制大量 marker 的效果就大大改善了。</p>\n<p><a href=\"https://github.com/zzcyrus/Leaflet.Canvas-Marker-Layer\" target=\"_blank\" rel=\"noopener\">仓库</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>之前写过一个基于 Leaflet 的标注点图层插件，<a href=\"https://github.com/zzcyrus/Leaflet.Canvas-Marker-Layer\" target=\"_blank\" rel=\"noopener\">Leaflet.Canvas-Marker-Layer</a>，今天简单的说一下为什么需要用到它。在 Leaflet 中如果你需要渲染 marker，有两种方式：</p>\n<ul>\n<li>一种是基于 dom 的<a href=\"https://leafletjs.com/reference-1.6.0.html#marker\" target=\"_blank\" rel=\"noopener\">UI-Marker</a></li>\n<li>另一种是基于 canvas 的<a href=\"https://leafletjs.com/reference-1.6.0.html#circlemarker\" target=\"_blank\" rel=\"noopener\">CircleMarker</a>。</li>\n</ul>\n<p>可想而知：</p>\n<ul>\n<li>dom 提供了强大的自定义能力，我们可以通过 css 绘制出各种想要的效果，填充各种想要的数据内容，但问题在于 marker 过多就会导致页面特别的卡顿，当然官方也悉心的给出了许多<a href=\"https://leafletjs.com/plugins.html#clusteringdecluttering\" target=\"_blank\" rel=\"noopener\">cluster 解决方案</a>，通过聚类或者碰撞检测，只展示一部分内容，根据缩放等级来调整展示内容的数量。</li>\n<li>canvas 则提供了非常高的渲染性能，但不足的是<code>CircleMarker</code>仅仅是在地图上绘制了一个矢量图形，比如圆，矩形等，灵活性比较差，通常是通过点击事件或 popup 来展示具体的内容。</li>\n</ul>\n<h1 id=\"起源\"><a href=\"#起源\" class=\"headerlink\" title=\"起源\"></a>起源</h1><p>那么如果我想两者兼得呢？实际上 canvas 本身的功能是很强大的，可以绘制各种图案，甚至各种颜色的文字，所以我们要做的其实就是拓展官方<code>CircleMarker</code>的功能，让它自定义程度更高，有点类似于<a href=\"https://leafletjs.com/reference-1.6.0.html#divicon\" target=\"_blank\" rel=\"noopener\">DivIcon</a>的概念。</p>\n<p>在 github 上搜寻类似功能时候，我找到了<a href=\"https://github.com/eJuke/Leaflet.Canvas-Markers\" target=\"_blank\" rel=\"noopener\">eJuke 的 Leaflet.Canvas-Markers</a>这个库，和我想要的功能基本类似，采用 canvas 来绘制大量的 maker，但是他只提供了图片类型的 marker，所以我们稍加改动就好。</p>\n<h1 id=\"源码说明\"><a href=\"#源码说明\" class=\"headerlink\" title=\"源码说明\"></a>源码说明</h1><p><code>ejuke</code>的库对于图层创建、事件处理已经比较完善，我们只要修改下<code>_drawMarker</code>方法就好：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">_drawMarker: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">marker, pointPos</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>._imageLookup) <span class=\"keyword\">this</span>._imageLookup = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!pointPos) &#123;</span><br><span class=\"line\">      pointPos = self._map.latLngToContainerPoint(marker.getLatLng())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 支持通过userDrawFunc返回layer（this）对象给用户</span></span><br><span class=\"line\">    <span class=\"comment\">// 通过layer._context就可以画出任何自定义的marker</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.options.userDrawFunc &amp;&amp; <span class=\"keyword\">typeof</span> (<span class=\"keyword\">this</span>.options.userDrawFunc) === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> size = marker.options.icon.options.iconSize</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.options.userDrawFunc(<span class=\"keyword\">this</span>, marker, pointPos, size)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      self._drawIcon(marker, pointPos)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"使用说明\"><a href=\"#使用说明\" class=\"headerlink\" title=\"使用说明\"></a>使用说明</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** userDrawFunc提供的参数说明</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>layer      图层对象，layer._context即canvas的context</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>marker     当前marker上存储的信息</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>pointPos   当前marker的像素坐标</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>size       当前marker的大小</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 你可以简单的画一个圆</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> layer = L.canvasMarkerLayer(&#123;</span><br><span class=\"line\">  userDrawFunc: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">layer, marker, pointPos, size</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ctx = layer._context;</span><br><span class=\"line\">    ctx.beginPath();</span><br><span class=\"line\">    ctx.arc(pointPos.x, pointPos.y, size[<span class=\"number\">0</span>] / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span> * <span class=\"built_in\">Math</span>.PI);</span><br><span class=\"line\">    ctx.fillStyle = <span class=\"string\">\"rgba(255,12,0,0.4)\"</span>;</span><br><span class=\"line\">    ctx.fill();</span><br><span class=\"line\">    ctx.closePath();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;).addTo(map);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 你也可以画一个矩形里面再配上文字</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> ciLayer = L.canvasMarkerLayer(&#123;</span><br><span class=\"line\">  userDrawFunc: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">layer, marker, pointPos, size</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> ctx = layer._context;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> number = marker.properties.number;</span><br><span class=\"line\">    ctx.beginPath();</span><br><span class=\"line\">    ctx.fillStyle = <span class=\"string\">\"rgba(255,0,0,0.8)\"</span>;</span><br><span class=\"line\">    ctx.fillRect(</span><br><span class=\"line\">      pointPos.x - size[<span class=\"number\">0</span>] / <span class=\"number\">2</span>,</span><br><span class=\"line\">      pointPos.y - size[<span class=\"number\">1</span>] / <span class=\"number\">2</span>,</span><br><span class=\"line\">      size[<span class=\"number\">0</span>],</span><br><span class=\"line\">      size[<span class=\"number\">1</span>]</span><br><span class=\"line\">    );</span><br><span class=\"line\">    ctx.font = <span class=\"string\">\"12px Helvetica Neue\"</span>;</span><br><span class=\"line\">    ctx.fillStyle = <span class=\"string\">\"#000\"</span>;</span><br><span class=\"line\">    ctx.fillText(number, pointPos.x, pointPos.y + size[<span class=\"number\">1</span>] / <span class=\"number\">4</span>);</span><br><span class=\"line\">    ctx.textAlign = <span class=\"string\">\"center\"</span>;</span><br><span class=\"line\">    ctx.closePath();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;).addTo(map);</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://kael.top/Leaflet.Canvas-Marker-Layer/example/text.html\">demo</a></p>\n<p>通过这样在 canvas 上绘制大量 marker 的效果就大大改善了。</p>\n<p><a href=\"https://github.com/zzcyrus/Leaflet.Canvas-Marker-Layer\" target=\"_blank\" rel=\"noopener\">仓库</a></p>\n"},{"title":"使用osm数据做一个自己的PostGIS数据库","date":"2019-03-12T11:54:08.000Z","_content":"\nPostGIS 是目前开源方案里面使用广泛的一种地理信息数据库，可玩性很强，实用性也很强，为了实现更多的地理信息操作，我们先来搭建一个简单的 PostGIS 数据库。\n\n<!-- more -->\n\n# 1. 安装步骤\n\n1. 准备一个 CentOS 7.x x64 环境\n2. 安装数据库 PostgreSQL 9.6\n3. 安装对应版本的 PostGIS 2.2.2\n4. 导入 openstreetmap 的中国区域数据\n\n# 2. PostgreSQL 9.6\n\n```bash\n# 安装数据库\nyum install https://download.postgresql.org/pub/repos/yum/9.6/redhat/rhel-7-x86_64/pgdg-centos96-9.6-3.noarch.rpm\n\nyum install postgresql96\n\nyum install postgresql96-server\n\n# 初始化数据库及服务\n/usr/pgsql-9.6/bin/postgresql96-setup initdb\nsystemctl enable postgresql-9.6\nsystemctl start postgresql-9.6\n\n# 配置环境变量\nexport PATH=/usr/pgsql-9.6/bin:$PATH\nexport LD_LIBRARY_PATH=/usr/pgsql-9.6/lib:$LD_LIBRARY_PATH\nexport PGDATA=/home/postgres/postgresql_data\n\n\n# 以下可选\n\n# 为数据库设置密码\nsu - postgres\npsql\npostgres=# ALTER USER postgres WITH PASSWORD 'postgres';\npostgres=# \\q\n\n# 开放防火墙端口\nfirewall-cmd --permanent --add-port=5432/tcp\nfirewall-cmd --reload\n\n# 修改配置文件允许外部使用密码访问\nvim /var/lib/pgsql/9.6/data/postgresql.conf\nlisten_addresses = 'localhost'  为  listen_addresses='*'\n\nvim /var/lib/pgsql/9.6/data/pg_hba.conf\nhost    all            all      0.0.0.0/0      md5\n\n```\n\n# 3. PostGIS\n\n```bash\n# 安装PostGIS\nsudo yum -y install epel-release\nsudo yum install postgis24_96\n\n# 初始化数据库osm\ncreatedb osm\n\npsql -h 127.0.0.1 -d osm -U postgres -f /usr/pgsql-9.6/share/contrib/postgis-2.4/postgis.sql\npsql -h 127.0.0.1 -d osm -U postgres -f /usr/pgsql-9.6/share/contrib/postgis-2.4/spatial_ref_sys.sql\npsql -d osm -c 'CREATE EXTENSION postgis; CREATE EXTENSION hstore;'\n\n# 可以基于osm创建china数据库（把osm作为一个可重复备份的库）\ncreatedb -T osm china\n\n```\n\n# 4. osm 数据导入\n\n```bash\n# 安装导入工具osm2pgsql\nyum install osm2pgsql\n\n# 下载中国区域的公开数据\nwget http://download.gisgraphy.com/openstreetmap/pbf/CN.tar.bz2\n\n# 解压数据\ntar jxvf CN.tar.bz2\n\n# 开始导入数据到china数据库\nosm2pgsql -c -d china --slim --hstore -C 2000 -p china -r pbf /home/parallels/Downloads/CN\n```\n\n#5. 测试\n\n至此，我们已经基于 osm 的数据有了一个地理信息库，我们可以通过以下 sql 做一些简单的测试\n\n```sql\nSELECT name FROM china_polygon WHERE name ~ '南京';\n```\n\n结果：\n![](polygon.png)\n\n```sql\nSELECT p1.name,p2.name,ST_Distance(p1.way,p2.way) FROM\n(SELECT * FROM china_point WHERE place='city' AND name = '南京市') p1 ,\n(SELECT * FROM china_point WHERE place='city' AND name = '北京市') p2\n```\n\n结果：\n![](distance.png)\n\n```sql\nSELECT name, ST_AsText(ST_Transform(way,4326)) FROM china_point WHERE place='city';\n```\n\n结果：\n![](point.png)\n\n当然数据库的功能不局限于此，基于此数据库我们可以做些更有趣的事情，今后我们会慢慢探讨。\n\n# 参考文档\n\n[digoal 的博客](https://github.com/digoal/blog/blob/master/201609/20160906_01.md)\n","source":"_posts/2019/osm-PostGIS-setup.md","raw":"---\ntitle: 使用osm数据做一个自己的PostGIS数据库\ndate: 2019-03-12 19:54:08\ntags: [GIS]\ncategories: PostGIS\n---\n\nPostGIS 是目前开源方案里面使用广泛的一种地理信息数据库，可玩性很强，实用性也很强，为了实现更多的地理信息操作，我们先来搭建一个简单的 PostGIS 数据库。\n\n<!-- more -->\n\n# 1. 安装步骤\n\n1. 准备一个 CentOS 7.x x64 环境\n2. 安装数据库 PostgreSQL 9.6\n3. 安装对应版本的 PostGIS 2.2.2\n4. 导入 openstreetmap 的中国区域数据\n\n# 2. PostgreSQL 9.6\n\n```bash\n# 安装数据库\nyum install https://download.postgresql.org/pub/repos/yum/9.6/redhat/rhel-7-x86_64/pgdg-centos96-9.6-3.noarch.rpm\n\nyum install postgresql96\n\nyum install postgresql96-server\n\n# 初始化数据库及服务\n/usr/pgsql-9.6/bin/postgresql96-setup initdb\nsystemctl enable postgresql-9.6\nsystemctl start postgresql-9.6\n\n# 配置环境变量\nexport PATH=/usr/pgsql-9.6/bin:$PATH\nexport LD_LIBRARY_PATH=/usr/pgsql-9.6/lib:$LD_LIBRARY_PATH\nexport PGDATA=/home/postgres/postgresql_data\n\n\n# 以下可选\n\n# 为数据库设置密码\nsu - postgres\npsql\npostgres=# ALTER USER postgres WITH PASSWORD 'postgres';\npostgres=# \\q\n\n# 开放防火墙端口\nfirewall-cmd --permanent --add-port=5432/tcp\nfirewall-cmd --reload\n\n# 修改配置文件允许外部使用密码访问\nvim /var/lib/pgsql/9.6/data/postgresql.conf\nlisten_addresses = 'localhost'  为  listen_addresses='*'\n\nvim /var/lib/pgsql/9.6/data/pg_hba.conf\nhost    all            all      0.0.0.0/0      md5\n\n```\n\n# 3. PostGIS\n\n```bash\n# 安装PostGIS\nsudo yum -y install epel-release\nsudo yum install postgis24_96\n\n# 初始化数据库osm\ncreatedb osm\n\npsql -h 127.0.0.1 -d osm -U postgres -f /usr/pgsql-9.6/share/contrib/postgis-2.4/postgis.sql\npsql -h 127.0.0.1 -d osm -U postgres -f /usr/pgsql-9.6/share/contrib/postgis-2.4/spatial_ref_sys.sql\npsql -d osm -c 'CREATE EXTENSION postgis; CREATE EXTENSION hstore;'\n\n# 可以基于osm创建china数据库（把osm作为一个可重复备份的库）\ncreatedb -T osm china\n\n```\n\n# 4. osm 数据导入\n\n```bash\n# 安装导入工具osm2pgsql\nyum install osm2pgsql\n\n# 下载中国区域的公开数据\nwget http://download.gisgraphy.com/openstreetmap/pbf/CN.tar.bz2\n\n# 解压数据\ntar jxvf CN.tar.bz2\n\n# 开始导入数据到china数据库\nosm2pgsql -c -d china --slim --hstore -C 2000 -p china -r pbf /home/parallels/Downloads/CN\n```\n\n#5. 测试\n\n至此，我们已经基于 osm 的数据有了一个地理信息库，我们可以通过以下 sql 做一些简单的测试\n\n```sql\nSELECT name FROM china_polygon WHERE name ~ '南京';\n```\n\n结果：\n![](polygon.png)\n\n```sql\nSELECT p1.name,p2.name,ST_Distance(p1.way,p2.way) FROM\n(SELECT * FROM china_point WHERE place='city' AND name = '南京市') p1 ,\n(SELECT * FROM china_point WHERE place='city' AND name = '北京市') p2\n```\n\n结果：\n![](distance.png)\n\n```sql\nSELECT name, ST_AsText(ST_Transform(way,4326)) FROM china_point WHERE place='city';\n```\n\n结果：\n![](point.png)\n\n当然数据库的功能不局限于此，基于此数据库我们可以做些更有趣的事情，今后我们会慢慢探讨。\n\n# 参考文档\n\n[digoal 的博客](https://github.com/digoal/blog/blob/master/201609/20160906_01.md)\n","slug":"osm-PostGIS-setup","published":1,"updated":"2019-06-28T05:56:28.441Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrkxgt3000di83insx78rfv","content":"<p>PostGIS 是目前开源方案里面使用广泛的一种地理信息数据库，可玩性很强，实用性也很强，为了实现更多的地理信息操作，我们先来搭建一个简单的 PostGIS 数据库。</p>\n<a id=\"more\"></a>\n<h1 id=\"1-安装步骤\"><a href=\"#1-安装步骤\" class=\"headerlink\" title=\"1. 安装步骤\"></a>1. 安装步骤</h1><ol>\n<li>准备一个 CentOS 7.x x64 环境</li>\n<li>安装数据库 PostgreSQL 9.6</li>\n<li>安装对应版本的 PostGIS 2.2.2</li>\n<li>导入 openstreetmap 的中国区域数据</li>\n</ol>\n<h1 id=\"2-PostgreSQL-9-6\"><a href=\"#2-PostgreSQL-9-6\" class=\"headerlink\" title=\"2. PostgreSQL 9.6\"></a>2. PostgreSQL 9.6</h1><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装数据库</span></span><br><span class=\"line\">yum install https://download.postgresql.org/pub/repos/yum/9.6/redhat/rhel-7-x86_64/pgdg-centos96-9.6-3.noarch.rpm</span><br><span class=\"line\"></span><br><span class=\"line\">yum install postgresql96</span><br><span class=\"line\"></span><br><span class=\"line\">yum install postgresql96-server</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化数据库及服务</span></span><br><span class=\"line\">/usr/pgsql-9.6/bin/postgresql96-setup initdb</span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> postgresql-9.6</span><br><span class=\"line\">systemctl start postgresql-9.6</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置环境变量</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=/usr/pgsql-9.6/bin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> LD_LIBRARY_PATH=/usr/pgsql-9.6/lib:<span class=\"variable\">$LD_LIBRARY_PATH</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PGDATA=/home/postgres/postgresql_data</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 以下可选</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 为数据库设置密码</span></span><br><span class=\"line\">su - postgres</span><br><span class=\"line\">psql</span><br><span class=\"line\">postgres=<span class=\"comment\"># ALTER USER postgres WITH PASSWORD 'postgres';</span></span><br><span class=\"line\">postgres=<span class=\"comment\"># \\q</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开放防火墙端口</span></span><br><span class=\"line\">firewall-cmd --permanent --add-port=5432/tcp</span><br><span class=\"line\">firewall-cmd --reload</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改配置文件允许外部使用密码访问</span></span><br><span class=\"line\">vim /var/lib/pgsql/9.6/data/postgresql.conf</span><br><span class=\"line\">listen_addresses = <span class=\"string\">'localhost'</span>  为  listen_addresses=<span class=\"string\">'*'</span></span><br><span class=\"line\"></span><br><span class=\"line\">vim /var/lib/pgsql/9.6/data/pg_hba.conf</span><br><span class=\"line\">host    all            all      0.0.0.0/0      md5</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-PostGIS\"><a href=\"#3-PostGIS\" class=\"headerlink\" title=\"3. PostGIS\"></a>3. PostGIS</h1><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装PostGIS</span></span><br><span class=\"line\">sudo yum -y install epel-release</span><br><span class=\"line\">sudo yum install postgis24_96</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化数据库osm</span></span><br><span class=\"line\">createdb osm</span><br><span class=\"line\"></span><br><span class=\"line\">psql -h 127.0.0.1 -d osm -U postgres -f /usr/pgsql-9.6/share/contrib/postgis-2.4/postgis.sql</span><br><span class=\"line\">psql -h 127.0.0.1 -d osm -U postgres -f /usr/pgsql-9.6/share/contrib/postgis-2.4/spatial_ref_sys.sql</span><br><span class=\"line\">psql -d osm -c <span class=\"string\">'CREATE EXTENSION postgis; CREATE EXTENSION hstore;'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 可以基于osm创建china数据库（把osm作为一个可重复备份的库）</span></span><br><span class=\"line\">createdb -T osm china</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-osm-数据导入\"><a href=\"#4-osm-数据导入\" class=\"headerlink\" title=\"4. osm 数据导入\"></a>4. osm 数据导入</h1><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装导入工具osm2pgsql</span></span><br><span class=\"line\">yum install osm2pgsql</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载中国区域的公开数据</span></span><br><span class=\"line\">wget http://download.gisgraphy.com/openstreetmap/pbf/CN.tar.bz2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 解压数据</span></span><br><span class=\"line\">tar jxvf CN.tar.bz2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开始导入数据到china数据库</span></span><br><span class=\"line\">osm2pgsql -c -d china --slim --hstore -C 2000 -p china -r pbf /home/parallels/Downloads/CN</span><br></pre></td></tr></table></figure>\n<p>#5. 测试</p>\n<p>至此，我们已经基于 osm 的数据有了一个地理信息库，我们可以通过以下 sql 做一些简单的测试</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">name</span> <span class=\"keyword\">FROM</span> china_polygon <span class=\"keyword\">WHERE</span> <span class=\"keyword\">name</span> ~ <span class=\"string\">'南京'</span>;</span><br></pre></td></tr></table></figure>\n<p>结果：<br><img src=\"polygon.png\" alt></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> p1.name,p2.name,ST_Distance(p1.way,p2.way) <span class=\"keyword\">FROM</span></span><br><span class=\"line\">(<span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> china_point <span class=\"keyword\">WHERE</span> place=<span class=\"string\">'city'</span> <span class=\"keyword\">AND</span> <span class=\"keyword\">name</span> = <span class=\"string\">'南京市'</span>) p1 ,</span><br><span class=\"line\">(<span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> china_point <span class=\"keyword\">WHERE</span> place=<span class=\"string\">'city'</span> <span class=\"keyword\">AND</span> <span class=\"keyword\">name</span> = <span class=\"string\">'北京市'</span>) p2</span><br></pre></td></tr></table></figure>\n<p>结果：<br><img src=\"distance.png\" alt></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">name</span>, ST_AsText(ST_Transform(way,<span class=\"number\">4326</span>)) <span class=\"keyword\">FROM</span> china_point <span class=\"keyword\">WHERE</span> place=<span class=\"string\">'city'</span>;</span><br></pre></td></tr></table></figure>\n<p>结果：<br><img src=\"point.png\" alt></p>\n<p>当然数据库的功能不局限于此，基于此数据库我们可以做些更有趣的事情，今后我们会慢慢探讨。</p>\n<h1 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h1><p><a href=\"https://github.com/digoal/blog/blob/master/201609/20160906_01.md\" target=\"_blank\" rel=\"noopener\">digoal 的博客</a></p>\n","site":{"data":{}},"excerpt":"<p>PostGIS 是目前开源方案里面使用广泛的一种地理信息数据库，可玩性很强，实用性也很强，为了实现更多的地理信息操作，我们先来搭建一个简单的 PostGIS 数据库。</p>","more":"<h1 id=\"1-安装步骤\"><a href=\"#1-安装步骤\" class=\"headerlink\" title=\"1. 安装步骤\"></a>1. 安装步骤</h1><ol>\n<li>准备一个 CentOS 7.x x64 环境</li>\n<li>安装数据库 PostgreSQL 9.6</li>\n<li>安装对应版本的 PostGIS 2.2.2</li>\n<li>导入 openstreetmap 的中国区域数据</li>\n</ol>\n<h1 id=\"2-PostgreSQL-9-6\"><a href=\"#2-PostgreSQL-9-6\" class=\"headerlink\" title=\"2. PostgreSQL 9.6\"></a>2. PostgreSQL 9.6</h1><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装数据库</span></span><br><span class=\"line\">yum install https://download.postgresql.org/pub/repos/yum/9.6/redhat/rhel-7-x86_64/pgdg-centos96-9.6-3.noarch.rpm</span><br><span class=\"line\"></span><br><span class=\"line\">yum install postgresql96</span><br><span class=\"line\"></span><br><span class=\"line\">yum install postgresql96-server</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化数据库及服务</span></span><br><span class=\"line\">/usr/pgsql-9.6/bin/postgresql96-setup initdb</span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> postgresql-9.6</span><br><span class=\"line\">systemctl start postgresql-9.6</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置环境变量</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=/usr/pgsql-9.6/bin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> LD_LIBRARY_PATH=/usr/pgsql-9.6/lib:<span class=\"variable\">$LD_LIBRARY_PATH</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PGDATA=/home/postgres/postgresql_data</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 以下可选</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 为数据库设置密码</span></span><br><span class=\"line\">su - postgres</span><br><span class=\"line\">psql</span><br><span class=\"line\">postgres=<span class=\"comment\"># ALTER USER postgres WITH PASSWORD 'postgres';</span></span><br><span class=\"line\">postgres=<span class=\"comment\"># \\q</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开放防火墙端口</span></span><br><span class=\"line\">firewall-cmd --permanent --add-port=5432/tcp</span><br><span class=\"line\">firewall-cmd --reload</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改配置文件允许外部使用密码访问</span></span><br><span class=\"line\">vim /var/lib/pgsql/9.6/data/postgresql.conf</span><br><span class=\"line\">listen_addresses = <span class=\"string\">'localhost'</span>  为  listen_addresses=<span class=\"string\">'*'</span></span><br><span class=\"line\"></span><br><span class=\"line\">vim /var/lib/pgsql/9.6/data/pg_hba.conf</span><br><span class=\"line\">host    all            all      0.0.0.0/0      md5</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-PostGIS\"><a href=\"#3-PostGIS\" class=\"headerlink\" title=\"3. PostGIS\"></a>3. PostGIS</h1><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装PostGIS</span></span><br><span class=\"line\">sudo yum -y install epel-release</span><br><span class=\"line\">sudo yum install postgis24_96</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化数据库osm</span></span><br><span class=\"line\">createdb osm</span><br><span class=\"line\"></span><br><span class=\"line\">psql -h 127.0.0.1 -d osm -U postgres -f /usr/pgsql-9.6/share/contrib/postgis-2.4/postgis.sql</span><br><span class=\"line\">psql -h 127.0.0.1 -d osm -U postgres -f /usr/pgsql-9.6/share/contrib/postgis-2.4/spatial_ref_sys.sql</span><br><span class=\"line\">psql -d osm -c <span class=\"string\">'CREATE EXTENSION postgis; CREATE EXTENSION hstore;'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 可以基于osm创建china数据库（把osm作为一个可重复备份的库）</span></span><br><span class=\"line\">createdb -T osm china</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-osm-数据导入\"><a href=\"#4-osm-数据导入\" class=\"headerlink\" title=\"4. osm 数据导入\"></a>4. osm 数据导入</h1><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装导入工具osm2pgsql</span></span><br><span class=\"line\">yum install osm2pgsql</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载中国区域的公开数据</span></span><br><span class=\"line\">wget http://download.gisgraphy.com/openstreetmap/pbf/CN.tar.bz2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 解压数据</span></span><br><span class=\"line\">tar jxvf CN.tar.bz2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开始导入数据到china数据库</span></span><br><span class=\"line\">osm2pgsql -c -d china --slim --hstore -C 2000 -p china -r pbf /home/parallels/Downloads/CN</span><br></pre></td></tr></table></figure>\n<p>#5. 测试</p>\n<p>至此，我们已经基于 osm 的数据有了一个地理信息库，我们可以通过以下 sql 做一些简单的测试</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">name</span> <span class=\"keyword\">FROM</span> china_polygon <span class=\"keyword\">WHERE</span> <span class=\"keyword\">name</span> ~ <span class=\"string\">'南京'</span>;</span><br></pre></td></tr></table></figure>\n<p>结果：<br><img src=\"polygon.png\" alt></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> p1.name,p2.name,ST_Distance(p1.way,p2.way) <span class=\"keyword\">FROM</span></span><br><span class=\"line\">(<span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> china_point <span class=\"keyword\">WHERE</span> place=<span class=\"string\">'city'</span> <span class=\"keyword\">AND</span> <span class=\"keyword\">name</span> = <span class=\"string\">'南京市'</span>) p1 ,</span><br><span class=\"line\">(<span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> china_point <span class=\"keyword\">WHERE</span> place=<span class=\"string\">'city'</span> <span class=\"keyword\">AND</span> <span class=\"keyword\">name</span> = <span class=\"string\">'北京市'</span>) p2</span><br></pre></td></tr></table></figure>\n<p>结果：<br><img src=\"distance.png\" alt></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">name</span>, ST_AsText(ST_Transform(way,<span class=\"number\">4326</span>)) <span class=\"keyword\">FROM</span> china_point <span class=\"keyword\">WHERE</span> place=<span class=\"string\">'city'</span>;</span><br></pre></td></tr></table></figure>\n<p>结果：<br><img src=\"point.png\" alt></p>\n<p>当然数据库的功能不局限于此，基于此数据库我们可以做些更有趣的事情，今后我们会慢慢探讨。</p>\n<h1 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h1><p><a href=\"https://github.com/digoal/blog/blob/master/201609/20160906_01.md\" target=\"_blank\" rel=\"noopener\">digoal 的博客</a></p>"},{"title":"tilestrata-dependency 插件使用及浅析","date":"2019-07-07T09:02:17.000Z","_content":"\n[tilestrata-dependency](https://github.com/naturalatlas/tilestrata-dependency)插件其实就是共享其他图层的数据源，如果你想定义两个不同格式的图层，例如分别是 png 和 jpg，这个插件就会非常的便利。你甚至可以传入一个 function 来精确控制不同层级使用不同图层的数据源。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-dependency --save\n```\n\n# 2. 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst dependency = require('tilestrata-dependency')\nconst mapnik = require('tilestrata-mapnik')\n\nconst server = tilestrata()\n\nserver\n  // 定义世界边界png图层\n  .layer('world_merc_png')\n  .route('tile.png')\n  .use(\n    mapnik({\n      pathname: 'style/world.xml'\n    })\n  )\n\nserver\n  // 定义世界边界jpg图层\n  .layer('world_merc_jpg')\n  .route('tile.jpg')\n  // 直接用png的源\n  .use(dependency('world_merc_png', 'tile.png'))\n\nserver\n  .layer('function_layer')\n  .route('tile.jpg')\n  // 不同层级用不同的源\n  .use(dependency(function(req) {\n    if (req.z < 5) {\n      return ['world_merc_png', 'tile.png'];\n    }\n    return ['world_merc_jpg', 'tile.jpg'];\n  });\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n`world_merc_png`和`world_merc_jpg`使用了相同的源，展示的内容一模一样：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-dependency-20190705152851.png)\n\n# 4. 代码浅析\n\n要弄清楚`dependency`插件的实现，首先要弄清楚它的类型，dependency 源代码很简单，它属于`Providers`类型的插件:\n\n```js\n// Providers 类型插件需要提供serve方法\nserve: function(server, tile, callback) {\n    callback(err, buffer, headers);\n},\n```\n\n接下来的代码主要逻辑就是如何利用指定的图层源创造一个`buffer`返回给新图层，以下代码就是 server 函数，有所精简：\n\n```js\n// req 即上面的tile参数，包含请求的瓦片地址和类型，例如tile.jpg\nvar mock = req.clone()\n// source 即指定的其他图层的数据源['world_merc_png', 'tile.png']\nvar source = getSource(req)\n\n// 分别把当前tile的layer和filename替换成指定源的对应值\nmock.layer = source[0]\nmock.filename = source[1]\n\n// server 即上面的server参数，代表整个tilestrata服务\nserver.serve(mock, false, function(status, buffer, headers) {\n  if (status === 200) {\n    // 利用伪造出来的指定源的请求内容去向服务器请求数据，获取buffer后返回给当前源\n    callback(null, buffer, headers)\n  } else {\n    callback(err)\n  }\n})\n```\n\n当前图层拿到了 buffer 内容，只要再进入自己后续的加工逻辑，处理成指定格式返回就好了。\n","source":"_posts/2019/tilestrata-dependency.md","raw":"---\ntitle: tilestrata-dependency 插件使用及浅析\ndate: 2019-07-07 17:02:17\ntags: [GIS]\ncategories: TileStrata\n---\n\n[tilestrata-dependency](https://github.com/naturalatlas/tilestrata-dependency)插件其实就是共享其他图层的数据源，如果你想定义两个不同格式的图层，例如分别是 png 和 jpg，这个插件就会非常的便利。你甚至可以传入一个 function 来精确控制不同层级使用不同图层的数据源。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-dependency --save\n```\n\n# 2. 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst dependency = require('tilestrata-dependency')\nconst mapnik = require('tilestrata-mapnik')\n\nconst server = tilestrata()\n\nserver\n  // 定义世界边界png图层\n  .layer('world_merc_png')\n  .route('tile.png')\n  .use(\n    mapnik({\n      pathname: 'style/world.xml'\n    })\n  )\n\nserver\n  // 定义世界边界jpg图层\n  .layer('world_merc_jpg')\n  .route('tile.jpg')\n  // 直接用png的源\n  .use(dependency('world_merc_png', 'tile.png'))\n\nserver\n  .layer('function_layer')\n  .route('tile.jpg')\n  // 不同层级用不同的源\n  .use(dependency(function(req) {\n    if (req.z < 5) {\n      return ['world_merc_png', 'tile.png'];\n    }\n    return ['world_merc_jpg', 'tile.jpg'];\n  });\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n`world_merc_png`和`world_merc_jpg`使用了相同的源，展示的内容一模一样：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-dependency-20190705152851.png)\n\n# 4. 代码浅析\n\n要弄清楚`dependency`插件的实现，首先要弄清楚它的类型，dependency 源代码很简单，它属于`Providers`类型的插件:\n\n```js\n// Providers 类型插件需要提供serve方法\nserve: function(server, tile, callback) {\n    callback(err, buffer, headers);\n},\n```\n\n接下来的代码主要逻辑就是如何利用指定的图层源创造一个`buffer`返回给新图层，以下代码就是 server 函数，有所精简：\n\n```js\n// req 即上面的tile参数，包含请求的瓦片地址和类型，例如tile.jpg\nvar mock = req.clone()\n// source 即指定的其他图层的数据源['world_merc_png', 'tile.png']\nvar source = getSource(req)\n\n// 分别把当前tile的layer和filename替换成指定源的对应值\nmock.layer = source[0]\nmock.filename = source[1]\n\n// server 即上面的server参数，代表整个tilestrata服务\nserver.serve(mock, false, function(status, buffer, headers) {\n  if (status === 200) {\n    // 利用伪造出来的指定源的请求内容去向服务器请求数据，获取buffer后返回给当前源\n    callback(null, buffer, headers)\n  } else {\n    callback(err)\n  }\n})\n```\n\n当前图层拿到了 buffer 内容，只要再进入自己后续的加工逻辑，处理成指定格式返回就好了。\n","slug":"tilestrata-dependency","published":1,"updated":"2019-07-07T09:04:03.888Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrkxgt3000ei83inkjuhzr1","content":"<p><a href=\"https://github.com/naturalatlas/tilestrata-dependency\" target=\"_blank\" rel=\"noopener\">tilestrata-dependency</a>插件其实就是共享其他图层的数据源，如果你想定义两个不同格式的图层，例如分别是 png 和 jpg，这个插件就会非常的便利。你甚至可以传入一个 function 来精确控制不同层级使用不同图层的数据源。</p>\n<a id=\"more\"></a>\n<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-dependency --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> dependency = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-dependency'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  <span class=\"comment\">// 定义世界边界png图层</span></span><br><span class=\"line\">  .layer(<span class=\"string\">'world_merc_png'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/world.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  <span class=\"comment\">// 定义世界边界jpg图层</span></span><br><span class=\"line\">  .layer(<span class=\"string\">'world_merc_jpg'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.jpg'</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 直接用png的源</span></span><br><span class=\"line\">  .use(dependency(<span class=\"string\">'world_merc_png'</span>, <span class=\"string\">'tile.png'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'function_layer'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.jpg'</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 不同层级用不同的源</span></span><br><span class=\"line\">  .use(dependency(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (req.z &lt; <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> [<span class=\"string\">'world_merc_png'</span>, <span class=\"string\">'tile.png'</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"string\">'world_merc_jpg'</span>, <span class=\"string\">'tile.jpg'</span>];</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p><code>world_merc_png</code>和<code>world_merc_jpg</code>使用了相同的源，展示的内容一模一样：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-dependency-20190705152851.png\" alt></p>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>要弄清楚<code>dependency</code>插件的实现，首先要弄清楚它的类型，dependency 源代码很简单，它属于<code>Providers</code>类型的插件:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Providers 类型插件需要提供serve方法</span></span><br><span class=\"line\">serve: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, tile, callback</span>) </span>&#123;</span><br><span class=\"line\">    callback(err, buffer, headers);</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>接下来的代码主要逻辑就是如何利用指定的图层源创造一个<code>buffer</code>返回给新图层，以下代码就是 server 函数，有所精简：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// req 即上面的tile参数，包含请求的瓦片地址和类型，例如tile.jpg</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mock = req.clone()</span><br><span class=\"line\"><span class=\"comment\">// source 即指定的其他图层的数据源['world_merc_png', 'tile.png']</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> source = getSource(req)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 分别把当前tile的layer和filename替换成指定源的对应值</span></span><br><span class=\"line\">mock.layer = source[<span class=\"number\">0</span>]</span><br><span class=\"line\">mock.filename = source[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// server 即上面的server参数，代表整个tilestrata服务</span></span><br><span class=\"line\">server.serve(mock, <span class=\"literal\">false</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">status, buffer, headers</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (status === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 利用伪造出来的指定源的请求内容去向服务器请求数据，获取buffer后返回给当前源</span></span><br><span class=\"line\">    callback(<span class=\"literal\">null</span>, buffer, headers)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    callback(err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>当前图层拿到了 buffer 内容，只要再进入自己后续的加工逻辑，处理成指定格式返回就好了。</p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/naturalatlas/tilestrata-dependency\" target=\"_blank\" rel=\"noopener\">tilestrata-dependency</a>插件其实就是共享其他图层的数据源，如果你想定义两个不同格式的图层，例如分别是 png 和 jpg，这个插件就会非常的便利。你甚至可以传入一个 function 来精确控制不同层级使用不同图层的数据源。</p>","more":"<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-dependency --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> dependency = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-dependency'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  <span class=\"comment\">// 定义世界边界png图层</span></span><br><span class=\"line\">  .layer(<span class=\"string\">'world_merc_png'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/world.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  <span class=\"comment\">// 定义世界边界jpg图层</span></span><br><span class=\"line\">  .layer(<span class=\"string\">'world_merc_jpg'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.jpg'</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 直接用png的源</span></span><br><span class=\"line\">  .use(dependency(<span class=\"string\">'world_merc_png'</span>, <span class=\"string\">'tile.png'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'function_layer'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.jpg'</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 不同层级用不同的源</span></span><br><span class=\"line\">  .use(dependency(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (req.z &lt; <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> [<span class=\"string\">'world_merc_png'</span>, <span class=\"string\">'tile.png'</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"string\">'world_merc_jpg'</span>, <span class=\"string\">'tile.jpg'</span>];</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p><code>world_merc_png</code>和<code>world_merc_jpg</code>使用了相同的源，展示的内容一模一样：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-dependency-20190705152851.png\" alt></p>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>要弄清楚<code>dependency</code>插件的实现，首先要弄清楚它的类型，dependency 源代码很简单，它属于<code>Providers</code>类型的插件:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Providers 类型插件需要提供serve方法</span></span><br><span class=\"line\">serve: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, tile, callback</span>) </span>&#123;</span><br><span class=\"line\">    callback(err, buffer, headers);</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>接下来的代码主要逻辑就是如何利用指定的图层源创造一个<code>buffer</code>返回给新图层，以下代码就是 server 函数，有所精简：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// req 即上面的tile参数，包含请求的瓦片地址和类型，例如tile.jpg</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mock = req.clone()</span><br><span class=\"line\"><span class=\"comment\">// source 即指定的其他图层的数据源['world_merc_png', 'tile.png']</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> source = getSource(req)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 分别把当前tile的layer和filename替换成指定源的对应值</span></span><br><span class=\"line\">mock.layer = source[<span class=\"number\">0</span>]</span><br><span class=\"line\">mock.filename = source[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// server 即上面的server参数，代表整个tilestrata服务</span></span><br><span class=\"line\">server.serve(mock, <span class=\"literal\">false</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">status, buffer, headers</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (status === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 利用伪造出来的指定源的请求内容去向服务器请求数据，获取buffer后返回给当前源</span></span><br><span class=\"line\">    callback(<span class=\"literal\">null</span>, buffer, headers)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    callback(err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>当前图层拿到了 buffer 内容，只要再进入自己后续的加工逻辑，处理成指定格式返回就好了。</p>"},{"title":"tilestrata-disk 插件使用及浅析","date":"2019-07-15T13:39:59.000Z","_content":"\n[tilestrata-disk](https://github.com/naturalatlas/tilestrata-disk)插件可以在磁盘中存储/检索瓦片。它可以兼顾瓦片缓存和瓦片提供两个功能，代码虽简单，但是功能十分全面，个人感觉非常的实用，很值得推荐。\n\n用它来缓存瓦片时，一定要为每个图层使用不同的目录（例如：\"tiles/layer_a\", \"tiles/layer_b\"）。如果设置了`maxage`参数，插件会检查瓦片的最近一次修改时间，如果间隔过长，将返回`null`。如果 设置`maxage=0`，就相当于没有开启缓存功能。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-disk --save\n```\n\n# 2. 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst mapnik = require('tilestrata-mapnik')\nconst disk = require('tilestrata-disk')\nconst server = tilestrata()\n\nserver\n  .layer('world_merc')\n  .route('tile.png')\n  // 直接缓存\n  .use(disk.cache({ dir: 'tilecache/world' }))\n  .use(\n    mapnik({\n      pathname: 'style/world.xml'\n    })\n  )\n\nserver\n  .layer('province')\n  .route('tile.png')\n  // 不同图层使用不同目录，同时设置最大缓存时间3600秒\n  .use(disk.cache({ maxage: 3600, dir: 'tilecache/province' }))\n  .use(\n    mapnik({\n      pathname: 'style/province.xml'\n    })\n  )\n\nserver.listen(9527)\n```\n\n此外，disk 插件的功能远不止如此：\n\n```js\n// 设置maxage为function，控制不同层级的过期时间\nserver\n  .layer('mylayer')\n  .route('tile.png')\n  .use(/* some provider */)\n  .use(\n    disk.cache({\n      dir: './tiles/mylayer',\n      maxage: function(server, req) {\n        if (req.z > 15) return 0 // 不缓存\n        if (req.z > 13) return 3600\n        return 3600 * 24\n      }\n    })\n  )\n\n// 可以通过path自定义缓存的结构和文件名\nserver\n  .layer('mylayer')\n  .route('tile.png')\n  .use(/* some provider */)\n  .use(disk.cache({ path: './tiles/{layer}/{z}/{x}/{y}-{filename}' }))\n\n// 通过callback的方式来设置\nserver\n  .layer('mylayer')\n  .route('tile.png')\n  .use(/* some provider */)\n  .use(\n    disk.cache({\n      path: function(tile) {\n        return './tiles/' + tile.layer + '/' + tile.z + '/' /* ... */\n      }\n    })\n  )\n\n// 直接使用缓存下来的文件当作provider，这样就不调用服务器生成图片了\nserver\n  .layer('mylayer')\n  .route('tile.png')\n  .use(disk.provider('/path/to/dir/{z}/{x}/{y}/file.png'))\n```\n\n甚至在`0.6.0`及其以上的 tilestrata 版本中，你还可以通过设定`refreshage`来控制缓存数据的寿命，这个参数需要与`maxage`一起设设置：\n\n```js\n.use(disk.cache({\n    dir: './tiles/mylayer',\n    refreshage: 3600, // 1 hour\n    maxage: 3600*24*7 // 1 week\n}));\n\nrefreshage: null  // 永远不刷新缓存\nrefreshage: 0     // 命中一次后就刷新\nrefreshage: 1800  // 半小时后刷新\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n下图中设置了`tilecache`缓存目录，可以看到瓦片会按照层级建立对应的目录结构并保存图片：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-disk-20190705160620.png)\n\n# 4. 代码浅析\n\n因为插件即提供了`cache`功能，也提供了`Provider`功能，所以其实它是这两种类型插件的组合，作为`Provider`还是比较简单的，核心是 serve 方法:\n\n```js\nserve: function(server, tile, callback) {\n  // 解析路径\n  var file = template\n    .replace('{layer}', tile.layer)\n    .replace('{filename}', tile.filename)\n    .replace('{x}', tile.x)\n    .replace('{y}', tile.y)\n    .replace('{z}', tile.z);\n\n  // 根绝路径读取文件为buffer\n  fs.readFile(file, function(err, buffer) {\n    if (err) {\n      if (err.code === 'ENOENT') {\n        var err = new Error('File not found');\n        err.statusCode = 404;\n        return callback(err);\n      }\n      return callback(err);\n    }\n    // 返回buffer给tilestrata\n    callback(null, buffer, {'Content-Type': mime(file)});\n  });\n}\n```\n\n在`cache`功能中，需要提供 get 和 set 方法，主要就是在 set 方法中保存文件，在 get 方法中判断是否过期，是否文件名命中缓存，收否需要刷新，之后再返回对应结果的内容：\n\n```js\n// set 方法\nFileSystemCache.prototype.set = function(\n  server,\n  req,\n  buffer,\n  headers,\n  callback\n) {\n  var maxage = this.ageTolerance('maxage', req)\n  if (maxage === 0) return callback()\n  // 只要maxage不为0，就在文件系统上存储图片，this._file是根据path或者dir设置计算出来的存储路径\n  fs.outputFile(this._file(req), buffer, callback)\n}\n```\n\n```js\n// get 方法（有所精简）\nFileSystemCache.prototype.get = function(server, req, callback) {\n  var maxage = this.ageTolerance('maxage', req)\n  // maxage为0，直接结束\n  if (maxage === 0) return done()\n\n  var self = this\n  // 获取缓存文件路径\n  var file = this._file(req)\n  fs.open(file, 'r', function(err, fd) {\n    fs.fstat(fd, function(err, stats) {\n      if (err) return done(err)\n      var mtime = stats.mtime.getTime()\n\n      // 根据maxage是否过期判断是否直接结束\n      var shouldServe = self.shouldServe(mtime, req)\n      if (!shouldServe) return done()\n\n      // 根据refreshage判断是否刷新\n      var shouldRefresh = self.shouldRefresh(mtime, req)\n      var headers = { 'Content-Type': mime(file) }\n      var buffer = new Buffer(stats.size)\n\n      // 如果没有这个文件，直接结束\n      if (!stats.size) {\n        return done(null, buffer, headers, shouldRefresh)\n      }\n\n      // 如果前面的都通过则读取文件为buffer\n      fs.read(fd, buffer, 0, stats.size, 0, function(err) {\n        if (err) return done(err)\n        // 返回buffer\n        done(null, buffer, headers, shouldRefresh)\n      })\n    })\n  })\n}\n```\n","source":"_posts/2019/tilestrata-disk.md","raw":"---\ntitle: tilestrata-disk 插件使用及浅析\ndate: 2019-07-15 21:39:59\ntags: [GIS]\ncategories: TileStrata\n---\n\n[tilestrata-disk](https://github.com/naturalatlas/tilestrata-disk)插件可以在磁盘中存储/检索瓦片。它可以兼顾瓦片缓存和瓦片提供两个功能，代码虽简单，但是功能十分全面，个人感觉非常的实用，很值得推荐。\n\n用它来缓存瓦片时，一定要为每个图层使用不同的目录（例如：\"tiles/layer_a\", \"tiles/layer_b\"）。如果设置了`maxage`参数，插件会检查瓦片的最近一次修改时间，如果间隔过长，将返回`null`。如果 设置`maxage=0`，就相当于没有开启缓存功能。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-disk --save\n```\n\n# 2. 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst mapnik = require('tilestrata-mapnik')\nconst disk = require('tilestrata-disk')\nconst server = tilestrata()\n\nserver\n  .layer('world_merc')\n  .route('tile.png')\n  // 直接缓存\n  .use(disk.cache({ dir: 'tilecache/world' }))\n  .use(\n    mapnik({\n      pathname: 'style/world.xml'\n    })\n  )\n\nserver\n  .layer('province')\n  .route('tile.png')\n  // 不同图层使用不同目录，同时设置最大缓存时间3600秒\n  .use(disk.cache({ maxage: 3600, dir: 'tilecache/province' }))\n  .use(\n    mapnik({\n      pathname: 'style/province.xml'\n    })\n  )\n\nserver.listen(9527)\n```\n\n此外，disk 插件的功能远不止如此：\n\n```js\n// 设置maxage为function，控制不同层级的过期时间\nserver\n  .layer('mylayer')\n  .route('tile.png')\n  .use(/* some provider */)\n  .use(\n    disk.cache({\n      dir: './tiles/mylayer',\n      maxage: function(server, req) {\n        if (req.z > 15) return 0 // 不缓存\n        if (req.z > 13) return 3600\n        return 3600 * 24\n      }\n    })\n  )\n\n// 可以通过path自定义缓存的结构和文件名\nserver\n  .layer('mylayer')\n  .route('tile.png')\n  .use(/* some provider */)\n  .use(disk.cache({ path: './tiles/{layer}/{z}/{x}/{y}-{filename}' }))\n\n// 通过callback的方式来设置\nserver\n  .layer('mylayer')\n  .route('tile.png')\n  .use(/* some provider */)\n  .use(\n    disk.cache({\n      path: function(tile) {\n        return './tiles/' + tile.layer + '/' + tile.z + '/' /* ... */\n      }\n    })\n  )\n\n// 直接使用缓存下来的文件当作provider，这样就不调用服务器生成图片了\nserver\n  .layer('mylayer')\n  .route('tile.png')\n  .use(disk.provider('/path/to/dir/{z}/{x}/{y}/file.png'))\n```\n\n甚至在`0.6.0`及其以上的 tilestrata 版本中，你还可以通过设定`refreshage`来控制缓存数据的寿命，这个参数需要与`maxage`一起设设置：\n\n```js\n.use(disk.cache({\n    dir: './tiles/mylayer',\n    refreshage: 3600, // 1 hour\n    maxage: 3600*24*7 // 1 week\n}));\n\nrefreshage: null  // 永远不刷新缓存\nrefreshage: 0     // 命中一次后就刷新\nrefreshage: 1800  // 半小时后刷新\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n下图中设置了`tilecache`缓存目录，可以看到瓦片会按照层级建立对应的目录结构并保存图片：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-disk-20190705160620.png)\n\n# 4. 代码浅析\n\n因为插件即提供了`cache`功能，也提供了`Provider`功能，所以其实它是这两种类型插件的组合，作为`Provider`还是比较简单的，核心是 serve 方法:\n\n```js\nserve: function(server, tile, callback) {\n  // 解析路径\n  var file = template\n    .replace('{layer}', tile.layer)\n    .replace('{filename}', tile.filename)\n    .replace('{x}', tile.x)\n    .replace('{y}', tile.y)\n    .replace('{z}', tile.z);\n\n  // 根绝路径读取文件为buffer\n  fs.readFile(file, function(err, buffer) {\n    if (err) {\n      if (err.code === 'ENOENT') {\n        var err = new Error('File not found');\n        err.statusCode = 404;\n        return callback(err);\n      }\n      return callback(err);\n    }\n    // 返回buffer给tilestrata\n    callback(null, buffer, {'Content-Type': mime(file)});\n  });\n}\n```\n\n在`cache`功能中，需要提供 get 和 set 方法，主要就是在 set 方法中保存文件，在 get 方法中判断是否过期，是否文件名命中缓存，收否需要刷新，之后再返回对应结果的内容：\n\n```js\n// set 方法\nFileSystemCache.prototype.set = function(\n  server,\n  req,\n  buffer,\n  headers,\n  callback\n) {\n  var maxage = this.ageTolerance('maxage', req)\n  if (maxage === 0) return callback()\n  // 只要maxage不为0，就在文件系统上存储图片，this._file是根据path或者dir设置计算出来的存储路径\n  fs.outputFile(this._file(req), buffer, callback)\n}\n```\n\n```js\n// get 方法（有所精简）\nFileSystemCache.prototype.get = function(server, req, callback) {\n  var maxage = this.ageTolerance('maxage', req)\n  // maxage为0，直接结束\n  if (maxage === 0) return done()\n\n  var self = this\n  // 获取缓存文件路径\n  var file = this._file(req)\n  fs.open(file, 'r', function(err, fd) {\n    fs.fstat(fd, function(err, stats) {\n      if (err) return done(err)\n      var mtime = stats.mtime.getTime()\n\n      // 根据maxage是否过期判断是否直接结束\n      var shouldServe = self.shouldServe(mtime, req)\n      if (!shouldServe) return done()\n\n      // 根据refreshage判断是否刷新\n      var shouldRefresh = self.shouldRefresh(mtime, req)\n      var headers = { 'Content-Type': mime(file) }\n      var buffer = new Buffer(stats.size)\n\n      // 如果没有这个文件，直接结束\n      if (!stats.size) {\n        return done(null, buffer, headers, shouldRefresh)\n      }\n\n      // 如果前面的都通过则读取文件为buffer\n      fs.read(fd, buffer, 0, stats.size, 0, function(err) {\n        if (err) return done(err)\n        // 返回buffer\n        done(null, buffer, headers, shouldRefresh)\n      })\n    })\n  })\n}\n```\n","slug":"tilestrata-disk","published":1,"updated":"2019-07-15T13:41:40.872Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrkxgt4000fi83i7qsgu23r","content":"<p><a href=\"https://github.com/naturalatlas/tilestrata-disk\" target=\"_blank\" rel=\"noopener\">tilestrata-disk</a>插件可以在磁盘中存储/检索瓦片。它可以兼顾瓦片缓存和瓦片提供两个功能，代码虽简单，但是功能十分全面，个人感觉非常的实用，很值得推荐。</p>\n<p>用它来缓存瓦片时，一定要为每个图层使用不同的目录（例如：”tiles/layer_a”, “tiles/layer_b”）。如果设置了<code>maxage</code>参数，插件会检查瓦片的最近一次修改时间，如果间隔过长，将返回<code>null</code>。如果 设置<code>maxage=0</code>，就相当于没有开启缓存功能。</p>\n<a id=\"more\"></a>\n<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-disk --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> disk = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-disk'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'world_merc'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 直接缓存</span></span><br><span class=\"line\">  .use(disk.cache(&#123; <span class=\"attr\">dir</span>: <span class=\"string\">'tilecache/world'</span> &#125;))</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/world.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'province'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 不同图层使用不同目录，同时设置最大缓存时间3600秒</span></span><br><span class=\"line\">  .use(disk.cache(&#123; <span class=\"attr\">maxage</span>: <span class=\"number\">3600</span>, <span class=\"attr\">dir</span>: <span class=\"string\">'tilecache/province'</span> &#125;))</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/province.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<p>此外，disk 插件的功能远不止如此：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置maxage为function，控制不同层级的过期时间</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'mylayer'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(<span class=\"comment\">/* some provider */</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    disk.cache(&#123;</span><br><span class=\"line\">      dir: <span class=\"string\">'./tiles/mylayer'</span>,</span><br><span class=\"line\">      maxage: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (req.z &gt; <span class=\"number\">15</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span> <span class=\"comment\">// 不缓存</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (req.z &gt; <span class=\"number\">13</span>) <span class=\"keyword\">return</span> <span class=\"number\">3600</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3600</span> * <span class=\"number\">24</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以通过path自定义缓存的结构和文件名</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'mylayer'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(<span class=\"comment\">/* some provider */</span>)</span><br><span class=\"line\">  .use(disk.cache(&#123; <span class=\"attr\">path</span>: <span class=\"string\">'./tiles/&#123;layer&#125;/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;-&#123;filename&#125;'</span> &#125;))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过callback的方式来设置</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'mylayer'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(<span class=\"comment\">/* some provider */</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    disk.cache(&#123;</span><br><span class=\"line\">      path: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tile</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'./tiles/'</span> + tile.layer + <span class=\"string\">'/'</span> + tile.z + <span class=\"string\">'/'</span> <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 直接使用缓存下来的文件当作provider，这样就不调用服务器生成图片了</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'mylayer'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(disk.provider(<span class=\"string\">'/path/to/dir/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;/file.png'</span>))</span><br></pre></td></tr></table></figure>\n<p>甚至在<code>0.6.0</code>及其以上的 tilestrata 版本中，你还可以通过设定<code>refreshage</code>来控制缓存数据的寿命，这个参数需要与<code>maxage</code>一起设设置：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">.use(disk.cache(&#123;</span><br><span class=\"line\">    dir: <span class=\"string\">'./tiles/mylayer'</span>,</span><br><span class=\"line\">    refreshage: <span class=\"number\">3600</span>, <span class=\"comment\">// 1 hour</span></span><br><span class=\"line\">    maxage: <span class=\"number\">3600</span>*<span class=\"number\">24</span>*<span class=\"number\">7</span> <span class=\"comment\">// 1 week</span></span><br><span class=\"line\">&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\">refreshage: <span class=\"literal\">null</span>  <span class=\"comment\">// 永远不刷新缓存</span></span><br><span class=\"line\">refreshage: <span class=\"number\">0</span>     <span class=\"comment\">// 命中一次后就刷新</span></span><br><span class=\"line\">refreshage: <span class=\"number\">1800</span>  <span class=\"comment\">// 半小时后刷新</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>下图中设置了<code>tilecache</code>缓存目录，可以看到瓦片会按照层级建立对应的目录结构并保存图片：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-disk-20190705160620.png\" alt></p>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>因为插件即提供了<code>cache</code>功能，也提供了<code>Provider</code>功能，所以其实它是这两种类型插件的组合，作为<code>Provider</code>还是比较简单的，核心是 serve 方法:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">serve: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, tile, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 解析路径</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> file = template</span><br><span class=\"line\">    .replace(<span class=\"string\">'&#123;layer&#125;'</span>, tile.layer)</span><br><span class=\"line\">    .replace(<span class=\"string\">'&#123;filename&#125;'</span>, tile.filename)</span><br><span class=\"line\">    .replace(<span class=\"string\">'&#123;x&#125;'</span>, tile.x)</span><br><span class=\"line\">    .replace(<span class=\"string\">'&#123;y&#125;'</span>, tile.y)</span><br><span class=\"line\">    .replace(<span class=\"string\">'&#123;z&#125;'</span>, tile.z);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 根绝路径读取文件为buffer</span></span><br><span class=\"line\">  fs.readFile(file, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, buffer</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (err.code === <span class=\"string\">'ENOENT'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> err = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'File not found'</span>);</span><br><span class=\"line\">        err.statusCode = <span class=\"number\">404</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> callback(err);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> callback(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回buffer给tilestrata</span></span><br><span class=\"line\">    callback(<span class=\"literal\">null</span>, buffer, &#123;<span class=\"string\">'Content-Type'</span>: mime(file)&#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>cache</code>功能中，需要提供 get 和 set 方法，主要就是在 set 方法中保存文件，在 get 方法中判断是否过期，是否文件名命中缓存，收否需要刷新，之后再返回对应结果的内容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// set 方法</span></span><br><span class=\"line\">FileSystemCache.prototype.set = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  server,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  req,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  buffer,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  headers,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  callback</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> maxage = <span class=\"keyword\">this</span>.ageTolerance(<span class=\"string\">'maxage'</span>, req)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (maxage === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> callback()</span><br><span class=\"line\">  <span class=\"comment\">// 只要maxage不为0，就在文件系统上存储图片，this._file是根据path或者dir设置计算出来的存储路径</span></span><br><span class=\"line\">  fs.outputFile(<span class=\"keyword\">this</span>._file(req), buffer, callback)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// get 方法（有所精简）</span></span><br><span class=\"line\">FileSystemCache.prototype.get = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> maxage = <span class=\"keyword\">this</span>.ageTolerance(<span class=\"string\">'maxage'</span>, req)</span><br><span class=\"line\">  <span class=\"comment\">// maxage为0，直接结束</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (maxage === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> done()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\">  <span class=\"comment\">// 获取缓存文件路径</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> file = <span class=\"keyword\">this</span>._file(req)</span><br><span class=\"line\">  fs.open(file, <span class=\"string\">'r'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, fd</span>) </span>&#123;</span><br><span class=\"line\">    fs.fstat(fd, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, stats</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> done(err)</span><br><span class=\"line\">      <span class=\"keyword\">var</span> mtime = stats.mtime.getTime()</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 根据maxage是否过期判断是否直接结束</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> shouldServe = self.shouldServe(mtime, req)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!shouldServe) <span class=\"keyword\">return</span> done()</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 根据refreshage判断是否刷新</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> shouldRefresh = self.shouldRefresh(mtime, req)</span><br><span class=\"line\">      <span class=\"keyword\">var</span> headers = &#123; <span class=\"string\">'Content-Type'</span>: mime(file) &#125;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> Buffer(stats.size)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 如果没有这个文件，直接结束</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!stats.size) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> done(<span class=\"literal\">null</span>, buffer, headers, shouldRefresh)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 如果前面的都通过则读取文件为buffer</span></span><br><span class=\"line\">      fs.read(fd, buffer, <span class=\"number\">0</span>, stats.size, <span class=\"number\">0</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> done(err)</span><br><span class=\"line\">        <span class=\"comment\">// 返回buffer</span></span><br><span class=\"line\">        done(<span class=\"literal\">null</span>, buffer, headers, shouldRefresh)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/naturalatlas/tilestrata-disk\" target=\"_blank\" rel=\"noopener\">tilestrata-disk</a>插件可以在磁盘中存储/检索瓦片。它可以兼顾瓦片缓存和瓦片提供两个功能，代码虽简单，但是功能十分全面，个人感觉非常的实用，很值得推荐。</p>\n<p>用它来缓存瓦片时，一定要为每个图层使用不同的目录（例如：”tiles/layer_a”, “tiles/layer_b”）。如果设置了<code>maxage</code>参数，插件会检查瓦片的最近一次修改时间，如果间隔过长，将返回<code>null</code>。如果 设置<code>maxage=0</code>，就相当于没有开启缓存功能。</p>","more":"<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-disk --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> disk = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-disk'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'world_merc'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 直接缓存</span></span><br><span class=\"line\">  .use(disk.cache(&#123; <span class=\"attr\">dir</span>: <span class=\"string\">'tilecache/world'</span> &#125;))</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/world.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'province'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 不同图层使用不同目录，同时设置最大缓存时间3600秒</span></span><br><span class=\"line\">  .use(disk.cache(&#123; <span class=\"attr\">maxage</span>: <span class=\"number\">3600</span>, <span class=\"attr\">dir</span>: <span class=\"string\">'tilecache/province'</span> &#125;))</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/province.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<p>此外，disk 插件的功能远不止如此：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置maxage为function，控制不同层级的过期时间</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'mylayer'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(<span class=\"comment\">/* some provider */</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    disk.cache(&#123;</span><br><span class=\"line\">      dir: <span class=\"string\">'./tiles/mylayer'</span>,</span><br><span class=\"line\">      maxage: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (req.z &gt; <span class=\"number\">15</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span> <span class=\"comment\">// 不缓存</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (req.z &gt; <span class=\"number\">13</span>) <span class=\"keyword\">return</span> <span class=\"number\">3600</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3600</span> * <span class=\"number\">24</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以通过path自定义缓存的结构和文件名</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'mylayer'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(<span class=\"comment\">/* some provider */</span>)</span><br><span class=\"line\">  .use(disk.cache(&#123; <span class=\"attr\">path</span>: <span class=\"string\">'./tiles/&#123;layer&#125;/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;-&#123;filename&#125;'</span> &#125;))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过callback的方式来设置</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'mylayer'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(<span class=\"comment\">/* some provider */</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    disk.cache(&#123;</span><br><span class=\"line\">      path: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tile</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'./tiles/'</span> + tile.layer + <span class=\"string\">'/'</span> + tile.z + <span class=\"string\">'/'</span> <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 直接使用缓存下来的文件当作provider，这样就不调用服务器生成图片了</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'mylayer'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(disk.provider(<span class=\"string\">'/path/to/dir/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;/file.png'</span>))</span><br></pre></td></tr></table></figure>\n<p>甚至在<code>0.6.0</code>及其以上的 tilestrata 版本中，你还可以通过设定<code>refreshage</code>来控制缓存数据的寿命，这个参数需要与<code>maxage</code>一起设设置：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">.use(disk.cache(&#123;</span><br><span class=\"line\">    dir: <span class=\"string\">'./tiles/mylayer'</span>,</span><br><span class=\"line\">    refreshage: <span class=\"number\">3600</span>, <span class=\"comment\">// 1 hour</span></span><br><span class=\"line\">    maxage: <span class=\"number\">3600</span>*<span class=\"number\">24</span>*<span class=\"number\">7</span> <span class=\"comment\">// 1 week</span></span><br><span class=\"line\">&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\">refreshage: <span class=\"literal\">null</span>  <span class=\"comment\">// 永远不刷新缓存</span></span><br><span class=\"line\">refreshage: <span class=\"number\">0</span>     <span class=\"comment\">// 命中一次后就刷新</span></span><br><span class=\"line\">refreshage: <span class=\"number\">1800</span>  <span class=\"comment\">// 半小时后刷新</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>下图中设置了<code>tilecache</code>缓存目录，可以看到瓦片会按照层级建立对应的目录结构并保存图片：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-disk-20190705160620.png\" alt></p>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>因为插件即提供了<code>cache</code>功能，也提供了<code>Provider</code>功能，所以其实它是这两种类型插件的组合，作为<code>Provider</code>还是比较简单的，核心是 serve 方法:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">serve: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, tile, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 解析路径</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> file = template</span><br><span class=\"line\">    .replace(<span class=\"string\">'&#123;layer&#125;'</span>, tile.layer)</span><br><span class=\"line\">    .replace(<span class=\"string\">'&#123;filename&#125;'</span>, tile.filename)</span><br><span class=\"line\">    .replace(<span class=\"string\">'&#123;x&#125;'</span>, tile.x)</span><br><span class=\"line\">    .replace(<span class=\"string\">'&#123;y&#125;'</span>, tile.y)</span><br><span class=\"line\">    .replace(<span class=\"string\">'&#123;z&#125;'</span>, tile.z);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 根绝路径读取文件为buffer</span></span><br><span class=\"line\">  fs.readFile(file, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, buffer</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (err.code === <span class=\"string\">'ENOENT'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> err = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'File not found'</span>);</span><br><span class=\"line\">        err.statusCode = <span class=\"number\">404</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> callback(err);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> callback(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回buffer给tilestrata</span></span><br><span class=\"line\">    callback(<span class=\"literal\">null</span>, buffer, &#123;<span class=\"string\">'Content-Type'</span>: mime(file)&#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>cache</code>功能中，需要提供 get 和 set 方法，主要就是在 set 方法中保存文件，在 get 方法中判断是否过期，是否文件名命中缓存，收否需要刷新，之后再返回对应结果的内容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// set 方法</span></span><br><span class=\"line\">FileSystemCache.prototype.set = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  server,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  req,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  buffer,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  headers,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  callback</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> maxage = <span class=\"keyword\">this</span>.ageTolerance(<span class=\"string\">'maxage'</span>, req)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (maxage === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> callback()</span><br><span class=\"line\">  <span class=\"comment\">// 只要maxage不为0，就在文件系统上存储图片，this._file是根据path或者dir设置计算出来的存储路径</span></span><br><span class=\"line\">  fs.outputFile(<span class=\"keyword\">this</span>._file(req), buffer, callback)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// get 方法（有所精简）</span></span><br><span class=\"line\">FileSystemCache.prototype.get = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> maxage = <span class=\"keyword\">this</span>.ageTolerance(<span class=\"string\">'maxage'</span>, req)</span><br><span class=\"line\">  <span class=\"comment\">// maxage为0，直接结束</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (maxage === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> done()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\">  <span class=\"comment\">// 获取缓存文件路径</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> file = <span class=\"keyword\">this</span>._file(req)</span><br><span class=\"line\">  fs.open(file, <span class=\"string\">'r'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, fd</span>) </span>&#123;</span><br><span class=\"line\">    fs.fstat(fd, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, stats</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> done(err)</span><br><span class=\"line\">      <span class=\"keyword\">var</span> mtime = stats.mtime.getTime()</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 根据maxage是否过期判断是否直接结束</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> shouldServe = self.shouldServe(mtime, req)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!shouldServe) <span class=\"keyword\">return</span> done()</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 根据refreshage判断是否刷新</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> shouldRefresh = self.shouldRefresh(mtime, req)</span><br><span class=\"line\">      <span class=\"keyword\">var</span> headers = &#123; <span class=\"string\">'Content-Type'</span>: mime(file) &#125;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> Buffer(stats.size)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 如果没有这个文件，直接结束</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!stats.size) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> done(<span class=\"literal\">null</span>, buffer, headers, shouldRefresh)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 如果前面的都通过则读取文件为buffer</span></span><br><span class=\"line\">      fs.read(fd, buffer, <span class=\"number\">0</span>, stats.size, <span class=\"number\">0</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> done(err)</span><br><span class=\"line\">        <span class=\"comment\">// 返回buffer</span></span><br><span class=\"line\">        done(<span class=\"literal\">null</span>, buffer, headers, shouldRefresh)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"tilestrata-blend 插件使用及浅析","date":"2019-07-08T07:19:26.000Z","_content":"\n[tilestrata-blend](https://github.com/naturalatlas/tilestrata-blend)插件可以将多个栅格瓦片图层合并成一个 png 图层，并且支持透明度、混合模式、图层过滤等选项。使用这个插件必须安装依赖[node-mapnik](https://github.com/mapnik/node-mapnik)。这个插件依然是一个利用 mapnik 强大的功能的`Provider`类型的插件，甚至可以基于 mapnik 增强它已有的功能。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-blend --save\n```\n\n# 2. 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst mapnik = require('tilestrata-mapnik')\nconst blend = require('tilestrata-blend')\nconst server = tilestrata()\n\n// 定义第一个世界边界图层\nserver\n  .layer('world_merc')\n  .route('tile.png')\n  .use(disk.cache({ dir: 'tilecache' }))\n  .use(\n    mapnik({\n      pathname: 'style/world.xml'\n    })\n  )\n\n// 定义第二个中国省界图层\nserver\n  .layer('province')\n  .route('tile.png')\n  .use(\n    mapnik({\n      pathname: 'style/province.xml'\n    })\n  )\n\n// 定义混合图层\nserver\n  .layer('blend_layer')\n  .route('combined.png')\n  .use(\n    blend(\n      [\n        ['world_merc', 'tile.png'],\n        [\n          'province',\n          'tile.png',\n          // 配置一些省界图层合并时候的参数\n          {\n            opacity: 0.5,\n            comp_op: 'multiply',\n            image_filters: 'agg-stack-blur(10,10)'\n          }\n        ]\n      ],\n      // 给合并后的图层设置一个可选的填充色\n      {\n        matte: 'ffffff'\n      }\n    )\n  )\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n可以在同一张瓦片上看到黄色的中国省界图层和世界边界图层，下图是没有配置仍和`options`：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-blend-no-option-20190705113008.png)\n\n下图是像上面演示的那样，给省界图层加入了一些`options`，例如 image_filters 和 opacity：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-blend-20190705102810.png)\n\n# 4. 代码浅析\n\n这个插件在背后依赖了[tilestrata-dependency](https://github.com/naturalatlas/tilestrata-dependency)，所以配置里面的`['world_merc', 'tile.png']`实际上是通过执行了`.use(dependency('world_merc_png', 'tile.png'))`操作来获取数据源：\n\n```js\n// 找到每个图层的数据源（代码有所精简）\nvar layers = layers.map(function(pair) {\n  var layer = pair[0]\n  var filename = pair[1]\n  var comp_options = pair[2] || {}\n  return [dependency(layer, filename), comp_options]\n})\n```\n\n当请求某个瓦片时候，对每个`layers`依次执行`fetchTile`获取对应图片和`prepareImage`预处理图片\n\n```js\n// 对每个数据源，获取数据，预处理图片（代码有所精简）\nasync.series(\n  [\n    function fetchTile(callback) {\n      callback(err)\n    },\n    function prepareImage(callback) {\n      // 这一步会创建new mapnik.Image\n      generateMatte(noop)\n    }\n  ],\n  function(err) {\n    callback(err, image ? [image, options] : null)\n  }\n)\n```\n\n完成每个数据源的单独处理后就是合并操作了，利用 mapnik 的[omposite](http://mapnik.org/documentation/node-mapnik/3.6/#Image.composite)方法来依次合并创建的每个`mapnik.Image`对象，最后再利用[demultiply](http://mapnik.org/documentation/node-mapnik/3.6/#Image.demultiply)解构为 buffer 返回给 tilestrata 就好了。\n\n```js\n// （代码有所精简）\nasync.eachSeries(images, function(res, callback) {\n    // 依次合并图片\n    intermediate.composite(image, res[1], callback);\n}, function(err) {\n    // 结构返回buffer\n    intermediate.demultiply(function(err) {\n            callback(null, buffer, {'Content-Type': 'image/png'});\n        });\n    });\n});\n```\n","source":"_posts/2019/tilestrata-blend.md","raw":"---\ntitle: tilestrata-blend 插件使用及浅析\ndate: 2019-07-08 15:19:26\ntags: [GIS]\ncategories: TileStrata\n---\n\n[tilestrata-blend](https://github.com/naturalatlas/tilestrata-blend)插件可以将多个栅格瓦片图层合并成一个 png 图层，并且支持透明度、混合模式、图层过滤等选项。使用这个插件必须安装依赖[node-mapnik](https://github.com/mapnik/node-mapnik)。这个插件依然是一个利用 mapnik 强大的功能的`Provider`类型的插件，甚至可以基于 mapnik 增强它已有的功能。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-blend --save\n```\n\n# 2. 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst mapnik = require('tilestrata-mapnik')\nconst blend = require('tilestrata-blend')\nconst server = tilestrata()\n\n// 定义第一个世界边界图层\nserver\n  .layer('world_merc')\n  .route('tile.png')\n  .use(disk.cache({ dir: 'tilecache' }))\n  .use(\n    mapnik({\n      pathname: 'style/world.xml'\n    })\n  )\n\n// 定义第二个中国省界图层\nserver\n  .layer('province')\n  .route('tile.png')\n  .use(\n    mapnik({\n      pathname: 'style/province.xml'\n    })\n  )\n\n// 定义混合图层\nserver\n  .layer('blend_layer')\n  .route('combined.png')\n  .use(\n    blend(\n      [\n        ['world_merc', 'tile.png'],\n        [\n          'province',\n          'tile.png',\n          // 配置一些省界图层合并时候的参数\n          {\n            opacity: 0.5,\n            comp_op: 'multiply',\n            image_filters: 'agg-stack-blur(10,10)'\n          }\n        ]\n      ],\n      // 给合并后的图层设置一个可选的填充色\n      {\n        matte: 'ffffff'\n      }\n    )\n  )\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n可以在同一张瓦片上看到黄色的中国省界图层和世界边界图层，下图是没有配置仍和`options`：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-blend-no-option-20190705113008.png)\n\n下图是像上面演示的那样，给省界图层加入了一些`options`，例如 image_filters 和 opacity：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-blend-20190705102810.png)\n\n# 4. 代码浅析\n\n这个插件在背后依赖了[tilestrata-dependency](https://github.com/naturalatlas/tilestrata-dependency)，所以配置里面的`['world_merc', 'tile.png']`实际上是通过执行了`.use(dependency('world_merc_png', 'tile.png'))`操作来获取数据源：\n\n```js\n// 找到每个图层的数据源（代码有所精简）\nvar layers = layers.map(function(pair) {\n  var layer = pair[0]\n  var filename = pair[1]\n  var comp_options = pair[2] || {}\n  return [dependency(layer, filename), comp_options]\n})\n```\n\n当请求某个瓦片时候，对每个`layers`依次执行`fetchTile`获取对应图片和`prepareImage`预处理图片\n\n```js\n// 对每个数据源，获取数据，预处理图片（代码有所精简）\nasync.series(\n  [\n    function fetchTile(callback) {\n      callback(err)\n    },\n    function prepareImage(callback) {\n      // 这一步会创建new mapnik.Image\n      generateMatte(noop)\n    }\n  ],\n  function(err) {\n    callback(err, image ? [image, options] : null)\n  }\n)\n```\n\n完成每个数据源的单独处理后就是合并操作了，利用 mapnik 的[omposite](http://mapnik.org/documentation/node-mapnik/3.6/#Image.composite)方法来依次合并创建的每个`mapnik.Image`对象，最后再利用[demultiply](http://mapnik.org/documentation/node-mapnik/3.6/#Image.demultiply)解构为 buffer 返回给 tilestrata 就好了。\n\n```js\n// （代码有所精简）\nasync.eachSeries(images, function(res, callback) {\n    // 依次合并图片\n    intermediate.composite(image, res[1], callback);\n}, function(err) {\n    // 结构返回buffer\n    intermediate.demultiply(function(err) {\n            callback(null, buffer, {'Content-Type': 'image/png'});\n        });\n    });\n});\n```\n","slug":"tilestrata-blend","published":1,"updated":"2019-07-08T07:23:13.198Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrkxgt4000gi83ikh73mun4","content":"<p><a href=\"https://github.com/naturalatlas/tilestrata-blend\" target=\"_blank\" rel=\"noopener\">tilestrata-blend</a>插件可以将多个栅格瓦片图层合并成一个 png 图层，并且支持透明度、混合模式、图层过滤等选项。使用这个插件必须安装依赖<a href=\"https://github.com/mapnik/node-mapnik\" target=\"_blank\" rel=\"noopener\">node-mapnik</a>。这个插件依然是一个利用 mapnik 强大的功能的<code>Provider</code>类型的插件，甚至可以基于 mapnik 增强它已有的功能。</p>\n<a id=\"more\"></a>\n<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-blend --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> blend = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-blend'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义第一个世界边界图层</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'world_merc'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(disk.cache(&#123; <span class=\"attr\">dir</span>: <span class=\"string\">'tilecache'</span> &#125;))</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/world.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义第二个中国省界图层</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'province'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/province.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义混合图层</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'blend_layer'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'combined.png'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    blend(</span><br><span class=\"line\">      [</span><br><span class=\"line\">        [<span class=\"string\">'world_merc'</span>, <span class=\"string\">'tile.png'</span>],</span><br><span class=\"line\">        [</span><br><span class=\"line\">          <span class=\"string\">'province'</span>,</span><br><span class=\"line\">          <span class=\"string\">'tile.png'</span>,</span><br><span class=\"line\">          <span class=\"comment\">// 配置一些省界图层合并时候的参数</span></span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            opacity: <span class=\"number\">0.5</span>,</span><br><span class=\"line\">            comp_op: <span class=\"string\">'multiply'</span>,</span><br><span class=\"line\">            image_filters: <span class=\"string\">'agg-stack-blur(10,10)'</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      ],</span><br><span class=\"line\">      <span class=\"comment\">// 给合并后的图层设置一个可选的填充色</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        matte: <span class=\"string\">'ffffff'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>可以在同一张瓦片上看到黄色的中国省界图层和世界边界图层，下图是没有配置仍和<code>options</code>：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-blend-no-option-20190705113008.png\" alt></p>\n<p>下图是像上面演示的那样，给省界图层加入了一些<code>options</code>，例如 image_filters 和 opacity：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-blend-20190705102810.png\" alt></p>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>这个插件在背后依赖了<a href=\"https://github.com/naturalatlas/tilestrata-dependency\" target=\"_blank\" rel=\"noopener\">tilestrata-dependency</a>，所以配置里面的<code>[&#39;world_merc&#39;, &#39;tile.png&#39;]</code>实际上是通过执行了<code>.use(dependency(&#39;world_merc_png&#39;, &#39;tile.png&#39;))</code>操作来获取数据源：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 找到每个图层的数据源（代码有所精简）</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> layers = layers.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">pair</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> layer = pair[<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"keyword\">var</span> filename = pair[<span class=\"number\">1</span>]</span><br><span class=\"line\">  <span class=\"keyword\">var</span> comp_options = pair[<span class=\"number\">2</span>] || &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [dependency(layer, filename), comp_options]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>当请求某个瓦片时候，对每个<code>layers</code>依次执行<code>fetchTile</code>获取对应图片和<code>prepareImage</code>预处理图片</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对每个数据源，获取数据，预处理图片（代码有所精简）</span></span><br><span class=\"line\"><span class=\"keyword\">async</span>.series(</span><br><span class=\"line\">  [</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetchTile</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">      callback(err)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">prepareImage</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 这一步会创建new mapnik.Image</span></span><br><span class=\"line\">      generateMatte(noop)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    callback(err, image ? [image, options] : <span class=\"literal\">null</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>完成每个数据源的单独处理后就是合并操作了，利用 mapnik 的<a href=\"http://mapnik.org/documentation/node-mapnik/3.6/#Image.composite\" target=\"_blank\" rel=\"noopener\">omposite</a>方法来依次合并创建的每个<code>mapnik.Image</code>对象，最后再利用<a href=\"http://mapnik.org/documentation/node-mapnik/3.6/#Image.demultiply\" target=\"_blank\" rel=\"noopener\">demultiply</a>解构为 buffer 返回给 tilestrata 就好了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// （代码有所精简）</span></span><br><span class=\"line\"><span class=\"keyword\">async</span>.eachSeries(images, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 依次合并图片</span></span><br><span class=\"line\">    intermediate.composite(image, res[<span class=\"number\">1</span>], callback);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 结构返回buffer</span></span><br><span class=\"line\">    intermediate.demultiply(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">            callback(<span class=\"literal\">null</span>, buffer, &#123;<span class=\"string\">'Content-Type'</span>: <span class=\"string\">'image/png'</span>&#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/naturalatlas/tilestrata-blend\" target=\"_blank\" rel=\"noopener\">tilestrata-blend</a>插件可以将多个栅格瓦片图层合并成一个 png 图层，并且支持透明度、混合模式、图层过滤等选项。使用这个插件必须安装依赖<a href=\"https://github.com/mapnik/node-mapnik\" target=\"_blank\" rel=\"noopener\">node-mapnik</a>。这个插件依然是一个利用 mapnik 强大的功能的<code>Provider</code>类型的插件，甚至可以基于 mapnik 增强它已有的功能。</p>","more":"<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-blend --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> blend = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-blend'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义第一个世界边界图层</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'world_merc'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(disk.cache(&#123; <span class=\"attr\">dir</span>: <span class=\"string\">'tilecache'</span> &#125;))</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/world.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义第二个中国省界图层</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'province'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/province.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义混合图层</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'blend_layer'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'combined.png'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    blend(</span><br><span class=\"line\">      [</span><br><span class=\"line\">        [<span class=\"string\">'world_merc'</span>, <span class=\"string\">'tile.png'</span>],</span><br><span class=\"line\">        [</span><br><span class=\"line\">          <span class=\"string\">'province'</span>,</span><br><span class=\"line\">          <span class=\"string\">'tile.png'</span>,</span><br><span class=\"line\">          <span class=\"comment\">// 配置一些省界图层合并时候的参数</span></span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            opacity: <span class=\"number\">0.5</span>,</span><br><span class=\"line\">            comp_op: <span class=\"string\">'multiply'</span>,</span><br><span class=\"line\">            image_filters: <span class=\"string\">'agg-stack-blur(10,10)'</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      ],</span><br><span class=\"line\">      <span class=\"comment\">// 给合并后的图层设置一个可选的填充色</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        matte: <span class=\"string\">'ffffff'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>可以在同一张瓦片上看到黄色的中国省界图层和世界边界图层，下图是没有配置仍和<code>options</code>：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-blend-no-option-20190705113008.png\" alt></p>\n<p>下图是像上面演示的那样，给省界图层加入了一些<code>options</code>，例如 image_filters 和 opacity：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-blend-20190705102810.png\" alt></p>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>这个插件在背后依赖了<a href=\"https://github.com/naturalatlas/tilestrata-dependency\" target=\"_blank\" rel=\"noopener\">tilestrata-dependency</a>，所以配置里面的<code>[&#39;world_merc&#39;, &#39;tile.png&#39;]</code>实际上是通过执行了<code>.use(dependency(&#39;world_merc_png&#39;, &#39;tile.png&#39;))</code>操作来获取数据源：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 找到每个图层的数据源（代码有所精简）</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> layers = layers.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">pair</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> layer = pair[<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"keyword\">var</span> filename = pair[<span class=\"number\">1</span>]</span><br><span class=\"line\">  <span class=\"keyword\">var</span> comp_options = pair[<span class=\"number\">2</span>] || &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [dependency(layer, filename), comp_options]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>当请求某个瓦片时候，对每个<code>layers</code>依次执行<code>fetchTile</code>获取对应图片和<code>prepareImage</code>预处理图片</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对每个数据源，获取数据，预处理图片（代码有所精简）</span></span><br><span class=\"line\"><span class=\"keyword\">async</span>.series(</span><br><span class=\"line\">  [</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetchTile</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">      callback(err)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">prepareImage</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 这一步会创建new mapnik.Image</span></span><br><span class=\"line\">      generateMatte(noop)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    callback(err, image ? [image, options] : <span class=\"literal\">null</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>完成每个数据源的单独处理后就是合并操作了，利用 mapnik 的<a href=\"http://mapnik.org/documentation/node-mapnik/3.6/#Image.composite\" target=\"_blank\" rel=\"noopener\">omposite</a>方法来依次合并创建的每个<code>mapnik.Image</code>对象，最后再利用<a href=\"http://mapnik.org/documentation/node-mapnik/3.6/#Image.demultiply\" target=\"_blank\" rel=\"noopener\">demultiply</a>解构为 buffer 返回给 tilestrata 就好了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// （代码有所精简）</span></span><br><span class=\"line\"><span class=\"keyword\">async</span>.eachSeries(images, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 依次合并图片</span></span><br><span class=\"line\">    intermediate.composite(image, res[<span class=\"number\">1</span>], callback);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 结构返回buffer</span></span><br><span class=\"line\">    intermediate.demultiply(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">            callback(<span class=\"literal\">null</span>, buffer, &#123;<span class=\"string\">'Content-Type'</span>: <span class=\"string\">'image/png'</span>&#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>"},{"title":"用PostGIS生成mvt格式的矢量瓦片","date":"2019-06-10T07:05:16.000Z","_content":"\nPostGIS 从 2.4.0 版本开始支持通过 box 生成 mvt 数据，我们用尽可能简单的方法搭建一个生产 mvt 数据的测试数据库。\n\n<!-- more -->\n\n基础工作环境：\n\n1. [docker](https://docs.docker.com/install/)\n2. [nodejs 8](https://nodejs.org/en/)\n\n# 1. 数据源\n\n从[geofabrik](http://download.geofabrik.de/)上我们可以下载的分好地区的[OpenStreetMap](https://www.openstreetmap.org/)数据，这样可以得到一个比较小的测试数据集。可以通过下面的地址下载到最新的中国区域数据：\n\n```bash\n# 直接下载国区的数据\nhttp://download.geofabrik.de/asia/china-latest.osm.pbf\n```\n\n# 2. 准备 PostGIS 环境\n\n我们直接用[mdillon/postgis](https://hub.docker.com/r/mdillon/postgis/)的 docker 镜像跑一个 PostGIS 数据库：\n\n```bash\n# 创建一个名称为gis网络\ndocker network create gis\ndocker run -d --name postgis -e POSTGRES_USER=gis --network gis -p 6543:5432 mdillon/postgis:10\n```\n\n这个镜像可以通过`POSTGRES_PASSWORD`指定数据库密码，如果没指定的话，密码会和`POSTGRES_USER`即用户名保持一致。\n\n建议通过`-p 5432:5432`映射下端口，方便我们在宿主机上直接连接调试。\n\n# 3. 导入 osm 数据到 PostGIS\n\n我们用[imposm3](https://github.com/omniscale/imposm3)来导入 osm 数据到库中。\n\nimposm3 主要需要配置 cache 目录（可选），connection 链接地址（必须）和 mapping 映射文件（必须）三个参数，官方仓库提供了一个[mapping 样例](https://github.com/omniscale/imposm3/blob/master/example-mapping.json)供参考。这里我们方便测试，就用这个[简单版本](https://blog-1255388623.cos.ap-shanghai.myqcloud.com/static/mapping.json)，定义了`admim、amenities、buildings`三张表。\n\n准备一个文件夹，把下载的 pbf 和 mapping 文件丢进去，再创建 cache 目录\n\n依然用上强大的 docker，[jawg/imposm3](https://hub.docker.com/r/jawg/imposm3/)可以帮助我们方便的执行 imposm3 操作。\n\n```\ndocker run --network gis --rm \\\n-v $(pwd)/cache:/tmp/imposm3 \\\n-v $(pwd)/china-latest.osm.pbf:/opt/imposm3/china-latest.osm.pbf \\\n-v $(pwd)/mapping.json:/opt/imposm3/mapping.json \\\njawg/imposm3 import \\\n-mapping mapping.json \\\n-read china-latest.osm.pbf \\\n-overwritecache -write -connection 'postgis://gis:gis@postgis/gis'\n```\n\n耐心等待导入完成，可以直接进入 docker 查看数据情况：\n\n```\ndocker exec -it postgis psql gis gis\n```\n\n或者通过第三方软件连接数据库，可以看到 import 导入的三张表：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/osm_mvt_postgis.png)\n\n# 4. 执行 SQL 脚本\n\n在数据库中执行 mapbox 提供的[TileBBox](https://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql)脚本，创建 TileBBox 函数\n\n```\nhttps://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql\n```\n\n这个函数的作用就是传入指定的`x,y,z`瓦片序列，转换成 MVT 需要的`tile coordinate space`，通常是 4096x4096 的网格\n\n# 5. 测试数据结果\n\nmvt 瓦片生成的关键就是[ST_AsMVT](https://postgis.net/docs/ST_AsMVT.html)和[ST_AsMVTGeom](https://postgis.net/docs/ST_AsMVTGeom.html)两个函数，所以可以直接调用来做个测试，这里查询`z=14,y=12917,6430`的瓦片对应的 mvt 数据\n\n先查询出范围内的 geometry，并转化成 mvt 需要的格式\n\n```sql\nSELECT ST_AsMVTGeom(\n   ST_Transform(\n\t  import.osm_buildings.geometry, 3857),\n\t  TileBBox(14, 12917, 6430, 3857),\n\t  256,\n\t  10,\n      true\n   ) geom, name\nFROM import.osm_buildings\nWHERE ST_Intersects(TileBBox(14, 12917, 6430, 3857), import.osm_buildings.geometry)\n```\n\n得到结果应该如下：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/asmvtgeom_result.png)\n\n再使用 ST_AsMVT 进行转换就行，完成的合并后的 sql 如下：\n\n```sql\nSELECT ST_AsMVT(q, 'osm_mvt', 256, 'geom') AS mvt\nFROM (\n  SELECT ST_AsMVTGeom(\n    ST_Transform(\n\t  import.osm_buildings.geometry, 3857),\n\t  TileBBox(14, 12917, 6430, 3857),\n\t  256,\n\t  10,\n      true\n  ) geom , name\n  FROM import.osm_buildings\n  WHERE ST_Intersects(TileBBox(14, 12917, 6430, 3857), import.osm_buildings.geometry)\n) AS q\n```\n\n# 6. 数据展示\n\n完整的地图区域数据前端展示可以使用 tilestrata 这个服务端工具，配合 tilestrata-postgismvt 插件就可以生成供地图调用的瓦片。\n\n具体的 demo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n对应的文章可以看一下这篇[tilestrata-postgismvt 使用](http://kael.top/2019/06/13/tilestrata-postgismvt/)\n\nclone 项目[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)，将项目里面`src/mvt/`目录下[index.js](https://github.com/zzcyrus/tilestrata-sample-code/blob/master/src/mvt/index.js)的`pgConfig`改成你的设置\n\n安装依赖，启动项目\n\n```\nnpm install\nnpm start\n```\n\n访问`example/mvt.html`就可以看到结果了。\n\n我们导入了三张表，分别是边界数据（蓝色）、设施（红点）和建筑（紫色），全部叠加之后如下图所示：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/mvt_preview.png)\n\n# 参考文档\n\n[https://blog.jawg.io/how-to-make-mvt-with-postgis/](https://blog.jawg.io/how-to-make-mvt-with-postgis/)\n","source":"_posts/2019/osm-postgis-mvt.md","raw":"---\ntitle: 用PostGIS生成mvt格式的矢量瓦片\ndate: 2019-06-10 15:05:16\ntags: [GIS]\ncategories: PostGIS\n---\n\nPostGIS 从 2.4.0 版本开始支持通过 box 生成 mvt 数据，我们用尽可能简单的方法搭建一个生产 mvt 数据的测试数据库。\n\n<!-- more -->\n\n基础工作环境：\n\n1. [docker](https://docs.docker.com/install/)\n2. [nodejs 8](https://nodejs.org/en/)\n\n# 1. 数据源\n\n从[geofabrik](http://download.geofabrik.de/)上我们可以下载的分好地区的[OpenStreetMap](https://www.openstreetmap.org/)数据，这样可以得到一个比较小的测试数据集。可以通过下面的地址下载到最新的中国区域数据：\n\n```bash\n# 直接下载国区的数据\nhttp://download.geofabrik.de/asia/china-latest.osm.pbf\n```\n\n# 2. 准备 PostGIS 环境\n\n我们直接用[mdillon/postgis](https://hub.docker.com/r/mdillon/postgis/)的 docker 镜像跑一个 PostGIS 数据库：\n\n```bash\n# 创建一个名称为gis网络\ndocker network create gis\ndocker run -d --name postgis -e POSTGRES_USER=gis --network gis -p 6543:5432 mdillon/postgis:10\n```\n\n这个镜像可以通过`POSTGRES_PASSWORD`指定数据库密码，如果没指定的话，密码会和`POSTGRES_USER`即用户名保持一致。\n\n建议通过`-p 5432:5432`映射下端口，方便我们在宿主机上直接连接调试。\n\n# 3. 导入 osm 数据到 PostGIS\n\n我们用[imposm3](https://github.com/omniscale/imposm3)来导入 osm 数据到库中。\n\nimposm3 主要需要配置 cache 目录（可选），connection 链接地址（必须）和 mapping 映射文件（必须）三个参数，官方仓库提供了一个[mapping 样例](https://github.com/omniscale/imposm3/blob/master/example-mapping.json)供参考。这里我们方便测试，就用这个[简单版本](https://blog-1255388623.cos.ap-shanghai.myqcloud.com/static/mapping.json)，定义了`admim、amenities、buildings`三张表。\n\n准备一个文件夹，把下载的 pbf 和 mapping 文件丢进去，再创建 cache 目录\n\n依然用上强大的 docker，[jawg/imposm3](https://hub.docker.com/r/jawg/imposm3/)可以帮助我们方便的执行 imposm3 操作。\n\n```\ndocker run --network gis --rm \\\n-v $(pwd)/cache:/tmp/imposm3 \\\n-v $(pwd)/china-latest.osm.pbf:/opt/imposm3/china-latest.osm.pbf \\\n-v $(pwd)/mapping.json:/opt/imposm3/mapping.json \\\njawg/imposm3 import \\\n-mapping mapping.json \\\n-read china-latest.osm.pbf \\\n-overwritecache -write -connection 'postgis://gis:gis@postgis/gis'\n```\n\n耐心等待导入完成，可以直接进入 docker 查看数据情况：\n\n```\ndocker exec -it postgis psql gis gis\n```\n\n或者通过第三方软件连接数据库，可以看到 import 导入的三张表：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/osm_mvt_postgis.png)\n\n# 4. 执行 SQL 脚本\n\n在数据库中执行 mapbox 提供的[TileBBox](https://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql)脚本，创建 TileBBox 函数\n\n```\nhttps://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql\n```\n\n这个函数的作用就是传入指定的`x,y,z`瓦片序列，转换成 MVT 需要的`tile coordinate space`，通常是 4096x4096 的网格\n\n# 5. 测试数据结果\n\nmvt 瓦片生成的关键就是[ST_AsMVT](https://postgis.net/docs/ST_AsMVT.html)和[ST_AsMVTGeom](https://postgis.net/docs/ST_AsMVTGeom.html)两个函数，所以可以直接调用来做个测试，这里查询`z=14,y=12917,6430`的瓦片对应的 mvt 数据\n\n先查询出范围内的 geometry，并转化成 mvt 需要的格式\n\n```sql\nSELECT ST_AsMVTGeom(\n   ST_Transform(\n\t  import.osm_buildings.geometry, 3857),\n\t  TileBBox(14, 12917, 6430, 3857),\n\t  256,\n\t  10,\n      true\n   ) geom, name\nFROM import.osm_buildings\nWHERE ST_Intersects(TileBBox(14, 12917, 6430, 3857), import.osm_buildings.geometry)\n```\n\n得到结果应该如下：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/asmvtgeom_result.png)\n\n再使用 ST_AsMVT 进行转换就行，完成的合并后的 sql 如下：\n\n```sql\nSELECT ST_AsMVT(q, 'osm_mvt', 256, 'geom') AS mvt\nFROM (\n  SELECT ST_AsMVTGeom(\n    ST_Transform(\n\t  import.osm_buildings.geometry, 3857),\n\t  TileBBox(14, 12917, 6430, 3857),\n\t  256,\n\t  10,\n      true\n  ) geom , name\n  FROM import.osm_buildings\n  WHERE ST_Intersects(TileBBox(14, 12917, 6430, 3857), import.osm_buildings.geometry)\n) AS q\n```\n\n# 6. 数据展示\n\n完整的地图区域数据前端展示可以使用 tilestrata 这个服务端工具，配合 tilestrata-postgismvt 插件就可以生成供地图调用的瓦片。\n\n具体的 demo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n对应的文章可以看一下这篇[tilestrata-postgismvt 使用](http://kael.top/2019/06/13/tilestrata-postgismvt/)\n\nclone 项目[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)，将项目里面`src/mvt/`目录下[index.js](https://github.com/zzcyrus/tilestrata-sample-code/blob/master/src/mvt/index.js)的`pgConfig`改成你的设置\n\n安装依赖，启动项目\n\n```\nnpm install\nnpm start\n```\n\n访问`example/mvt.html`就可以看到结果了。\n\n我们导入了三张表，分别是边界数据（蓝色）、设施（红点）和建筑（紫色），全部叠加之后如下图所示：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/mvt_preview.png)\n\n# 参考文档\n\n[https://blog.jawg.io/how-to-make-mvt-with-postgis/](https://blog.jawg.io/how-to-make-mvt-with-postgis/)\n","slug":"osm-postgis-mvt","published":1,"updated":"2019-08-01T10:08:54.927Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrkxgt5000hi83i4owzzs9k","content":"<p>PostGIS 从 2.4.0 版本开始支持通过 box 生成 mvt 数据，我们用尽可能简单的方法搭建一个生产 mvt 数据的测试数据库。</p>\n<a id=\"more\"></a>\n<p>基础工作环境：</p>\n<ol>\n<li><a href=\"https://docs.docker.com/install/\" target=\"_blank\" rel=\"noopener\">docker</a></li>\n<li><a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">nodejs 8</a></li>\n</ol>\n<h1 id=\"1-数据源\"><a href=\"#1-数据源\" class=\"headerlink\" title=\"1. 数据源\"></a>1. 数据源</h1><p>从<a href=\"http://download.geofabrik.de/\" target=\"_blank\" rel=\"noopener\">geofabrik</a>上我们可以下载的分好地区的<a href=\"https://www.openstreetmap.org/\" target=\"_blank\" rel=\"noopener\">OpenStreetMap</a>数据，这样可以得到一个比较小的测试数据集。可以通过下面的地址下载到最新的中国区域数据：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 直接下载国区的数据</span></span><br><span class=\"line\">http://download.geofabrik.de/asia/china-latest.osm.pbf</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-准备-PostGIS-环境\"><a href=\"#2-准备-PostGIS-环境\" class=\"headerlink\" title=\"2. 准备 PostGIS 环境\"></a>2. 准备 PostGIS 环境</h1><p>我们直接用<a href=\"https://hub.docker.com/r/mdillon/postgis/\" target=\"_blank\" rel=\"noopener\">mdillon/postgis</a>的 docker 镜像跑一个 PostGIS 数据库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建一个名称为gis网络</span></span><br><span class=\"line\">docker network create gis</span><br><span class=\"line\">docker run -d --name postgis -e POSTGRES_USER=gis --network gis -p 6543:5432 mdillon/postgis:10</span><br></pre></td></tr></table></figure>\n<p>这个镜像可以通过<code>POSTGRES_PASSWORD</code>指定数据库密码，如果没指定的话，密码会和<code>POSTGRES_USER</code>即用户名保持一致。</p>\n<p>建议通过<code>-p 5432:5432</code>映射下端口，方便我们在宿主机上直接连接调试。</p>\n<h1 id=\"3-导入-osm-数据到-PostGIS\"><a href=\"#3-导入-osm-数据到-PostGIS\" class=\"headerlink\" title=\"3. 导入 osm 数据到 PostGIS\"></a>3. 导入 osm 数据到 PostGIS</h1><p>我们用<a href=\"https://github.com/omniscale/imposm3\" target=\"_blank\" rel=\"noopener\">imposm3</a>来导入 osm 数据到库中。</p>\n<p>imposm3 主要需要配置 cache 目录（可选），connection 链接地址（必须）和 mapping 映射文件（必须）三个参数，官方仓库提供了一个<a href=\"https://github.com/omniscale/imposm3/blob/master/example-mapping.json\" target=\"_blank\" rel=\"noopener\">mapping 样例</a>供参考。这里我们方便测试，就用这个<a href=\"https://blog-1255388623.cos.ap-shanghai.myqcloud.com/static/mapping.json\" target=\"_blank\" rel=\"noopener\">简单版本</a>，定义了<code>admim、amenities、buildings</code>三张表。</p>\n<p>准备一个文件夹，把下载的 pbf 和 mapping 文件丢进去，再创建 cache 目录</p>\n<p>依然用上强大的 docker，<a href=\"https://hub.docker.com/r/jawg/imposm3/\" target=\"_blank\" rel=\"noopener\">jawg/imposm3</a>可以帮助我们方便的执行 imposm3 操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run --network gis --rm \\</span><br><span class=\"line\">-v $(pwd)/cache:/tmp/imposm3 \\</span><br><span class=\"line\">-v $(pwd)/china-latest.osm.pbf:/opt/imposm3/china-latest.osm.pbf \\</span><br><span class=\"line\">-v $(pwd)/mapping.json:/opt/imposm3/mapping.json \\</span><br><span class=\"line\">jawg/imposm3 import \\</span><br><span class=\"line\">-mapping mapping.json \\</span><br><span class=\"line\">-read china-latest.osm.pbf \\</span><br><span class=\"line\">-overwritecache -write -connection &apos;postgis://gis:gis@postgis/gis&apos;</span><br></pre></td></tr></table></figure>\n<p>耐心等待导入完成，可以直接进入 docker 查看数据情况：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker exec -it postgis psql gis gis</span><br></pre></td></tr></table></figure>\n<p>或者通过第三方软件连接数据库，可以看到 import 导入的三张表：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/osm_mvt_postgis.png\" alt></p>\n<h1 id=\"4-执行-SQL-脚本\"><a href=\"#4-执行-SQL-脚本\" class=\"headerlink\" title=\"4. 执行 SQL 脚本\"></a>4. 执行 SQL 脚本</h1><p>在数据库中执行 mapbox 提供的<a href=\"https://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql\" target=\"_blank\" rel=\"noopener\">TileBBox</a>脚本，创建 TileBBox 函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql</span><br></pre></td></tr></table></figure>\n<p>这个函数的作用就是传入指定的<code>x,y,z</code>瓦片序列，转换成 MVT 需要的<code>tile coordinate space</code>，通常是 4096x4096 的网格</p>\n<h1 id=\"5-测试数据结果\"><a href=\"#5-测试数据结果\" class=\"headerlink\" title=\"5. 测试数据结果\"></a>5. 测试数据结果</h1><p>mvt 瓦片生成的关键就是<a href=\"https://postgis.net/docs/ST_AsMVT.html\" target=\"_blank\" rel=\"noopener\">ST_AsMVT</a>和<a href=\"https://postgis.net/docs/ST_AsMVTGeom.html\" target=\"_blank\" rel=\"noopener\">ST_AsMVTGeom</a>两个函数，所以可以直接调用来做个测试，这里查询<code>z=14,y=12917,6430</code>的瓦片对应的 mvt 数据</p>\n<p>先查询出范围内的 geometry，并转化成 mvt 需要的格式</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> ST_AsMVTGeom(</span><br><span class=\"line\">   ST_Transform(</span><br><span class=\"line\">\t  import.osm_buildings.geometry, <span class=\"number\">3857</span>),</span><br><span class=\"line\">\t  TileBBox(<span class=\"number\">14</span>, <span class=\"number\">12917</span>, <span class=\"number\">6430</span>, <span class=\"number\">3857</span>),</span><br><span class=\"line\">\t  <span class=\"number\">256</span>,</span><br><span class=\"line\">\t  <span class=\"number\">10</span>,</span><br><span class=\"line\">      <span class=\"literal\">true</span></span><br><span class=\"line\">   ) geom, <span class=\"keyword\">name</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> import.osm_buildings</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> ST_Intersects(TileBBox(<span class=\"number\">14</span>, <span class=\"number\">12917</span>, <span class=\"number\">6430</span>, <span class=\"number\">3857</span>), import.osm_buildings.geometry)</span><br></pre></td></tr></table></figure>\n<p>得到结果应该如下：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/asmvtgeom_result.png\" alt></p>\n<p>再使用 ST_AsMVT 进行转换就行，完成的合并后的 sql 如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> ST_AsMVT(q, <span class=\"string\">'osm_mvt'</span>, <span class=\"number\">256</span>, <span class=\"string\">'geom'</span>) <span class=\"keyword\">AS</span> mvt</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> (</span><br><span class=\"line\">  <span class=\"keyword\">SELECT</span> ST_AsMVTGeom(</span><br><span class=\"line\">    ST_Transform(</span><br><span class=\"line\">\t  import.osm_buildings.geometry, <span class=\"number\">3857</span>),</span><br><span class=\"line\">\t  TileBBox(<span class=\"number\">14</span>, <span class=\"number\">12917</span>, <span class=\"number\">6430</span>, <span class=\"number\">3857</span>),</span><br><span class=\"line\">\t  <span class=\"number\">256</span>,</span><br><span class=\"line\">\t  <span class=\"number\">10</span>,</span><br><span class=\"line\">      <span class=\"literal\">true</span></span><br><span class=\"line\">  ) geom , <span class=\"keyword\">name</span></span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> import.osm_buildings</span><br><span class=\"line\">  <span class=\"keyword\">WHERE</span> ST_Intersects(TileBBox(<span class=\"number\">14</span>, <span class=\"number\">12917</span>, <span class=\"number\">6430</span>, <span class=\"number\">3857</span>), import.osm_buildings.geometry)</span><br><span class=\"line\">) <span class=\"keyword\">AS</span> q</span><br></pre></td></tr></table></figure>\n<h1 id=\"6-数据展示\"><a href=\"#6-数据展示\" class=\"headerlink\" title=\"6. 数据展示\"></a>6. 数据展示</h1><p>完整的地图区域数据前端展示可以使用 tilestrata 这个服务端工具，配合 tilestrata-postgismvt 插件就可以生成供地图调用的瓦片。</p>\n<p>具体的 demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>对应的文章可以看一下这篇<a href=\"http://kael.top/2019/06/13/tilestrata-postgismvt/\">tilestrata-postgismvt 使用</a></p>\n<p>clone 项目<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a>，将项目里面<code>src/mvt/</code>目录下<a href=\"https://github.com/zzcyrus/tilestrata-sample-code/blob/master/src/mvt/index.js\" target=\"_blank\" rel=\"noopener\">index.js</a>的<code>pgConfig</code>改成你的设置</p>\n<p>安装依赖，启动项目</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<p>访问<code>example/mvt.html</code>就可以看到结果了。</p>\n<p>我们导入了三张表，分别是边界数据（蓝色）、设施（红点）和建筑（紫色），全部叠加之后如下图所示：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/mvt_preview.png\" alt></p>\n<h1 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h1><p><a href=\"https://blog.jawg.io/how-to-make-mvt-with-postgis/\" target=\"_blank\" rel=\"noopener\">https://blog.jawg.io/how-to-make-mvt-with-postgis/</a></p>\n","site":{"data":{}},"excerpt":"<p>PostGIS 从 2.4.0 版本开始支持通过 box 生成 mvt 数据，我们用尽可能简单的方法搭建一个生产 mvt 数据的测试数据库。</p>","more":"<p>基础工作环境：</p>\n<ol>\n<li><a href=\"https://docs.docker.com/install/\" target=\"_blank\" rel=\"noopener\">docker</a></li>\n<li><a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">nodejs 8</a></li>\n</ol>\n<h1 id=\"1-数据源\"><a href=\"#1-数据源\" class=\"headerlink\" title=\"1. 数据源\"></a>1. 数据源</h1><p>从<a href=\"http://download.geofabrik.de/\" target=\"_blank\" rel=\"noopener\">geofabrik</a>上我们可以下载的分好地区的<a href=\"https://www.openstreetmap.org/\" target=\"_blank\" rel=\"noopener\">OpenStreetMap</a>数据，这样可以得到一个比较小的测试数据集。可以通过下面的地址下载到最新的中国区域数据：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 直接下载国区的数据</span></span><br><span class=\"line\">http://download.geofabrik.de/asia/china-latest.osm.pbf</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-准备-PostGIS-环境\"><a href=\"#2-准备-PostGIS-环境\" class=\"headerlink\" title=\"2. 准备 PostGIS 环境\"></a>2. 准备 PostGIS 环境</h1><p>我们直接用<a href=\"https://hub.docker.com/r/mdillon/postgis/\" target=\"_blank\" rel=\"noopener\">mdillon/postgis</a>的 docker 镜像跑一个 PostGIS 数据库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建一个名称为gis网络</span></span><br><span class=\"line\">docker network create gis</span><br><span class=\"line\">docker run -d --name postgis -e POSTGRES_USER=gis --network gis -p 6543:5432 mdillon/postgis:10</span><br></pre></td></tr></table></figure>\n<p>这个镜像可以通过<code>POSTGRES_PASSWORD</code>指定数据库密码，如果没指定的话，密码会和<code>POSTGRES_USER</code>即用户名保持一致。</p>\n<p>建议通过<code>-p 5432:5432</code>映射下端口，方便我们在宿主机上直接连接调试。</p>\n<h1 id=\"3-导入-osm-数据到-PostGIS\"><a href=\"#3-导入-osm-数据到-PostGIS\" class=\"headerlink\" title=\"3. 导入 osm 数据到 PostGIS\"></a>3. 导入 osm 数据到 PostGIS</h1><p>我们用<a href=\"https://github.com/omniscale/imposm3\" target=\"_blank\" rel=\"noopener\">imposm3</a>来导入 osm 数据到库中。</p>\n<p>imposm3 主要需要配置 cache 目录（可选），connection 链接地址（必须）和 mapping 映射文件（必须）三个参数，官方仓库提供了一个<a href=\"https://github.com/omniscale/imposm3/blob/master/example-mapping.json\" target=\"_blank\" rel=\"noopener\">mapping 样例</a>供参考。这里我们方便测试，就用这个<a href=\"https://blog-1255388623.cos.ap-shanghai.myqcloud.com/static/mapping.json\" target=\"_blank\" rel=\"noopener\">简单版本</a>，定义了<code>admim、amenities、buildings</code>三张表。</p>\n<p>准备一个文件夹，把下载的 pbf 和 mapping 文件丢进去，再创建 cache 目录</p>\n<p>依然用上强大的 docker，<a href=\"https://hub.docker.com/r/jawg/imposm3/\" target=\"_blank\" rel=\"noopener\">jawg/imposm3</a>可以帮助我们方便的执行 imposm3 操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run --network gis --rm \\</span><br><span class=\"line\">-v $(pwd)/cache:/tmp/imposm3 \\</span><br><span class=\"line\">-v $(pwd)/china-latest.osm.pbf:/opt/imposm3/china-latest.osm.pbf \\</span><br><span class=\"line\">-v $(pwd)/mapping.json:/opt/imposm3/mapping.json \\</span><br><span class=\"line\">jawg/imposm3 import \\</span><br><span class=\"line\">-mapping mapping.json \\</span><br><span class=\"line\">-read china-latest.osm.pbf \\</span><br><span class=\"line\">-overwritecache -write -connection &apos;postgis://gis:gis@postgis/gis&apos;</span><br></pre></td></tr></table></figure>\n<p>耐心等待导入完成，可以直接进入 docker 查看数据情况：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker exec -it postgis psql gis gis</span><br></pre></td></tr></table></figure>\n<p>或者通过第三方软件连接数据库，可以看到 import 导入的三张表：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/osm_mvt_postgis.png\" alt></p>\n<h1 id=\"4-执行-SQL-脚本\"><a href=\"#4-执行-SQL-脚本\" class=\"headerlink\" title=\"4. 执行 SQL 脚本\"></a>4. 执行 SQL 脚本</h1><p>在数据库中执行 mapbox 提供的<a href=\"https://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql\" target=\"_blank\" rel=\"noopener\">TileBBox</a>脚本，创建 TileBBox 函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql</span><br></pre></td></tr></table></figure>\n<p>这个函数的作用就是传入指定的<code>x,y,z</code>瓦片序列，转换成 MVT 需要的<code>tile coordinate space</code>，通常是 4096x4096 的网格</p>\n<h1 id=\"5-测试数据结果\"><a href=\"#5-测试数据结果\" class=\"headerlink\" title=\"5. 测试数据结果\"></a>5. 测试数据结果</h1><p>mvt 瓦片生成的关键就是<a href=\"https://postgis.net/docs/ST_AsMVT.html\" target=\"_blank\" rel=\"noopener\">ST_AsMVT</a>和<a href=\"https://postgis.net/docs/ST_AsMVTGeom.html\" target=\"_blank\" rel=\"noopener\">ST_AsMVTGeom</a>两个函数，所以可以直接调用来做个测试，这里查询<code>z=14,y=12917,6430</code>的瓦片对应的 mvt 数据</p>\n<p>先查询出范围内的 geometry，并转化成 mvt 需要的格式</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> ST_AsMVTGeom(</span><br><span class=\"line\">   ST_Transform(</span><br><span class=\"line\">\t  import.osm_buildings.geometry, <span class=\"number\">3857</span>),</span><br><span class=\"line\">\t  TileBBox(<span class=\"number\">14</span>, <span class=\"number\">12917</span>, <span class=\"number\">6430</span>, <span class=\"number\">3857</span>),</span><br><span class=\"line\">\t  <span class=\"number\">256</span>,</span><br><span class=\"line\">\t  <span class=\"number\">10</span>,</span><br><span class=\"line\">      <span class=\"literal\">true</span></span><br><span class=\"line\">   ) geom, <span class=\"keyword\">name</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> import.osm_buildings</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> ST_Intersects(TileBBox(<span class=\"number\">14</span>, <span class=\"number\">12917</span>, <span class=\"number\">6430</span>, <span class=\"number\">3857</span>), import.osm_buildings.geometry)</span><br></pre></td></tr></table></figure>\n<p>得到结果应该如下：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/asmvtgeom_result.png\" alt></p>\n<p>再使用 ST_AsMVT 进行转换就行，完成的合并后的 sql 如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> ST_AsMVT(q, <span class=\"string\">'osm_mvt'</span>, <span class=\"number\">256</span>, <span class=\"string\">'geom'</span>) <span class=\"keyword\">AS</span> mvt</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> (</span><br><span class=\"line\">  <span class=\"keyword\">SELECT</span> ST_AsMVTGeom(</span><br><span class=\"line\">    ST_Transform(</span><br><span class=\"line\">\t  import.osm_buildings.geometry, <span class=\"number\">3857</span>),</span><br><span class=\"line\">\t  TileBBox(<span class=\"number\">14</span>, <span class=\"number\">12917</span>, <span class=\"number\">6430</span>, <span class=\"number\">3857</span>),</span><br><span class=\"line\">\t  <span class=\"number\">256</span>,</span><br><span class=\"line\">\t  <span class=\"number\">10</span>,</span><br><span class=\"line\">      <span class=\"literal\">true</span></span><br><span class=\"line\">  ) geom , <span class=\"keyword\">name</span></span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> import.osm_buildings</span><br><span class=\"line\">  <span class=\"keyword\">WHERE</span> ST_Intersects(TileBBox(<span class=\"number\">14</span>, <span class=\"number\">12917</span>, <span class=\"number\">6430</span>, <span class=\"number\">3857</span>), import.osm_buildings.geometry)</span><br><span class=\"line\">) <span class=\"keyword\">AS</span> q</span><br></pre></td></tr></table></figure>\n<h1 id=\"6-数据展示\"><a href=\"#6-数据展示\" class=\"headerlink\" title=\"6. 数据展示\"></a>6. 数据展示</h1><p>完整的地图区域数据前端展示可以使用 tilestrata 这个服务端工具，配合 tilestrata-postgismvt 插件就可以生成供地图调用的瓦片。</p>\n<p>具体的 demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>对应的文章可以看一下这篇<a href=\"http://kael.top/2019/06/13/tilestrata-postgismvt/\">tilestrata-postgismvt 使用</a></p>\n<p>clone 项目<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a>，将项目里面<code>src/mvt/</code>目录下<a href=\"https://github.com/zzcyrus/tilestrata-sample-code/blob/master/src/mvt/index.js\" target=\"_blank\" rel=\"noopener\">index.js</a>的<code>pgConfig</code>改成你的设置</p>\n<p>安装依赖，启动项目</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<p>访问<code>example/mvt.html</code>就可以看到结果了。</p>\n<p>我们导入了三张表，分别是边界数据（蓝色）、设施（红点）和建筑（紫色），全部叠加之后如下图所示：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/mvt_preview.png\" alt></p>\n<h1 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h1><p><a href=\"https://blog.jawg.io/how-to-make-mvt-with-postgis/\" target=\"_blank\" rel=\"noopener\">https://blog.jawg.io/how-to-make-mvt-with-postgis/</a></p>"},{"title":"tilestrata-etag 插件使用及浅析","date":"2019-07-15T13:39:54.000Z","_content":"\n[tilestrata-etag](https://github.com/naturalatlas/tilestrata-etag)插件可以在 tilestrata 的请求中设置 ETag，可以让服务缓存变得更加高效可控，节省带宽。如果客户端的 ETag 的版本和服务器要发送的一致，则可以直接使用缓存中的数据，不再重新发送数据。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-etag --save\n```\n\n# 2. 使用\n\n默认情况下，插件不会对所有大于 512kb 的数据启用，因为在 large buffers 上 ETag 的计算会很占用 CPU 的时间。但你也可以通过`limit`选项来更改这一默认设置，例如设置为`null`将会无视文件的大小上限，设置为一个文件大小的字符串或者数字，则会以此为上限。\n\n```js\nconst tilestrata = require('tilestrata')\nconst etag = require('tilestrata-etag')\nconst dependency = require('tilestrata-dependency')\nconst mapnik = require('tilestrata-mapnik')\nconst server = tilestrata()\n\n// 用mapnik数据源做一个普通的图层来对比\nserver\n  .layer('world_merc')\n  .route('tile.png')\n  .use(disk.cache({ dir: 'tilecache' }))\n  .use(\n    mapnik({\n      pathname: 'style/world.xml'\n    })\n  )\n\n// 用相同的数据源设置etag后做一个新图层来对比\nserver\n  .layer('etag')\n  .route('tile.png')\n  .use(dependency('world_merc', 'tile.png'))\n  .use(etag({ limit: '1mb' }))\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n可以看到 etag 图层所有 response 中已经带上了`ETag`\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-etag-result-20190705101438.png)\n\n# 4. 代码浅析\n\n首先定义插件类型，这其实是一个`Response Hooks`类型的插件，劫持修改了正常的服务返回值。插件引入了`filesize-parser`用来计算文件大小，设置上限`max_length`，使用[etag](https://www.npmjs.com/package/etag)来生成 etag。\n\n```js\n// max_length由limit设置得出\nif (status_type === 2 && result.buffer && result.buffer.length < max_length) {\n  var resultEtag = result.headers['etag'] || result.headers['ETag']\n  // 如果没有etag，就使用etag库生成\n  if (!resultEtag) {\n    resultEtag = etag(result.buffer)\n    result.headers['ETag'] = resultEtag\n  }\n  // 插件还会判断是否有设置if-none-match\n  var ifnonematch = req.headers['if-none-match']\n  if (ifnonematch && ifnonematch === resultEtag) {\n    result.status = 304\n    result.buffer = new Buffer([])\n  }\n}\n```\n","source":"_posts/2019/tilestrata-etag.md","raw":"---\ntitle: tilestrata-etag 插件使用及浅析\ndate: 2019-07-15 21:39:54\ntags: [GIS]\ncategories: TileStrata\n---\n\n[tilestrata-etag](https://github.com/naturalatlas/tilestrata-etag)插件可以在 tilestrata 的请求中设置 ETag，可以让服务缓存变得更加高效可控，节省带宽。如果客户端的 ETag 的版本和服务器要发送的一致，则可以直接使用缓存中的数据，不再重新发送数据。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-etag --save\n```\n\n# 2. 使用\n\n默认情况下，插件不会对所有大于 512kb 的数据启用，因为在 large buffers 上 ETag 的计算会很占用 CPU 的时间。但你也可以通过`limit`选项来更改这一默认设置，例如设置为`null`将会无视文件的大小上限，设置为一个文件大小的字符串或者数字，则会以此为上限。\n\n```js\nconst tilestrata = require('tilestrata')\nconst etag = require('tilestrata-etag')\nconst dependency = require('tilestrata-dependency')\nconst mapnik = require('tilestrata-mapnik')\nconst server = tilestrata()\n\n// 用mapnik数据源做一个普通的图层来对比\nserver\n  .layer('world_merc')\n  .route('tile.png')\n  .use(disk.cache({ dir: 'tilecache' }))\n  .use(\n    mapnik({\n      pathname: 'style/world.xml'\n    })\n  )\n\n// 用相同的数据源设置etag后做一个新图层来对比\nserver\n  .layer('etag')\n  .route('tile.png')\n  .use(dependency('world_merc', 'tile.png'))\n  .use(etag({ limit: '1mb' }))\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n可以看到 etag 图层所有 response 中已经带上了`ETag`\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-etag-result-20190705101438.png)\n\n# 4. 代码浅析\n\n首先定义插件类型，这其实是一个`Response Hooks`类型的插件，劫持修改了正常的服务返回值。插件引入了`filesize-parser`用来计算文件大小，设置上限`max_length`，使用[etag](https://www.npmjs.com/package/etag)来生成 etag。\n\n```js\n// max_length由limit设置得出\nif (status_type === 2 && result.buffer && result.buffer.length < max_length) {\n  var resultEtag = result.headers['etag'] || result.headers['ETag']\n  // 如果没有etag，就使用etag库生成\n  if (!resultEtag) {\n    resultEtag = etag(result.buffer)\n    result.headers['ETag'] = resultEtag\n  }\n  // 插件还会判断是否有设置if-none-match\n  var ifnonematch = req.headers['if-none-match']\n  if (ifnonematch && ifnonematch === resultEtag) {\n    result.status = 304\n    result.buffer = new Buffer([])\n  }\n}\n```\n","slug":"tilestrata-etag","published":1,"updated":"2019-07-15T13:40:53.156Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrkxgt6000ii83ilj8svgp8","content":"<p><a href=\"https://github.com/naturalatlas/tilestrata-etag\" target=\"_blank\" rel=\"noopener\">tilestrata-etag</a>插件可以在 tilestrata 的请求中设置 ETag，可以让服务缓存变得更加高效可控，节省带宽。如果客户端的 ETag 的版本和服务器要发送的一致，则可以直接使用缓存中的数据，不再重新发送数据。</p>\n<a id=\"more\"></a>\n<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-etag --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><p>默认情况下，插件不会对所有大于 512kb 的数据启用，因为在 large buffers 上 ETag 的计算会很占用 CPU 的时间。但你也可以通过<code>limit</code>选项来更改这一默认设置，例如设置为<code>null</code>将会无视文件的大小上限，设置为一个文件大小的字符串或者数字，则会以此为上限。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> etag = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-etag'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> dependency = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-dependency'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用mapnik数据源做一个普通的图层来对比</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'world_merc'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(disk.cache(&#123; <span class=\"attr\">dir</span>: <span class=\"string\">'tilecache'</span> &#125;))</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/world.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用相同的数据源设置etag后做一个新图层来对比</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'etag'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(dependency(<span class=\"string\">'world_merc'</span>, <span class=\"string\">'tile.png'</span>))</span><br><span class=\"line\">  .use(etag(&#123; <span class=\"attr\">limit</span>: <span class=\"string\">'1mb'</span> &#125;))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>可以看到 etag 图层所有 response 中已经带上了<code>ETag</code></p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-etag-result-20190705101438.png\" alt></p>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>首先定义插件类型，这其实是一个<code>Response Hooks</code>类型的插件，劫持修改了正常的服务返回值。插件引入了<code>filesize-parser</code>用来计算文件大小，设置上限<code>max_length</code>，使用<a href=\"https://www.npmjs.com/package/etag\" target=\"_blank\" rel=\"noopener\">etag</a>来生成 etag。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// max_length由limit设置得出</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (status_type === <span class=\"number\">2</span> &amp;&amp; result.buffer &amp;&amp; result.buffer.length &lt; max_length) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> resultEtag = result.headers[<span class=\"string\">'etag'</span>] || result.headers[<span class=\"string\">'ETag'</span>]</span><br><span class=\"line\">  <span class=\"comment\">// 如果没有etag，就使用etag库生成</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!resultEtag) &#123;</span><br><span class=\"line\">    resultEtag = etag(result.buffer)</span><br><span class=\"line\">    result.headers[<span class=\"string\">'ETag'</span>] = resultEtag</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 插件还会判断是否有设置if-none-match</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> ifnonematch = req.headers[<span class=\"string\">'if-none-match'</span>]</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ifnonematch &amp;&amp; ifnonematch === resultEtag) &#123;</span><br><span class=\"line\">    result.status = <span class=\"number\">304</span></span><br><span class=\"line\">    result.buffer = <span class=\"keyword\">new</span> Buffer([])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/naturalatlas/tilestrata-etag\" target=\"_blank\" rel=\"noopener\">tilestrata-etag</a>插件可以在 tilestrata 的请求中设置 ETag，可以让服务缓存变得更加高效可控，节省带宽。如果客户端的 ETag 的版本和服务器要发送的一致，则可以直接使用缓存中的数据，不再重新发送数据。</p>","more":"<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-etag --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><p>默认情况下，插件不会对所有大于 512kb 的数据启用，因为在 large buffers 上 ETag 的计算会很占用 CPU 的时间。但你也可以通过<code>limit</code>选项来更改这一默认设置，例如设置为<code>null</code>将会无视文件的大小上限，设置为一个文件大小的字符串或者数字，则会以此为上限。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> etag = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-etag'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> dependency = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-dependency'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用mapnik数据源做一个普通的图层来对比</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'world_merc'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(disk.cache(&#123; <span class=\"attr\">dir</span>: <span class=\"string\">'tilecache'</span> &#125;))</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/world.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用相同的数据源设置etag后做一个新图层来对比</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'etag'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(dependency(<span class=\"string\">'world_merc'</span>, <span class=\"string\">'tile.png'</span>))</span><br><span class=\"line\">  .use(etag(&#123; <span class=\"attr\">limit</span>: <span class=\"string\">'1mb'</span> &#125;))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>可以看到 etag 图层所有 response 中已经带上了<code>ETag</code></p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-etag-result-20190705101438.png\" alt></p>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>首先定义插件类型，这其实是一个<code>Response Hooks</code>类型的插件，劫持修改了正常的服务返回值。插件引入了<code>filesize-parser</code>用来计算文件大小，设置上限<code>max_length</code>，使用<a href=\"https://www.npmjs.com/package/etag\" target=\"_blank\" rel=\"noopener\">etag</a>来生成 etag。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// max_length由limit设置得出</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (status_type === <span class=\"number\">2</span> &amp;&amp; result.buffer &amp;&amp; result.buffer.length &lt; max_length) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> resultEtag = result.headers[<span class=\"string\">'etag'</span>] || result.headers[<span class=\"string\">'ETag'</span>]</span><br><span class=\"line\">  <span class=\"comment\">// 如果没有etag，就使用etag库生成</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!resultEtag) &#123;</span><br><span class=\"line\">    resultEtag = etag(result.buffer)</span><br><span class=\"line\">    result.headers[<span class=\"string\">'ETag'</span>] = resultEtag</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 插件还会判断是否有设置if-none-match</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> ifnonematch = req.headers[<span class=\"string\">'if-none-match'</span>]</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ifnonematch &amp;&amp; ifnonematch === resultEtag) &#123;</span><br><span class=\"line\">    result.status = <span class=\"number\">304</span></span><br><span class=\"line\">    result.buffer = <span class=\"keyword\">new</span> Buffer([])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"tilestrata-headers 插件使用及浅析","date":"2019-06-26T03:25:05.000Z","_content":"\n[tilestrata-headers](https://github.com/naturalatlas/tilestrata-headers)插件用来设置请求的响应头`response headers`，常用的可以解决缓存控制、跨域等问题，实用性很高。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```bash\nnpm install tilestrata-headers --save\n```\n\n# 2. 使用\n\n```js\nvar headers = require(\"tilestrata-headers\");\nvar tilestrata = require(\"tilestrata\");\n\nserver = tilestrata();\n\nserver\n  .layer(\"osm_mvt_amenities\")\n  .route(\"tile.mvt\")\n  .use(\n    headers({\n      \"Access-Control-Allow-Origin\": \"*\",\n      \"Cache-Control\": \"max-age=3600\"\n    })\n  );\n\nserver.listen(8080);\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n未开启\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-headers-null-20190606114255.png)\n\n开启\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-headers-result-20190606114432.png)\n\n# 4. 代码浅析\n\n原理比较简单，在`tilestrata`的设计中，会使用`use`去注册各种类型的插件，`tilestrata-headers`就是`reshook`类型的插件，在初始化的过程中会被注册\n\n```js\nTileRequestHandler.prototype.use = function(plugin) {\n  if (!plugin) return this;\n  // ...简化后的代码\n  if (plugin.reshook) return this._registerResponseHook(plugin);\n};\n\nTileRequestHandler.prototype._registerResponseHook = function(plugin) {\n  var id = \"reshook#\" + this.responseHooks.length;\n  if (!plugin) throw new Error(\"Falsy value passed to registerResponseHook()\");\n  if (typeof plugin.reshook !== \"function\")\n    throw new Error(\n      \"Attempted to register a response hook with no reshook() method\"\n    );\n  this.responseHooks.push({ id: id, plugin: plugin });\n  return this;\n};\n```\n\n通过这种方式，插件劫持每个 response，给每个 response header 加上我们自定义的内容。\n","source":"_posts/2019/tilestrata-headers.md","raw":"---\ntitle: tilestrata-headers 插件使用及浅析\ndate: 2019-06-26 11:25:05\ntags: [GIS]\ncategories: TileStrata\n---\n\n[tilestrata-headers](https://github.com/naturalatlas/tilestrata-headers)插件用来设置请求的响应头`response headers`，常用的可以解决缓存控制、跨域等问题，实用性很高。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```bash\nnpm install tilestrata-headers --save\n```\n\n# 2. 使用\n\n```js\nvar headers = require(\"tilestrata-headers\");\nvar tilestrata = require(\"tilestrata\");\n\nserver = tilestrata();\n\nserver\n  .layer(\"osm_mvt_amenities\")\n  .route(\"tile.mvt\")\n  .use(\n    headers({\n      \"Access-Control-Allow-Origin\": \"*\",\n      \"Cache-Control\": \"max-age=3600\"\n    })\n  );\n\nserver.listen(8080);\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n未开启\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-headers-null-20190606114255.png)\n\n开启\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-headers-result-20190606114432.png)\n\n# 4. 代码浅析\n\n原理比较简单，在`tilestrata`的设计中，会使用`use`去注册各种类型的插件，`tilestrata-headers`就是`reshook`类型的插件，在初始化的过程中会被注册\n\n```js\nTileRequestHandler.prototype.use = function(plugin) {\n  if (!plugin) return this;\n  // ...简化后的代码\n  if (plugin.reshook) return this._registerResponseHook(plugin);\n};\n\nTileRequestHandler.prototype._registerResponseHook = function(plugin) {\n  var id = \"reshook#\" + this.responseHooks.length;\n  if (!plugin) throw new Error(\"Falsy value passed to registerResponseHook()\");\n  if (typeof plugin.reshook !== \"function\")\n    throw new Error(\n      \"Attempted to register a response hook with no reshook() method\"\n    );\n  this.responseHooks.push({ id: id, plugin: plugin });\n  return this;\n};\n```\n\n通过这种方式，插件劫持每个 response，给每个 response header 加上我们自定义的内容。\n","slug":"tilestrata-headers","published":1,"updated":"2019-06-28T05:56:28.441Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrkxgt6000ji83ixj7f8io4","content":"<p><a href=\"https://github.com/naturalatlas/tilestrata-headers\" target=\"_blank\" rel=\"noopener\">tilestrata-headers</a>插件用来设置请求的响应头<code>response headers</code>，常用的可以解决缓存控制、跨域等问题，实用性很高。</p>\n<a id=\"more\"></a>\n<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install tilestrata-headers --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> headers = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata-headers\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">server = tilestrata();</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">\"osm_mvt_amenities\"</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">\"tile.mvt\"</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">\"Access-Control-Allow-Origin\"</span>: <span class=\"string\">\"*\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"Cache-Control\"</span>: <span class=\"string\">\"max-age=3600\"</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">8080</span>);</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>未开启</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-headers-null-20190606114255.png\" alt></p>\n<p>开启</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-headers-result-20190606114432.png\" alt></p>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>原理比较简单，在<code>tilestrata</code>的设计中，会使用<code>use</code>去注册各种类型的插件，<code>tilestrata-headers</code>就是<code>reshook</code>类型的插件，在初始化的过程中会被注册</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">TileRequestHandler.prototype.use = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">plugin</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!plugin) <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ...简化后的代码</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (plugin.reshook) <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._registerResponseHook(plugin);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">TileRequestHandler.prototype._registerResponseHook = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">plugin</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> id = <span class=\"string\">\"reshook#\"</span> + <span class=\"keyword\">this</span>.responseHooks.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!plugin) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Falsy value passed to registerResponseHook()\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> plugin.reshook !== <span class=\"string\">\"function\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">      <span class=\"string\">\"Attempted to register a response hook with no reshook() method\"</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.responseHooks.push(&#123; <span class=\"attr\">id</span>: id, <span class=\"attr\">plugin</span>: plugin &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>通过这种方式，插件劫持每个 response，给每个 response header 加上我们自定义的内容。</p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/naturalatlas/tilestrata-headers\" target=\"_blank\" rel=\"noopener\">tilestrata-headers</a>插件用来设置请求的响应头<code>response headers</code>，常用的可以解决缓存控制、跨域等问题，实用性很高。</p>","more":"<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install tilestrata-headers --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> headers = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata-headers\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">server = tilestrata();</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">\"osm_mvt_amenities\"</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">\"tile.mvt\"</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">\"Access-Control-Allow-Origin\"</span>: <span class=\"string\">\"*\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"Cache-Control\"</span>: <span class=\"string\">\"max-age=3600\"</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">8080</span>);</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>未开启</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-headers-null-20190606114255.png\" alt></p>\n<p>开启</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-headers-result-20190606114432.png\" alt></p>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>原理比较简单，在<code>tilestrata</code>的设计中，会使用<code>use</code>去注册各种类型的插件，<code>tilestrata-headers</code>就是<code>reshook</code>类型的插件，在初始化的过程中会被注册</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">TileRequestHandler.prototype.use = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">plugin</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!plugin) <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ...简化后的代码</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (plugin.reshook) <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._registerResponseHook(plugin);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">TileRequestHandler.prototype._registerResponseHook = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">plugin</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> id = <span class=\"string\">\"reshook#\"</span> + <span class=\"keyword\">this</span>.responseHooks.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!plugin) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Falsy value passed to registerResponseHook()\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> plugin.reshook !== <span class=\"string\">\"function\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">      <span class=\"string\">\"Attempted to register a response hook with no reshook() method\"</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.responseHooks.push(&#123; <span class=\"attr\">id</span>: id, <span class=\"attr\">plugin</span>: plugin &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>通过这种方式，插件劫持每个 response，给每个 response header 加上我们自定义的内容。</p>"},{"title":"tilestrata-gm 插件使用及浅析","date":"2019-07-14T12:54:50.000Z","_content":"\n[tilestrata-gm](https://github.com/naturalatlas/tilestrata-gm)插件和 tilestrata-sharp 功能上类似，背后使用的依赖[graphicsmagick](http://www.graphicsmagick.org/)的[gm](http://aheckmann.github.io/gm/docs.html)库来做图像处理，所以具体能够实现的哪些功可以去 gm 的文档中查询。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 安装\n\n由于插件依赖于[graphicsmagick](http://www.graphicsmagick.org/)，需要根据[安装指南](http://www.graphicsmagick.org/README.html)在各个平台下进行安装，MacOS 可以直接用 brew 安装\n\n```sh\n$ brew install graphicsmagick\n# 再安装插件\n$ npm install tilestrata-gm --save\n```\n\n# 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst mapnik = require('tilestrata-mapnik')\nconst gm = require('tilestrata-gm')\nconst server = tilestrata()\n\nserver\n  .layer('world_merc_gm')\n  .route('tile.png')\n  .use(\n    // 定义数据源\n    mapnik({\n      pathname: 'style/world.xml'\n    })\n  )\n  .use(\n    gm(function(image) {\n      return image\n        .blur(7, 3) // 模糊处理\n        .rotate('green', 45) // 旋转，配色\n    })\n  )\n\n// 可以同时能处理的任务的个数\ngm.setMaxConcurrency(2)\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n下图是原始的瓦片样式：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-sharp-original-20190705114413.png)\n\n使用 gm 插件进行了模糊处理，旋转了 45°，背景填充为绿色后的结果：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-gm-result-20190705135250.png)\n\n# 代码浅析\n\n插件的整体逻辑和 tilestrata-sharp 基本一致，在`toBuffer`阶段有所不同，gm 选择了在`async.queue`队列中逐步转化成 buffer 再返回给 tiletrata，这也是为什么会有`setMaxConcurrency`这个方法的原因。\n\n```js\n// 代码有所精简\n// toBuffer队列\nvar gmQueue = async.queue(function(image, callback) {\n\timage.toBuffer(function(err, buffer) {\n\t\tcallback(err, buffer);\n\t});\n}, concurrency);\n\ntransform: function(server, req, buffer, headers, callback) {\n    var image;\n\n    try {\n        // 创建gm对象\n        image = gm(buffer);\n        // 执行回调函数里面的处理规则\n        fn(image);\n    }\n    catch (err) { return callback(err); }\n\n    // 放入async.queue中，逐步执行\n    gmQueue.push(image, function(err, buffer) {\n        if (err) return callback(err);\n        if (image._outputFormat) {\n            headers['Content-Type'] = 'image/' + image._outputFormat;\n        }\n        callback(null, buffer, headers);\n    });\n}\n```\n","source":"_posts/2019/tilestrata-gm.md","raw":"---\ntitle: tilestrata-gm 插件使用及浅析\ndate: 2019-07-14 20:54:50\ntags: [GIS]\ncategories: TileStrata\n---\n\n[tilestrata-gm](https://github.com/naturalatlas/tilestrata-gm)插件和 tilestrata-sharp 功能上类似，背后使用的依赖[graphicsmagick](http://www.graphicsmagick.org/)的[gm](http://aheckmann.github.io/gm/docs.html)库来做图像处理，所以具体能够实现的哪些功可以去 gm 的文档中查询。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 安装\n\n由于插件依赖于[graphicsmagick](http://www.graphicsmagick.org/)，需要根据[安装指南](http://www.graphicsmagick.org/README.html)在各个平台下进行安装，MacOS 可以直接用 brew 安装\n\n```sh\n$ brew install graphicsmagick\n# 再安装插件\n$ npm install tilestrata-gm --save\n```\n\n# 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst mapnik = require('tilestrata-mapnik')\nconst gm = require('tilestrata-gm')\nconst server = tilestrata()\n\nserver\n  .layer('world_merc_gm')\n  .route('tile.png')\n  .use(\n    // 定义数据源\n    mapnik({\n      pathname: 'style/world.xml'\n    })\n  )\n  .use(\n    gm(function(image) {\n      return image\n        .blur(7, 3) // 模糊处理\n        .rotate('green', 45) // 旋转，配色\n    })\n  )\n\n// 可以同时能处理的任务的个数\ngm.setMaxConcurrency(2)\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n下图是原始的瓦片样式：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-sharp-original-20190705114413.png)\n\n使用 gm 插件进行了模糊处理，旋转了 45°，背景填充为绿色后的结果：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-gm-result-20190705135250.png)\n\n# 代码浅析\n\n插件的整体逻辑和 tilestrata-sharp 基本一致，在`toBuffer`阶段有所不同，gm 选择了在`async.queue`队列中逐步转化成 buffer 再返回给 tiletrata，这也是为什么会有`setMaxConcurrency`这个方法的原因。\n\n```js\n// 代码有所精简\n// toBuffer队列\nvar gmQueue = async.queue(function(image, callback) {\n\timage.toBuffer(function(err, buffer) {\n\t\tcallback(err, buffer);\n\t});\n}, concurrency);\n\ntransform: function(server, req, buffer, headers, callback) {\n    var image;\n\n    try {\n        // 创建gm对象\n        image = gm(buffer);\n        // 执行回调函数里面的处理规则\n        fn(image);\n    }\n    catch (err) { return callback(err); }\n\n    // 放入async.queue中，逐步执行\n    gmQueue.push(image, function(err, buffer) {\n        if (err) return callback(err);\n        if (image._outputFormat) {\n            headers['Content-Type'] = 'image/' + image._outputFormat;\n        }\n        callback(null, buffer, headers);\n    });\n}\n```\n","slug":"tilestrata-gm","published":1,"updated":"2019-07-14T13:00:28.449Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrkxgt7000ki83icsb13631","content":"<p><a href=\"https://github.com/naturalatlas/tilestrata-gm\" target=\"_blank\" rel=\"noopener\">tilestrata-gm</a>插件和 tilestrata-sharp 功能上类似，背后使用的依赖<a href=\"http://www.graphicsmagick.org/\" target=\"_blank\" rel=\"noopener\">graphicsmagick</a>的<a href=\"http://aheckmann.github.io/gm/docs.html\" target=\"_blank\" rel=\"noopener\">gm</a>库来做图像处理，所以具体能够实现的哪些功可以去 gm 的文档中查询。</p>\n<a id=\"more\"></a>\n<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><p>由于插件依赖于<a href=\"http://www.graphicsmagick.org/\" target=\"_blank\" rel=\"noopener\">graphicsmagick</a>，需要根据<a href=\"http://www.graphicsmagick.org/README.html\" target=\"_blank\" rel=\"noopener\">安装指南</a>在各个平台下进行安装，MacOS 可以直接用 brew 安装</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ brew install graphicsmagick</span><br><span class=\"line\"><span class=\"comment\"># 再安装插件</span></span><br><span class=\"line\">$ npm install tilestrata-gm --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> gm = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-gm'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'world_merc_gm'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    <span class=\"comment\">// 定义数据源</span></span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/world.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    gm(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">image</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> image</span><br><span class=\"line\">        .blur(<span class=\"number\">7</span>, <span class=\"number\">3</span>) <span class=\"comment\">// 模糊处理</span></span><br><span class=\"line\">        .rotate(<span class=\"string\">'green'</span>, <span class=\"number\">45</span>) <span class=\"comment\">// 旋转，配色</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以同时能处理的任务的个数</span></span><br><span class=\"line\">gm.setMaxConcurrency(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>下图是原始的瓦片样式：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-sharp-original-20190705114413.png\" alt></p>\n<p>使用 gm 插件进行了模糊处理，旋转了 45°，背景填充为绿色后的结果：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-gm-result-20190705135250.png\" alt></p>\n<h1 id=\"代码浅析\"><a href=\"#代码浅析\" class=\"headerlink\" title=\"代码浅析\"></a>代码浅析</h1><p>插件的整体逻辑和 tilestrata-sharp 基本一致，在<code>toBuffer</code>阶段有所不同，gm 选择了在<code>async.queue</code>队列中逐步转化成 buffer 再返回给 tiletrata，这也是为什么会有<code>setMaxConcurrency</code>这个方法的原因。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码有所精简</span></span><br><span class=\"line\"><span class=\"comment\">// toBuffer队列</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> gmQueue = <span class=\"keyword\">async</span>.queue(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">image, callback</span>) </span>&#123;</span><br><span class=\"line\">\timage.toBuffer(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, buffer</span>) </span>&#123;</span><br><span class=\"line\">\t\tcallback(err, buffer);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;, concurrency);</span><br><span class=\"line\"></span><br><span class=\"line\">transform: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req, buffer, headers, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> image;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建gm对象</span></span><br><span class=\"line\">        image = gm(buffer);</span><br><span class=\"line\">        <span class=\"comment\">// 执行回调函数里面的处理规则</span></span><br><span class=\"line\">        fn(image);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (err) &#123; <span class=\"keyword\">return</span> callback(err); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 放入async.queue中，逐步执行</span></span><br><span class=\"line\">    gmQueue.push(image, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, buffer</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> callback(err);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (image._outputFormat) &#123;</span><br><span class=\"line\">            headers[<span class=\"string\">'Content-Type'</span>] = <span class=\"string\">'image/'</span> + image._outputFormat;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        callback(<span class=\"literal\">null</span>, buffer, headers);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/naturalatlas/tilestrata-gm\" target=\"_blank\" rel=\"noopener\">tilestrata-gm</a>插件和 tilestrata-sharp 功能上类似，背后使用的依赖<a href=\"http://www.graphicsmagick.org/\" target=\"_blank\" rel=\"noopener\">graphicsmagick</a>的<a href=\"http://aheckmann.github.io/gm/docs.html\" target=\"_blank\" rel=\"noopener\">gm</a>库来做图像处理，所以具体能够实现的哪些功可以去 gm 的文档中查询。</p>","more":"<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><p>由于插件依赖于<a href=\"http://www.graphicsmagick.org/\" target=\"_blank\" rel=\"noopener\">graphicsmagick</a>，需要根据<a href=\"http://www.graphicsmagick.org/README.html\" target=\"_blank\" rel=\"noopener\">安装指南</a>在各个平台下进行安装，MacOS 可以直接用 brew 安装</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ brew install graphicsmagick</span><br><span class=\"line\"><span class=\"comment\"># 再安装插件</span></span><br><span class=\"line\">$ npm install tilestrata-gm --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> gm = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-gm'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'world_merc_gm'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    <span class=\"comment\">// 定义数据源</span></span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/world.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    gm(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">image</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> image</span><br><span class=\"line\">        .blur(<span class=\"number\">7</span>, <span class=\"number\">3</span>) <span class=\"comment\">// 模糊处理</span></span><br><span class=\"line\">        .rotate(<span class=\"string\">'green'</span>, <span class=\"number\">45</span>) <span class=\"comment\">// 旋转，配色</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以同时能处理的任务的个数</span></span><br><span class=\"line\">gm.setMaxConcurrency(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>下图是原始的瓦片样式：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-sharp-original-20190705114413.png\" alt></p>\n<p>使用 gm 插件进行了模糊处理，旋转了 45°，背景填充为绿色后的结果：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-gm-result-20190705135250.png\" alt></p>\n<h1 id=\"代码浅析\"><a href=\"#代码浅析\" class=\"headerlink\" title=\"代码浅析\"></a>代码浅析</h1><p>插件的整体逻辑和 tilestrata-sharp 基本一致，在<code>toBuffer</code>阶段有所不同，gm 选择了在<code>async.queue</code>队列中逐步转化成 buffer 再返回给 tiletrata，这也是为什么会有<code>setMaxConcurrency</code>这个方法的原因。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码有所精简</span></span><br><span class=\"line\"><span class=\"comment\">// toBuffer队列</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> gmQueue = <span class=\"keyword\">async</span>.queue(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">image, callback</span>) </span>&#123;</span><br><span class=\"line\">\timage.toBuffer(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, buffer</span>) </span>&#123;</span><br><span class=\"line\">\t\tcallback(err, buffer);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;, concurrency);</span><br><span class=\"line\"></span><br><span class=\"line\">transform: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req, buffer, headers, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> image;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建gm对象</span></span><br><span class=\"line\">        image = gm(buffer);</span><br><span class=\"line\">        <span class=\"comment\">// 执行回调函数里面的处理规则</span></span><br><span class=\"line\">        fn(image);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (err) &#123; <span class=\"keyword\">return</span> callback(err); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 放入async.queue中，逐步执行</span></span><br><span class=\"line\">    gmQueue.push(image, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, buffer</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> callback(err);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (image._outputFormat) &#123;</span><br><span class=\"line\">            headers[<span class=\"string\">'Content-Type'</span>] = <span class=\"string\">'image/'</span> + image._outputFormat;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        callback(<span class=\"literal\">null</span>, buffer, headers);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"tilestrata 入门指南","date":"2019-07-18T10:13:53.000Z","_content":"\n简单来说[**Tilestrata**](https://github.com/naturalatlas/tilestrata)就是一个瓦片地图服务器。根据其自身的介绍，它有如下的特点：零配置，简洁，测试覆盖率高，性能高，拓展性强。可以通过[TileStrata Balancer](https://github.com/naturalatlas/tilestrata-balancer)实现负载均衡，无缝伸缩。可以通过内置[控制台](https://github.com/naturalatlas/tilestrata#profiling--debugging-performance)去调试查看渲染时间。\n\n<!--more-->\n\n本文主要基于官方的文档介绍及部分使用心得，旨在帮助大家快速上手，进阶使用会后续说明。\n\n安装：\n\n```sh\n$ npm install tilestrata --save\n```\n\n## 1. 主要结构\n\nTileStrata 的结构上有以下五个主要组成部分，通常用来实现各种插件，我个人习惯把它们看作是生命周期流程，正是由于这些 hook 的存在，我们就可以在 TileStrata 生命周期的各个阶段去实现各种巧妙的功能：\n\n- `request hook` – 请求预处理\n- `cache` – 缓存控制\n- `provider` – 数据源，比如 mapnik\n- `transform` – 最关键的阶段，可以在瓦片输出的过程中对其做各种加工，比如旋转，染色\n- `response hook` – 响应后处理，比如 headers、jsonp 插件\n\n官方提供了一张很直观的流程图：\n\n![](https://camo.githubusercontent.com/67abe0f563502d78ef12b4ce20cba57222dfcf6f/68747470733a2f2f63646e2e7261776769742e636f6d2f6e61747572616c61746c61732f74696c657374726174612f6d61737465722f6d6973632f67726170686963732f726571666c6f772e737667)\n\n## 2. 常用插件\n\n- [tilestrata-mapnik](https://github.com/naturalatlas/tilestrata-mapnik) – 使用 [mapnik](http://mapnik.org/)做数据源进行渲染\n- [tilestrata-disk](https://github.com/naturalatlas/tilestrata-disk) – 服务端缓存插件\n- [tilestrata-dependency](https://github.com/naturalatlas/tilestrata-dependency) – 直接使用其他定义好的图层来获取数据，而不是定义一个 provider\n- [tilestrata-sharp](https://github.com/naturalatlas/tilestrata-sharp) – 用 [libvips](https://www.npmjs.com/package/sharp)来做一些图片的处理，比如压缩，旋转，转换类型\n- [tilestrata-gm](https://github.com/naturalatlas/tilestrata-gm) – 使用 [GraphicsMagick](https://www.npmjs.com/package/gm)来对图片做处理，大体上和上面类似\n- [tilestrata-headers](https://github.com/naturalatlas/tilestrata-headers) – 设置请求的响应头，可以解决跨域问题\n- [tilestrata-blend](https://github.com/naturalatlas/tilestrata-blend) – 合成多个瓦片图层为一个图层，比方组合道路+建筑为一个图层\n- [tilestrata-jsonp](https://github.com/naturalatlas/tilestrata-jsonp) – 使 utfgrids 类的 json 数据支持 jsonp 请求方式\n- [tilestrata-datadog](https://github.com/naturalatlas/tilestrata-datadog) – 继承数据到[Datadog](https://www.datadoghq.com/)服务\n- [tilestrata-utfmerge](https://github.com/naturalatlas/tilestrata-utfmerge) – 合并两个 utfgrids 类图层为一个图层\n- [tilestrata-vtile](https://github.com/naturalatlas/tilestrata-vtile) – 输出 mapnik 数据为矢量切片 pbf 格式\n- [tilestrata-vtile-raster](https://github.com/naturalatlas/tilestrata-vtile-raster) – 将上面的 pbf 的是瓦片转换成栅格瓦片\n- [tilestrata-vtile-composite](https://github.com/naturalatlas/tilestrata-vtile-composite) – 合并多个矢量瓦片图层\n- [tilestrata-proxy](https://github.com/naturalatlas/tilestrata-proxy) – 为其他瓦片服务器提供代理\n- [tilestrata-lru](https://github.com/naturalatlas/tilestrata-lru) – 在内存中缓存瓦片数据\n- [tilestrata-etag](https://github.com/naturalatlas/tilestrata-etag) – 让瓦片图层支持自定义 ETag 标签，一般用来处理 http 缓存\n- [tilestrata-bing](https://github.com/naturalatlas/tilestrata-bing) – Bing 地图的 provider\n- [tilestrata-underzoom](https://github.com/naturalatlas/tilestrata-underzoom) - Build mosaics of higher-zoom tiles\n- [tilestrata-postgismvt](https://github.com/Stezii/tilestrata-postgismvt) – 使用 PostGIS 数据库输出 mvt 格式的瓦片\n- [tilestrata-postgis-geojson-tiles](https://github.com/naturalatlas/tilestrata-postgis-geojson-tiles) – 使用 PostGIS 数据库输出 GeoJSON 格式的瓦片\n\n## 3. 基本使用\n\n```js\nvar tilestrata = require('tilestrata')\nvar disk = require('tilestrata-disk')\nvar sharp = require('tilestrata-sharp')\nvar mapnik = require('tilestrata-mapnik')\nvar dependency = require('tilestrata-dependency')\nvar strata = tilestrata()\n\n// 定义一个图层\nstrata\n  .layer('layerName')\n  // 设置第一个瓦片路径\n  .route('tileName.png')\n  // 设置缓存目录\n  .use(disk.cache({ dir: '/var/lib/tiles/basemap' }))\n  // 设置数据源mapnik\n  .use(\n    mapnik({\n      pathname: '/path/to/map.xml',\n      tileSize: 512,\n      scale: 2\n    })\n  )\n  // 设置第二个瓦片路径\n  .route('tileSharp.png')\n  .use(disk.cache({ dir: '/var/lib/tiles/basemap' }))\n  // 用dependency插件直接使用layerName的源\n  .use(dependency('layerName', 'tileName.png'))\n  // 用sharp插件resize每个瓦片的大小\n  .use(\n    sharp(function(image, sharp) {\n      return image.resize(256)\n    })\n  )\n\n// 启动服务\nstrata.listen(8080)\n```\n\n服务启动后，可以通过下面的地址来访问瓦片数据：\n\n```\n/layerName/:z/:x:/:y/tileName.png\n```\n\n### 3.1 不定义瓦片名称\n\n从 [2.1.0](https://github.com/naturalatlas/tilestrata/releases/tag/v2.1.0)版本开始, 在设置`route`名称的时候，可以直接采用下面的形式，更加符合通用的瓦片格式：\n\n```js\n.route('*.png') // /layer/0/0/0.png\n.route('*@2x.png') // /layer/0/0/0@2x.png\n```\n\n### 3.2 整合 [Express.js](http://expressjs.com/) / [Connect](https://github.com/senchalabs/connect)\n\nTileStrata 可以定义成 Express 的一个中间件去使用，不必通过执行`strata.listen(8080)`来启动一个 server 服务，\n\n```js\nvar tilestrata = require('tilestrata')\nvar strata = tilestrata()\nstrata.layer('basemap') /* ... */\nstrata.layer('contours') /* ... */\n\napp.use(\n  tilestrata.middleware({\n    server: strata,\n    prefix: '/maps'\n  })\n)\n```\n\n## 4. 使用说明\n\n### 4.1 支持 Metatile 的负载均衡和图层共享\n\nTileStrata 从 [2.0.0](https://github.com/naturalatlas/tilestrata/releases/tag/v2.0.0) 版本开始支持集成[TileStrata Balancer](https://github.com/naturalatlas/tilestrata-balancer), 这是一个专门针对瓦片服务中的[metatiles](http://wiki.openstreetmap.org/wiki/Meta_tiles)设计的弹性负载均衡器，一般的负载均衡器并没有`metatiles`这个概念，所以会简单的把瓦片请求的分散到多个服务器，这样会导致冗余的渲染，不仅速度慢还会造成服务器资源浪费。\n\n需要额外注意的是，均衡器并不会假设负载池中的所有服务器都提供了相同的图层， 它会持续追踪每个节点上提供的所有的图层，因此他知道某个图层明确的访问路径。\n\n- **Fully elastic** （最小化配置）\n- **Consistent routing** (提高本地缓存命中率)\n- **Metatile-aware** (防止冗余渲染)\n- **Layer-aware** (支持图层的异构分布)\n\n[**TileStrata Balancer 详细文档 →**](https://github.com/naturalatlas/tilestrata-balancer)\n\n### 4.2 重建瓦片缓存\n\n在更新了图层的样式或者数据源后，你需要更新瓦片。这时候不必立刻删掉所有旧缓存，可以在请求头中设置`X-TileStrata-SkipCache`，逐步请求这些瓦片让服务器重新构建它们。[TileMantle](https://github.com/naturalatlas/tilemantle)工作可以让这个过程十分简单：\n\n```sh\nnpm install -g tilemantle\ntilemantle http://myhost.com/mylayer/{z}/{x}/{y}/t.png \\\n    -p 44.9457507,-109.5939822 -b 30mi -z 10-14 \\\n    -H \"X-TileStrata-SkipCache:mylayer/t.png\"\n```\n\n如果你使用了 [tilestrata-dependency](https://github.com/naturalatlas/tilestrata-dependency) 插件, 请求头则需要设置成如下形式：\n\n```\nX-TileStrata-SkipCache:*\nX-TileStrata-SkipCache:[layer]/[file],[layer]/[file],...\n```\n\n在一些高级的使用场景中，为了确保瓦片在缓存实际写入文件系统之前不要从服务器返回请求，需要额外做如下设置：\n\n```\nX-TileStrata-CacheWait:1\n```\n\n### 4.1 健康检查\n\nTileStrata 包含一个名为`/health`内置路径，如果服务器连接正常，你会收到`200 OK`的返回值。这可以用来自定义一些错误和成功提醒，设置想要的返回值。只要在初始化 tilestrata 时，给选项中的 healthy 设置一个回调函数即可。\n\n```js\n// 不健康状态\nvar strata = tilestrata({\n  healthy: function(callback) {\n    callback(new Error('CPU is too high'), { loadavg: 3 })\n  }\n})\n\n// 错误信息'CPU is too high'会包装在message字段中返回\n\n// 健康状态\nvar strata = tilestrata({\n  healthy: function(callback) {\n    callback(null, { loadavg: 1 })\n  }\n})\n\n// 正确的返回值中将会额外的多一个loadavg字段，这将是你自定义的内容\n```\n","source":"_posts/2019/tilestrata-intro.md","raw":"---\ntitle: tilestrata 入门指南\ndate: 2019-07-18 18:13:53\ntags: [GIS]\ncategories: TileStrata\n---\n\n简单来说[**Tilestrata**](https://github.com/naturalatlas/tilestrata)就是一个瓦片地图服务器。根据其自身的介绍，它有如下的特点：零配置，简洁，测试覆盖率高，性能高，拓展性强。可以通过[TileStrata Balancer](https://github.com/naturalatlas/tilestrata-balancer)实现负载均衡，无缝伸缩。可以通过内置[控制台](https://github.com/naturalatlas/tilestrata#profiling--debugging-performance)去调试查看渲染时间。\n\n<!--more-->\n\n本文主要基于官方的文档介绍及部分使用心得，旨在帮助大家快速上手，进阶使用会后续说明。\n\n安装：\n\n```sh\n$ npm install tilestrata --save\n```\n\n## 1. 主要结构\n\nTileStrata 的结构上有以下五个主要组成部分，通常用来实现各种插件，我个人习惯把它们看作是生命周期流程，正是由于这些 hook 的存在，我们就可以在 TileStrata 生命周期的各个阶段去实现各种巧妙的功能：\n\n- `request hook` – 请求预处理\n- `cache` – 缓存控制\n- `provider` – 数据源，比如 mapnik\n- `transform` – 最关键的阶段，可以在瓦片输出的过程中对其做各种加工，比如旋转，染色\n- `response hook` – 响应后处理，比如 headers、jsonp 插件\n\n官方提供了一张很直观的流程图：\n\n![](https://camo.githubusercontent.com/67abe0f563502d78ef12b4ce20cba57222dfcf6f/68747470733a2f2f63646e2e7261776769742e636f6d2f6e61747572616c61746c61732f74696c657374726174612f6d61737465722f6d6973632f67726170686963732f726571666c6f772e737667)\n\n## 2. 常用插件\n\n- [tilestrata-mapnik](https://github.com/naturalatlas/tilestrata-mapnik) – 使用 [mapnik](http://mapnik.org/)做数据源进行渲染\n- [tilestrata-disk](https://github.com/naturalatlas/tilestrata-disk) – 服务端缓存插件\n- [tilestrata-dependency](https://github.com/naturalatlas/tilestrata-dependency) – 直接使用其他定义好的图层来获取数据，而不是定义一个 provider\n- [tilestrata-sharp](https://github.com/naturalatlas/tilestrata-sharp) – 用 [libvips](https://www.npmjs.com/package/sharp)来做一些图片的处理，比如压缩，旋转，转换类型\n- [tilestrata-gm](https://github.com/naturalatlas/tilestrata-gm) – 使用 [GraphicsMagick](https://www.npmjs.com/package/gm)来对图片做处理，大体上和上面类似\n- [tilestrata-headers](https://github.com/naturalatlas/tilestrata-headers) – 设置请求的响应头，可以解决跨域问题\n- [tilestrata-blend](https://github.com/naturalatlas/tilestrata-blend) – 合成多个瓦片图层为一个图层，比方组合道路+建筑为一个图层\n- [tilestrata-jsonp](https://github.com/naturalatlas/tilestrata-jsonp) – 使 utfgrids 类的 json 数据支持 jsonp 请求方式\n- [tilestrata-datadog](https://github.com/naturalatlas/tilestrata-datadog) – 继承数据到[Datadog](https://www.datadoghq.com/)服务\n- [tilestrata-utfmerge](https://github.com/naturalatlas/tilestrata-utfmerge) – 合并两个 utfgrids 类图层为一个图层\n- [tilestrata-vtile](https://github.com/naturalatlas/tilestrata-vtile) – 输出 mapnik 数据为矢量切片 pbf 格式\n- [tilestrata-vtile-raster](https://github.com/naturalatlas/tilestrata-vtile-raster) – 将上面的 pbf 的是瓦片转换成栅格瓦片\n- [tilestrata-vtile-composite](https://github.com/naturalatlas/tilestrata-vtile-composite) – 合并多个矢量瓦片图层\n- [tilestrata-proxy](https://github.com/naturalatlas/tilestrata-proxy) – 为其他瓦片服务器提供代理\n- [tilestrata-lru](https://github.com/naturalatlas/tilestrata-lru) – 在内存中缓存瓦片数据\n- [tilestrata-etag](https://github.com/naturalatlas/tilestrata-etag) – 让瓦片图层支持自定义 ETag 标签，一般用来处理 http 缓存\n- [tilestrata-bing](https://github.com/naturalatlas/tilestrata-bing) – Bing 地图的 provider\n- [tilestrata-underzoom](https://github.com/naturalatlas/tilestrata-underzoom) - Build mosaics of higher-zoom tiles\n- [tilestrata-postgismvt](https://github.com/Stezii/tilestrata-postgismvt) – 使用 PostGIS 数据库输出 mvt 格式的瓦片\n- [tilestrata-postgis-geojson-tiles](https://github.com/naturalatlas/tilestrata-postgis-geojson-tiles) – 使用 PostGIS 数据库输出 GeoJSON 格式的瓦片\n\n## 3. 基本使用\n\n```js\nvar tilestrata = require('tilestrata')\nvar disk = require('tilestrata-disk')\nvar sharp = require('tilestrata-sharp')\nvar mapnik = require('tilestrata-mapnik')\nvar dependency = require('tilestrata-dependency')\nvar strata = tilestrata()\n\n// 定义一个图层\nstrata\n  .layer('layerName')\n  // 设置第一个瓦片路径\n  .route('tileName.png')\n  // 设置缓存目录\n  .use(disk.cache({ dir: '/var/lib/tiles/basemap' }))\n  // 设置数据源mapnik\n  .use(\n    mapnik({\n      pathname: '/path/to/map.xml',\n      tileSize: 512,\n      scale: 2\n    })\n  )\n  // 设置第二个瓦片路径\n  .route('tileSharp.png')\n  .use(disk.cache({ dir: '/var/lib/tiles/basemap' }))\n  // 用dependency插件直接使用layerName的源\n  .use(dependency('layerName', 'tileName.png'))\n  // 用sharp插件resize每个瓦片的大小\n  .use(\n    sharp(function(image, sharp) {\n      return image.resize(256)\n    })\n  )\n\n// 启动服务\nstrata.listen(8080)\n```\n\n服务启动后，可以通过下面的地址来访问瓦片数据：\n\n```\n/layerName/:z/:x:/:y/tileName.png\n```\n\n### 3.1 不定义瓦片名称\n\n从 [2.1.0](https://github.com/naturalatlas/tilestrata/releases/tag/v2.1.0)版本开始, 在设置`route`名称的时候，可以直接采用下面的形式，更加符合通用的瓦片格式：\n\n```js\n.route('*.png') // /layer/0/0/0.png\n.route('*@2x.png') // /layer/0/0/0@2x.png\n```\n\n### 3.2 整合 [Express.js](http://expressjs.com/) / [Connect](https://github.com/senchalabs/connect)\n\nTileStrata 可以定义成 Express 的一个中间件去使用，不必通过执行`strata.listen(8080)`来启动一个 server 服务，\n\n```js\nvar tilestrata = require('tilestrata')\nvar strata = tilestrata()\nstrata.layer('basemap') /* ... */\nstrata.layer('contours') /* ... */\n\napp.use(\n  tilestrata.middleware({\n    server: strata,\n    prefix: '/maps'\n  })\n)\n```\n\n## 4. 使用说明\n\n### 4.1 支持 Metatile 的负载均衡和图层共享\n\nTileStrata 从 [2.0.0](https://github.com/naturalatlas/tilestrata/releases/tag/v2.0.0) 版本开始支持集成[TileStrata Balancer](https://github.com/naturalatlas/tilestrata-balancer), 这是一个专门针对瓦片服务中的[metatiles](http://wiki.openstreetmap.org/wiki/Meta_tiles)设计的弹性负载均衡器，一般的负载均衡器并没有`metatiles`这个概念，所以会简单的把瓦片请求的分散到多个服务器，这样会导致冗余的渲染，不仅速度慢还会造成服务器资源浪费。\n\n需要额外注意的是，均衡器并不会假设负载池中的所有服务器都提供了相同的图层， 它会持续追踪每个节点上提供的所有的图层，因此他知道某个图层明确的访问路径。\n\n- **Fully elastic** （最小化配置）\n- **Consistent routing** (提高本地缓存命中率)\n- **Metatile-aware** (防止冗余渲染)\n- **Layer-aware** (支持图层的异构分布)\n\n[**TileStrata Balancer 详细文档 →**](https://github.com/naturalatlas/tilestrata-balancer)\n\n### 4.2 重建瓦片缓存\n\n在更新了图层的样式或者数据源后，你需要更新瓦片。这时候不必立刻删掉所有旧缓存，可以在请求头中设置`X-TileStrata-SkipCache`，逐步请求这些瓦片让服务器重新构建它们。[TileMantle](https://github.com/naturalatlas/tilemantle)工作可以让这个过程十分简单：\n\n```sh\nnpm install -g tilemantle\ntilemantle http://myhost.com/mylayer/{z}/{x}/{y}/t.png \\\n    -p 44.9457507,-109.5939822 -b 30mi -z 10-14 \\\n    -H \"X-TileStrata-SkipCache:mylayer/t.png\"\n```\n\n如果你使用了 [tilestrata-dependency](https://github.com/naturalatlas/tilestrata-dependency) 插件, 请求头则需要设置成如下形式：\n\n```\nX-TileStrata-SkipCache:*\nX-TileStrata-SkipCache:[layer]/[file],[layer]/[file],...\n```\n\n在一些高级的使用场景中，为了确保瓦片在缓存实际写入文件系统之前不要从服务器返回请求，需要额外做如下设置：\n\n```\nX-TileStrata-CacheWait:1\n```\n\n### 4.1 健康检查\n\nTileStrata 包含一个名为`/health`内置路径，如果服务器连接正常，你会收到`200 OK`的返回值。这可以用来自定义一些错误和成功提醒，设置想要的返回值。只要在初始化 tilestrata 时，给选项中的 healthy 设置一个回调函数即可。\n\n```js\n// 不健康状态\nvar strata = tilestrata({\n  healthy: function(callback) {\n    callback(new Error('CPU is too high'), { loadavg: 3 })\n  }\n})\n\n// 错误信息'CPU is too high'会包装在message字段中返回\n\n// 健康状态\nvar strata = tilestrata({\n  healthy: function(callback) {\n    callback(null, { loadavg: 1 })\n  }\n})\n\n// 正确的返回值中将会额外的多一个loadavg字段，这将是你自定义的内容\n```\n","slug":"tilestrata-intro","published":1,"updated":"2019-07-18T10:16:42.601Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrkxgt7000li83ihtgezhmr","content":"<p>简单来说<a href=\"https://github.com/naturalatlas/tilestrata\" target=\"_blank\" rel=\"noopener\"><strong>Tilestrata</strong></a>就是一个瓦片地图服务器。根据其自身的介绍，它有如下的特点：零配置，简洁，测试覆盖率高，性能高，拓展性强。可以通过<a href=\"https://github.com/naturalatlas/tilestrata-balancer\" target=\"_blank\" rel=\"noopener\">TileStrata Balancer</a>实现负载均衡，无缝伸缩。可以通过内置<a href=\"https://github.com/naturalatlas/tilestrata#profiling--debugging-performance\" target=\"_blank\" rel=\"noopener\">控制台</a>去调试查看渲染时间。</p>\n<a id=\"more\"></a>\n<p>本文主要基于官方的文档介绍及部分使用心得，旨在帮助大家快速上手，进阶使用会后续说明。</p>\n<p>安装：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata --save</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-主要结构\"><a href=\"#1-主要结构\" class=\"headerlink\" title=\"1. 主要结构\"></a>1. 主要结构</h2><p>TileStrata 的结构上有以下五个主要组成部分，通常用来实现各种插件，我个人习惯把它们看作是生命周期流程，正是由于这些 hook 的存在，我们就可以在 TileStrata 生命周期的各个阶段去实现各种巧妙的功能：</p>\n<ul>\n<li><code>request hook</code> – 请求预处理</li>\n<li><code>cache</code> – 缓存控制</li>\n<li><code>provider</code> – 数据源，比如 mapnik</li>\n<li><code>transform</code> – 最关键的阶段，可以在瓦片输出的过程中对其做各种加工，比如旋转，染色</li>\n<li><code>response hook</code> – 响应后处理，比如 headers、jsonp 插件</li>\n</ul>\n<p>官方提供了一张很直观的流程图：</p>\n<p><img src=\"https://camo.githubusercontent.com/67abe0f563502d78ef12b4ce20cba57222dfcf6f/68747470733a2f2f63646e2e7261776769742e636f6d2f6e61747572616c61746c61732f74696c657374726174612f6d61737465722f6d6973632f67726170686963732f726571666c6f772e737667\" alt></p>\n<h2 id=\"2-常用插件\"><a href=\"#2-常用插件\" class=\"headerlink\" title=\"2. 常用插件\"></a>2. 常用插件</h2><ul>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-mapnik\" target=\"_blank\" rel=\"noopener\">tilestrata-mapnik</a> – 使用 <a href=\"http://mapnik.org/\" target=\"_blank\" rel=\"noopener\">mapnik</a>做数据源进行渲染</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-disk\" target=\"_blank\" rel=\"noopener\">tilestrata-disk</a> – 服务端缓存插件</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-dependency\" target=\"_blank\" rel=\"noopener\">tilestrata-dependency</a> – 直接使用其他定义好的图层来获取数据，而不是定义一个 provider</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-sharp\" target=\"_blank\" rel=\"noopener\">tilestrata-sharp</a> – 用 <a href=\"https://www.npmjs.com/package/sharp\" target=\"_blank\" rel=\"noopener\">libvips</a>来做一些图片的处理，比如压缩，旋转，转换类型</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-gm\" target=\"_blank\" rel=\"noopener\">tilestrata-gm</a> – 使用 <a href=\"https://www.npmjs.com/package/gm\" target=\"_blank\" rel=\"noopener\">GraphicsMagick</a>来对图片做处理，大体上和上面类似</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-headers\" target=\"_blank\" rel=\"noopener\">tilestrata-headers</a> – 设置请求的响应头，可以解决跨域问题</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-blend\" target=\"_blank\" rel=\"noopener\">tilestrata-blend</a> – 合成多个瓦片图层为一个图层，比方组合道路+建筑为一个图层</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-jsonp\" target=\"_blank\" rel=\"noopener\">tilestrata-jsonp</a> – 使 utfgrids 类的 json 数据支持 jsonp 请求方式</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-datadog\" target=\"_blank\" rel=\"noopener\">tilestrata-datadog</a> – 继承数据到<a href=\"https://www.datadoghq.com/\" target=\"_blank\" rel=\"noopener\">Datadog</a>服务</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-utfmerge\" target=\"_blank\" rel=\"noopener\">tilestrata-utfmerge</a> – 合并两个 utfgrids 类图层为一个图层</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-vtile\" target=\"_blank\" rel=\"noopener\">tilestrata-vtile</a> – 输出 mapnik 数据为矢量切片 pbf 格式</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-vtile-raster\" target=\"_blank\" rel=\"noopener\">tilestrata-vtile-raster</a> – 将上面的 pbf 的是瓦片转换成栅格瓦片</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-vtile-composite\" target=\"_blank\" rel=\"noopener\">tilestrata-vtile-composite</a> – 合并多个矢量瓦片图层</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-proxy\" target=\"_blank\" rel=\"noopener\">tilestrata-proxy</a> – 为其他瓦片服务器提供代理</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-lru\" target=\"_blank\" rel=\"noopener\">tilestrata-lru</a> – 在内存中缓存瓦片数据</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-etag\" target=\"_blank\" rel=\"noopener\">tilestrata-etag</a> – 让瓦片图层支持自定义 ETag 标签，一般用来处理 http 缓存</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-bing\" target=\"_blank\" rel=\"noopener\">tilestrata-bing</a> – Bing 地图的 provider</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-underzoom\" target=\"_blank\" rel=\"noopener\">tilestrata-underzoom</a> - Build mosaics of higher-zoom tiles</li>\n<li><a href=\"https://github.com/Stezii/tilestrata-postgismvt\" target=\"_blank\" rel=\"noopener\">tilestrata-postgismvt</a> – 使用 PostGIS 数据库输出 mvt 格式的瓦片</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-postgis-geojson-tiles\" target=\"_blank\" rel=\"noopener\">tilestrata-postgis-geojson-tiles</a> – 使用 PostGIS 数据库输出 GeoJSON 格式的瓦片</li>\n</ul>\n<h2 id=\"3-基本使用\"><a href=\"#3-基本使用\" class=\"headerlink\" title=\"3. 基本使用\"></a>3. 基本使用</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> disk = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-disk'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> sharp = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-sharp'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> dependency = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-dependency'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> strata = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个图层</span></span><br><span class=\"line\">strata</span><br><span class=\"line\">  .layer(<span class=\"string\">'layerName'</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 设置第一个瓦片路径</span></span><br><span class=\"line\">  .route(<span class=\"string\">'tileName.png'</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 设置缓存目录</span></span><br><span class=\"line\">  .use(disk.cache(&#123; <span class=\"attr\">dir</span>: <span class=\"string\">'/var/lib/tiles/basemap'</span> &#125;))</span><br><span class=\"line\">  <span class=\"comment\">// 设置数据源mapnik</span></span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'/path/to/map.xml'</span>,</span><br><span class=\"line\">      tileSize: <span class=\"number\">512</span>,</span><br><span class=\"line\">      scale: <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  <span class=\"comment\">// 设置第二个瓦片路径</span></span><br><span class=\"line\">  .route(<span class=\"string\">'tileSharp.png'</span>)</span><br><span class=\"line\">  .use(disk.cache(&#123; <span class=\"attr\">dir</span>: <span class=\"string\">'/var/lib/tiles/basemap'</span> &#125;))</span><br><span class=\"line\">  <span class=\"comment\">// 用dependency插件直接使用layerName的源</span></span><br><span class=\"line\">  .use(dependency(<span class=\"string\">'layerName'</span>, <span class=\"string\">'tileName.png'</span>))</span><br><span class=\"line\">  <span class=\"comment\">// 用sharp插件resize每个瓦片的大小</span></span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    sharp(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">image, sharp</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> image.resize(<span class=\"number\">256</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">strata.listen(<span class=\"number\">8080</span>)</span><br></pre></td></tr></table></figure>\n<p>服务启动后，可以通过下面的地址来访问瓦片数据：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/layerName/:z/:x:/:y/tileName.png</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-1-不定义瓦片名称\"><a href=\"#3-1-不定义瓦片名称\" class=\"headerlink\" title=\"3.1 不定义瓦片名称\"></a>3.1 不定义瓦片名称</h3><p>从 <a href=\"https://github.com/naturalatlas/tilestrata/releases/tag/v2.1.0\" target=\"_blank\" rel=\"noopener\">2.1.0</a>版本开始, 在设置<code>route</code>名称的时候，可以直接采用下面的形式，更加符合通用的瓦片格式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">.route(<span class=\"string\">'*.png'</span>) <span class=\"comment\">// /layer/0/0/0.png</span></span><br><span class=\"line\">.route(<span class=\"string\">'*@2x.png'</span>) <span class=\"comment\">// /layer/0/0/0@2x.png</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-整合-Express-js-Connect\"><a href=\"#3-2-整合-Express-js-Connect\" class=\"headerlink\" title=\"3.2 整合 Express.js / Connect\"></a>3.2 整合 <a href=\"http://expressjs.com/\" target=\"_blank\" rel=\"noopener\">Express.js</a> / <a href=\"https://github.com/senchalabs/connect\" target=\"_blank\" rel=\"noopener\">Connect</a></h3><p>TileStrata 可以定义成 Express 的一个中间件去使用，不必通过执行<code>strata.listen(8080)</code>来启动一个 server 服务，</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> strata = tilestrata()</span><br><span class=\"line\">strata.layer(<span class=\"string\">'basemap'</span>) <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">strata.layer(<span class=\"string\">'contours'</span>) <span class=\"comment\">/* ... */</span></span><br><span class=\"line\"></span><br><span class=\"line\">app.use(</span><br><span class=\"line\">  tilestrata.middleware(&#123;</span><br><span class=\"line\">    server: strata,</span><br><span class=\"line\">    prefix: <span class=\"string\">'/maps'</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-使用说明\"><a href=\"#4-使用说明\" class=\"headerlink\" title=\"4. 使用说明\"></a>4. 使用说明</h2><h3 id=\"4-1-支持-Metatile-的负载均衡和图层共享\"><a href=\"#4-1-支持-Metatile-的负载均衡和图层共享\" class=\"headerlink\" title=\"4.1 支持 Metatile 的负载均衡和图层共享\"></a>4.1 支持 Metatile 的负载均衡和图层共享</h3><p>TileStrata 从 <a href=\"https://github.com/naturalatlas/tilestrata/releases/tag/v2.0.0\" target=\"_blank\" rel=\"noopener\">2.0.0</a> 版本开始支持集成<a href=\"https://github.com/naturalatlas/tilestrata-balancer\" target=\"_blank\" rel=\"noopener\">TileStrata Balancer</a>, 这是一个专门针对瓦片服务中的<a href=\"http://wiki.openstreetmap.org/wiki/Meta_tiles\" target=\"_blank\" rel=\"noopener\">metatiles</a>设计的弹性负载均衡器，一般的负载均衡器并没有<code>metatiles</code>这个概念，所以会简单的把瓦片请求的分散到多个服务器，这样会导致冗余的渲染，不仅速度慢还会造成服务器资源浪费。</p>\n<p>需要额外注意的是，均衡器并不会假设负载池中的所有服务器都提供了相同的图层， 它会持续追踪每个节点上提供的所有的图层，因此他知道某个图层明确的访问路径。</p>\n<ul>\n<li><strong>Fully elastic</strong> （最小化配置）</li>\n<li><strong>Consistent routing</strong> (提高本地缓存命中率)</li>\n<li><strong>Metatile-aware</strong> (防止冗余渲染)</li>\n<li><strong>Layer-aware</strong> (支持图层的异构分布)</li>\n</ul>\n<p><a href=\"https://github.com/naturalatlas/tilestrata-balancer\" target=\"_blank\" rel=\"noopener\"><strong>TileStrata Balancer 详细文档 →</strong></a></p>\n<h3 id=\"4-2-重建瓦片缓存\"><a href=\"#4-2-重建瓦片缓存\" class=\"headerlink\" title=\"4.2 重建瓦片缓存\"></a>4.2 重建瓦片缓存</h3><p>在更新了图层的样式或者数据源后，你需要更新瓦片。这时候不必立刻删掉所有旧缓存，可以在请求头中设置<code>X-TileStrata-SkipCache</code>，逐步请求这些瓦片让服务器重新构建它们。<a href=\"https://github.com/naturalatlas/tilemantle\" target=\"_blank\" rel=\"noopener\">TileMantle</a>工作可以让这个过程十分简单：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install -g tilemantle</span><br><span class=\"line\">tilemantle http://myhost.com/mylayer/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;/t.png \\</span><br><span class=\"line\">    -p 44.9457507,-109.5939822 -b 30mi -z 10-14 \\</span><br><span class=\"line\">    -H <span class=\"string\">\"X-TileStrata-SkipCache:mylayer/t.png\"</span></span><br></pre></td></tr></table></figure>\n<p>如果你使用了 <a href=\"https://github.com/naturalatlas/tilestrata-dependency\" target=\"_blank\" rel=\"noopener\">tilestrata-dependency</a> 插件, 请求头则需要设置成如下形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">X-TileStrata-SkipCache:*</span><br><span class=\"line\">X-TileStrata-SkipCache:[layer]/[file],[layer]/[file],...</span><br></pre></td></tr></table></figure>\n<p>在一些高级的使用场景中，为了确保瓦片在缓存实际写入文件系统之前不要从服务器返回请求，需要额外做如下设置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">X-TileStrata-CacheWait:1</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-1-健康检查\"><a href=\"#4-1-健康检查\" class=\"headerlink\" title=\"4.1 健康检查\"></a>4.1 健康检查</h3><p>TileStrata 包含一个名为<code>/health</code>内置路径，如果服务器连接正常，你会收到<code>200 OK</code>的返回值。这可以用来自定义一些错误和成功提醒，设置想要的返回值。只要在初始化 tilestrata 时，给选项中的 healthy 设置一个回调函数即可。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不健康状态</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> strata = tilestrata(&#123;</span><br><span class=\"line\">  healthy: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">    callback(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'CPU is too high'</span>), &#123; <span class=\"attr\">loadavg</span>: <span class=\"number\">3</span> &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 错误信息'CPU is too high'会包装在message字段中返回</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 健康状态</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> strata = tilestrata(&#123;</span><br><span class=\"line\">  healthy: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">    callback(<span class=\"literal\">null</span>, &#123; <span class=\"attr\">loadavg</span>: <span class=\"number\">1</span> &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确的返回值中将会额外的多一个loadavg字段，这将是你自定义的内容</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>简单来说<a href=\"https://github.com/naturalatlas/tilestrata\" target=\"_blank\" rel=\"noopener\"><strong>Tilestrata</strong></a>就是一个瓦片地图服务器。根据其自身的介绍，它有如下的特点：零配置，简洁，测试覆盖率高，性能高，拓展性强。可以通过<a href=\"https://github.com/naturalatlas/tilestrata-balancer\" target=\"_blank\" rel=\"noopener\">TileStrata Balancer</a>实现负载均衡，无缝伸缩。可以通过内置<a href=\"https://github.com/naturalatlas/tilestrata#profiling--debugging-performance\" target=\"_blank\" rel=\"noopener\">控制台</a>去调试查看渲染时间。</p>","more":"<p>本文主要基于官方的文档介绍及部分使用心得，旨在帮助大家快速上手，进阶使用会后续说明。</p>\n<p>安装：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata --save</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-主要结构\"><a href=\"#1-主要结构\" class=\"headerlink\" title=\"1. 主要结构\"></a>1. 主要结构</h2><p>TileStrata 的结构上有以下五个主要组成部分，通常用来实现各种插件，我个人习惯把它们看作是生命周期流程，正是由于这些 hook 的存在，我们就可以在 TileStrata 生命周期的各个阶段去实现各种巧妙的功能：</p>\n<ul>\n<li><code>request hook</code> – 请求预处理</li>\n<li><code>cache</code> – 缓存控制</li>\n<li><code>provider</code> – 数据源，比如 mapnik</li>\n<li><code>transform</code> – 最关键的阶段，可以在瓦片输出的过程中对其做各种加工，比如旋转，染色</li>\n<li><code>response hook</code> – 响应后处理，比如 headers、jsonp 插件</li>\n</ul>\n<p>官方提供了一张很直观的流程图：</p>\n<p><img src=\"https://camo.githubusercontent.com/67abe0f563502d78ef12b4ce20cba57222dfcf6f/68747470733a2f2f63646e2e7261776769742e636f6d2f6e61747572616c61746c61732f74696c657374726174612f6d61737465722f6d6973632f67726170686963732f726571666c6f772e737667\" alt></p>\n<h2 id=\"2-常用插件\"><a href=\"#2-常用插件\" class=\"headerlink\" title=\"2. 常用插件\"></a>2. 常用插件</h2><ul>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-mapnik\" target=\"_blank\" rel=\"noopener\">tilestrata-mapnik</a> – 使用 <a href=\"http://mapnik.org/\" target=\"_blank\" rel=\"noopener\">mapnik</a>做数据源进行渲染</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-disk\" target=\"_blank\" rel=\"noopener\">tilestrata-disk</a> – 服务端缓存插件</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-dependency\" target=\"_blank\" rel=\"noopener\">tilestrata-dependency</a> – 直接使用其他定义好的图层来获取数据，而不是定义一个 provider</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-sharp\" target=\"_blank\" rel=\"noopener\">tilestrata-sharp</a> – 用 <a href=\"https://www.npmjs.com/package/sharp\" target=\"_blank\" rel=\"noopener\">libvips</a>来做一些图片的处理，比如压缩，旋转，转换类型</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-gm\" target=\"_blank\" rel=\"noopener\">tilestrata-gm</a> – 使用 <a href=\"https://www.npmjs.com/package/gm\" target=\"_blank\" rel=\"noopener\">GraphicsMagick</a>来对图片做处理，大体上和上面类似</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-headers\" target=\"_blank\" rel=\"noopener\">tilestrata-headers</a> – 设置请求的响应头，可以解决跨域问题</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-blend\" target=\"_blank\" rel=\"noopener\">tilestrata-blend</a> – 合成多个瓦片图层为一个图层，比方组合道路+建筑为一个图层</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-jsonp\" target=\"_blank\" rel=\"noopener\">tilestrata-jsonp</a> – 使 utfgrids 类的 json 数据支持 jsonp 请求方式</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-datadog\" target=\"_blank\" rel=\"noopener\">tilestrata-datadog</a> – 继承数据到<a href=\"https://www.datadoghq.com/\" target=\"_blank\" rel=\"noopener\">Datadog</a>服务</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-utfmerge\" target=\"_blank\" rel=\"noopener\">tilestrata-utfmerge</a> – 合并两个 utfgrids 类图层为一个图层</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-vtile\" target=\"_blank\" rel=\"noopener\">tilestrata-vtile</a> – 输出 mapnik 数据为矢量切片 pbf 格式</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-vtile-raster\" target=\"_blank\" rel=\"noopener\">tilestrata-vtile-raster</a> – 将上面的 pbf 的是瓦片转换成栅格瓦片</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-vtile-composite\" target=\"_blank\" rel=\"noopener\">tilestrata-vtile-composite</a> – 合并多个矢量瓦片图层</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-proxy\" target=\"_blank\" rel=\"noopener\">tilestrata-proxy</a> – 为其他瓦片服务器提供代理</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-lru\" target=\"_blank\" rel=\"noopener\">tilestrata-lru</a> – 在内存中缓存瓦片数据</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-etag\" target=\"_blank\" rel=\"noopener\">tilestrata-etag</a> – 让瓦片图层支持自定义 ETag 标签，一般用来处理 http 缓存</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-bing\" target=\"_blank\" rel=\"noopener\">tilestrata-bing</a> – Bing 地图的 provider</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-underzoom\" target=\"_blank\" rel=\"noopener\">tilestrata-underzoom</a> - Build mosaics of higher-zoom tiles</li>\n<li><a href=\"https://github.com/Stezii/tilestrata-postgismvt\" target=\"_blank\" rel=\"noopener\">tilestrata-postgismvt</a> – 使用 PostGIS 数据库输出 mvt 格式的瓦片</li>\n<li><a href=\"https://github.com/naturalatlas/tilestrata-postgis-geojson-tiles\" target=\"_blank\" rel=\"noopener\">tilestrata-postgis-geojson-tiles</a> – 使用 PostGIS 数据库输出 GeoJSON 格式的瓦片</li>\n</ul>\n<h2 id=\"3-基本使用\"><a href=\"#3-基本使用\" class=\"headerlink\" title=\"3. 基本使用\"></a>3. 基本使用</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> disk = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-disk'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> sharp = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-sharp'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> dependency = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-dependency'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> strata = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个图层</span></span><br><span class=\"line\">strata</span><br><span class=\"line\">  .layer(<span class=\"string\">'layerName'</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 设置第一个瓦片路径</span></span><br><span class=\"line\">  .route(<span class=\"string\">'tileName.png'</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 设置缓存目录</span></span><br><span class=\"line\">  .use(disk.cache(&#123; <span class=\"attr\">dir</span>: <span class=\"string\">'/var/lib/tiles/basemap'</span> &#125;))</span><br><span class=\"line\">  <span class=\"comment\">// 设置数据源mapnik</span></span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'/path/to/map.xml'</span>,</span><br><span class=\"line\">      tileSize: <span class=\"number\">512</span>,</span><br><span class=\"line\">      scale: <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  <span class=\"comment\">// 设置第二个瓦片路径</span></span><br><span class=\"line\">  .route(<span class=\"string\">'tileSharp.png'</span>)</span><br><span class=\"line\">  .use(disk.cache(&#123; <span class=\"attr\">dir</span>: <span class=\"string\">'/var/lib/tiles/basemap'</span> &#125;))</span><br><span class=\"line\">  <span class=\"comment\">// 用dependency插件直接使用layerName的源</span></span><br><span class=\"line\">  .use(dependency(<span class=\"string\">'layerName'</span>, <span class=\"string\">'tileName.png'</span>))</span><br><span class=\"line\">  <span class=\"comment\">// 用sharp插件resize每个瓦片的大小</span></span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    sharp(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">image, sharp</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> image.resize(<span class=\"number\">256</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">strata.listen(<span class=\"number\">8080</span>)</span><br></pre></td></tr></table></figure>\n<p>服务启动后，可以通过下面的地址来访问瓦片数据：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/layerName/:z/:x:/:y/tileName.png</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-1-不定义瓦片名称\"><a href=\"#3-1-不定义瓦片名称\" class=\"headerlink\" title=\"3.1 不定义瓦片名称\"></a>3.1 不定义瓦片名称</h3><p>从 <a href=\"https://github.com/naturalatlas/tilestrata/releases/tag/v2.1.0\" target=\"_blank\" rel=\"noopener\">2.1.0</a>版本开始, 在设置<code>route</code>名称的时候，可以直接采用下面的形式，更加符合通用的瓦片格式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">.route(<span class=\"string\">'*.png'</span>) <span class=\"comment\">// /layer/0/0/0.png</span></span><br><span class=\"line\">.route(<span class=\"string\">'*@2x.png'</span>) <span class=\"comment\">// /layer/0/0/0@2x.png</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-整合-Express-js-Connect\"><a href=\"#3-2-整合-Express-js-Connect\" class=\"headerlink\" title=\"3.2 整合 Express.js / Connect\"></a>3.2 整合 <a href=\"http://expressjs.com/\" target=\"_blank\" rel=\"noopener\">Express.js</a> / <a href=\"https://github.com/senchalabs/connect\" target=\"_blank\" rel=\"noopener\">Connect</a></h3><p>TileStrata 可以定义成 Express 的一个中间件去使用，不必通过执行<code>strata.listen(8080)</code>来启动一个 server 服务，</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> strata = tilestrata()</span><br><span class=\"line\">strata.layer(<span class=\"string\">'basemap'</span>) <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">strata.layer(<span class=\"string\">'contours'</span>) <span class=\"comment\">/* ... */</span></span><br><span class=\"line\"></span><br><span class=\"line\">app.use(</span><br><span class=\"line\">  tilestrata.middleware(&#123;</span><br><span class=\"line\">    server: strata,</span><br><span class=\"line\">    prefix: <span class=\"string\">'/maps'</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-使用说明\"><a href=\"#4-使用说明\" class=\"headerlink\" title=\"4. 使用说明\"></a>4. 使用说明</h2><h3 id=\"4-1-支持-Metatile-的负载均衡和图层共享\"><a href=\"#4-1-支持-Metatile-的负载均衡和图层共享\" class=\"headerlink\" title=\"4.1 支持 Metatile 的负载均衡和图层共享\"></a>4.1 支持 Metatile 的负载均衡和图层共享</h3><p>TileStrata 从 <a href=\"https://github.com/naturalatlas/tilestrata/releases/tag/v2.0.0\" target=\"_blank\" rel=\"noopener\">2.0.0</a> 版本开始支持集成<a href=\"https://github.com/naturalatlas/tilestrata-balancer\" target=\"_blank\" rel=\"noopener\">TileStrata Balancer</a>, 这是一个专门针对瓦片服务中的<a href=\"http://wiki.openstreetmap.org/wiki/Meta_tiles\" target=\"_blank\" rel=\"noopener\">metatiles</a>设计的弹性负载均衡器，一般的负载均衡器并没有<code>metatiles</code>这个概念，所以会简单的把瓦片请求的分散到多个服务器，这样会导致冗余的渲染，不仅速度慢还会造成服务器资源浪费。</p>\n<p>需要额外注意的是，均衡器并不会假设负载池中的所有服务器都提供了相同的图层， 它会持续追踪每个节点上提供的所有的图层，因此他知道某个图层明确的访问路径。</p>\n<ul>\n<li><strong>Fully elastic</strong> （最小化配置）</li>\n<li><strong>Consistent routing</strong> (提高本地缓存命中率)</li>\n<li><strong>Metatile-aware</strong> (防止冗余渲染)</li>\n<li><strong>Layer-aware</strong> (支持图层的异构分布)</li>\n</ul>\n<p><a href=\"https://github.com/naturalatlas/tilestrata-balancer\" target=\"_blank\" rel=\"noopener\"><strong>TileStrata Balancer 详细文档 →</strong></a></p>\n<h3 id=\"4-2-重建瓦片缓存\"><a href=\"#4-2-重建瓦片缓存\" class=\"headerlink\" title=\"4.2 重建瓦片缓存\"></a>4.2 重建瓦片缓存</h3><p>在更新了图层的样式或者数据源后，你需要更新瓦片。这时候不必立刻删掉所有旧缓存，可以在请求头中设置<code>X-TileStrata-SkipCache</code>，逐步请求这些瓦片让服务器重新构建它们。<a href=\"https://github.com/naturalatlas/tilemantle\" target=\"_blank\" rel=\"noopener\">TileMantle</a>工作可以让这个过程十分简单：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install -g tilemantle</span><br><span class=\"line\">tilemantle http://myhost.com/mylayer/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;/t.png \\</span><br><span class=\"line\">    -p 44.9457507,-109.5939822 -b 30mi -z 10-14 \\</span><br><span class=\"line\">    -H <span class=\"string\">\"X-TileStrata-SkipCache:mylayer/t.png\"</span></span><br></pre></td></tr></table></figure>\n<p>如果你使用了 <a href=\"https://github.com/naturalatlas/tilestrata-dependency\" target=\"_blank\" rel=\"noopener\">tilestrata-dependency</a> 插件, 请求头则需要设置成如下形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">X-TileStrata-SkipCache:*</span><br><span class=\"line\">X-TileStrata-SkipCache:[layer]/[file],[layer]/[file],...</span><br></pre></td></tr></table></figure>\n<p>在一些高级的使用场景中，为了确保瓦片在缓存实际写入文件系统之前不要从服务器返回请求，需要额外做如下设置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">X-TileStrata-CacheWait:1</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-1-健康检查\"><a href=\"#4-1-健康检查\" class=\"headerlink\" title=\"4.1 健康检查\"></a>4.1 健康检查</h3><p>TileStrata 包含一个名为<code>/health</code>内置路径，如果服务器连接正常，你会收到<code>200 OK</code>的返回值。这可以用来自定义一些错误和成功提醒，设置想要的返回值。只要在初始化 tilestrata 时，给选项中的 healthy 设置一个回调函数即可。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不健康状态</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> strata = tilestrata(&#123;</span><br><span class=\"line\">  healthy: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">    callback(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'CPU is too high'</span>), &#123; <span class=\"attr\">loadavg</span>: <span class=\"number\">3</span> &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 错误信息'CPU is too high'会包装在message字段中返回</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 健康状态</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> strata = tilestrata(&#123;</span><br><span class=\"line\">  healthy: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">    callback(<span class=\"literal\">null</span>, &#123; <span class=\"attr\">loadavg</span>: <span class=\"number\">1</span> &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确的返回值中将会额外的多一个loadavg字段，这将是你自定义的内容</span></span><br></pre></td></tr></table></figure>"},{"title":"tilestrata-jsonp 插件使用及浅析","date":"2019-06-23T12:15:44.000Z","_content":"\n[tilestrata-jsonp](https://github.com/naturalatlas/tilestrata-jsonp)插件可以将一些网格（utfgrids）的 json 请求包装成 jsonp，使你不必配置 CORS 也可以跨域访问这些资源。这是除了 tilestrata-headers 以外的另一个实用型插件。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```bash\nnpm install tilestrata-jsonp --save\n```\n\n# 2. 使用\n\n```js\nvar tilestrata = require(\"tilestrata\");\nvar jsonp = require(\"tilestrata-jsonp\");\nvar tilestrataPostGISGeoJSON = require(\"tilestrata-postgis-geojson-tiles\");\n\nserver = tilestrata();\n\nserver\n  .layer(\"geojson_tiles_jsonp\")\n  .route(\"tile.json\")\n  .use(jsonp({ variable: \"callback\" }))\n  .use(\n    // Provider 这里用tilestrataPostGISGeoJSON做示例\n    tilestrataPostGISGeoJSON({\n      geometryField: \"geom\",\n      sql: function(server, req) {\n        return \"select name, {geojson} from (select name, ST_Transform(way,4326) as geom from osm_polygon where name ~ '上海') as a1 WHERE ST_Intersects(geom, {bbox})\";\n      },\n      pgConfig: {\n        username: \"postgres\",\n        password: \"postgres\",\n        host: \"localhost\",\n        port: \"5432\",\n        database: \"osm\"\n      }\n    })\n  );\n\nserver.listen(9527);\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n在启动 server 后，我们可以直接用`jquery`请求某个固定层级的瓦片，来测试是否成功触发`callbak`函数\n\n```js\n$.ajax({\n  url: \"http://127.0.0.1:9527/geojson_tiles_jsonp/4/15/8/tile.json\",\n  type: \"GET\",\n  dataType: \"jsonp\",\n  success: function(data) {\n    console.log(\"jsonp使用成功\");\n  }\n});\n```\n\n结果\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-jsonp-result-20190606145036.png)\n\n# 4. 代码浅析\n\n原理比较简单，和 headers 插件类似，在`tilestrata`的设计中，会使用`use`去注册各种类型的插件，`tilestrata-headers`就是`reshook`类型的插件，在初始化的过程中会被注册\n\n```js\nTileRequestHandler.prototype.use = function(plugin) {\n  if (!plugin) return this;\n  // ...简化后的代码\n  if (plugin.reshook) return this._registerResponseHook(plugin);\n};\n\nTileRequestHandler.prototype._registerResponseHook = function(plugin) {\n  var id = \"reshook#\" + this.responseHooks.length;\n  if (!plugin) throw new Error(\"Falsy value passed to registerResponseHook()\");\n  if (typeof plugin.reshook !== \"function\")\n    throw new Error(\n      \"Attempted to register a response hook with no reshook() method\"\n    );\n  this.responseHooks.push({ id: id, plugin: plugin });\n  return this;\n};\n```\n\n通过这种方式，插件会设置响应内容为`Content-Type: text/javascript;`，给我们返回一段包含了回调函数的代码，来执行我们预先定义好的 callbak 函数。\n","source":"_posts/2019/tilestrata-jsonp.md","raw":"---\ntitle: tilestrata-jsonp 插件使用及浅析\ndate: 2019-06-23 20:15:44\ntags: [GIS]\ncategories: TileStrata\n---\n\n[tilestrata-jsonp](https://github.com/naturalatlas/tilestrata-jsonp)插件可以将一些网格（utfgrids）的 json 请求包装成 jsonp，使你不必配置 CORS 也可以跨域访问这些资源。这是除了 tilestrata-headers 以外的另一个实用型插件。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```bash\nnpm install tilestrata-jsonp --save\n```\n\n# 2. 使用\n\n```js\nvar tilestrata = require(\"tilestrata\");\nvar jsonp = require(\"tilestrata-jsonp\");\nvar tilestrataPostGISGeoJSON = require(\"tilestrata-postgis-geojson-tiles\");\n\nserver = tilestrata();\n\nserver\n  .layer(\"geojson_tiles_jsonp\")\n  .route(\"tile.json\")\n  .use(jsonp({ variable: \"callback\" }))\n  .use(\n    // Provider 这里用tilestrataPostGISGeoJSON做示例\n    tilestrataPostGISGeoJSON({\n      geometryField: \"geom\",\n      sql: function(server, req) {\n        return \"select name, {geojson} from (select name, ST_Transform(way,4326) as geom from osm_polygon where name ~ '上海') as a1 WHERE ST_Intersects(geom, {bbox})\";\n      },\n      pgConfig: {\n        username: \"postgres\",\n        password: \"postgres\",\n        host: \"localhost\",\n        port: \"5432\",\n        database: \"osm\"\n      }\n    })\n  );\n\nserver.listen(9527);\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n在启动 server 后，我们可以直接用`jquery`请求某个固定层级的瓦片，来测试是否成功触发`callbak`函数\n\n```js\n$.ajax({\n  url: \"http://127.0.0.1:9527/geojson_tiles_jsonp/4/15/8/tile.json\",\n  type: \"GET\",\n  dataType: \"jsonp\",\n  success: function(data) {\n    console.log(\"jsonp使用成功\");\n  }\n});\n```\n\n结果\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-jsonp-result-20190606145036.png)\n\n# 4. 代码浅析\n\n原理比较简单，和 headers 插件类似，在`tilestrata`的设计中，会使用`use`去注册各种类型的插件，`tilestrata-headers`就是`reshook`类型的插件，在初始化的过程中会被注册\n\n```js\nTileRequestHandler.prototype.use = function(plugin) {\n  if (!plugin) return this;\n  // ...简化后的代码\n  if (plugin.reshook) return this._registerResponseHook(plugin);\n};\n\nTileRequestHandler.prototype._registerResponseHook = function(plugin) {\n  var id = \"reshook#\" + this.responseHooks.length;\n  if (!plugin) throw new Error(\"Falsy value passed to registerResponseHook()\");\n  if (typeof plugin.reshook !== \"function\")\n    throw new Error(\n      \"Attempted to register a response hook with no reshook() method\"\n    );\n  this.responseHooks.push({ id: id, plugin: plugin });\n  return this;\n};\n```\n\n通过这种方式，插件会设置响应内容为`Content-Type: text/javascript;`，给我们返回一段包含了回调函数的代码，来执行我们预先定义好的 callbak 函数。\n","slug":"tilestrata-jsonp","published":1,"updated":"2019-06-28T05:56:28.441Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrkxgt8000mi83ihlaclpmb","content":"<p><a href=\"https://github.com/naturalatlas/tilestrata-jsonp\" target=\"_blank\" rel=\"noopener\">tilestrata-jsonp</a>插件可以将一些网格（utfgrids）的 json 请求包装成 jsonp，使你不必配置 CORS 也可以跨域访问这些资源。这是除了 tilestrata-headers 以外的另一个实用型插件。</p>\n<a id=\"more\"></a>\n<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install tilestrata-jsonp --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> jsonp = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata-jsonp\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> tilestrataPostGISGeoJSON = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata-postgis-geojson-tiles\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">server = tilestrata();</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">\"geojson_tiles_jsonp\"</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">\"tile.json\"</span>)</span><br><span class=\"line\">  .use(jsonp(&#123; <span class=\"attr\">variable</span>: <span class=\"string\">\"callback\"</span> &#125;))</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    <span class=\"comment\">// Provider 这里用tilestrataPostGISGeoJSON做示例</span></span><br><span class=\"line\">    tilestrataPostGISGeoJSON(&#123;</span><br><span class=\"line\">      geometryField: <span class=\"string\">\"geom\"</span>,</span><br><span class=\"line\">      sql: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"select name, &#123;geojson&#125; from (select name, ST_Transform(way,4326) as geom from osm_polygon where name ~ '上海') as a1 WHERE ST_Intersects(geom, &#123;bbox&#125;)\"</span>;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      pgConfig: &#123;</span><br><span class=\"line\">        username: <span class=\"string\">\"postgres\"</span>,</span><br><span class=\"line\">        password: <span class=\"string\">\"postgres\"</span>,</span><br><span class=\"line\">        host: <span class=\"string\">\"localhost\"</span>,</span><br><span class=\"line\">        port: <span class=\"string\">\"5432\"</span>,</span><br><span class=\"line\">        database: <span class=\"string\">\"osm\"</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>);</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>在启动 server 后，我们可以直接用<code>jquery</code>请求某个固定层级的瓦片，来测试是否成功触发<code>callbak</code>函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">  url: <span class=\"string\">\"http://127.0.0.1:9527/geojson_tiles_jsonp/4/15/8/tile.json\"</span>,</span><br><span class=\"line\">  type: <span class=\"string\">\"GET\"</span>,</span><br><span class=\"line\">  dataType: <span class=\"string\">\"jsonp\"</span>,</span><br><span class=\"line\">  success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"jsonp使用成功\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>结果</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-jsonp-result-20190606145036.png\" alt></p>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>原理比较简单，和 headers 插件类似，在<code>tilestrata</code>的设计中，会使用<code>use</code>去注册各种类型的插件，<code>tilestrata-headers</code>就是<code>reshook</code>类型的插件，在初始化的过程中会被注册</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">TileRequestHandler.prototype.use = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">plugin</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!plugin) <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ...简化后的代码</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (plugin.reshook) <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._registerResponseHook(plugin);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">TileRequestHandler.prototype._registerResponseHook = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">plugin</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> id = <span class=\"string\">\"reshook#\"</span> + <span class=\"keyword\">this</span>.responseHooks.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!plugin) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Falsy value passed to registerResponseHook()\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> plugin.reshook !== <span class=\"string\">\"function\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">      <span class=\"string\">\"Attempted to register a response hook with no reshook() method\"</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.responseHooks.push(&#123; <span class=\"attr\">id</span>: id, <span class=\"attr\">plugin</span>: plugin &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>通过这种方式，插件会设置响应内容为<code>Content-Type: text/javascript;</code>，给我们返回一段包含了回调函数的代码，来执行我们预先定义好的 callbak 函数。</p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/naturalatlas/tilestrata-jsonp\" target=\"_blank\" rel=\"noopener\">tilestrata-jsonp</a>插件可以将一些网格（utfgrids）的 json 请求包装成 jsonp，使你不必配置 CORS 也可以跨域访问这些资源。这是除了 tilestrata-headers 以外的另一个实用型插件。</p>","more":"<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install tilestrata-jsonp --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> jsonp = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata-jsonp\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> tilestrataPostGISGeoJSON = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata-postgis-geojson-tiles\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">server = tilestrata();</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">\"geojson_tiles_jsonp\"</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">\"tile.json\"</span>)</span><br><span class=\"line\">  .use(jsonp(&#123; <span class=\"attr\">variable</span>: <span class=\"string\">\"callback\"</span> &#125;))</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    <span class=\"comment\">// Provider 这里用tilestrataPostGISGeoJSON做示例</span></span><br><span class=\"line\">    tilestrataPostGISGeoJSON(&#123;</span><br><span class=\"line\">      geometryField: <span class=\"string\">\"geom\"</span>,</span><br><span class=\"line\">      sql: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"select name, &#123;geojson&#125; from (select name, ST_Transform(way,4326) as geom from osm_polygon where name ~ '上海') as a1 WHERE ST_Intersects(geom, &#123;bbox&#125;)\"</span>;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      pgConfig: &#123;</span><br><span class=\"line\">        username: <span class=\"string\">\"postgres\"</span>,</span><br><span class=\"line\">        password: <span class=\"string\">\"postgres\"</span>,</span><br><span class=\"line\">        host: <span class=\"string\">\"localhost\"</span>,</span><br><span class=\"line\">        port: <span class=\"string\">\"5432\"</span>,</span><br><span class=\"line\">        database: <span class=\"string\">\"osm\"</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>);</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>在启动 server 后，我们可以直接用<code>jquery</code>请求某个固定层级的瓦片，来测试是否成功触发<code>callbak</code>函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">  url: <span class=\"string\">\"http://127.0.0.1:9527/geojson_tiles_jsonp/4/15/8/tile.json\"</span>,</span><br><span class=\"line\">  type: <span class=\"string\">\"GET\"</span>,</span><br><span class=\"line\">  dataType: <span class=\"string\">\"jsonp\"</span>,</span><br><span class=\"line\">  success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"jsonp使用成功\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>结果</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-jsonp-result-20190606145036.png\" alt></p>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>原理比较简单，和 headers 插件类似，在<code>tilestrata</code>的设计中，会使用<code>use</code>去注册各种类型的插件，<code>tilestrata-headers</code>就是<code>reshook</code>类型的插件，在初始化的过程中会被注册</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">TileRequestHandler.prototype.use = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">plugin</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!plugin) <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ...简化后的代码</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (plugin.reshook) <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._registerResponseHook(plugin);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">TileRequestHandler.prototype._registerResponseHook = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">plugin</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> id = <span class=\"string\">\"reshook#\"</span> + <span class=\"keyword\">this</span>.responseHooks.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!plugin) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Falsy value passed to registerResponseHook()\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> plugin.reshook !== <span class=\"string\">\"function\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">      <span class=\"string\">\"Attempted to register a response hook with no reshook() method\"</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.responseHooks.push(&#123; <span class=\"attr\">id</span>: id, <span class=\"attr\">plugin</span>: plugin &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>通过这种方式，插件会设置响应内容为<code>Content-Type: text/javascript;</code>，给我们返回一段包含了回调函数的代码，来执行我们预先定义好的 callbak 函数。</p>"},{"title":"tilestrata-mapnik 插件使用及浅析","date":"2019-06-11T03:26:12.000Z","_content":"\n[tilestrata-mapnik](https://github.com/naturalatlas/tilestrata-mapnik)顾名思义，mapnik 作为地图数据源，tilestrata 负责瓦片化的一个插件。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```bash\nnpm install mapnik --save\nnpm install tilestrata-mapnik --save\n```\n\n虽然最新的 mapnik4.0 已经支持了 nodejs 10 版本，这里仍然建议采用**nodejs 8** 环境，更为稳定，如果安装失败可以考虑切换到**nodejs 8**\n\n# 2. 使用\n\n准备好 mapnik 的 xml 配置文件\n\n```js\nvar tilestrata = require(\"tilestrata\");\nvar mapnik = require(\"tilestrata-mapnik\");\n\nserver = tilestrata();\n\nserver\n  .layer(\"layer_name\")\n  .route(\"tile.png\")\n  .use(\n    mapnik({\n      pathname: \"style/china.xml\"\n    })\n  );\n\nserver.listen(8080);\n```\n\ntilestrata-mapnik 支持的`options`有\n\n```js\n{\n  interactivity: false,\n  xml: null,\n  pathname: null,\n  metatile: 2,\n  resolution: 4,\n  bufferSize: 128,\n  tileSize: 256,\n  scale: 1\n}\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-mapnik-result-20190606105844.png)\n\n# 4. 代码浅析\n\n插件会根据传入的`options`构建一个[tilelive-mapnik](https://github.com/mapbox/tilelive-mapnik)对象 source\n\n```js\nsource = new MapnikBackend(options, function(err, result) {\n  source = result;\n  callback(err);\n});\n```\n\n根据`options`里面`interactivity`的值，分别调用了下面两个函数，对数据源会做个是否满足调用条件的判断，如果满足就设置一下`options`里面数据`format`的值\n\n```js\n// interactivity为 false，设置 format为 png\nsource.getTile();\n\n// interactivity为 true，设置 format为 utf\nsource.getGrid();\n```\n\n针对两种不同的`format`，分别创建 mapnik 实例\n\n```js\n// format为 png\nimage = new mapnik.Image();\n\n// format为 utf\nimage = new mapnik.Grid();\n```\n\n在请求具体的某个 zxy 瓦片的时候，就使用 mapnik 获取指定瓦片的方法`view`就好了。\n\n```js\nimage.view(x, y, width, height); // 获取指定瓦片\n```\n\n流程图\n\n```mermaid\ngraph TD\nA[tilestrata-mapnik] -->|options| B(tilelive-mapnik)\nB --> C{interactivity}\nC -->|true| D[getGrid]\nD --> F[mapnik.Grid]\nC -->|false| E[getTile]\nE --> G[mapnik.Image]\nF --> H[view]\nG --> H[view]\n```\n","source":"_posts/2019/tilestrata-mapnik.md","raw":"---\ntitle: tilestrata-mapnik 插件使用及浅析\ndate: 2019-06-11 11:26:12\ntags: [GIS]\ncategories: TileStrata\n---\n\n[tilestrata-mapnik](https://github.com/naturalatlas/tilestrata-mapnik)顾名思义，mapnik 作为地图数据源，tilestrata 负责瓦片化的一个插件。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```bash\nnpm install mapnik --save\nnpm install tilestrata-mapnik --save\n```\n\n虽然最新的 mapnik4.0 已经支持了 nodejs 10 版本，这里仍然建议采用**nodejs 8** 环境，更为稳定，如果安装失败可以考虑切换到**nodejs 8**\n\n# 2. 使用\n\n准备好 mapnik 的 xml 配置文件\n\n```js\nvar tilestrata = require(\"tilestrata\");\nvar mapnik = require(\"tilestrata-mapnik\");\n\nserver = tilestrata();\n\nserver\n  .layer(\"layer_name\")\n  .route(\"tile.png\")\n  .use(\n    mapnik({\n      pathname: \"style/china.xml\"\n    })\n  );\n\nserver.listen(8080);\n```\n\ntilestrata-mapnik 支持的`options`有\n\n```js\n{\n  interactivity: false,\n  xml: null,\n  pathname: null,\n  metatile: 2,\n  resolution: 4,\n  bufferSize: 128,\n  tileSize: 256,\n  scale: 1\n}\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-mapnik-result-20190606105844.png)\n\n# 4. 代码浅析\n\n插件会根据传入的`options`构建一个[tilelive-mapnik](https://github.com/mapbox/tilelive-mapnik)对象 source\n\n```js\nsource = new MapnikBackend(options, function(err, result) {\n  source = result;\n  callback(err);\n});\n```\n\n根据`options`里面`interactivity`的值，分别调用了下面两个函数，对数据源会做个是否满足调用条件的判断，如果满足就设置一下`options`里面数据`format`的值\n\n```js\n// interactivity为 false，设置 format为 png\nsource.getTile();\n\n// interactivity为 true，设置 format为 utf\nsource.getGrid();\n```\n\n针对两种不同的`format`，分别创建 mapnik 实例\n\n```js\n// format为 png\nimage = new mapnik.Image();\n\n// format为 utf\nimage = new mapnik.Grid();\n```\n\n在请求具体的某个 zxy 瓦片的时候，就使用 mapnik 获取指定瓦片的方法`view`就好了。\n\n```js\nimage.view(x, y, width, height); // 获取指定瓦片\n```\n\n流程图\n\n```mermaid\ngraph TD\nA[tilestrata-mapnik] -->|options| B(tilelive-mapnik)\nB --> C{interactivity}\nC -->|true| D[getGrid]\nD --> F[mapnik.Grid]\nC -->|false| E[getTile]\nE --> G[mapnik.Image]\nF --> H[view]\nG --> H[view]\n```\n","slug":"tilestrata-mapnik","published":1,"updated":"2019-06-28T05:56:28.441Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrkxgt8000ni83i6rntyx3t","content":"<p><a href=\"https://github.com/naturalatlas/tilestrata-mapnik\" target=\"_blank\" rel=\"noopener\">tilestrata-mapnik</a>顾名思义，mapnik 作为地图数据源，tilestrata 负责瓦片化的一个插件。</p>\n<a id=\"more\"></a>\n<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install mapnik --save</span><br><span class=\"line\">npm install tilestrata-mapnik --save</span><br></pre></td></tr></table></figure>\n<p>虽然最新的 mapnik4.0 已经支持了 nodejs 10 版本，这里仍然建议采用<strong>nodejs 8</strong> 环境，更为稳定，如果安装失败可以考虑切换到<strong>nodejs 8</strong></p>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><p>准备好 mapnik 的 xml 配置文件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata-mapnik\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">server = tilestrata();</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">\"layer_name\"</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">\"tile.png\"</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">\"style/china.xml\"</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">8080</span>);</span><br></pre></td></tr></table></figure>\n<p>tilestrata-mapnik 支持的<code>options</code>有</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  interactivity: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  xml: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  pathname: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  metatile: <span class=\"number\">2</span>,</span><br><span class=\"line\">  resolution: <span class=\"number\">4</span>,</span><br><span class=\"line\">  bufferSize: <span class=\"number\">128</span>,</span><br><span class=\"line\">  tileSize: <span class=\"number\">256</span>,</span><br><span class=\"line\">  scale: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-mapnik-result-20190606105844.png\" alt></p>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>插件会根据传入的<code>options</code>构建一个<a href=\"https://github.com/mapbox/tilelive-mapnik\" target=\"_blank\" rel=\"noopener\">tilelive-mapnik</a>对象 source</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">source = <span class=\"keyword\">new</span> MapnikBackend(options, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">  source = result;</span><br><span class=\"line\">  callback(err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>根据<code>options</code>里面<code>interactivity</code>的值，分别调用了下面两个函数，对数据源会做个是否满足调用条件的判断，如果满足就设置一下<code>options</code>里面数据<code>format</code>的值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// interactivity为 false，设置 format为 png</span></span><br><span class=\"line\">source.getTile();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// interactivity为 true，设置 format为 utf</span></span><br><span class=\"line\">source.getGrid();</span><br></pre></td></tr></table></figure>\n<p>针对两种不同的<code>format</code>，分别创建 mapnik 实例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// format为 png</span></span><br><span class=\"line\">image = <span class=\"keyword\">new</span> mapnik.Image();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// format为 utf</span></span><br><span class=\"line\">image = <span class=\"keyword\">new</span> mapnik.Grid();</span><br></pre></td></tr></table></figure>\n<p>在请求具体的某个 zxy 瓦片的时候，就使用 mapnik 获取指定瓦片的方法<code>view</code>就好了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">image.view(x, y, width, height); <span class=\"comment\">// 获取指定瓦片</span></span><br></pre></td></tr></table></figure>\n<p>流程图</p>\n<pre class=\"mermaid\">graph TD\nA[tilestrata-mapnik] -->|options| B(tilelive-mapnik)\nB --> C{interactivity}\nC -->|true| D[getGrid]\nD --> F[mapnik.Grid]\nC -->|false| E[getTile]\nE --> G[mapnik.Image]\nF --> H[view]\nG --> H[view]</pre>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/naturalatlas/tilestrata-mapnik\" target=\"_blank\" rel=\"noopener\">tilestrata-mapnik</a>顾名思义，mapnik 作为地图数据源，tilestrata 负责瓦片化的一个插件。</p>","more":"<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install mapnik --save</span><br><span class=\"line\">npm install tilestrata-mapnik --save</span><br></pre></td></tr></table></figure>\n<p>虽然最新的 mapnik4.0 已经支持了 nodejs 10 版本，这里仍然建议采用<strong>nodejs 8</strong> 环境，更为稳定，如果安装失败可以考虑切换到<strong>nodejs 8</strong></p>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><p>准备好 mapnik 的 xml 配置文件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata-mapnik\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">server = tilestrata();</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">\"layer_name\"</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">\"tile.png\"</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">\"style/china.xml\"</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">8080</span>);</span><br></pre></td></tr></table></figure>\n<p>tilestrata-mapnik 支持的<code>options</code>有</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  interactivity: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  xml: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  pathname: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  metatile: <span class=\"number\">2</span>,</span><br><span class=\"line\">  resolution: <span class=\"number\">4</span>,</span><br><span class=\"line\">  bufferSize: <span class=\"number\">128</span>,</span><br><span class=\"line\">  tileSize: <span class=\"number\">256</span>,</span><br><span class=\"line\">  scale: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-mapnik-result-20190606105844.png\" alt></p>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>插件会根据传入的<code>options</code>构建一个<a href=\"https://github.com/mapbox/tilelive-mapnik\" target=\"_blank\" rel=\"noopener\">tilelive-mapnik</a>对象 source</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">source = <span class=\"keyword\">new</span> MapnikBackend(options, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">  source = result;</span><br><span class=\"line\">  callback(err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>根据<code>options</code>里面<code>interactivity</code>的值，分别调用了下面两个函数，对数据源会做个是否满足调用条件的判断，如果满足就设置一下<code>options</code>里面数据<code>format</code>的值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// interactivity为 false，设置 format为 png</span></span><br><span class=\"line\">source.getTile();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// interactivity为 true，设置 format为 utf</span></span><br><span class=\"line\">source.getGrid();</span><br></pre></td></tr></table></figure>\n<p>针对两种不同的<code>format</code>，分别创建 mapnik 实例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// format为 png</span></span><br><span class=\"line\">image = <span class=\"keyword\">new</span> mapnik.Image();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// format为 utf</span></span><br><span class=\"line\">image = <span class=\"keyword\">new</span> mapnik.Grid();</span><br></pre></td></tr></table></figure>\n<p>在请求具体的某个 zxy 瓦片的时候，就使用 mapnik 获取指定瓦片的方法<code>view</code>就好了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">image.view(x, y, width, height); <span class=\"comment\">// 获取指定瓦片</span></span><br></pre></td></tr></table></figure>\n<p>流程图</p>\n<pre class=\"mermaid\">graph TD\nA[tilestrata-mapnik] -->|options| B(tilelive-mapnik)\nB --> C{interactivity}\nC -->|true| D[getGrid]\nD --> F[mapnik.Grid]\nC -->|false| E[getTile]\nE --> G[mapnik.Image]\nF --> H[view]\nG --> H[view]</pre>"},{"title":"tilestrata 插件发开指南","date":"2019-07-22T10:16:33.000Z","_content":"\n[Tilestrata](https://github.com/naturalatlas/tilestrata)的插件开发基本围绕着生命周期各个阶段展开，如果要开发一个自己的插件，首先想清楚插件的功能属于生命周期的哪个阶段，依据官方规定好的该阶段代码结构，写好插件内容，在服务端利用`use`进行注册就好。个人觉得`Tilestrata`吸引人的一个地方就是在于插件机制非常的灵活和便捷，十分好上手。\n\n<!--more-->\n\n这篇文章主要基于官方文档说明。\n\n生命周期的各个阶段如下：\n\n- `request hook` – 请求预处理\n- `cache` – 缓存控制\n- `provider` – 数据源，比如 mapnik\n- `transform` – 最关键的阶段，可以在瓦片输出的过程中对其做各种加工，比如旋转，染色\n- `response hook` – 响应后处理，比如 headers、jsonp 插件\n\n# 1. 插件共有部分\n\n所有的插件都可以拥有`init`和`destroy`两个生命周期方法，分别在插件的启动和结束时触发。这个两个方法的第一个参数是当前`tilestrata`实例，第二个参数是`callback`回调函数。\n\n```js\ninit: function(server, callback) {\n    callback(err);\n},\n```\n\n# 2. request 请求插件\n\nrequest 类型的插件必须提供`reqhook`方法，参数如下。其中`req`参数代表[http.IncomingMessage](http://nodejs.org/api/http.html#http_http_incomingmessage) ，`res`参数代表[http.ServerResponse](http://nodejs.org/api/http.html#http_class_http_serverresponse)。 如果不执行里面的`callback`回调函数，甚至这个请求都不会进入后续`server`的处理逻辑中，所以千万别忘了它。\n\n```js\nmodule.exports = function(options) {\n  return {\n    name: 'myplugin',\n    init: function(server, callback) {\n      callback(err)\n    },\n    // 我是必须提供的核心方法\n    reqhook: function(server, tile, req, res, callback) {\n      callback()\n    },\n    destroy: function(server, callback) {\n      callback(err)\n    }\n  }\n}\n```\n\n# 3. Caches 缓存插件\n\nCaches 类型的插件必须提供`get`和`set`方法，参数分别如下。当你的缓存过程失败出错的时候，tilestrata 会忽略错误，无视这段逻辑，尝试直接从数据源获取数据。\n\n```js\nmodule.exports = function(options) {\n  return {\n    name: 'myplugin',\n    init: function(server, callback) {\n      callback(err)\n    },\n    // 我是必须提供的核心方法\n    get: function(server, tile, callback) {\n      callback(err, buffer, headers /* refresh */)\n    },\n    // 我是必须提供的核心方法\n    set: function(server, tile, buffer, headers, callback) {\n      callback(err)\n    },\n    destroy: function(server, callback) {\n      callback(err)\n    }\n  }\n}\n```\n\n有一种特殊的场景：虽然请求命中了缓存，仍然需要在后台生成一张新的瓦片。比方说某一张瓦片已经很久没更新了，需要重新生成，但又不是那么着急，一定要用户等着这个新瓦片渲染出来，所以其实我们需要的是返回缓存结果，同时更新瓦片缓存。这种情况下为`get()`方法的`callback`增加第四个参数`true`就好了。\n\n```js\ncallback(null, buffer, headers, true)\n```\n\n# 4. Providers 数据源插件\n\nProviders 类型的插件必须提供`serve`方法，参数如下。主要作用就是提供**数据源**，数据可以来源于第本地的某个功能模块比方说 mapnik 服务，可以来源于在线的第三方服务，比如说对 bing 地图服务做了一个代理转发。\n\n```js\nmodule.exports = function(options) {\n  return {\n    name: 'myplugin',\n    init: function(server, callback) {\n      callback(err)\n    },\n    // 我是必须提供的核心方法\n    serve: function(server, tile, callback) {\n      callback(err, buffer, headers)\n    },\n    destroy: function(server, callback) {\n      callback(err)\n    }\n  }\n}\n```\n\n# 5. Transforms 数据处理插件\n\nTransforms 类型的插件必须提供`transform`方法，参数如下。它的主要作用是在数据从 provider 取出来之后，做一些额外的处理，比方说加一个水印，调整一下透明度，再把处理后的结果输出出去。要注意下这个过程是发生在**缓存之前**的。\n\n```js\nmodule.exports = function(options) {\n  return {\n    name: 'myplugin',\n    init: function(server, callback) {\n      callback(err)\n    },\n    // 我是必须提供的核心方法\n    transform: function(server, tile, buffer, headers, callback) {\n      callback(err, buffer, headers)\n    },\n    destroy: function(server, callback) {\n      callback(err)\n    }\n  }\n}\n```\n\n# 6. Response 响应插件\n\nResponse 类型的插件必须提供`reshook`方法，参数如下，其中参数里面的`result`包含了三个属性：`headers`, `buffer`和 `status`，这三个属性在返回真正的结果之前都是可以被修改的。比方说在返回结果之前，给每一个`headers`都加上`'Access-Control-Allow-Origin': '*'`来让请求支持跨域访问。此外`req`参数代表[http.IncomingMessage](http://nodejs.org/api/http.html#http_http_incomingmessage) ，`res`参数代表[http.ServerResponse](http://nodejs.org/api/http.html#http_class_http_serverresponse)。\n\n```js\nmodule.exports = function(options) {\n  return {\n    name: 'myplugin',\n    init: function(server, callback) {\n      callback(err)\n    },\n    // 我是必须提供的核心方法\n    reshook: function(server, tile, req, res, result, callback) {\n      callback()\n    },\n    destroy: function(server, callback) {\n      callback(err)\n    }\n  }\n}\n```\n\n# 7. 同时提供多个功能的插件\n\n有时候一个插件由多个部分组成，所以你可以把多个功能放进一个数组传递给 TileStrata。例如我想做一个插件记录响应时间，那既要在 request 时做出记录，也要在 response 时做出记录，把它俩放进数组就 ok 了。\n\n```js\nmodule.exports = function() {\n    return [\n        //  第一个插件\n        {name: 'myplugin', reqhook: function(...) { /* ... */ }},\n        //  第一个插件\n        {name: 'myplugin', reshook: function(...) { /* ... */ }}\n    ];\n};\n```\n\n通观下来，整个 Tilestrata 插件开发的流程其实是非常舒畅和自由的，可以充分的发挥创造力。\n","source":"_posts/2019/tilestrata-plugin.md","raw":"---\ntitle: tilestrata 插件发开指南\ndate: 2019-07-22 18:16:33\ntags: [GIS]\ncategories: TileStrata\n---\n\n[Tilestrata](https://github.com/naturalatlas/tilestrata)的插件开发基本围绕着生命周期各个阶段展开，如果要开发一个自己的插件，首先想清楚插件的功能属于生命周期的哪个阶段，依据官方规定好的该阶段代码结构，写好插件内容，在服务端利用`use`进行注册就好。个人觉得`Tilestrata`吸引人的一个地方就是在于插件机制非常的灵活和便捷，十分好上手。\n\n<!--more-->\n\n这篇文章主要基于官方文档说明。\n\n生命周期的各个阶段如下：\n\n- `request hook` – 请求预处理\n- `cache` – 缓存控制\n- `provider` – 数据源，比如 mapnik\n- `transform` – 最关键的阶段，可以在瓦片输出的过程中对其做各种加工，比如旋转，染色\n- `response hook` – 响应后处理，比如 headers、jsonp 插件\n\n# 1. 插件共有部分\n\n所有的插件都可以拥有`init`和`destroy`两个生命周期方法，分别在插件的启动和结束时触发。这个两个方法的第一个参数是当前`tilestrata`实例，第二个参数是`callback`回调函数。\n\n```js\ninit: function(server, callback) {\n    callback(err);\n},\n```\n\n# 2. request 请求插件\n\nrequest 类型的插件必须提供`reqhook`方法，参数如下。其中`req`参数代表[http.IncomingMessage](http://nodejs.org/api/http.html#http_http_incomingmessage) ，`res`参数代表[http.ServerResponse](http://nodejs.org/api/http.html#http_class_http_serverresponse)。 如果不执行里面的`callback`回调函数，甚至这个请求都不会进入后续`server`的处理逻辑中，所以千万别忘了它。\n\n```js\nmodule.exports = function(options) {\n  return {\n    name: 'myplugin',\n    init: function(server, callback) {\n      callback(err)\n    },\n    // 我是必须提供的核心方法\n    reqhook: function(server, tile, req, res, callback) {\n      callback()\n    },\n    destroy: function(server, callback) {\n      callback(err)\n    }\n  }\n}\n```\n\n# 3. Caches 缓存插件\n\nCaches 类型的插件必须提供`get`和`set`方法，参数分别如下。当你的缓存过程失败出错的时候，tilestrata 会忽略错误，无视这段逻辑，尝试直接从数据源获取数据。\n\n```js\nmodule.exports = function(options) {\n  return {\n    name: 'myplugin',\n    init: function(server, callback) {\n      callback(err)\n    },\n    // 我是必须提供的核心方法\n    get: function(server, tile, callback) {\n      callback(err, buffer, headers /* refresh */)\n    },\n    // 我是必须提供的核心方法\n    set: function(server, tile, buffer, headers, callback) {\n      callback(err)\n    },\n    destroy: function(server, callback) {\n      callback(err)\n    }\n  }\n}\n```\n\n有一种特殊的场景：虽然请求命中了缓存，仍然需要在后台生成一张新的瓦片。比方说某一张瓦片已经很久没更新了，需要重新生成，但又不是那么着急，一定要用户等着这个新瓦片渲染出来，所以其实我们需要的是返回缓存结果，同时更新瓦片缓存。这种情况下为`get()`方法的`callback`增加第四个参数`true`就好了。\n\n```js\ncallback(null, buffer, headers, true)\n```\n\n# 4. Providers 数据源插件\n\nProviders 类型的插件必须提供`serve`方法，参数如下。主要作用就是提供**数据源**，数据可以来源于第本地的某个功能模块比方说 mapnik 服务，可以来源于在线的第三方服务，比如说对 bing 地图服务做了一个代理转发。\n\n```js\nmodule.exports = function(options) {\n  return {\n    name: 'myplugin',\n    init: function(server, callback) {\n      callback(err)\n    },\n    // 我是必须提供的核心方法\n    serve: function(server, tile, callback) {\n      callback(err, buffer, headers)\n    },\n    destroy: function(server, callback) {\n      callback(err)\n    }\n  }\n}\n```\n\n# 5. Transforms 数据处理插件\n\nTransforms 类型的插件必须提供`transform`方法，参数如下。它的主要作用是在数据从 provider 取出来之后，做一些额外的处理，比方说加一个水印，调整一下透明度，再把处理后的结果输出出去。要注意下这个过程是发生在**缓存之前**的。\n\n```js\nmodule.exports = function(options) {\n  return {\n    name: 'myplugin',\n    init: function(server, callback) {\n      callback(err)\n    },\n    // 我是必须提供的核心方法\n    transform: function(server, tile, buffer, headers, callback) {\n      callback(err, buffer, headers)\n    },\n    destroy: function(server, callback) {\n      callback(err)\n    }\n  }\n}\n```\n\n# 6. Response 响应插件\n\nResponse 类型的插件必须提供`reshook`方法，参数如下，其中参数里面的`result`包含了三个属性：`headers`, `buffer`和 `status`，这三个属性在返回真正的结果之前都是可以被修改的。比方说在返回结果之前，给每一个`headers`都加上`'Access-Control-Allow-Origin': '*'`来让请求支持跨域访问。此外`req`参数代表[http.IncomingMessage](http://nodejs.org/api/http.html#http_http_incomingmessage) ，`res`参数代表[http.ServerResponse](http://nodejs.org/api/http.html#http_class_http_serverresponse)。\n\n```js\nmodule.exports = function(options) {\n  return {\n    name: 'myplugin',\n    init: function(server, callback) {\n      callback(err)\n    },\n    // 我是必须提供的核心方法\n    reshook: function(server, tile, req, res, result, callback) {\n      callback()\n    },\n    destroy: function(server, callback) {\n      callback(err)\n    }\n  }\n}\n```\n\n# 7. 同时提供多个功能的插件\n\n有时候一个插件由多个部分组成，所以你可以把多个功能放进一个数组传递给 TileStrata。例如我想做一个插件记录响应时间，那既要在 request 时做出记录，也要在 response 时做出记录，把它俩放进数组就 ok 了。\n\n```js\nmodule.exports = function() {\n    return [\n        //  第一个插件\n        {name: 'myplugin', reqhook: function(...) { /* ... */ }},\n        //  第一个插件\n        {name: 'myplugin', reshook: function(...) { /* ... */ }}\n    ];\n};\n```\n\n通观下来，整个 Tilestrata 插件开发的流程其实是非常舒畅和自由的，可以充分的发挥创造力。\n","slug":"tilestrata-plugin","published":1,"updated":"2019-07-22T10:18:46.341Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrkxgt9000oi83idjw7821k","content":"<p><a href=\"https://github.com/naturalatlas/tilestrata\" target=\"_blank\" rel=\"noopener\">Tilestrata</a>的插件开发基本围绕着生命周期各个阶段展开，如果要开发一个自己的插件，首先想清楚插件的功能属于生命周期的哪个阶段，依据官方规定好的该阶段代码结构，写好插件内容，在服务端利用<code>use</code>进行注册就好。个人觉得<code>Tilestrata</code>吸引人的一个地方就是在于插件机制非常的灵活和便捷，十分好上手。</p>\n<a id=\"more\"></a>\n<p>这篇文章主要基于官方文档说明。</p>\n<p>生命周期的各个阶段如下：</p>\n<ul>\n<li><code>request hook</code> – 请求预处理</li>\n<li><code>cache</code> – 缓存控制</li>\n<li><code>provider</code> – 数据源，比如 mapnik</li>\n<li><code>transform</code> – 最关键的阶段，可以在瓦片输出的过程中对其做各种加工，比如旋转，染色</li>\n<li><code>response hook</code> – 响应后处理，比如 headers、jsonp 插件</li>\n</ul>\n<h1 id=\"1-插件共有部分\"><a href=\"#1-插件共有部分\" class=\"headerlink\" title=\"1. 插件共有部分\"></a>1. 插件共有部分</h1><p>所有的插件都可以拥有<code>init</code>和<code>destroy</code>两个生命周期方法，分别在插件的启动和结束时触发。这个两个方法的第一个参数是当前<code>tilestrata</code>实例，第二个参数是<code>callback</code>回调函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, callback</span>) </span>&#123;</span><br><span class=\"line\">    callback(err);</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-request-请求插件\"><a href=\"#2-request-请求插件\" class=\"headerlink\" title=\"2. request 请求插件\"></a>2. request 请求插件</h1><p>request 类型的插件必须提供<code>reqhook</code>方法，参数如下。其中<code>req</code>参数代表<a href=\"http://nodejs.org/api/http.html#http_http_incomingmessage\" target=\"_blank\" rel=\"noopener\">http.IncomingMessage</a> ，<code>res</code>参数代表<a href=\"http://nodejs.org/api/http.html#http_class_http_serverresponse\" target=\"_blank\" rel=\"noopener\">http.ServerResponse</a>。 如果不执行里面的<code>callback</code>回调函数，甚至这个请求都不会进入后续<code>server</code>的处理逻辑中，所以千万别忘了它。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'myplugin'</span>,</span><br><span class=\"line\">    init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, callback</span>) </span>&#123;</span><br><span class=\"line\">      callback(err)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 我是必须提供的核心方法</span></span><br><span class=\"line\">    reqhook: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, tile, req, res, callback</span>) </span>&#123;</span><br><span class=\"line\">      callback()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    destroy: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, callback</span>) </span>&#123;</span><br><span class=\"line\">      callback(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-Caches-缓存插件\"><a href=\"#3-Caches-缓存插件\" class=\"headerlink\" title=\"3. Caches 缓存插件\"></a>3. Caches 缓存插件</h1><p>Caches 类型的插件必须提供<code>get</code>和<code>set</code>方法，参数分别如下。当你的缓存过程失败出错的时候，tilestrata 会忽略错误，无视这段逻辑，尝试直接从数据源获取数据。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'myplugin'</span>,</span><br><span class=\"line\">    init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, callback</span>) </span>&#123;</span><br><span class=\"line\">      callback(err)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 我是必须提供的核心方法</span></span><br><span class=\"line\">    <span class=\"keyword\">get</span>: function(server, tile, callback) &#123;</span><br><span class=\"line\">      callback(err, buffer, headers <span class=\"comment\">/* refresh */</span>)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 我是必须提供的核心方法</span></span><br><span class=\"line\">    <span class=\"keyword\">set</span>: function(server, tile, buffer, headers, callback) &#123;</span><br><span class=\"line\">      callback(err)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    destroy: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, callback</span>) </span>&#123;</span><br><span class=\"line\">      callback(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有一种特殊的场景：虽然请求命中了缓存，仍然需要在后台生成一张新的瓦片。比方说某一张瓦片已经很久没更新了，需要重新生成，但又不是那么着急，一定要用户等着这个新瓦片渲染出来，所以其实我们需要的是返回缓存结果，同时更新瓦片缓存。这种情况下为<code>get()</code>方法的<code>callback</code>增加第四个参数<code>true</code>就好了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">callback(<span class=\"literal\">null</span>, buffer, headers, <span class=\"literal\">true</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-Providers-数据源插件\"><a href=\"#4-Providers-数据源插件\" class=\"headerlink\" title=\"4. Providers 数据源插件\"></a>4. Providers 数据源插件</h1><p>Providers 类型的插件必须提供<code>serve</code>方法，参数如下。主要作用就是提供<strong>数据源</strong>，数据可以来源于第本地的某个功能模块比方说 mapnik 服务，可以来源于在线的第三方服务，比如说对 bing 地图服务做了一个代理转发。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'myplugin'</span>,</span><br><span class=\"line\">    init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, callback</span>) </span>&#123;</span><br><span class=\"line\">      callback(err)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 我是必须提供的核心方法</span></span><br><span class=\"line\">    serve: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, tile, callback</span>) </span>&#123;</span><br><span class=\"line\">      callback(err, buffer, headers)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    destroy: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, callback</span>) </span>&#123;</span><br><span class=\"line\">      callback(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"5-Transforms-数据处理插件\"><a href=\"#5-Transforms-数据处理插件\" class=\"headerlink\" title=\"5. Transforms 数据处理插件\"></a>5. Transforms 数据处理插件</h1><p>Transforms 类型的插件必须提供<code>transform</code>方法，参数如下。它的主要作用是在数据从 provider 取出来之后，做一些额外的处理，比方说加一个水印，调整一下透明度，再把处理后的结果输出出去。要注意下这个过程是发生在<strong>缓存之前</strong>的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'myplugin'</span>,</span><br><span class=\"line\">    init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, callback</span>) </span>&#123;</span><br><span class=\"line\">      callback(err)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 我是必须提供的核心方法</span></span><br><span class=\"line\">    transform: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, tile, buffer, headers, callback</span>) </span>&#123;</span><br><span class=\"line\">      callback(err, buffer, headers)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    destroy: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, callback</span>) </span>&#123;</span><br><span class=\"line\">      callback(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"6-Response-响应插件\"><a href=\"#6-Response-响应插件\" class=\"headerlink\" title=\"6. Response 响应插件\"></a>6. Response 响应插件</h1><p>Response 类型的插件必须提供<code>reshook</code>方法，参数如下，其中参数里面的<code>result</code>包含了三个属性：<code>headers</code>, <code>buffer</code>和 <code>status</code>，这三个属性在返回真正的结果之前都是可以被修改的。比方说在返回结果之前，给每一个<code>headers</code>都加上<code>&#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;</code>来让请求支持跨域访问。此外<code>req</code>参数代表<a href=\"http://nodejs.org/api/http.html#http_http_incomingmessage\" target=\"_blank\" rel=\"noopener\">http.IncomingMessage</a> ，<code>res</code>参数代表<a href=\"http://nodejs.org/api/http.html#http_class_http_serverresponse\" target=\"_blank\" rel=\"noopener\">http.ServerResponse</a>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'myplugin'</span>,</span><br><span class=\"line\">    init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, callback</span>) </span>&#123;</span><br><span class=\"line\">      callback(err)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 我是必须提供的核心方法</span></span><br><span class=\"line\">    reshook: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, tile, req, res, result, callback</span>) </span>&#123;</span><br><span class=\"line\">      callback()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    destroy: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, callback</span>) </span>&#123;</span><br><span class=\"line\">      callback(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"7-同时提供多个功能的插件\"><a href=\"#7-同时提供多个功能的插件\" class=\"headerlink\" title=\"7. 同时提供多个功能的插件\"></a>7. 同时提供多个功能的插件</h1><p>有时候一个插件由多个部分组成，所以你可以把多个功能放进一个数组传递给 TileStrata。例如我想做一个插件记录响应时间，那既要在 request 时做出记录，也要在 response 时做出记录，把它俩放进数组就 ok 了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [</span><br><span class=\"line\">        <span class=\"comment\">//  第一个插件</span></span><br><span class=\"line\">        &#123;<span class=\"attr\">name</span>: <span class=\"string\">'myplugin'</span>, <span class=\"attr\">reqhook</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...</span>) </span>&#123; <span class=\"comment\">/* ... */</span> &#125;&#125;,</span><br><span class=\"line\">        <span class=\"comment\">//  第一个插件</span></span><br><span class=\"line\">        &#123;<span class=\"attr\">name</span>: <span class=\"string\">'myplugin'</span>, <span class=\"attr\">reshook</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...</span>) </span>&#123; <span class=\"comment\">/* ... */</span> &#125;&#125;</span><br><span class=\"line\">    ];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>通观下来，整个 Tilestrata 插件开发的流程其实是非常舒畅和自由的，可以充分的发挥创造力。</p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/naturalatlas/tilestrata\" target=\"_blank\" rel=\"noopener\">Tilestrata</a>的插件开发基本围绕着生命周期各个阶段展开，如果要开发一个自己的插件，首先想清楚插件的功能属于生命周期的哪个阶段，依据官方规定好的该阶段代码结构，写好插件内容，在服务端利用<code>use</code>进行注册就好。个人觉得<code>Tilestrata</code>吸引人的一个地方就是在于插件机制非常的灵活和便捷，十分好上手。</p>","more":"<p>这篇文章主要基于官方文档说明。</p>\n<p>生命周期的各个阶段如下：</p>\n<ul>\n<li><code>request hook</code> – 请求预处理</li>\n<li><code>cache</code> – 缓存控制</li>\n<li><code>provider</code> – 数据源，比如 mapnik</li>\n<li><code>transform</code> – 最关键的阶段，可以在瓦片输出的过程中对其做各种加工，比如旋转，染色</li>\n<li><code>response hook</code> – 响应后处理，比如 headers、jsonp 插件</li>\n</ul>\n<h1 id=\"1-插件共有部分\"><a href=\"#1-插件共有部分\" class=\"headerlink\" title=\"1. 插件共有部分\"></a>1. 插件共有部分</h1><p>所有的插件都可以拥有<code>init</code>和<code>destroy</code>两个生命周期方法，分别在插件的启动和结束时触发。这个两个方法的第一个参数是当前<code>tilestrata</code>实例，第二个参数是<code>callback</code>回调函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, callback</span>) </span>&#123;</span><br><span class=\"line\">    callback(err);</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-request-请求插件\"><a href=\"#2-request-请求插件\" class=\"headerlink\" title=\"2. request 请求插件\"></a>2. request 请求插件</h1><p>request 类型的插件必须提供<code>reqhook</code>方法，参数如下。其中<code>req</code>参数代表<a href=\"http://nodejs.org/api/http.html#http_http_incomingmessage\" target=\"_blank\" rel=\"noopener\">http.IncomingMessage</a> ，<code>res</code>参数代表<a href=\"http://nodejs.org/api/http.html#http_class_http_serverresponse\" target=\"_blank\" rel=\"noopener\">http.ServerResponse</a>。 如果不执行里面的<code>callback</code>回调函数，甚至这个请求都不会进入后续<code>server</code>的处理逻辑中，所以千万别忘了它。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'myplugin'</span>,</span><br><span class=\"line\">    init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, callback</span>) </span>&#123;</span><br><span class=\"line\">      callback(err)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 我是必须提供的核心方法</span></span><br><span class=\"line\">    reqhook: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, tile, req, res, callback</span>) </span>&#123;</span><br><span class=\"line\">      callback()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    destroy: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, callback</span>) </span>&#123;</span><br><span class=\"line\">      callback(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-Caches-缓存插件\"><a href=\"#3-Caches-缓存插件\" class=\"headerlink\" title=\"3. Caches 缓存插件\"></a>3. Caches 缓存插件</h1><p>Caches 类型的插件必须提供<code>get</code>和<code>set</code>方法，参数分别如下。当你的缓存过程失败出错的时候，tilestrata 会忽略错误，无视这段逻辑，尝试直接从数据源获取数据。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'myplugin'</span>,</span><br><span class=\"line\">    init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, callback</span>) </span>&#123;</span><br><span class=\"line\">      callback(err)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 我是必须提供的核心方法</span></span><br><span class=\"line\">    <span class=\"keyword\">get</span>: function(server, tile, callback) &#123;</span><br><span class=\"line\">      callback(err, buffer, headers <span class=\"comment\">/* refresh */</span>)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 我是必须提供的核心方法</span></span><br><span class=\"line\">    <span class=\"keyword\">set</span>: function(server, tile, buffer, headers, callback) &#123;</span><br><span class=\"line\">      callback(err)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    destroy: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, callback</span>) </span>&#123;</span><br><span class=\"line\">      callback(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有一种特殊的场景：虽然请求命中了缓存，仍然需要在后台生成一张新的瓦片。比方说某一张瓦片已经很久没更新了，需要重新生成，但又不是那么着急，一定要用户等着这个新瓦片渲染出来，所以其实我们需要的是返回缓存结果，同时更新瓦片缓存。这种情况下为<code>get()</code>方法的<code>callback</code>增加第四个参数<code>true</code>就好了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">callback(<span class=\"literal\">null</span>, buffer, headers, <span class=\"literal\">true</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-Providers-数据源插件\"><a href=\"#4-Providers-数据源插件\" class=\"headerlink\" title=\"4. Providers 数据源插件\"></a>4. Providers 数据源插件</h1><p>Providers 类型的插件必须提供<code>serve</code>方法，参数如下。主要作用就是提供<strong>数据源</strong>，数据可以来源于第本地的某个功能模块比方说 mapnik 服务，可以来源于在线的第三方服务，比如说对 bing 地图服务做了一个代理转发。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'myplugin'</span>,</span><br><span class=\"line\">    init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, callback</span>) </span>&#123;</span><br><span class=\"line\">      callback(err)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 我是必须提供的核心方法</span></span><br><span class=\"line\">    serve: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, tile, callback</span>) </span>&#123;</span><br><span class=\"line\">      callback(err, buffer, headers)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    destroy: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, callback</span>) </span>&#123;</span><br><span class=\"line\">      callback(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"5-Transforms-数据处理插件\"><a href=\"#5-Transforms-数据处理插件\" class=\"headerlink\" title=\"5. Transforms 数据处理插件\"></a>5. Transforms 数据处理插件</h1><p>Transforms 类型的插件必须提供<code>transform</code>方法，参数如下。它的主要作用是在数据从 provider 取出来之后，做一些额外的处理，比方说加一个水印，调整一下透明度，再把处理后的结果输出出去。要注意下这个过程是发生在<strong>缓存之前</strong>的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'myplugin'</span>,</span><br><span class=\"line\">    init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, callback</span>) </span>&#123;</span><br><span class=\"line\">      callback(err)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 我是必须提供的核心方法</span></span><br><span class=\"line\">    transform: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, tile, buffer, headers, callback</span>) </span>&#123;</span><br><span class=\"line\">      callback(err, buffer, headers)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    destroy: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, callback</span>) </span>&#123;</span><br><span class=\"line\">      callback(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"6-Response-响应插件\"><a href=\"#6-Response-响应插件\" class=\"headerlink\" title=\"6. Response 响应插件\"></a>6. Response 响应插件</h1><p>Response 类型的插件必须提供<code>reshook</code>方法，参数如下，其中参数里面的<code>result</code>包含了三个属性：<code>headers</code>, <code>buffer</code>和 <code>status</code>，这三个属性在返回真正的结果之前都是可以被修改的。比方说在返回结果之前，给每一个<code>headers</code>都加上<code>&#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;</code>来让请求支持跨域访问。此外<code>req</code>参数代表<a href=\"http://nodejs.org/api/http.html#http_http_incomingmessage\" target=\"_blank\" rel=\"noopener\">http.IncomingMessage</a> ，<code>res</code>参数代表<a href=\"http://nodejs.org/api/http.html#http_class_http_serverresponse\" target=\"_blank\" rel=\"noopener\">http.ServerResponse</a>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'myplugin'</span>,</span><br><span class=\"line\">    init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, callback</span>) </span>&#123;</span><br><span class=\"line\">      callback(err)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 我是必须提供的核心方法</span></span><br><span class=\"line\">    reshook: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, tile, req, res, result, callback</span>) </span>&#123;</span><br><span class=\"line\">      callback()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    destroy: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, callback</span>) </span>&#123;</span><br><span class=\"line\">      callback(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"7-同时提供多个功能的插件\"><a href=\"#7-同时提供多个功能的插件\" class=\"headerlink\" title=\"7. 同时提供多个功能的插件\"></a>7. 同时提供多个功能的插件</h1><p>有时候一个插件由多个部分组成，所以你可以把多个功能放进一个数组传递给 TileStrata。例如我想做一个插件记录响应时间，那既要在 request 时做出记录，也要在 response 时做出记录，把它俩放进数组就 ok 了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [</span><br><span class=\"line\">        <span class=\"comment\">//  第一个插件</span></span><br><span class=\"line\">        &#123;<span class=\"attr\">name</span>: <span class=\"string\">'myplugin'</span>, <span class=\"attr\">reqhook</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...</span>) </span>&#123; <span class=\"comment\">/* ... */</span> &#125;&#125;,</span><br><span class=\"line\">        <span class=\"comment\">//  第一个插件</span></span><br><span class=\"line\">        &#123;<span class=\"attr\">name</span>: <span class=\"string\">'myplugin'</span>, <span class=\"attr\">reshook</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...</span>) </span>&#123; <span class=\"comment\">/* ... */</span> &#125;&#125;</span><br><span class=\"line\">    ];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>通观下来，整个 Tilestrata 插件开发的流程其实是非常舒畅和自由的，可以充分的发挥创造力。</p>"},{"title":"tilestrata-lru  插件使用及浅析","date":"2019-07-11T14:51:22.000Z","_content":"\n[tilestrata-lru](https://github.com/naturalatlas/tilestrata-lru)插件使用内存来缓存瓦片。所以使用起来需要额外的小心，如果没有仔细的配置它有可能导致内存溢出。但若果你需要在不同的图层或者路径中共享某个资源，这个插件就是为此而生的。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-lru --save\n```\n\n# 2. 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst lru = require('tilestrata-lru')\nconst mapnik = require('tilestrata-mapnik')\nconst headers = require('tilestrata-headers')\n\nconst server = tilestrata()\n\nconst provider = mapnik({\n  pathname: 'style/province.xml'\n})\n\n// 设置最大占用20mb的内存\nserver\n  .layer('lru_layer_size')\n  .route('tile.png')\n  .use(provider)\n  .use(\n    headers({\n      'Access-Control-Allow-Origin': '*'\n    })\n  )\n  .use(lru({ size: '20mb', ttl: 30 })) // ttl in seconds\n\n// 设置最多缓存20个数据\nserver\n  .layer('lru_layer_number')\n  .route('tile.png')\n  .use(provider)\n  .use(\n    headers({\n      'Access-Control-Allow-Origin': '*'\n    })\n  )\n  .use(lru({ size: 20, ttl: 30 }))\n\n// 手动设置cache中数据对应key的结构\nserver\n  .layer('lru_layer_key')\n  .route('tile.png')\n  .use(provider)\n  .use(\n    headers({\n      'Access-Control-Allow-Origin': '*'\n    })\n  )\n  .use(\n    lru({\n      key: function(req) {\n        return (\n          req.z +\n          ',' +\n          req.x +\n          ',' +\n          req.y +\n          ',' +\n          req.layer +\n          ',' +\n          req.filename +\n          ',' +\n          'lru_layer_custom_key'\n        )\n      }\n    })\n  )\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n多次访问某个瓦片，如`http://127.0.0.1:9527/lru_layer_number/4/12/6/tile.png`，可以发现插件会在后几次从`cache`中直接 get 获取数据：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-lru-20190705162618.png)\n\n# 4. 代码浅析\n\n首先定义插件类型，`Caches`类型的插件需要给 tilestrata 提供`set`和`get`两个回调函数，核心是[lru-cache](https://www.npmjs.com/package/lru-cache)库\n\n```js\n// 代码有所精简\n// 设置缓存用到的key，如果没有自己设置key的结构，那默认将采用如下的结构\nvar key =\n  opts.key ||\n  function(req) {\n    return (\n      req.z + ',' + req.x + ',' + req.y + ',' + req.layer + ',' + req.filename\n    )\n  }\n\n// 判断设置的是数量还是内存大小\nif (typeof opts.size === 'string') {\n  lruopts.max = filesizeParser(opts.size)\n  lruopts.length = function(item) {\n    return item.buffer.length\n  }\n} else if (typeof opts.size === 'number') {\n  lruopts.max = opts.size\n}\n\n// 根据options创建lru-cache对象\nvar cache = new SyncCache(lruopts)\n\nreturn {\n  get: function(server, req, callback) {\n    // 获取数据\n    var item = cache.get(key(req))\n    if (item) return callback(null, item.buffer, item.headers)\n    callback()\n  },\n  set: function(server, req, buffer, headers, callback) {\n    // 缓存数据\n    cache.set(key(req), { buffer: buffer, headers: headers })\n    callback()\n  }\n}\n```\n","source":"_posts/2019/tilestrata-lru.md","raw":"---\ntitle: tilestrata-lru  插件使用及浅析\ndate: 2019-07-11 22:51:22\ntags: [GIS]\ncategories: TileStrata\n---\n\n[tilestrata-lru](https://github.com/naturalatlas/tilestrata-lru)插件使用内存来缓存瓦片。所以使用起来需要额外的小心，如果没有仔细的配置它有可能导致内存溢出。但若果你需要在不同的图层或者路径中共享某个资源，这个插件就是为此而生的。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-lru --save\n```\n\n# 2. 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst lru = require('tilestrata-lru')\nconst mapnik = require('tilestrata-mapnik')\nconst headers = require('tilestrata-headers')\n\nconst server = tilestrata()\n\nconst provider = mapnik({\n  pathname: 'style/province.xml'\n})\n\n// 设置最大占用20mb的内存\nserver\n  .layer('lru_layer_size')\n  .route('tile.png')\n  .use(provider)\n  .use(\n    headers({\n      'Access-Control-Allow-Origin': '*'\n    })\n  )\n  .use(lru({ size: '20mb', ttl: 30 })) // ttl in seconds\n\n// 设置最多缓存20个数据\nserver\n  .layer('lru_layer_number')\n  .route('tile.png')\n  .use(provider)\n  .use(\n    headers({\n      'Access-Control-Allow-Origin': '*'\n    })\n  )\n  .use(lru({ size: 20, ttl: 30 }))\n\n// 手动设置cache中数据对应key的结构\nserver\n  .layer('lru_layer_key')\n  .route('tile.png')\n  .use(provider)\n  .use(\n    headers({\n      'Access-Control-Allow-Origin': '*'\n    })\n  )\n  .use(\n    lru({\n      key: function(req) {\n        return (\n          req.z +\n          ',' +\n          req.x +\n          ',' +\n          req.y +\n          ',' +\n          req.layer +\n          ',' +\n          req.filename +\n          ',' +\n          'lru_layer_custom_key'\n        )\n      }\n    })\n  )\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n多次访问某个瓦片，如`http://127.0.0.1:9527/lru_layer_number/4/12/6/tile.png`，可以发现插件会在后几次从`cache`中直接 get 获取数据：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-lru-20190705162618.png)\n\n# 4. 代码浅析\n\n首先定义插件类型，`Caches`类型的插件需要给 tilestrata 提供`set`和`get`两个回调函数，核心是[lru-cache](https://www.npmjs.com/package/lru-cache)库\n\n```js\n// 代码有所精简\n// 设置缓存用到的key，如果没有自己设置key的结构，那默认将采用如下的结构\nvar key =\n  opts.key ||\n  function(req) {\n    return (\n      req.z + ',' + req.x + ',' + req.y + ',' + req.layer + ',' + req.filename\n    )\n  }\n\n// 判断设置的是数量还是内存大小\nif (typeof opts.size === 'string') {\n  lruopts.max = filesizeParser(opts.size)\n  lruopts.length = function(item) {\n    return item.buffer.length\n  }\n} else if (typeof opts.size === 'number') {\n  lruopts.max = opts.size\n}\n\n// 根据options创建lru-cache对象\nvar cache = new SyncCache(lruopts)\n\nreturn {\n  get: function(server, req, callback) {\n    // 获取数据\n    var item = cache.get(key(req))\n    if (item) return callback(null, item.buffer, item.headers)\n    callback()\n  },\n  set: function(server, req, buffer, headers, callback) {\n    // 缓存数据\n    cache.set(key(req), { buffer: buffer, headers: headers })\n    callback()\n  }\n}\n```\n","slug":"tilestrata-lru","published":1,"updated":"2019-07-11T14:52:47.660Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrkxgt9000pi83i8n2hbqr0","content":"<p><a href=\"https://github.com/naturalatlas/tilestrata-lru\" target=\"_blank\" rel=\"noopener\">tilestrata-lru</a>插件使用内存来缓存瓦片。所以使用起来需要额外的小心，如果没有仔细的配置它有可能导致内存溢出。但若果你需要在不同的图层或者路径中共享某个资源，这个插件就是为此而生的。</p>\n<a id=\"more\"></a>\n<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-lru --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> lru = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-lru'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> headers = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-headers'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> provider = mapnik(&#123;</span><br><span class=\"line\">  pathname: <span class=\"string\">'style/province.xml'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置最大占用20mb的内存</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'lru_layer_size'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(provider)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">'Access-Control-Allow-Origin'</span>: <span class=\"string\">'*'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(lru(&#123; <span class=\"attr\">size</span>: <span class=\"string\">'20mb'</span>, <span class=\"attr\">ttl</span>: <span class=\"number\">30</span> &#125;)) <span class=\"comment\">// ttl in seconds</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置最多缓存20个数据</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'lru_layer_number'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(provider)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">'Access-Control-Allow-Origin'</span>: <span class=\"string\">'*'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(lru(&#123; <span class=\"attr\">size</span>: <span class=\"number\">20</span>, <span class=\"attr\">ttl</span>: <span class=\"number\">30</span> &#125;))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 手动设置cache中数据对应key的结构</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'lru_layer_key'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(provider)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">'Access-Control-Allow-Origin'</span>: <span class=\"string\">'*'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    lru(&#123;</span><br><span class=\"line\">      key: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">          req.z +</span><br><span class=\"line\">          <span class=\"string\">','</span> +</span><br><span class=\"line\">          req.x +</span><br><span class=\"line\">          <span class=\"string\">','</span> +</span><br><span class=\"line\">          req.y +</span><br><span class=\"line\">          <span class=\"string\">','</span> +</span><br><span class=\"line\">          req.layer +</span><br><span class=\"line\">          <span class=\"string\">','</span> +</span><br><span class=\"line\">          req.filename +</span><br><span class=\"line\">          <span class=\"string\">','</span> +</span><br><span class=\"line\">          <span class=\"string\">'lru_layer_custom_key'</span></span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>多次访问某个瓦片，如<code>http://127.0.0.1:9527/lru_layer_number/4/12/6/tile.png</code>，可以发现插件会在后几次从<code>cache</code>中直接 get 获取数据：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-lru-20190705162618.png\" alt></p>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>首先定义插件类型，<code>Caches</code>类型的插件需要给 tilestrata 提供<code>set</code>和<code>get</code>两个回调函数，核心是<a href=\"https://www.npmjs.com/package/lru-cache\" target=\"_blank\" rel=\"noopener\">lru-cache</a>库</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码有所精简</span></span><br><span class=\"line\"><span class=\"comment\">// 设置缓存用到的key，如果没有自己设置key的结构，那默认将采用如下的结构</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> key =</span><br><span class=\"line\">  opts.key ||</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      req.z + <span class=\"string\">','</span> + req.x + <span class=\"string\">','</span> + req.y + <span class=\"string\">','</span> + req.layer + <span class=\"string\">','</span> + req.filename</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断设置的是数量还是内存大小</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> opts.size === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">  lruopts.max = filesizeParser(opts.size)</span><br><span class=\"line\">  lruopts.length = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> item.buffer.length</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> opts.size === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">  lruopts.max = opts.size</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据options创建lru-cache对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cache = <span class=\"keyword\">new</span> SyncCache(lruopts)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>: function(server, req, callback) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取数据</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> item = cache.get(key(req))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (item) <span class=\"keyword\">return</span> callback(<span class=\"literal\">null</span>, item.buffer, item.headers)</span><br><span class=\"line\">    callback()</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"keyword\">set</span>: function(server, req, buffer, headers, callback) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 缓存数据</span></span><br><span class=\"line\">    cache.set(key(req), &#123; <span class=\"attr\">buffer</span>: buffer, <span class=\"attr\">headers</span>: headers &#125;)</span><br><span class=\"line\">    callback()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/naturalatlas/tilestrata-lru\" target=\"_blank\" rel=\"noopener\">tilestrata-lru</a>插件使用内存来缓存瓦片。所以使用起来需要额外的小心，如果没有仔细的配置它有可能导致内存溢出。但若果你需要在不同的图层或者路径中共享某个资源，这个插件就是为此而生的。</p>","more":"<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-lru --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> lru = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-lru'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> headers = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-headers'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> provider = mapnik(&#123;</span><br><span class=\"line\">  pathname: <span class=\"string\">'style/province.xml'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置最大占用20mb的内存</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'lru_layer_size'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(provider)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">'Access-Control-Allow-Origin'</span>: <span class=\"string\">'*'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(lru(&#123; <span class=\"attr\">size</span>: <span class=\"string\">'20mb'</span>, <span class=\"attr\">ttl</span>: <span class=\"number\">30</span> &#125;)) <span class=\"comment\">// ttl in seconds</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置最多缓存20个数据</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'lru_layer_number'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(provider)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">'Access-Control-Allow-Origin'</span>: <span class=\"string\">'*'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(lru(&#123; <span class=\"attr\">size</span>: <span class=\"number\">20</span>, <span class=\"attr\">ttl</span>: <span class=\"number\">30</span> &#125;))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 手动设置cache中数据对应key的结构</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'lru_layer_key'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(provider)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">'Access-Control-Allow-Origin'</span>: <span class=\"string\">'*'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    lru(&#123;</span><br><span class=\"line\">      key: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">          req.z +</span><br><span class=\"line\">          <span class=\"string\">','</span> +</span><br><span class=\"line\">          req.x +</span><br><span class=\"line\">          <span class=\"string\">','</span> +</span><br><span class=\"line\">          req.y +</span><br><span class=\"line\">          <span class=\"string\">','</span> +</span><br><span class=\"line\">          req.layer +</span><br><span class=\"line\">          <span class=\"string\">','</span> +</span><br><span class=\"line\">          req.filename +</span><br><span class=\"line\">          <span class=\"string\">','</span> +</span><br><span class=\"line\">          <span class=\"string\">'lru_layer_custom_key'</span></span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>多次访问某个瓦片，如<code>http://127.0.0.1:9527/lru_layer_number/4/12/6/tile.png</code>，可以发现插件会在后几次从<code>cache</code>中直接 get 获取数据：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-lru-20190705162618.png\" alt></p>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>首先定义插件类型，<code>Caches</code>类型的插件需要给 tilestrata 提供<code>set</code>和<code>get</code>两个回调函数，核心是<a href=\"https://www.npmjs.com/package/lru-cache\" target=\"_blank\" rel=\"noopener\">lru-cache</a>库</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码有所精简</span></span><br><span class=\"line\"><span class=\"comment\">// 设置缓存用到的key，如果没有自己设置key的结构，那默认将采用如下的结构</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> key =</span><br><span class=\"line\">  opts.key ||</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      req.z + <span class=\"string\">','</span> + req.x + <span class=\"string\">','</span> + req.y + <span class=\"string\">','</span> + req.layer + <span class=\"string\">','</span> + req.filename</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断设置的是数量还是内存大小</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> opts.size === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">  lruopts.max = filesizeParser(opts.size)</span><br><span class=\"line\">  lruopts.length = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> item.buffer.length</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> opts.size === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">  lruopts.max = opts.size</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据options创建lru-cache对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cache = <span class=\"keyword\">new</span> SyncCache(lruopts)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>: function(server, req, callback) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取数据</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> item = cache.get(key(req))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (item) <span class=\"keyword\">return</span> callback(<span class=\"literal\">null</span>, item.buffer, item.headers)</span><br><span class=\"line\">    callback()</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"keyword\">set</span>: function(server, req, buffer, headers, callback) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 缓存数据</span></span><br><span class=\"line\">    cache.set(key(req), &#123; <span class=\"attr\">buffer</span>: buffer, <span class=\"attr\">headers</span>: headers &#125;)</span><br><span class=\"line\">    callback()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"tilestrata-postgismvt 插件使用及浅析","date":"2019-06-13T08:02:44.000Z","_content":"\n[tilestrata-postgismvt](https://github.com/Stezii/tilestrata-postgismvt)是一个用来从 PostGIS 数据库中检索出 mvt 格式矢量瓦片的插件。PostGIS 在 2.4.0 版本后支持了直接生成 mvt 数据，这让我们更方便的加工出矢量瓦片。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 基本要求\n\nPostGIS 需要在[2.4.0](https://postgis.net/2017/09/30/postgis-2.4.0/)版本及以上\n\n# 2. 安装\n\n```bash\n## 不推荐\nnpm install tilestrata-postgismvt --save\n```\n\n在 ST_AsMVT 方法更新后 ，虽然作者更新了代码，但是 npm 包并不是最新的，建议用下面的方法安装最新版，或者直接去 Github 上下载\n\n```bash\n## 推荐\nnpm install --save https://github.com/Stezii/tilestrata-postgismvt\n```\n\n或者通过 package.json\n\n```json\n\"tilestrata-postgismvt\": \"github:Stezii/tilestrata-postgismvt\"\n```\n\n# 3. 使用\n\n前提：一个导入了 osm 数据的支持 PostGIS 2.4.0 的数据服务器\n\n执行 mapbox 的脚本[TileBBox.sql](https://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql)添加`TileBBox`函数\n\n## 3.1 普通模式\n\n```js\nvar tilestrata = require(\"tilestrata\");\nvar postgismvt = require(\"tilestrata-postgismvt\");\nvar headers = require(\"tilestrata-headers\");\n\nserver = tilestrata();\n\nserver\n  .layer(\"osm_mvt\")\n  .route(\"tile.mvt\")\n  .use(\n    headers({\n      \"Access-Control-Allow-Origin\": \"*\"\n    })\n  )\n  .use(\n    postgismvt({\n      lyr: {\n        table: \"import.osm_buildings\", // 表名\n        geometry: \"geometry\", // geometry在表中的字段名\n        srid: 3857, // 坐标系\n        minZoom: 3,\n        maxZoom: 19,\n        buffer: 10, // 裁剪geometry时的缓冲距离，PostGIS默认为256\n        fields: \"name\", // 额外字段名\n        resolution: 256 // 分辨率，可以是function\n      },\n      pgConfig: {\n        // 通过`pgConfig`属性配置PostGIS相关属性\n        host: \"localhost\",\n        user: \"gis\",\n        password: \"gis\",\n        database: \"gis\",\n        port: \"6543\"\n      }\n    })\n  );\n\nserver.listen(8080);\n```\n\n## 3.2 点云数据\n\n如果是点要素，可以使用 cluster 模式，只要定义`lry`中的`mode`属性为`cluster_fields、cluster或function`,注意的是需要同时定义`type`为`circle`\n\n```js\nserver.layer('layer_name').route('tile.mvt')\n  .use(postgismvt({\n    lyr: {\n      ...\n      mode: 'cluster' // or 'cluster_fields'\n    },\n    pgConfig: {\n      ...\n    }}))\n  );\n```\n\n`mode`和`resolution`都支持是一个函数。通过这种方式可以手动指定一些缩放级别，用来控制精度\n\n```js\nserver.layer('layer_name').route('tile.mvt')\n  .use(postgismvt({\n    lyr: {\n      resolution: function(server, req) {\n        if (req.z > 12) return 512;\n        return 256;\n      },\n      mode: function(server, req) {\n        if (req.z > 15) return null;\n        if (req.z > 13) return 'cluster_fields';\n        return 'cluster';\n      }\n    },\n    pgConfig: {\n      ...\n    }}))\n  );\n```\n\n# 4. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-postgismvt20190606111135.png)\n\n# 5. 代码浅析\n\n其实核心的方法就是用到了 PostGIS 的`ST_AsMVT`和`ST_AsMVTGeom`函数。mapbox 提供[TileBBox.sql](https://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql)用来计算 zxy 位置的瓦片对应的 box 边界，再查询出其中的 geom，转换成 mvt 格式。\n\n比如说 `z=14,x=12917,y=6430`的瓦片对应的 sql 如下：\n\n```sql\nSELECT ST_AsMVT(q, 'osm_mvt', 256, 'geom') AS mvt\nFROM (\n  SELECT ST_AsMVTGeom(\n    ST_Transform(\n\t  import.osm_buildings.geometry, 3857),\n\t  TileBBox(14, 12917, 6430, 3857),\n\t  256,\n\t  10,\n      true\n\t) geom ,name\n    FROM import.osm_buildings\n    WHERE ST_Intersects(TileBBox(14, 12917, 6430, 3857), import.osm_buildings.geometry)\n) AS q\n```\n\n此外，`fields`是可以用逗号分割传递多个想要的字段名的。\n","source":"_posts/2019/tilestrata-postgismvt.md","raw":"---\ntitle: tilestrata-postgismvt 插件使用及浅析\ndate: 2019-06-13 16:02:44\ntags: [GIS]\ncategories: TileStrata\n---\n\n[tilestrata-postgismvt](https://github.com/Stezii/tilestrata-postgismvt)是一个用来从 PostGIS 数据库中检索出 mvt 格式矢量瓦片的插件。PostGIS 在 2.4.0 版本后支持了直接生成 mvt 数据，这让我们更方便的加工出矢量瓦片。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 基本要求\n\nPostGIS 需要在[2.4.0](https://postgis.net/2017/09/30/postgis-2.4.0/)版本及以上\n\n# 2. 安装\n\n```bash\n## 不推荐\nnpm install tilestrata-postgismvt --save\n```\n\n在 ST_AsMVT 方法更新后 ，虽然作者更新了代码，但是 npm 包并不是最新的，建议用下面的方法安装最新版，或者直接去 Github 上下载\n\n```bash\n## 推荐\nnpm install --save https://github.com/Stezii/tilestrata-postgismvt\n```\n\n或者通过 package.json\n\n```json\n\"tilestrata-postgismvt\": \"github:Stezii/tilestrata-postgismvt\"\n```\n\n# 3. 使用\n\n前提：一个导入了 osm 数据的支持 PostGIS 2.4.0 的数据服务器\n\n执行 mapbox 的脚本[TileBBox.sql](https://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql)添加`TileBBox`函数\n\n## 3.1 普通模式\n\n```js\nvar tilestrata = require(\"tilestrata\");\nvar postgismvt = require(\"tilestrata-postgismvt\");\nvar headers = require(\"tilestrata-headers\");\n\nserver = tilestrata();\n\nserver\n  .layer(\"osm_mvt\")\n  .route(\"tile.mvt\")\n  .use(\n    headers({\n      \"Access-Control-Allow-Origin\": \"*\"\n    })\n  )\n  .use(\n    postgismvt({\n      lyr: {\n        table: \"import.osm_buildings\", // 表名\n        geometry: \"geometry\", // geometry在表中的字段名\n        srid: 3857, // 坐标系\n        minZoom: 3,\n        maxZoom: 19,\n        buffer: 10, // 裁剪geometry时的缓冲距离，PostGIS默认为256\n        fields: \"name\", // 额外字段名\n        resolution: 256 // 分辨率，可以是function\n      },\n      pgConfig: {\n        // 通过`pgConfig`属性配置PostGIS相关属性\n        host: \"localhost\",\n        user: \"gis\",\n        password: \"gis\",\n        database: \"gis\",\n        port: \"6543\"\n      }\n    })\n  );\n\nserver.listen(8080);\n```\n\n## 3.2 点云数据\n\n如果是点要素，可以使用 cluster 模式，只要定义`lry`中的`mode`属性为`cluster_fields、cluster或function`,注意的是需要同时定义`type`为`circle`\n\n```js\nserver.layer('layer_name').route('tile.mvt')\n  .use(postgismvt({\n    lyr: {\n      ...\n      mode: 'cluster' // or 'cluster_fields'\n    },\n    pgConfig: {\n      ...\n    }}))\n  );\n```\n\n`mode`和`resolution`都支持是一个函数。通过这种方式可以手动指定一些缩放级别，用来控制精度\n\n```js\nserver.layer('layer_name').route('tile.mvt')\n  .use(postgismvt({\n    lyr: {\n      resolution: function(server, req) {\n        if (req.z > 12) return 512;\n        return 256;\n      },\n      mode: function(server, req) {\n        if (req.z > 15) return null;\n        if (req.z > 13) return 'cluster_fields';\n        return 'cluster';\n      }\n    },\n    pgConfig: {\n      ...\n    }}))\n  );\n```\n\n# 4. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-postgismvt20190606111135.png)\n\n# 5. 代码浅析\n\n其实核心的方法就是用到了 PostGIS 的`ST_AsMVT`和`ST_AsMVTGeom`函数。mapbox 提供[TileBBox.sql](https://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql)用来计算 zxy 位置的瓦片对应的 box 边界，再查询出其中的 geom，转换成 mvt 格式。\n\n比如说 `z=14,x=12917,y=6430`的瓦片对应的 sql 如下：\n\n```sql\nSELECT ST_AsMVT(q, 'osm_mvt', 256, 'geom') AS mvt\nFROM (\n  SELECT ST_AsMVTGeom(\n    ST_Transform(\n\t  import.osm_buildings.geometry, 3857),\n\t  TileBBox(14, 12917, 6430, 3857),\n\t  256,\n\t  10,\n      true\n\t) geom ,name\n    FROM import.osm_buildings\n    WHERE ST_Intersects(TileBBox(14, 12917, 6430, 3857), import.osm_buildings.geometry)\n) AS q\n```\n\n此外，`fields`是可以用逗号分割传递多个想要的字段名的。\n","slug":"tilestrata-postgismvt","published":1,"updated":"2019-06-28T05:56:28.441Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrkxgta000qi83inaowv78g","content":"<p><a href=\"https://github.com/Stezii/tilestrata-postgismvt\" target=\"_blank\" rel=\"noopener\">tilestrata-postgismvt</a>是一个用来从 PostGIS 数据库中检索出 mvt 格式矢量瓦片的插件。PostGIS 在 2.4.0 版本后支持了直接生成 mvt 数据，这让我们更方便的加工出矢量瓦片。</p>\n<a id=\"more\"></a>\n<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-基本要求\"><a href=\"#1-基本要求\" class=\"headerlink\" title=\"1. 基本要求\"></a>1. 基本要求</h1><p>PostGIS 需要在<a href=\"https://postgis.net/2017/09/30/postgis-2.4.0/\" target=\"_blank\" rel=\"noopener\">2.4.0</a>版本及以上</p>\n<h1 id=\"2-安装\"><a href=\"#2-安装\" class=\"headerlink\" title=\"2. 安装\"></a>2. 安装</h1><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 不推荐</span></span><br><span class=\"line\">npm install tilestrata-postgismvt --save</span><br></pre></td></tr></table></figure>\n<p>在 ST_AsMVT 方法更新后 ，虽然作者更新了代码，但是 npm 包并不是最新的，建议用下面的方法安装最新版，或者直接去 Github 上下载</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 推荐</span></span><br><span class=\"line\">npm install --save https://github.com/Stezii/tilestrata-postgismvt</span><br></pre></td></tr></table></figure>\n<p>或者通过 package.json</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">\"tilestrata-postgismvt\": \"github:Stezii/tilestrata-postgismvt\"</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-使用\"><a href=\"#3-使用\" class=\"headerlink\" title=\"3. 使用\"></a>3. 使用</h1><p>前提：一个导入了 osm 数据的支持 PostGIS 2.4.0 的数据服务器</p>\n<p>执行 mapbox 的脚本<a href=\"https://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql\" target=\"_blank\" rel=\"noopener\">TileBBox.sql</a>添加<code>TileBBox</code>函数</p>\n<h2 id=\"3-1-普通模式\"><a href=\"#3-1-普通模式\" class=\"headerlink\" title=\"3.1 普通模式\"></a>3.1 普通模式</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> postgismvt = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata-postgismvt\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> headers = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata-headers\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">server = tilestrata();</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">\"osm_mvt\"</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">\"tile.mvt\"</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">\"Access-Control-Allow-Origin\"</span>: <span class=\"string\">\"*\"</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    postgismvt(&#123;</span><br><span class=\"line\">      lyr: &#123;</span><br><span class=\"line\">        table: <span class=\"string\">\"import.osm_buildings\"</span>, <span class=\"comment\">// 表名</span></span><br><span class=\"line\">        geometry: <span class=\"string\">\"geometry\"</span>, <span class=\"comment\">// geometry在表中的字段名</span></span><br><span class=\"line\">        srid: <span class=\"number\">3857</span>, <span class=\"comment\">// 坐标系</span></span><br><span class=\"line\">        minZoom: <span class=\"number\">3</span>,</span><br><span class=\"line\">        maxZoom: <span class=\"number\">19</span>,</span><br><span class=\"line\">        buffer: <span class=\"number\">10</span>, <span class=\"comment\">// 裁剪geometry时的缓冲距离，PostGIS默认为256</span></span><br><span class=\"line\">        fields: <span class=\"string\">\"name\"</span>, <span class=\"comment\">// 额外字段名</span></span><br><span class=\"line\">        resolution: <span class=\"number\">256</span> <span class=\"comment\">// 分辨率，可以是function</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      pgConfig: &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 通过`pgConfig`属性配置PostGIS相关属性</span></span><br><span class=\"line\">        host: <span class=\"string\">\"localhost\"</span>,</span><br><span class=\"line\">        user: <span class=\"string\">\"gis\"</span>,</span><br><span class=\"line\">        password: <span class=\"string\">\"gis\"</span>,</span><br><span class=\"line\">        database: <span class=\"string\">\"gis\"</span>,</span><br><span class=\"line\">        port: <span class=\"string\">\"6543\"</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">8080</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-2-点云数据\"><a href=\"#3-2-点云数据\" class=\"headerlink\" title=\"3.2 点云数据\"></a>3.2 点云数据</h2><p>如果是点要素，可以使用 cluster 模式，只要定义<code>lry</code>中的<code>mode</code>属性为<code>cluster_fields、cluster或function</code>,注意的是需要同时定义<code>type</code>为<code>circle</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">server.layer(<span class=\"string\">'layer_name'</span>).route(<span class=\"string\">'tile.mvt'</span>)</span><br><span class=\"line\">  .use(postgismvt(&#123;</span><br><span class=\"line\">    lyr: &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      mode: <span class=\"string\">'cluster'</span> <span class=\"comment\">// or 'cluster_fields'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    pgConfig: &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;&#125;))</span><br><span class=\"line\">  );</span><br></pre></td></tr></table></figure>\n<p><code>mode</code>和<code>resolution</code>都支持是一个函数。通过这种方式可以手动指定一些缩放级别，用来控制精度</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">server.layer(<span class=\"string\">'layer_name'</span>).route(<span class=\"string\">'tile.mvt'</span>)</span><br><span class=\"line\">  .use(postgismvt(&#123;</span><br><span class=\"line\">    lyr: &#123;</span><br><span class=\"line\">      resolution: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (req.z &gt; <span class=\"number\">12</span>) <span class=\"keyword\">return</span> <span class=\"number\">512</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">256</span>;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      mode: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (req.z &gt; <span class=\"number\">15</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (req.z &gt; <span class=\"number\">13</span>) <span class=\"keyword\">return</span> <span class=\"string\">'cluster_fields'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'cluster'</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    pgConfig: &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;&#125;))</span><br><span class=\"line\">  );</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-效果\"><a href=\"#4-效果\" class=\"headerlink\" title=\"4. 效果\"></a>4. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-postgismvt20190606111135.png\" alt></p>\n<h1 id=\"5-代码浅析\"><a href=\"#5-代码浅析\" class=\"headerlink\" title=\"5. 代码浅析\"></a>5. 代码浅析</h1><p>其实核心的方法就是用到了 PostGIS 的<code>ST_AsMVT</code>和<code>ST_AsMVTGeom</code>函数。mapbox 提供<a href=\"https://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql\" target=\"_blank\" rel=\"noopener\">TileBBox.sql</a>用来计算 zxy 位置的瓦片对应的 box 边界，再查询出其中的 geom，转换成 mvt 格式。</p>\n<p>比如说 <code>z=14,x=12917,y=6430</code>的瓦片对应的 sql 如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> ST_AsMVT(q, <span class=\"string\">'osm_mvt'</span>, <span class=\"number\">256</span>, <span class=\"string\">'geom'</span>) <span class=\"keyword\">AS</span> mvt</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> (</span><br><span class=\"line\">  <span class=\"keyword\">SELECT</span> ST_AsMVTGeom(</span><br><span class=\"line\">    ST_Transform(</span><br><span class=\"line\">\t  import.osm_buildings.geometry, <span class=\"number\">3857</span>),</span><br><span class=\"line\">\t  TileBBox(<span class=\"number\">14</span>, <span class=\"number\">12917</span>, <span class=\"number\">6430</span>, <span class=\"number\">3857</span>),</span><br><span class=\"line\">\t  <span class=\"number\">256</span>,</span><br><span class=\"line\">\t  <span class=\"number\">10</span>,</span><br><span class=\"line\">      <span class=\"literal\">true</span></span><br><span class=\"line\">\t) geom ,<span class=\"keyword\">name</span></span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> import.osm_buildings</span><br><span class=\"line\">    <span class=\"keyword\">WHERE</span> ST_Intersects(TileBBox(<span class=\"number\">14</span>, <span class=\"number\">12917</span>, <span class=\"number\">6430</span>, <span class=\"number\">3857</span>), import.osm_buildings.geometry)</span><br><span class=\"line\">) <span class=\"keyword\">AS</span> q</span><br></pre></td></tr></table></figure>\n<p>此外，<code>fields</code>是可以用逗号分割传递多个想要的字段名的。</p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/Stezii/tilestrata-postgismvt\" target=\"_blank\" rel=\"noopener\">tilestrata-postgismvt</a>是一个用来从 PostGIS 数据库中检索出 mvt 格式矢量瓦片的插件。PostGIS 在 2.4.0 版本后支持了直接生成 mvt 数据，这让我们更方便的加工出矢量瓦片。</p>","more":"<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-基本要求\"><a href=\"#1-基本要求\" class=\"headerlink\" title=\"1. 基本要求\"></a>1. 基本要求</h1><p>PostGIS 需要在<a href=\"https://postgis.net/2017/09/30/postgis-2.4.0/\" target=\"_blank\" rel=\"noopener\">2.4.0</a>版本及以上</p>\n<h1 id=\"2-安装\"><a href=\"#2-安装\" class=\"headerlink\" title=\"2. 安装\"></a>2. 安装</h1><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 不推荐</span></span><br><span class=\"line\">npm install tilestrata-postgismvt --save</span><br></pre></td></tr></table></figure>\n<p>在 ST_AsMVT 方法更新后 ，虽然作者更新了代码，但是 npm 包并不是最新的，建议用下面的方法安装最新版，或者直接去 Github 上下载</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 推荐</span></span><br><span class=\"line\">npm install --save https://github.com/Stezii/tilestrata-postgismvt</span><br></pre></td></tr></table></figure>\n<p>或者通过 package.json</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">\"tilestrata-postgismvt\": \"github:Stezii/tilestrata-postgismvt\"</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-使用\"><a href=\"#3-使用\" class=\"headerlink\" title=\"3. 使用\"></a>3. 使用</h1><p>前提：一个导入了 osm 数据的支持 PostGIS 2.4.0 的数据服务器</p>\n<p>执行 mapbox 的脚本<a href=\"https://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql\" target=\"_blank\" rel=\"noopener\">TileBBox.sql</a>添加<code>TileBBox</code>函数</p>\n<h2 id=\"3-1-普通模式\"><a href=\"#3-1-普通模式\" class=\"headerlink\" title=\"3.1 普通模式\"></a>3.1 普通模式</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> postgismvt = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata-postgismvt\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> headers = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata-headers\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">server = tilestrata();</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">\"osm_mvt\"</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">\"tile.mvt\"</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">\"Access-Control-Allow-Origin\"</span>: <span class=\"string\">\"*\"</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    postgismvt(&#123;</span><br><span class=\"line\">      lyr: &#123;</span><br><span class=\"line\">        table: <span class=\"string\">\"import.osm_buildings\"</span>, <span class=\"comment\">// 表名</span></span><br><span class=\"line\">        geometry: <span class=\"string\">\"geometry\"</span>, <span class=\"comment\">// geometry在表中的字段名</span></span><br><span class=\"line\">        srid: <span class=\"number\">3857</span>, <span class=\"comment\">// 坐标系</span></span><br><span class=\"line\">        minZoom: <span class=\"number\">3</span>,</span><br><span class=\"line\">        maxZoom: <span class=\"number\">19</span>,</span><br><span class=\"line\">        buffer: <span class=\"number\">10</span>, <span class=\"comment\">// 裁剪geometry时的缓冲距离，PostGIS默认为256</span></span><br><span class=\"line\">        fields: <span class=\"string\">\"name\"</span>, <span class=\"comment\">// 额外字段名</span></span><br><span class=\"line\">        resolution: <span class=\"number\">256</span> <span class=\"comment\">// 分辨率，可以是function</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      pgConfig: &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 通过`pgConfig`属性配置PostGIS相关属性</span></span><br><span class=\"line\">        host: <span class=\"string\">\"localhost\"</span>,</span><br><span class=\"line\">        user: <span class=\"string\">\"gis\"</span>,</span><br><span class=\"line\">        password: <span class=\"string\">\"gis\"</span>,</span><br><span class=\"line\">        database: <span class=\"string\">\"gis\"</span>,</span><br><span class=\"line\">        port: <span class=\"string\">\"6543\"</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">8080</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-2-点云数据\"><a href=\"#3-2-点云数据\" class=\"headerlink\" title=\"3.2 点云数据\"></a>3.2 点云数据</h2><p>如果是点要素，可以使用 cluster 模式，只要定义<code>lry</code>中的<code>mode</code>属性为<code>cluster_fields、cluster或function</code>,注意的是需要同时定义<code>type</code>为<code>circle</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">server.layer(<span class=\"string\">'layer_name'</span>).route(<span class=\"string\">'tile.mvt'</span>)</span><br><span class=\"line\">  .use(postgismvt(&#123;</span><br><span class=\"line\">    lyr: &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      mode: <span class=\"string\">'cluster'</span> <span class=\"comment\">// or 'cluster_fields'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    pgConfig: &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;&#125;))</span><br><span class=\"line\">  );</span><br></pre></td></tr></table></figure>\n<p><code>mode</code>和<code>resolution</code>都支持是一个函数。通过这种方式可以手动指定一些缩放级别，用来控制精度</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">server.layer(<span class=\"string\">'layer_name'</span>).route(<span class=\"string\">'tile.mvt'</span>)</span><br><span class=\"line\">  .use(postgismvt(&#123;</span><br><span class=\"line\">    lyr: &#123;</span><br><span class=\"line\">      resolution: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (req.z &gt; <span class=\"number\">12</span>) <span class=\"keyword\">return</span> <span class=\"number\">512</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">256</span>;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      mode: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (req.z &gt; <span class=\"number\">15</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (req.z &gt; <span class=\"number\">13</span>) <span class=\"keyword\">return</span> <span class=\"string\">'cluster_fields'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'cluster'</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    pgConfig: &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;&#125;))</span><br><span class=\"line\">  );</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-效果\"><a href=\"#4-效果\" class=\"headerlink\" title=\"4. 效果\"></a>4. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-postgismvt20190606111135.png\" alt></p>\n<h1 id=\"5-代码浅析\"><a href=\"#5-代码浅析\" class=\"headerlink\" title=\"5. 代码浅析\"></a>5. 代码浅析</h1><p>其实核心的方法就是用到了 PostGIS 的<code>ST_AsMVT</code>和<code>ST_AsMVTGeom</code>函数。mapbox 提供<a href=\"https://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql\" target=\"_blank\" rel=\"noopener\">TileBBox.sql</a>用来计算 zxy 位置的瓦片对应的 box 边界，再查询出其中的 geom，转换成 mvt 格式。</p>\n<p>比如说 <code>z=14,x=12917,y=6430</code>的瓦片对应的 sql 如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> ST_AsMVT(q, <span class=\"string\">'osm_mvt'</span>, <span class=\"number\">256</span>, <span class=\"string\">'geom'</span>) <span class=\"keyword\">AS</span> mvt</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> (</span><br><span class=\"line\">  <span class=\"keyword\">SELECT</span> ST_AsMVTGeom(</span><br><span class=\"line\">    ST_Transform(</span><br><span class=\"line\">\t  import.osm_buildings.geometry, <span class=\"number\">3857</span>),</span><br><span class=\"line\">\t  TileBBox(<span class=\"number\">14</span>, <span class=\"number\">12917</span>, <span class=\"number\">6430</span>, <span class=\"number\">3857</span>),</span><br><span class=\"line\">\t  <span class=\"number\">256</span>,</span><br><span class=\"line\">\t  <span class=\"number\">10</span>,</span><br><span class=\"line\">      <span class=\"literal\">true</span></span><br><span class=\"line\">\t) geom ,<span class=\"keyword\">name</span></span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> import.osm_buildings</span><br><span class=\"line\">    <span class=\"keyword\">WHERE</span> ST_Intersects(TileBBox(<span class=\"number\">14</span>, <span class=\"number\">12917</span>, <span class=\"number\">6430</span>, <span class=\"number\">3857</span>), import.osm_buildings.geometry)</span><br><span class=\"line\">) <span class=\"keyword\">AS</span> q</span><br></pre></td></tr></table></figure>\n<p>此外，<code>fields</code>是可以用逗号分割传递多个想要的字段名的。</p>"},{"title":"tilestrata-sharp 插件使用及浅析","date":"2019-07-14T12:54:55.000Z","_content":"\n[tilestrata-sharp](https://github.com/naturalatlas/tilestrata-sharp)插件通过使用[libvips](https://github.com/jcupitt/libvips)的[sharp](https://github.com/lovell/sharp)库来转换处理图片。对于图片处理的一些方法参数都可以从 sharp 的[官方文档](https://sharp.pixelplumbing.com/en/stable/)中来找寻，这个插件相当于起到了一个搭桥铺路的作用，核心依然是 sharp。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install sharp --save\n$ npm install tilestrata-sharp --save\n```\n\n# 2. 使用\n\n插件官网中对于使用的说明非常简单，因为插件本身不包含处理图片的逻辑，所以更多的使用方法得去[sharp](https://sharp.pixelplumbing.com/en/stable/)中找寻\n\n```js\nconst tilestrata = require('tilestrata')\nconst mapnik = require('tilestrata-mapnik')\nconst sharp = require('tilestrata-sharp')\nconst server = tilestrata()\n\nserver\n  .layer('world_merc_sharp')\n  .route('tile.png')\n  .use(\n    // 定义数据源\n    mapnik({\n      pathname: 'style/world.xml'\n    })\n  )\n  .use(\n    sharp(function(image, sharp) {\n      return image\n        .resize(256) // 重新设置大小\n        .rotate(180) // 旋转\n        .greyscale() // 灰度处理\n    })\n  )\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n下图是原始的瓦片样式：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-sharp-original-20190705114413.png)\n\n在使用了 sharp 插件进行了旋转 180°，灰度处理之后，如下所示：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-sharp-result-20190705113728.png)\n\n# 4. 代码浅析\n\n这个插件比较简单，属于`transform`类型，返回 buffer 给 tilestrata 之前会根据用户设置的回调函数里面的处理规则，调用`sharp`处理成新的 buffer，然后再返回。\n\n```js\ntransform: function(server, req, buffer, headers, callback) {\n    var image;\n\n    try {\n        // 用原buffer生成sharp对象\n        image = sharp(buffer);\n        // 执行回调里面的处理规则\n        fn(image, sharp);\n    }\n    catch (err) { return callback(err); }\n\n    // 转化回buffer\n    image.toBuffer(function(err, buffer, info) {\n        if (err) return callback(err);\n        headers['Content-Type'] = 'image/' + info.format;\n        // 还给tilestrata\n        callback(null, buffer, headers);\n    });\n}\n```\n","source":"_posts/2019/tilestrata-sharp.md","raw":"---\ntitle: tilestrata-sharp 插件使用及浅析\ndate: 2019-07-14 20:54:55\ntags: [GIS]\ncategories: TileStrata\n---\n\n[tilestrata-sharp](https://github.com/naturalatlas/tilestrata-sharp)插件通过使用[libvips](https://github.com/jcupitt/libvips)的[sharp](https://github.com/lovell/sharp)库来转换处理图片。对于图片处理的一些方法参数都可以从 sharp 的[官方文档](https://sharp.pixelplumbing.com/en/stable/)中来找寻，这个插件相当于起到了一个搭桥铺路的作用，核心依然是 sharp。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install sharp --save\n$ npm install tilestrata-sharp --save\n```\n\n# 2. 使用\n\n插件官网中对于使用的说明非常简单，因为插件本身不包含处理图片的逻辑，所以更多的使用方法得去[sharp](https://sharp.pixelplumbing.com/en/stable/)中找寻\n\n```js\nconst tilestrata = require('tilestrata')\nconst mapnik = require('tilestrata-mapnik')\nconst sharp = require('tilestrata-sharp')\nconst server = tilestrata()\n\nserver\n  .layer('world_merc_sharp')\n  .route('tile.png')\n  .use(\n    // 定义数据源\n    mapnik({\n      pathname: 'style/world.xml'\n    })\n  )\n  .use(\n    sharp(function(image, sharp) {\n      return image\n        .resize(256) // 重新设置大小\n        .rotate(180) // 旋转\n        .greyscale() // 灰度处理\n    })\n  )\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n下图是原始的瓦片样式：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-sharp-original-20190705114413.png)\n\n在使用了 sharp 插件进行了旋转 180°，灰度处理之后，如下所示：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-sharp-result-20190705113728.png)\n\n# 4. 代码浅析\n\n这个插件比较简单，属于`transform`类型，返回 buffer 给 tilestrata 之前会根据用户设置的回调函数里面的处理规则，调用`sharp`处理成新的 buffer，然后再返回。\n\n```js\ntransform: function(server, req, buffer, headers, callback) {\n    var image;\n\n    try {\n        // 用原buffer生成sharp对象\n        image = sharp(buffer);\n        // 执行回调里面的处理规则\n        fn(image, sharp);\n    }\n    catch (err) { return callback(err); }\n\n    // 转化回buffer\n    image.toBuffer(function(err, buffer, info) {\n        if (err) return callback(err);\n        headers['Content-Type'] = 'image/' + info.format;\n        // 还给tilestrata\n        callback(null, buffer, headers);\n    });\n}\n```\n","slug":"tilestrata-sharp","published":1,"updated":"2019-07-14T12:58:59.927Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrkxgta000ri83ifhmezpoj","content":"<p><a href=\"https://github.com/naturalatlas/tilestrata-sharp\" target=\"_blank\" rel=\"noopener\">tilestrata-sharp</a>插件通过使用<a href=\"https://github.com/jcupitt/libvips\" target=\"_blank\" rel=\"noopener\">libvips</a>的<a href=\"https://github.com/lovell/sharp\" target=\"_blank\" rel=\"noopener\">sharp</a>库来转换处理图片。对于图片处理的一些方法参数都可以从 sharp 的<a href=\"https://sharp.pixelplumbing.com/en/stable/\" target=\"_blank\" rel=\"noopener\">官方文档</a>中来找寻，这个插件相当于起到了一个搭桥铺路的作用，核心依然是 sharp。</p>\n<a id=\"more\"></a>\n<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install sharp --save</span><br><span class=\"line\">$ npm install tilestrata-sharp --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><p>插件官网中对于使用的说明非常简单，因为插件本身不包含处理图片的逻辑，所以更多的使用方法得去<a href=\"https://sharp.pixelplumbing.com/en/stable/\" target=\"_blank\" rel=\"noopener\">sharp</a>中找寻</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> sharp = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-sharp'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'world_merc_sharp'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    <span class=\"comment\">// 定义数据源</span></span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/world.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    sharp(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">image, sharp</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> image</span><br><span class=\"line\">        .resize(<span class=\"number\">256</span>) <span class=\"comment\">// 重新设置大小</span></span><br><span class=\"line\">        .rotate(<span class=\"number\">180</span>) <span class=\"comment\">// 旋转</span></span><br><span class=\"line\">        .greyscale() <span class=\"comment\">// 灰度处理</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>下图是原始的瓦片样式：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-sharp-original-20190705114413.png\" alt></p>\n<p>在使用了 sharp 插件进行了旋转 180°，灰度处理之后，如下所示：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-sharp-result-20190705113728.png\" alt></p>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>这个插件比较简单，属于<code>transform</code>类型，返回 buffer 给 tilestrata 之前会根据用户设置的回调函数里面的处理规则，调用<code>sharp</code>处理成新的 buffer，然后再返回。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">transform: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req, buffer, headers, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> image;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 用原buffer生成sharp对象</span></span><br><span class=\"line\">        image = sharp(buffer);</span><br><span class=\"line\">        <span class=\"comment\">// 执行回调里面的处理规则</span></span><br><span class=\"line\">        fn(image, sharp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (err) &#123; <span class=\"keyword\">return</span> callback(err); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 转化回buffer</span></span><br><span class=\"line\">    image.toBuffer(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, buffer, info</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> callback(err);</span><br><span class=\"line\">        headers[<span class=\"string\">'Content-Type'</span>] = <span class=\"string\">'image/'</span> + info.format;</span><br><span class=\"line\">        <span class=\"comment\">// 还给tilestrata</span></span><br><span class=\"line\">        callback(<span class=\"literal\">null</span>, buffer, headers);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/naturalatlas/tilestrata-sharp\" target=\"_blank\" rel=\"noopener\">tilestrata-sharp</a>插件通过使用<a href=\"https://github.com/jcupitt/libvips\" target=\"_blank\" rel=\"noopener\">libvips</a>的<a href=\"https://github.com/lovell/sharp\" target=\"_blank\" rel=\"noopener\">sharp</a>库来转换处理图片。对于图片处理的一些方法参数都可以从 sharp 的<a href=\"https://sharp.pixelplumbing.com/en/stable/\" target=\"_blank\" rel=\"noopener\">官方文档</a>中来找寻，这个插件相当于起到了一个搭桥铺路的作用，核心依然是 sharp。</p>","more":"<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install sharp --save</span><br><span class=\"line\">$ npm install tilestrata-sharp --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><p>插件官网中对于使用的说明非常简单，因为插件本身不包含处理图片的逻辑，所以更多的使用方法得去<a href=\"https://sharp.pixelplumbing.com/en/stable/\" target=\"_blank\" rel=\"noopener\">sharp</a>中找寻</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> sharp = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-sharp'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'world_merc_sharp'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    <span class=\"comment\">// 定义数据源</span></span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/world.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    sharp(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">image, sharp</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> image</span><br><span class=\"line\">        .resize(<span class=\"number\">256</span>) <span class=\"comment\">// 重新设置大小</span></span><br><span class=\"line\">        .rotate(<span class=\"number\">180</span>) <span class=\"comment\">// 旋转</span></span><br><span class=\"line\">        .greyscale() <span class=\"comment\">// 灰度处理</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>下图是原始的瓦片样式：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-sharp-original-20190705114413.png\" alt></p>\n<p>在使用了 sharp 插件进行了旋转 180°，灰度处理之后，如下所示：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-sharp-result-20190705113728.png\" alt></p>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>这个插件比较简单，属于<code>transform</code>类型，返回 buffer 给 tilestrata 之前会根据用户设置的回调函数里面的处理规则，调用<code>sharp</code>处理成新的 buffer，然后再返回。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">transform: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req, buffer, headers, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> image;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 用原buffer生成sharp对象</span></span><br><span class=\"line\">        image = sharp(buffer);</span><br><span class=\"line\">        <span class=\"comment\">// 执行回调里面的处理规则</span></span><br><span class=\"line\">        fn(image, sharp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (err) &#123; <span class=\"keyword\">return</span> callback(err); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 转化回buffer</span></span><br><span class=\"line\">    image.toBuffer(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, buffer, info</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> callback(err);</span><br><span class=\"line\">        headers[<span class=\"string\">'Content-Type'</span>] = <span class=\"string\">'image/'</span> + info.format;</span><br><span class=\"line\">        <span class=\"comment\">// 还给tilestrata</span></span><br><span class=\"line\">        callback(<span class=\"literal\">null</span>, buffer, headers);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"tilestrata-underzoom  插件使用及浅析","date":"2019-07-11T14:44:51.000Z","_content":"\n[tilestrata-underzoom](https://github.com/naturalatlas/tilestrata-underzoom)插件从介绍上看就是在请求高级别瓦片时，用低级别的瓦片进行拼接，而不是直接生产指定级别的瓦片。使用这个插件必须安装依赖[node-mapnik](https://github.com/mapnik/node-mapnik)。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 0. 发生了什么\n\n比方说我们请求了`4/13/6`瓦片，即`x=13,y=6,z=4`，插件会分别找到`[[26,12,5],[27,12,5],[27,13,5],[26,13,5]]`四个瓦片，获取数据，然后把四张图片进行合并，而不是直接渲染出`4/13/6`对应的图像。我个人的理解中，在向外缩放的过程中，人眼可视区域内的地图范围越来越大，对于 server 来说要渲染的内容也就越来越多，这个时候就要既保证渲染的展现结果，又要保证渲染过程对服务器资源的占用，`underzoom`对于瓦片地图来说就是针对这一问题的探索。\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-underzoom --save\n```\n\n# 2. 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst dependency = require('tilestrata-dependency')\nconst underzoom = require('tilestrata-underzoom')\nconst mapnik = require('tilestrata-mapnik')\nconst server = tilestrata()\n\n// 用mapnik定义一个世界范围地图\nserver\n  .layer('world_merc')\n  .route('tile.png')\n  .use(\n    mapnik({\n      pathname: 'style/world.xml'\n    })\n  )\n\n// 定义underzoom图层\nserver\n  .layer('underzoom')\n  .route('tile@2x.png')\n  .use(\n    underzoom({\n      source: dependency('world_merc', 'tile.png'),\n      inputSize: 256,\n      outputSize: 512,\n      zooms: 1 // 1以下层级全部采用underzoom的方式拼接\n    })\n  )\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n不启用 underzoom 的效果：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-underzoom-original-20190708145711.png)\n\nunderzoom 放大两倍的效果：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-underzoom-result-20190708145813.png)\n\n可以看到，整个地图看上去**清晰了很多，边缘更加明显**，这是因为低级别瓦片本身的精细程度就高，合并成大图后的对于细节的效果也会更好。\n但是地图左边区域原先就基本上是只由线勾勒出的**白色区域**，在低瓦片中可以看到，合并成大图后就基本上看不清了，这是因为本身线宽是很细的，比如说是 1px 宽度，合并大图的过程中这个宽度并不会增加，但图片整个的像素变大了，所以细线就基本看不清了，这也是插件不好的地方。\n\n# 4. 代码浅析\n\n说到合并图片，就能想到之前我们说过的`tilestrata-blend`插件，它是将两个不同数据源的结果图片进行了合并，而这个插件是将同一个数据源的四个低级别瓦片合并成了一个。\n\n根据 underzoom 的`inputSize、zooms`的配置项，先准备好一个`Mapnik.Image`对象：\n\n```js\nvar canvas = new Mapnik.Image(canvasSize, canvasSize)\n```\n\n之后使用`@mapbox/tilebelt`库获取请求地址的下属四个低级别瓦片地址，分别请求数据，利用上面准备好的`Mapnik.Image`对象，使用[Image.composite](http://mapnik.org/documentation/node-mapnik/3.6/#Image.composite)方法来合并四张图片，最后返回结果就好。\n\n```js\n// 代码有所精简\nfunction startFetchAndComposite(callback) {\n  // 例如请求 4/13/6\n  // 此时coordList就是 [[26,12,5],[27,12,5],[27,13,5],[26,13,5]]\n  var coordList = getTileCoords(req.x, req.y, req.z, underzoomLevels)\n  // 遍历coordList\n  async.each(\n    coordList,\n    function(coords, callback) {\n      // clone一个新的请求\n      var childReq = req.clone()\n      childReq.x = coords[0]\n      childReq.y = coords[1]\n      childReq.z = coords[2]\n      options.source.serve(server, childReq, function(\n        err,\n        childBuffer,\n        childHeaders\n      ) {\n        // 获取数据\n        Mapnik.Image.fromBytes(childBuffer, function(err, image) {\n          // 执行合并操作\n          canvas.composite(\n            image,\n            {\n              comp_op: Mapnik.compositeOp.src_over,\n              dx: x,\n              dy: y,\n              opacity: 1\n            },\n            callback\n          )\n        })\n      })\n    },\n    callback\n  )\n}\n```\n","source":"_posts/2019/tilestrata-underzoom.md","raw":"---\ntitle: tilestrata-underzoom  插件使用及浅析\ndate: 2019-07-11 22:44:51\ntags: [GIS]\ncategories: TileStrata\n---\n\n[tilestrata-underzoom](https://github.com/naturalatlas/tilestrata-underzoom)插件从介绍上看就是在请求高级别瓦片时，用低级别的瓦片进行拼接，而不是直接生产指定级别的瓦片。使用这个插件必须安装依赖[node-mapnik](https://github.com/mapnik/node-mapnik)。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 0. 发生了什么\n\n比方说我们请求了`4/13/6`瓦片，即`x=13,y=6,z=4`，插件会分别找到`[[26,12,5],[27,12,5],[27,13,5],[26,13,5]]`四个瓦片，获取数据，然后把四张图片进行合并，而不是直接渲染出`4/13/6`对应的图像。我个人的理解中，在向外缩放的过程中，人眼可视区域内的地图范围越来越大，对于 server 来说要渲染的内容也就越来越多，这个时候就要既保证渲染的展现结果，又要保证渲染过程对服务器资源的占用，`underzoom`对于瓦片地图来说就是针对这一问题的探索。\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-underzoom --save\n```\n\n# 2. 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst dependency = require('tilestrata-dependency')\nconst underzoom = require('tilestrata-underzoom')\nconst mapnik = require('tilestrata-mapnik')\nconst server = tilestrata()\n\n// 用mapnik定义一个世界范围地图\nserver\n  .layer('world_merc')\n  .route('tile.png')\n  .use(\n    mapnik({\n      pathname: 'style/world.xml'\n    })\n  )\n\n// 定义underzoom图层\nserver\n  .layer('underzoom')\n  .route('tile@2x.png')\n  .use(\n    underzoom({\n      source: dependency('world_merc', 'tile.png'),\n      inputSize: 256,\n      outputSize: 512,\n      zooms: 1 // 1以下层级全部采用underzoom的方式拼接\n    })\n  )\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n不启用 underzoom 的效果：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-underzoom-original-20190708145711.png)\n\nunderzoom 放大两倍的效果：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-underzoom-result-20190708145813.png)\n\n可以看到，整个地图看上去**清晰了很多，边缘更加明显**，这是因为低级别瓦片本身的精细程度就高，合并成大图后的对于细节的效果也会更好。\n但是地图左边区域原先就基本上是只由线勾勒出的**白色区域**，在低瓦片中可以看到，合并成大图后就基本上看不清了，这是因为本身线宽是很细的，比如说是 1px 宽度，合并大图的过程中这个宽度并不会增加，但图片整个的像素变大了，所以细线就基本看不清了，这也是插件不好的地方。\n\n# 4. 代码浅析\n\n说到合并图片，就能想到之前我们说过的`tilestrata-blend`插件，它是将两个不同数据源的结果图片进行了合并，而这个插件是将同一个数据源的四个低级别瓦片合并成了一个。\n\n根据 underzoom 的`inputSize、zooms`的配置项，先准备好一个`Mapnik.Image`对象：\n\n```js\nvar canvas = new Mapnik.Image(canvasSize, canvasSize)\n```\n\n之后使用`@mapbox/tilebelt`库获取请求地址的下属四个低级别瓦片地址，分别请求数据，利用上面准备好的`Mapnik.Image`对象，使用[Image.composite](http://mapnik.org/documentation/node-mapnik/3.6/#Image.composite)方法来合并四张图片，最后返回结果就好。\n\n```js\n// 代码有所精简\nfunction startFetchAndComposite(callback) {\n  // 例如请求 4/13/6\n  // 此时coordList就是 [[26,12,5],[27,12,5],[27,13,5],[26,13,5]]\n  var coordList = getTileCoords(req.x, req.y, req.z, underzoomLevels)\n  // 遍历coordList\n  async.each(\n    coordList,\n    function(coords, callback) {\n      // clone一个新的请求\n      var childReq = req.clone()\n      childReq.x = coords[0]\n      childReq.y = coords[1]\n      childReq.z = coords[2]\n      options.source.serve(server, childReq, function(\n        err,\n        childBuffer,\n        childHeaders\n      ) {\n        // 获取数据\n        Mapnik.Image.fromBytes(childBuffer, function(err, image) {\n          // 执行合并操作\n          canvas.composite(\n            image,\n            {\n              comp_op: Mapnik.compositeOp.src_over,\n              dx: x,\n              dy: y,\n              opacity: 1\n            },\n            callback\n          )\n        })\n      })\n    },\n    callback\n  )\n}\n```\n","slug":"tilestrata-underzoom","published":1,"updated":"2019-07-11T14:49:59.188Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrkxgtb000si83i893if5jx","content":"<p><a href=\"https://github.com/naturalatlas/tilestrata-underzoom\" target=\"_blank\" rel=\"noopener\">tilestrata-underzoom</a>插件从介绍上看就是在请求高级别瓦片时，用低级别的瓦片进行拼接，而不是直接生产指定级别的瓦片。使用这个插件必须安装依赖<a href=\"https://github.com/mapnik/node-mapnik\" target=\"_blank\" rel=\"noopener\">node-mapnik</a>。</p>\n<a id=\"more\"></a>\n<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"0-发生了什么\"><a href=\"#0-发生了什么\" class=\"headerlink\" title=\"0. 发生了什么\"></a>0. 发生了什么</h1><p>比方说我们请求了<code>4/13/6</code>瓦片，即<code>x=13,y=6,z=4</code>，插件会分别找到<code>[[26,12,5],[27,12,5],[27,13,5],[26,13,5]]</code>四个瓦片，获取数据，然后把四张图片进行合并，而不是直接渲染出<code>4/13/6</code>对应的图像。我个人的理解中，在向外缩放的过程中，人眼可视区域内的地图范围越来越大，对于 server 来说要渲染的内容也就越来越多，这个时候就要既保证渲染的展现结果，又要保证渲染过程对服务器资源的占用，<code>underzoom</code>对于瓦片地图来说就是针对这一问题的探索。</p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-underzoom --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> dependency = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-dependency'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> underzoom = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-underzoom'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用mapnik定义一个世界范围地图</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'world_merc'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/world.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义underzoom图层</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'underzoom'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile@2x.png'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    underzoom(&#123;</span><br><span class=\"line\">      source: dependency(<span class=\"string\">'world_merc'</span>, <span class=\"string\">'tile.png'</span>),</span><br><span class=\"line\">      inputSize: <span class=\"number\">256</span>,</span><br><span class=\"line\">      outputSize: <span class=\"number\">512</span>,</span><br><span class=\"line\">      zooms: <span class=\"number\">1</span> <span class=\"comment\">// 1以下层级全部采用underzoom的方式拼接</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>不启用 underzoom 的效果：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-underzoom-original-20190708145711.png\" alt></p>\n<p>underzoom 放大两倍的效果：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-underzoom-result-20190708145813.png\" alt></p>\n<p>可以看到，整个地图看上去<strong>清晰了很多，边缘更加明显</strong>，这是因为低级别瓦片本身的精细程度就高，合并成大图后的对于细节的效果也会更好。<br>但是地图左边区域原先就基本上是只由线勾勒出的<strong>白色区域</strong>，在低瓦片中可以看到，合并成大图后就基本上看不清了，这是因为本身线宽是很细的，比如说是 1px 宽度，合并大图的过程中这个宽度并不会增加，但图片整个的像素变大了，所以细线就基本看不清了，这也是插件不好的地方。</p>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>说到合并图片，就能想到之前我们说过的<code>tilestrata-blend</code>插件，它是将两个不同数据源的结果图片进行了合并，而这个插件是将同一个数据源的四个低级别瓦片合并成了一个。</p>\n<p>根据 underzoom 的<code>inputSize、zooms</code>的配置项，先准备好一个<code>Mapnik.Image</code>对象：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canvas = <span class=\"keyword\">new</span> Mapnik.Image(canvasSize, canvasSize)</span><br></pre></td></tr></table></figure>\n<p>之后使用<code>@mapbox/tilebelt</code>库获取请求地址的下属四个低级别瓦片地址，分别请求数据，利用上面准备好的<code>Mapnik.Image</code>对象，使用<a href=\"http://mapnik.org/documentation/node-mapnik/3.6/#Image.composite\" target=\"_blank\" rel=\"noopener\">Image.composite</a>方法来合并四张图片，最后返回结果就好。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码有所精简</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">startFetchAndComposite</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 例如请求 4/13/6</span></span><br><span class=\"line\">  <span class=\"comment\">// 此时coordList就是 [[26,12,5],[27,12,5],[27,13,5],[26,13,5]]</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> coordList = getTileCoords(req.x, req.y, req.z, underzoomLevels)</span><br><span class=\"line\">  <span class=\"comment\">// 遍历coordList</span></span><br><span class=\"line\">  <span class=\"keyword\">async</span>.each(</span><br><span class=\"line\">    coordList,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">coords, callback</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// clone一个新的请求</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> childReq = req.clone()</span><br><span class=\"line\">      childReq.x = coords[<span class=\"number\">0</span>]</span><br><span class=\"line\">      childReq.y = coords[<span class=\"number\">1</span>]</span><br><span class=\"line\">      childReq.z = coords[<span class=\"number\">2</span>]</span><br><span class=\"line\">      options.source.serve(server, childReq, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        err,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        childBuffer,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        childHeaders</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      </span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取数据</span></span><br><span class=\"line\">        Mapnik.Image.fromBytes(childBuffer, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, image</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">// 执行合并操作</span></span><br><span class=\"line\">          canvas.composite(</span><br><span class=\"line\">            image,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              comp_op: Mapnik.compositeOp.src_over,</span><br><span class=\"line\">              dx: x,</span><br><span class=\"line\">              dy: y,</span><br><span class=\"line\">              opacity: <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            callback</span><br><span class=\"line\">          )</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    callback</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/naturalatlas/tilestrata-underzoom\" target=\"_blank\" rel=\"noopener\">tilestrata-underzoom</a>插件从介绍上看就是在请求高级别瓦片时，用低级别的瓦片进行拼接，而不是直接生产指定级别的瓦片。使用这个插件必须安装依赖<a href=\"https://github.com/mapnik/node-mapnik\" target=\"_blank\" rel=\"noopener\">node-mapnik</a>。</p>","more":"<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"0-发生了什么\"><a href=\"#0-发生了什么\" class=\"headerlink\" title=\"0. 发生了什么\"></a>0. 发生了什么</h1><p>比方说我们请求了<code>4/13/6</code>瓦片，即<code>x=13,y=6,z=4</code>，插件会分别找到<code>[[26,12,5],[27,12,5],[27,13,5],[26,13,5]]</code>四个瓦片，获取数据，然后把四张图片进行合并，而不是直接渲染出<code>4/13/6</code>对应的图像。我个人的理解中，在向外缩放的过程中，人眼可视区域内的地图范围越来越大，对于 server 来说要渲染的内容也就越来越多，这个时候就要既保证渲染的展现结果，又要保证渲染过程对服务器资源的占用，<code>underzoom</code>对于瓦片地图来说就是针对这一问题的探索。</p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-underzoom --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> dependency = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-dependency'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> underzoom = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-underzoom'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用mapnik定义一个世界范围地图</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'world_merc'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/world.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义underzoom图层</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'underzoom'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile@2x.png'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    underzoom(&#123;</span><br><span class=\"line\">      source: dependency(<span class=\"string\">'world_merc'</span>, <span class=\"string\">'tile.png'</span>),</span><br><span class=\"line\">      inputSize: <span class=\"number\">256</span>,</span><br><span class=\"line\">      outputSize: <span class=\"number\">512</span>,</span><br><span class=\"line\">      zooms: <span class=\"number\">1</span> <span class=\"comment\">// 1以下层级全部采用underzoom的方式拼接</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>不启用 underzoom 的效果：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-underzoom-original-20190708145711.png\" alt></p>\n<p>underzoom 放大两倍的效果：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-underzoom-result-20190708145813.png\" alt></p>\n<p>可以看到，整个地图看上去<strong>清晰了很多，边缘更加明显</strong>，这是因为低级别瓦片本身的精细程度就高，合并成大图后的对于细节的效果也会更好。<br>但是地图左边区域原先就基本上是只由线勾勒出的<strong>白色区域</strong>，在低瓦片中可以看到，合并成大图后就基本上看不清了，这是因为本身线宽是很细的，比如说是 1px 宽度，合并大图的过程中这个宽度并不会增加，但图片整个的像素变大了，所以细线就基本看不清了，这也是插件不好的地方。</p>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>说到合并图片，就能想到之前我们说过的<code>tilestrata-blend</code>插件，它是将两个不同数据源的结果图片进行了合并，而这个插件是将同一个数据源的四个低级别瓦片合并成了一个。</p>\n<p>根据 underzoom 的<code>inputSize、zooms</code>的配置项，先准备好一个<code>Mapnik.Image</code>对象：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canvas = <span class=\"keyword\">new</span> Mapnik.Image(canvasSize, canvasSize)</span><br></pre></td></tr></table></figure>\n<p>之后使用<code>@mapbox/tilebelt</code>库获取请求地址的下属四个低级别瓦片地址，分别请求数据，利用上面准备好的<code>Mapnik.Image</code>对象，使用<a href=\"http://mapnik.org/documentation/node-mapnik/3.6/#Image.composite\" target=\"_blank\" rel=\"noopener\">Image.composite</a>方法来合并四张图片，最后返回结果就好。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码有所精简</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">startFetchAndComposite</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 例如请求 4/13/6</span></span><br><span class=\"line\">  <span class=\"comment\">// 此时coordList就是 [[26,12,5],[27,12,5],[27,13,5],[26,13,5]]</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> coordList = getTileCoords(req.x, req.y, req.z, underzoomLevels)</span><br><span class=\"line\">  <span class=\"comment\">// 遍历coordList</span></span><br><span class=\"line\">  <span class=\"keyword\">async</span>.each(</span><br><span class=\"line\">    coordList,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">coords, callback</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// clone一个新的请求</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> childReq = req.clone()</span><br><span class=\"line\">      childReq.x = coords[<span class=\"number\">0</span>]</span><br><span class=\"line\">      childReq.y = coords[<span class=\"number\">1</span>]</span><br><span class=\"line\">      childReq.z = coords[<span class=\"number\">2</span>]</span><br><span class=\"line\">      options.source.serve(server, childReq, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        err,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        childBuffer,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        childHeaders</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      </span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取数据</span></span><br><span class=\"line\">        Mapnik.Image.fromBytes(childBuffer, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, image</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">// 执行合并操作</span></span><br><span class=\"line\">          canvas.composite(</span><br><span class=\"line\">            image,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              comp_op: Mapnik.compositeOp.src_over,</span><br><span class=\"line\">              dx: x,</span><br><span class=\"line\">              dy: y,</span><br><span class=\"line\">              opacity: <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            callback</span><br><span class=\"line\">          )</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    callback</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"tilestrata-postgis-geojson-tiles 插件使用及浅析","date":"2019-07-02T13:42:51.000Z","_content":"\n[tilestrata-postgis-geojson-tiles](https://github.com/naturalatlas/tilestrata-postgis-geojson-tiles)插件以 PostGIS 为数据源，生成 GeoJSON 格式的矢量瓦片。轻量但功能强大，配置项丰富，效果拔群。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-postgis-geojson-tiles --save\n```\n\n# 2. 使用\n\n插件的配置比较复杂：\n\n- `geometryField` _( string, 必选)_ : 数据表中存储地理数据的列名。 (默认 = `\"geom\"`)\n- `sql` _( function, 必选)_ : 一个返回 PostGIS 查询语句的函数。 _注意防治 sql 注入。_ 查询语句包含以下内容:\n  - `{bbox}` (box2d): 缓冲区的 bbox 范围\n  - `{geojson}` (text): 被裁剪出来的地理信息数据\n- `pgConfig` _( object, 必选)_ : postgres 数据库配置：\n  - `{host}` (string)\n  - `{password}` (string)\n  - `{user}` (string)\n  - `{port}` (string)\n  - `{database}` (string)\n- `simplifyFactor` _( number, 可选 )_ : 地理数据简化程度的参数。 (默认 = `0.75`)\n- `buffer` _( number, 可选)_ : 围绕每个切片的缓冲大小，以像素为单位 (默认 = `16`)\n- `collectGeometry` _( boolean, 可选 )_ : 在转换成 GeoJson 之前是用 ST_Collect 把多个图形合并成一个简单图形。 (默认 = `false`)\n- `mergeMultiLineStrings` _( boolean, 可选 )_ : 在转换成 GeoJson 之前是和否用 ST_LineMerge 合并 MultiLineStrings 数据。 (默认 = `false`)\n- `dumpGeometry` _( boolean, 可选 )_ : 是否用 ST_Dump 来拆分图形 (默认 = `false`)\n\n这里我使用了 demo 中的 world_merc.shp 数据导入了 PostGIS 中作为测试数据源\n\n```js\nconst tilestrata = require('tilestrata')\nconst tilestrataPostGISGeoJSON = require('tilestrata-postgis-geojson-tiles')\nconst headers = require('tilestrata-headers')\n\nconst server = tilestrata()\n\nserver\n  .layer('geojson-tiles')\n  .route('tile.json')\n  // 配置跨域\n  .use(\n    headers({\n      'Access-Control-Allow-Origin': '*'\n    })\n  )\n  // 定义数据源\n  .use(\n    tilestrataPostGISGeoJSON({\n      geometryField: 'geom',\n      sql: function(server, req) {\n        return 'select name, {geojson} from world_merc WHERE ST_Intersects(geom, {bbox})'\n      },\n      pgConfig: {\n        username: 'postgres',\n        password: 'postgres',\n        host: '10.211.55.4',\n        port: '5432',\n        database: 'shapefile'\n      }\n    })\n  )\n\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n`http://127.0.0.1:9527/world_merc/6/55/25/tile.png`对应的栅格瓦片的结果如下图所示\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/geojson-tile-png-20190701212419.png)\n\n`http://127.0.0.1:9527/geojson-tiles/6/55/25/tile.json`请求对应的地址获取 GeoJSON 格式的矢量数据：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/geojson-tile-json-20190701212838.png)\n\n在[geojson.io](http://geojson.io)查看效果如下图所示：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/geojson-tile-result-20190701212926.png)\n\nGeoJSON 结果和渲染出来的 png 的图形基本是一致。\n\n# 4. 代码浅析\n\n从插件功能可以看出来属于`Providers`类型的插件，那么核心就是 serve 方法。首先插件会根据我们传入的数据库信息来建立 Postgres 对象，这个不需要展开讲。\n\n当请求某个瓦片的时候，插件根据传入的 zxy 信息，调用了`@mapbox/sphericalmercator`库来把 zxy 坐标转换成 bbox 对象\n\n```js\nvar sm = new SphericalMercator({ size: 256 })\nvar bbox = sm.bbox(tile.x, tile.y, tile.z)\n\nvar w = bbox[2] - bbox[0]\nvar h = bbox[3] - bbox[1]\nvar bufferX = (buffer * w) / 256\nvar bufferY = (buffer * h) / 256\nbbox[0] -= bufferX\nbbox[1] -= bufferY\nbbox[2] += bufferX\nbbox[3] += bufferY\n```\n\n在定义图层的时候会传入一个`sql`函数，里面包含了`{bbox}`和`{geojson}`两个预设的字段，在源代码中这两个字段将会分别被计算出来，合成一个 sql 在数据库中进行查询\n\n```js\n// 代码为了便于理解有所精简改动\n\n// 利用上面计算的bbox来组装bboxsql\nvar bboxSQL =\n  \"ST_SetSRID('BOX(\" +\n  bbox[0] +\n  ' ' +\n  bbox[1] +\n  ',' +\n  bbox[2] +\n  ' ' +\n  bbox[3] +\n  \" )'::box2d, 4326)\"\n\n// 根据传入的geomField等字段组装geojsonSQL\nvar geojsonSQL =\n  'ST_MakeValid(ST_SimplifyPreserveTopology(' +\n  geomField +\n  ', ' +\n  simplifyTolerance +\n  ')) ST_Intersection(' +\n  geojsonSQL +\n  ', {bbox}) ST_AsGeoJSON(' +\n  geojsonSQL +\n  ') AS geojson'\n\nsql = sql.replace(/{geojson}/g, geojsonSQL).replace(/{bbox}/g, bboxSQL)\n\n// 查询\npgPool.query(sql, callback)\n```\n\n最后把查询出来的结果封装在`FeatureCollection`中形成一个完整的 GeoJSON 返回给 tilestrata 就可以了。\n\n```js\n// 组装GeoJSON\nvar outputText =\n  '{\"type\": \"FeatureCollection\", \"features\": [' +\n  result.rows\n    .map(function(row) {\n      if (row.geojson) {\n        var featureString = '{\"type\": \"Feature\", \"geometry\": ' + row.geojson\n        delete row.geojson\n        return featureString + ', \"properties\": ' + JSON.stringify(row) + '}'\n      }\n    })\n    .join(',') +\n  ']}'\n// 返回结果\ncallback(null, outputText, { 'Content-Type': 'application/json' })\n```\n","source":"_posts/2019/tilestrata-postgis-geojson-tiles.md","raw":"---\ntitle: tilestrata-postgis-geojson-tiles 插件使用及浅析\ndate: 2019-07-02 21:42:51\ntags: [GIS]\ncategories: TileStrata\n---\n\n[tilestrata-postgis-geojson-tiles](https://github.com/naturalatlas/tilestrata-postgis-geojson-tiles)插件以 PostGIS 为数据源，生成 GeoJSON 格式的矢量瓦片。轻量但功能强大，配置项丰富，效果拔群。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-postgis-geojson-tiles --save\n```\n\n# 2. 使用\n\n插件的配置比较复杂：\n\n- `geometryField` _( string, 必选)_ : 数据表中存储地理数据的列名。 (默认 = `\"geom\"`)\n- `sql` _( function, 必选)_ : 一个返回 PostGIS 查询语句的函数。 _注意防治 sql 注入。_ 查询语句包含以下内容:\n  - `{bbox}` (box2d): 缓冲区的 bbox 范围\n  - `{geojson}` (text): 被裁剪出来的地理信息数据\n- `pgConfig` _( object, 必选)_ : postgres 数据库配置：\n  - `{host}` (string)\n  - `{password}` (string)\n  - `{user}` (string)\n  - `{port}` (string)\n  - `{database}` (string)\n- `simplifyFactor` _( number, 可选 )_ : 地理数据简化程度的参数。 (默认 = `0.75`)\n- `buffer` _( number, 可选)_ : 围绕每个切片的缓冲大小，以像素为单位 (默认 = `16`)\n- `collectGeometry` _( boolean, 可选 )_ : 在转换成 GeoJson 之前是用 ST_Collect 把多个图形合并成一个简单图形。 (默认 = `false`)\n- `mergeMultiLineStrings` _( boolean, 可选 )_ : 在转换成 GeoJson 之前是和否用 ST_LineMerge 合并 MultiLineStrings 数据。 (默认 = `false`)\n- `dumpGeometry` _( boolean, 可选 )_ : 是否用 ST_Dump 来拆分图形 (默认 = `false`)\n\n这里我使用了 demo 中的 world_merc.shp 数据导入了 PostGIS 中作为测试数据源\n\n```js\nconst tilestrata = require('tilestrata')\nconst tilestrataPostGISGeoJSON = require('tilestrata-postgis-geojson-tiles')\nconst headers = require('tilestrata-headers')\n\nconst server = tilestrata()\n\nserver\n  .layer('geojson-tiles')\n  .route('tile.json')\n  // 配置跨域\n  .use(\n    headers({\n      'Access-Control-Allow-Origin': '*'\n    })\n  )\n  // 定义数据源\n  .use(\n    tilestrataPostGISGeoJSON({\n      geometryField: 'geom',\n      sql: function(server, req) {\n        return 'select name, {geojson} from world_merc WHERE ST_Intersects(geom, {bbox})'\n      },\n      pgConfig: {\n        username: 'postgres',\n        password: 'postgres',\n        host: '10.211.55.4',\n        port: '5432',\n        database: 'shapefile'\n      }\n    })\n  )\n\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n`http://127.0.0.1:9527/world_merc/6/55/25/tile.png`对应的栅格瓦片的结果如下图所示\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/geojson-tile-png-20190701212419.png)\n\n`http://127.0.0.1:9527/geojson-tiles/6/55/25/tile.json`请求对应的地址获取 GeoJSON 格式的矢量数据：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/geojson-tile-json-20190701212838.png)\n\n在[geojson.io](http://geojson.io)查看效果如下图所示：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/geojson-tile-result-20190701212926.png)\n\nGeoJSON 结果和渲染出来的 png 的图形基本是一致。\n\n# 4. 代码浅析\n\n从插件功能可以看出来属于`Providers`类型的插件，那么核心就是 serve 方法。首先插件会根据我们传入的数据库信息来建立 Postgres 对象，这个不需要展开讲。\n\n当请求某个瓦片的时候，插件根据传入的 zxy 信息，调用了`@mapbox/sphericalmercator`库来把 zxy 坐标转换成 bbox 对象\n\n```js\nvar sm = new SphericalMercator({ size: 256 })\nvar bbox = sm.bbox(tile.x, tile.y, tile.z)\n\nvar w = bbox[2] - bbox[0]\nvar h = bbox[3] - bbox[1]\nvar bufferX = (buffer * w) / 256\nvar bufferY = (buffer * h) / 256\nbbox[0] -= bufferX\nbbox[1] -= bufferY\nbbox[2] += bufferX\nbbox[3] += bufferY\n```\n\n在定义图层的时候会传入一个`sql`函数，里面包含了`{bbox}`和`{geojson}`两个预设的字段，在源代码中这两个字段将会分别被计算出来，合成一个 sql 在数据库中进行查询\n\n```js\n// 代码为了便于理解有所精简改动\n\n// 利用上面计算的bbox来组装bboxsql\nvar bboxSQL =\n  \"ST_SetSRID('BOX(\" +\n  bbox[0] +\n  ' ' +\n  bbox[1] +\n  ',' +\n  bbox[2] +\n  ' ' +\n  bbox[3] +\n  \" )'::box2d, 4326)\"\n\n// 根据传入的geomField等字段组装geojsonSQL\nvar geojsonSQL =\n  'ST_MakeValid(ST_SimplifyPreserveTopology(' +\n  geomField +\n  ', ' +\n  simplifyTolerance +\n  ')) ST_Intersection(' +\n  geojsonSQL +\n  ', {bbox}) ST_AsGeoJSON(' +\n  geojsonSQL +\n  ') AS geojson'\n\nsql = sql.replace(/{geojson}/g, geojsonSQL).replace(/{bbox}/g, bboxSQL)\n\n// 查询\npgPool.query(sql, callback)\n```\n\n最后把查询出来的结果封装在`FeatureCollection`中形成一个完整的 GeoJSON 返回给 tilestrata 就可以了。\n\n```js\n// 组装GeoJSON\nvar outputText =\n  '{\"type\": \"FeatureCollection\", \"features\": [' +\n  result.rows\n    .map(function(row) {\n      if (row.geojson) {\n        var featureString = '{\"type\": \"Feature\", \"geometry\": ' + row.geojson\n        delete row.geojson\n        return featureString + ', \"properties\": ' + JSON.stringify(row) + '}'\n      }\n    })\n    .join(',') +\n  ']}'\n// 返回结果\ncallback(null, outputText, { 'Content-Type': 'application/json' })\n```\n","slug":"tilestrata-postgis-geojson-tiles","published":1,"updated":"2019-07-02T13:45:51.353Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrkxgtb000ti83iebon2kkk","content":"<p><a href=\"https://github.com/naturalatlas/tilestrata-postgis-geojson-tiles\" target=\"_blank\" rel=\"noopener\">tilestrata-postgis-geojson-tiles</a>插件以 PostGIS 为数据源，生成 GeoJSON 格式的矢量瓦片。轻量但功能强大，配置项丰富，效果拔群。</p>\n<a id=\"more\"></a>\n<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-postgis-geojson-tiles --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><p>插件的配置比较复杂：</p>\n<ul>\n<li><code>geometryField</code> <em>( string, 必选)</em> : 数据表中存储地理数据的列名。 (默认 = <code>&quot;geom&quot;</code>)</li>\n<li><code>sql</code> <em>( function, 必选)</em> : 一个返回 PostGIS 查询语句的函数。 <em>注意防治 sql 注入。</em> 查询语句包含以下内容:<ul>\n<li><code>{bbox}</code> (box2d): 缓冲区的 bbox 范围</li>\n<li><code>{geojson}</code> (text): 被裁剪出来的地理信息数据</li>\n</ul>\n</li>\n<li><code>pgConfig</code> <em>( object, 必选)</em> : postgres 数据库配置：<ul>\n<li><code>{host}</code> (string)</li>\n<li><code>{password}</code> (string)</li>\n<li><code>{user}</code> (string)</li>\n<li><code>{port}</code> (string)</li>\n<li><code>{database}</code> (string)</li>\n</ul>\n</li>\n<li><code>simplifyFactor</code> <em>( number, 可选 )</em> : 地理数据简化程度的参数。 (默认 = <code>0.75</code>)</li>\n<li><code>buffer</code> <em>( number, 可选)</em> : 围绕每个切片的缓冲大小，以像素为单位 (默认 = <code>16</code>)</li>\n<li><code>collectGeometry</code> <em>( boolean, 可选 )</em> : 在转换成 GeoJson 之前是用 ST_Collect 把多个图形合并成一个简单图形。 (默认 = <code>false</code>)</li>\n<li><code>mergeMultiLineStrings</code> <em>( boolean, 可选 )</em> : 在转换成 GeoJson 之前是和否用 ST_LineMerge 合并 MultiLineStrings 数据。 (默认 = <code>false</code>)</li>\n<li><code>dumpGeometry</code> <em>( boolean, 可选 )</em> : 是否用 ST_Dump 来拆分图形 (默认 = <code>false</code>)</li>\n</ul>\n<p>这里我使用了 demo 中的 world_merc.shp 数据导入了 PostGIS 中作为测试数据源</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> tilestrataPostGISGeoJSON = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-postgis-geojson-tiles'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> headers = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-headers'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'geojson-tiles'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.json'</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 配置跨域</span></span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">'Access-Control-Allow-Origin'</span>: <span class=\"string\">'*'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  <span class=\"comment\">// 定义数据源</span></span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    tilestrataPostGISGeoJSON(&#123;</span><br><span class=\"line\">      geometryField: <span class=\"string\">'geom'</span>,</span><br><span class=\"line\">      sql: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'select name, &#123;geojson&#125; from world_merc WHERE ST_Intersects(geom, &#123;bbox&#125;)'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      pgConfig: &#123;</span><br><span class=\"line\">        username: <span class=\"string\">'postgres'</span>,</span><br><span class=\"line\">        password: <span class=\"string\">'postgres'</span>,</span><br><span class=\"line\">        host: <span class=\"string\">'10.211.55.4'</span>,</span><br><span class=\"line\">        port: <span class=\"string\">'5432'</span>,</span><br><span class=\"line\">        database: <span class=\"string\">'shapefile'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p><code>http://127.0.0.1:9527/world_merc/6/55/25/tile.png</code>对应的栅格瓦片的结果如下图所示</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/geojson-tile-png-20190701212419.png\" alt></p>\n<p><code>http://127.0.0.1:9527/geojson-tiles/6/55/25/tile.json</code>请求对应的地址获取 GeoJSON 格式的矢量数据：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/geojson-tile-json-20190701212838.png\" alt></p>\n<p>在<a href=\"http://geojson.io\" target=\"_blank\" rel=\"noopener\">geojson.io</a>查看效果如下图所示：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/geojson-tile-result-20190701212926.png\" alt></p>\n<p>GeoJSON 结果和渲染出来的 png 的图形基本是一致。</p>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>从插件功能可以看出来属于<code>Providers</code>类型的插件，那么核心就是 serve 方法。首先插件会根据我们传入的数据库信息来建立 Postgres 对象，这个不需要展开讲。</p>\n<p>当请求某个瓦片的时候，插件根据传入的 zxy 信息，调用了<code>@mapbox/sphericalmercator</code>库来把 zxy 坐标转换成 bbox 对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sm = <span class=\"keyword\">new</span> SphericalMercator(&#123; <span class=\"attr\">size</span>: <span class=\"number\">256</span> &#125;)</span><br><span class=\"line\"><span class=\"keyword\">var</span> bbox = sm.bbox(tile.x, tile.y, tile.z)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> w = bbox[<span class=\"number\">2</span>] - bbox[<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> h = bbox[<span class=\"number\">3</span>] - bbox[<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> bufferX = (buffer * w) / <span class=\"number\">256</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bufferY = (buffer * h) / <span class=\"number\">256</span></span><br><span class=\"line\">bbox[<span class=\"number\">0</span>] -= bufferX</span><br><span class=\"line\">bbox[<span class=\"number\">1</span>] -= bufferY</span><br><span class=\"line\">bbox[<span class=\"number\">2</span>] += bufferX</span><br><span class=\"line\">bbox[<span class=\"number\">3</span>] += bufferY</span><br></pre></td></tr></table></figure>\n<p>在定义图层的时候会传入一个<code>sql</code>函数，里面包含了<code>{bbox}</code>和<code>{geojson}</code>两个预设的字段，在源代码中这两个字段将会分别被计算出来，合成一个 sql 在数据库中进行查询</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码为了便于理解有所精简改动</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 利用上面计算的bbox来组装bboxsql</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bboxSQL =</span><br><span class=\"line\">  <span class=\"string\">\"ST_SetSRID('BOX(\"</span> +</span><br><span class=\"line\">  bbox[<span class=\"number\">0</span>] +</span><br><span class=\"line\">  <span class=\"string\">' '</span> +</span><br><span class=\"line\">  bbox[<span class=\"number\">1</span>] +</span><br><span class=\"line\">  <span class=\"string\">','</span> +</span><br><span class=\"line\">  bbox[<span class=\"number\">2</span>] +</span><br><span class=\"line\">  <span class=\"string\">' '</span> +</span><br><span class=\"line\">  bbox[<span class=\"number\">3</span>] +</span><br><span class=\"line\">  <span class=\"string\">\" )'::box2d, 4326)\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据传入的geomField等字段组装geojsonSQL</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> geojsonSQL =</span><br><span class=\"line\">  <span class=\"string\">'ST_MakeValid(ST_SimplifyPreserveTopology('</span> +</span><br><span class=\"line\">  geomField +</span><br><span class=\"line\">  <span class=\"string\">', '</span> +</span><br><span class=\"line\">  simplifyTolerance +</span><br><span class=\"line\">  <span class=\"string\">')) ST_Intersection('</span> +</span><br><span class=\"line\">  geojsonSQL +</span><br><span class=\"line\">  <span class=\"string\">', &#123;bbox&#125;) ST_AsGeoJSON('</span> +</span><br><span class=\"line\">  geojsonSQL +</span><br><span class=\"line\">  <span class=\"string\">') AS geojson'</span></span><br><span class=\"line\"></span><br><span class=\"line\">sql = sql.replace(<span class=\"regexp\">/&#123;geojson&#125;/g</span>, geojsonSQL).replace(<span class=\"regexp\">/&#123;bbox&#125;/g</span>, bboxSQL)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查询</span></span><br><span class=\"line\">pgPool.query(sql, callback)</span><br></pre></td></tr></table></figure>\n<p>最后把查询出来的结果封装在<code>FeatureCollection</code>中形成一个完整的 GeoJSON 返回给 tilestrata 就可以了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 组装GeoJSON</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> outputText =</span><br><span class=\"line\">  <span class=\"string\">'&#123;\"type\": \"FeatureCollection\", \"features\": ['</span> +</span><br><span class=\"line\">  result.rows</span><br><span class=\"line\">    .map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">row</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (row.geojson) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> featureString = <span class=\"string\">'&#123;\"type\": \"Feature\", \"geometry\": '</span> + row.geojson</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> row.geojson</span><br><span class=\"line\">        <span class=\"keyword\">return</span> featureString + <span class=\"string\">', \"properties\": '</span> + <span class=\"built_in\">JSON</span>.stringify(row) + <span class=\"string\">'&#125;'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .join(<span class=\"string\">','</span>) +</span><br><span class=\"line\">  <span class=\"string\">']&#125;'</span></span><br><span class=\"line\"><span class=\"comment\">// 返回结果</span></span><br><span class=\"line\">callback(<span class=\"literal\">null</span>, outputText, &#123; <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'application/json'</span> &#125;)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/naturalatlas/tilestrata-postgis-geojson-tiles\" target=\"_blank\" rel=\"noopener\">tilestrata-postgis-geojson-tiles</a>插件以 PostGIS 为数据源，生成 GeoJSON 格式的矢量瓦片。轻量但功能强大，配置项丰富，效果拔群。</p>","more":"<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-postgis-geojson-tiles --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><p>插件的配置比较复杂：</p>\n<ul>\n<li><code>geometryField</code> <em>( string, 必选)</em> : 数据表中存储地理数据的列名。 (默认 = <code>&quot;geom&quot;</code>)</li>\n<li><code>sql</code> <em>( function, 必选)</em> : 一个返回 PostGIS 查询语句的函数。 <em>注意防治 sql 注入。</em> 查询语句包含以下内容:<ul>\n<li><code>{bbox}</code> (box2d): 缓冲区的 bbox 范围</li>\n<li><code>{geojson}</code> (text): 被裁剪出来的地理信息数据</li>\n</ul>\n</li>\n<li><code>pgConfig</code> <em>( object, 必选)</em> : postgres 数据库配置：<ul>\n<li><code>{host}</code> (string)</li>\n<li><code>{password}</code> (string)</li>\n<li><code>{user}</code> (string)</li>\n<li><code>{port}</code> (string)</li>\n<li><code>{database}</code> (string)</li>\n</ul>\n</li>\n<li><code>simplifyFactor</code> <em>( number, 可选 )</em> : 地理数据简化程度的参数。 (默认 = <code>0.75</code>)</li>\n<li><code>buffer</code> <em>( number, 可选)</em> : 围绕每个切片的缓冲大小，以像素为单位 (默认 = <code>16</code>)</li>\n<li><code>collectGeometry</code> <em>( boolean, 可选 )</em> : 在转换成 GeoJson 之前是用 ST_Collect 把多个图形合并成一个简单图形。 (默认 = <code>false</code>)</li>\n<li><code>mergeMultiLineStrings</code> <em>( boolean, 可选 )</em> : 在转换成 GeoJson 之前是和否用 ST_LineMerge 合并 MultiLineStrings 数据。 (默认 = <code>false</code>)</li>\n<li><code>dumpGeometry</code> <em>( boolean, 可选 )</em> : 是否用 ST_Dump 来拆分图形 (默认 = <code>false</code>)</li>\n</ul>\n<p>这里我使用了 demo 中的 world_merc.shp 数据导入了 PostGIS 中作为测试数据源</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> tilestrataPostGISGeoJSON = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-postgis-geojson-tiles'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> headers = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-headers'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'geojson-tiles'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.json'</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 配置跨域</span></span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">'Access-Control-Allow-Origin'</span>: <span class=\"string\">'*'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  <span class=\"comment\">// 定义数据源</span></span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    tilestrataPostGISGeoJSON(&#123;</span><br><span class=\"line\">      geometryField: <span class=\"string\">'geom'</span>,</span><br><span class=\"line\">      sql: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'select name, &#123;geojson&#125; from world_merc WHERE ST_Intersects(geom, &#123;bbox&#125;)'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      pgConfig: &#123;</span><br><span class=\"line\">        username: <span class=\"string\">'postgres'</span>,</span><br><span class=\"line\">        password: <span class=\"string\">'postgres'</span>,</span><br><span class=\"line\">        host: <span class=\"string\">'10.211.55.4'</span>,</span><br><span class=\"line\">        port: <span class=\"string\">'5432'</span>,</span><br><span class=\"line\">        database: <span class=\"string\">'shapefile'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p><code>http://127.0.0.1:9527/world_merc/6/55/25/tile.png</code>对应的栅格瓦片的结果如下图所示</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/geojson-tile-png-20190701212419.png\" alt></p>\n<p><code>http://127.0.0.1:9527/geojson-tiles/6/55/25/tile.json</code>请求对应的地址获取 GeoJSON 格式的矢量数据：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/geojson-tile-json-20190701212838.png\" alt></p>\n<p>在<a href=\"http://geojson.io\" target=\"_blank\" rel=\"noopener\">geojson.io</a>查看效果如下图所示：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/geojson-tile-result-20190701212926.png\" alt></p>\n<p>GeoJSON 结果和渲染出来的 png 的图形基本是一致。</p>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>从插件功能可以看出来属于<code>Providers</code>类型的插件，那么核心就是 serve 方法。首先插件会根据我们传入的数据库信息来建立 Postgres 对象，这个不需要展开讲。</p>\n<p>当请求某个瓦片的时候，插件根据传入的 zxy 信息，调用了<code>@mapbox/sphericalmercator</code>库来把 zxy 坐标转换成 bbox 对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sm = <span class=\"keyword\">new</span> SphericalMercator(&#123; <span class=\"attr\">size</span>: <span class=\"number\">256</span> &#125;)</span><br><span class=\"line\"><span class=\"keyword\">var</span> bbox = sm.bbox(tile.x, tile.y, tile.z)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> w = bbox[<span class=\"number\">2</span>] - bbox[<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> h = bbox[<span class=\"number\">3</span>] - bbox[<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> bufferX = (buffer * w) / <span class=\"number\">256</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bufferY = (buffer * h) / <span class=\"number\">256</span></span><br><span class=\"line\">bbox[<span class=\"number\">0</span>] -= bufferX</span><br><span class=\"line\">bbox[<span class=\"number\">1</span>] -= bufferY</span><br><span class=\"line\">bbox[<span class=\"number\">2</span>] += bufferX</span><br><span class=\"line\">bbox[<span class=\"number\">3</span>] += bufferY</span><br></pre></td></tr></table></figure>\n<p>在定义图层的时候会传入一个<code>sql</code>函数，里面包含了<code>{bbox}</code>和<code>{geojson}</code>两个预设的字段，在源代码中这两个字段将会分别被计算出来，合成一个 sql 在数据库中进行查询</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码为了便于理解有所精简改动</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 利用上面计算的bbox来组装bboxsql</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bboxSQL =</span><br><span class=\"line\">  <span class=\"string\">\"ST_SetSRID('BOX(\"</span> +</span><br><span class=\"line\">  bbox[<span class=\"number\">0</span>] +</span><br><span class=\"line\">  <span class=\"string\">' '</span> +</span><br><span class=\"line\">  bbox[<span class=\"number\">1</span>] +</span><br><span class=\"line\">  <span class=\"string\">','</span> +</span><br><span class=\"line\">  bbox[<span class=\"number\">2</span>] +</span><br><span class=\"line\">  <span class=\"string\">' '</span> +</span><br><span class=\"line\">  bbox[<span class=\"number\">3</span>] +</span><br><span class=\"line\">  <span class=\"string\">\" )'::box2d, 4326)\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据传入的geomField等字段组装geojsonSQL</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> geojsonSQL =</span><br><span class=\"line\">  <span class=\"string\">'ST_MakeValid(ST_SimplifyPreserveTopology('</span> +</span><br><span class=\"line\">  geomField +</span><br><span class=\"line\">  <span class=\"string\">', '</span> +</span><br><span class=\"line\">  simplifyTolerance +</span><br><span class=\"line\">  <span class=\"string\">')) ST_Intersection('</span> +</span><br><span class=\"line\">  geojsonSQL +</span><br><span class=\"line\">  <span class=\"string\">', &#123;bbox&#125;) ST_AsGeoJSON('</span> +</span><br><span class=\"line\">  geojsonSQL +</span><br><span class=\"line\">  <span class=\"string\">') AS geojson'</span></span><br><span class=\"line\"></span><br><span class=\"line\">sql = sql.replace(<span class=\"regexp\">/&#123;geojson&#125;/g</span>, geojsonSQL).replace(<span class=\"regexp\">/&#123;bbox&#125;/g</span>, bboxSQL)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查询</span></span><br><span class=\"line\">pgPool.query(sql, callback)</span><br></pre></td></tr></table></figure>\n<p>最后把查询出来的结果封装在<code>FeatureCollection</code>中形成一个完整的 GeoJSON 返回给 tilestrata 就可以了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 组装GeoJSON</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> outputText =</span><br><span class=\"line\">  <span class=\"string\">'&#123;\"type\": \"FeatureCollection\", \"features\": ['</span> +</span><br><span class=\"line\">  result.rows</span><br><span class=\"line\">    .map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">row</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (row.geojson) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> featureString = <span class=\"string\">'&#123;\"type\": \"Feature\", \"geometry\": '</span> + row.geojson</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> row.geojson</span><br><span class=\"line\">        <span class=\"keyword\">return</span> featureString + <span class=\"string\">', \"properties\": '</span> + <span class=\"built_in\">JSON</span>.stringify(row) + <span class=\"string\">'&#125;'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .join(<span class=\"string\">','</span>) +</span><br><span class=\"line\">  <span class=\"string\">']&#125;'</span></span><br><span class=\"line\"><span class=\"comment\">// 返回结果</span></span><br><span class=\"line\">callback(<span class=\"literal\">null</span>, outputText, &#123; <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'application/json'</span> &#125;)</span><br></pre></td></tr></table></figure>"},{"title":"tilestrata-vtile-raster 插件使用及浅析","date":"2019-07-05T06:05:38.000Z","_content":"\n[tilestrata-vtile-raster](https://github.com/naturalatlas/tilestrata-vtile-raster)是配合`tilestrata-vtile`插件用来将 mapnik 的`pbf`格式的矢量瓦片转换成栅格图片。使用这个插件必须安装依赖[node-mapnik](https://github.com/mapnik/node-mapnik)。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-vtile-raster --save\n```\n\n# 2. 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst vtile = require('tilestrata-vtile')\nconst vtileraster = require('tilestrata-vtile-raster')\nconst headers = require('tilestrata-headers')\n\nconst server = tilestrata()\n\n// 定义省界边界数据源\nconst common = {\n  xml: 'style/province.xml',\n  tileSize: 256,\n  metatile: 1,\n  bufferSize: 128\n}\n\nserver\n  .layer('osm_pbf_raster')\n  .route('tile.pbf') // 定义vtile pbf图层做对比\n  .use(\n    headers({\n      'Access-Control-Allow-Origin': '*'\n    })\n  )\n  .use(vtile(common))\n  .route('tile.png') // 定义vtile-raster png图层做对比\n  .use(\n    vtileraster(common, {\n      tilesource: ['osm_pbf_raster', 'tile.pbf']\n    })\n  )\n  .route('tile.json')\n  .use(\n    vtileraster(common, {\n      tilesource: ['osm_pbf_raster', 'tile.pbf']\n    })\n  )\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n可以直接使用常规的栅格瓦片加载方式来加载`tile.png`图层，无须使用矢量瓦片的加载方式。可以和[tilestrata-vtile 插件浅析](https://kael.top/2019/07/04/tilestrata-vtile/)对比观看。\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/v-tile-raster-result-20190704172822.png)\n\n# 4. 代码浅析\n\n核心仍然是 mapnik 的功能，过程上大体是和 tilestrata-vtile 插件类似的，不同的地方在当请求图层的时候，不再单纯的使用[VectorTile](http://mapnik.org/documentation/node-mapnik/3.6/#VectorTile)的`getData`方法，首先代码会依据是否可交互属性`interactivity`来构造一个类型是`mapnik.Image`的`surface`参数\n\n```js\nif (self.interactivity) {\n  surface = new mapnik.Grid(dim, dim)\n  // ... 省略\n} else {\n  surface = new mapnik.Image(dim, dim)\n}\n```\n\n然后使用[VectorTile.render](http://mapnik.org/documentation/node-mapnik/3.6/#VectorTile.render)这个方法，通过 xml 构建出来的 map 和上面的 surface 参数，就可以将矢量数据转化为栅格图片：\n\n```js\nvectorTile.render(self.map, surface, options, callback)\n```\n","source":"_posts/2019/tilestrata-vtile-raster.md","raw":"---\ntitle: tilestrata-vtile-raster 插件使用及浅析\ndate: 2019-07-05 14:05:38\ntags: [GIS]\ncategories: TileStrata\n---\n\n[tilestrata-vtile-raster](https://github.com/naturalatlas/tilestrata-vtile-raster)是配合`tilestrata-vtile`插件用来将 mapnik 的`pbf`格式的矢量瓦片转换成栅格图片。使用这个插件必须安装依赖[node-mapnik](https://github.com/mapnik/node-mapnik)。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-vtile-raster --save\n```\n\n# 2. 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst vtile = require('tilestrata-vtile')\nconst vtileraster = require('tilestrata-vtile-raster')\nconst headers = require('tilestrata-headers')\n\nconst server = tilestrata()\n\n// 定义省界边界数据源\nconst common = {\n  xml: 'style/province.xml',\n  tileSize: 256,\n  metatile: 1,\n  bufferSize: 128\n}\n\nserver\n  .layer('osm_pbf_raster')\n  .route('tile.pbf') // 定义vtile pbf图层做对比\n  .use(\n    headers({\n      'Access-Control-Allow-Origin': '*'\n    })\n  )\n  .use(vtile(common))\n  .route('tile.png') // 定义vtile-raster png图层做对比\n  .use(\n    vtileraster(common, {\n      tilesource: ['osm_pbf_raster', 'tile.pbf']\n    })\n  )\n  .route('tile.json')\n  .use(\n    vtileraster(common, {\n      tilesource: ['osm_pbf_raster', 'tile.pbf']\n    })\n  )\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n可以直接使用常规的栅格瓦片加载方式来加载`tile.png`图层，无须使用矢量瓦片的加载方式。可以和[tilestrata-vtile 插件浅析](https://kael.top/2019/07/04/tilestrata-vtile/)对比观看。\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/v-tile-raster-result-20190704172822.png)\n\n# 4. 代码浅析\n\n核心仍然是 mapnik 的功能，过程上大体是和 tilestrata-vtile 插件类似的，不同的地方在当请求图层的时候，不再单纯的使用[VectorTile](http://mapnik.org/documentation/node-mapnik/3.6/#VectorTile)的`getData`方法，首先代码会依据是否可交互属性`interactivity`来构造一个类型是`mapnik.Image`的`surface`参数\n\n```js\nif (self.interactivity) {\n  surface = new mapnik.Grid(dim, dim)\n  // ... 省略\n} else {\n  surface = new mapnik.Image(dim, dim)\n}\n```\n\n然后使用[VectorTile.render](http://mapnik.org/documentation/node-mapnik/3.6/#VectorTile.render)这个方法，通过 xml 构建出来的 map 和上面的 surface 参数，就可以将矢量数据转化为栅格图片：\n\n```js\nvectorTile.render(self.map, surface, options, callback)\n```\n","slug":"tilestrata-vtile-raster","published":1,"updated":"2019-07-05T06:08:56.914Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrkxgtc000ui83ikh4x33x3","content":"<p><a href=\"https://github.com/naturalatlas/tilestrata-vtile-raster\" target=\"_blank\" rel=\"noopener\">tilestrata-vtile-raster</a>是配合<code>tilestrata-vtile</code>插件用来将 mapnik 的<code>pbf</code>格式的矢量瓦片转换成栅格图片。使用这个插件必须安装依赖<a href=\"https://github.com/mapnik/node-mapnik\" target=\"_blank\" rel=\"noopener\">node-mapnik</a>。</p>\n<a id=\"more\"></a>\n<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-vtile-raster --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> vtile = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-vtile'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> vtileraster = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-vtile-raster'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> headers = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-headers'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义省界边界数据源</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> common = &#123;</span><br><span class=\"line\">  xml: <span class=\"string\">'style/province.xml'</span>,</span><br><span class=\"line\">  tileSize: <span class=\"number\">256</span>,</span><br><span class=\"line\">  metatile: <span class=\"number\">1</span>,</span><br><span class=\"line\">  bufferSize: <span class=\"number\">128</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'osm_pbf_raster'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.pbf'</span>) <span class=\"comment\">// 定义vtile pbf图层做对比</span></span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">'Access-Control-Allow-Origin'</span>: <span class=\"string\">'*'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(vtile(common))</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>) <span class=\"comment\">// 定义vtile-raster png图层做对比</span></span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    vtileraster(common, &#123;</span><br><span class=\"line\">      tilesource: [<span class=\"string\">'osm_pbf_raster'</span>, <span class=\"string\">'tile.pbf'</span>]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.json'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    vtileraster(common, &#123;</span><br><span class=\"line\">      tilesource: [<span class=\"string\">'osm_pbf_raster'</span>, <span class=\"string\">'tile.pbf'</span>]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>可以直接使用常规的栅格瓦片加载方式来加载<code>tile.png</code>图层，无须使用矢量瓦片的加载方式。可以和<a href=\"https://kael.top/2019/07/04/tilestrata-vtile/\">tilestrata-vtile 插件浅析</a>对比观看。</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/v-tile-raster-result-20190704172822.png\" alt></p>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>核心仍然是 mapnik 的功能，过程上大体是和 tilestrata-vtile 插件类似的，不同的地方在当请求图层的时候，不再单纯的使用<a href=\"http://mapnik.org/documentation/node-mapnik/3.6/#VectorTile\" target=\"_blank\" rel=\"noopener\">VectorTile</a>的<code>getData</code>方法，首先代码会依据是否可交互属性<code>interactivity</code>来构造一个类型是<code>mapnik.Image</code>的<code>surface</code>参数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (self.interactivity) &#123;</span><br><span class=\"line\">  surface = <span class=\"keyword\">new</span> mapnik.Grid(dim, dim)</span><br><span class=\"line\">  <span class=\"comment\">// ... 省略</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  surface = <span class=\"keyword\">new</span> mapnik.Image(dim, dim)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后使用<a href=\"http://mapnik.org/documentation/node-mapnik/3.6/#VectorTile.render\" target=\"_blank\" rel=\"noopener\">VectorTile.render</a>这个方法，通过 xml 构建出来的 map 和上面的 surface 参数，就可以将矢量数据转化为栅格图片：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">vectorTile.render(self.map, surface, options, callback)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/naturalatlas/tilestrata-vtile-raster\" target=\"_blank\" rel=\"noopener\">tilestrata-vtile-raster</a>是配合<code>tilestrata-vtile</code>插件用来将 mapnik 的<code>pbf</code>格式的矢量瓦片转换成栅格图片。使用这个插件必须安装依赖<a href=\"https://github.com/mapnik/node-mapnik\" target=\"_blank\" rel=\"noopener\">node-mapnik</a>。</p>","more":"<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-vtile-raster --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> vtile = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-vtile'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> vtileraster = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-vtile-raster'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> headers = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-headers'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义省界边界数据源</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> common = &#123;</span><br><span class=\"line\">  xml: <span class=\"string\">'style/province.xml'</span>,</span><br><span class=\"line\">  tileSize: <span class=\"number\">256</span>,</span><br><span class=\"line\">  metatile: <span class=\"number\">1</span>,</span><br><span class=\"line\">  bufferSize: <span class=\"number\">128</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'osm_pbf_raster'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.pbf'</span>) <span class=\"comment\">// 定义vtile pbf图层做对比</span></span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">'Access-Control-Allow-Origin'</span>: <span class=\"string\">'*'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(vtile(common))</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>) <span class=\"comment\">// 定义vtile-raster png图层做对比</span></span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    vtileraster(common, &#123;</span><br><span class=\"line\">      tilesource: [<span class=\"string\">'osm_pbf_raster'</span>, <span class=\"string\">'tile.pbf'</span>]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.json'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    vtileraster(common, &#123;</span><br><span class=\"line\">      tilesource: [<span class=\"string\">'osm_pbf_raster'</span>, <span class=\"string\">'tile.pbf'</span>]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>可以直接使用常规的栅格瓦片加载方式来加载<code>tile.png</code>图层，无须使用矢量瓦片的加载方式。可以和<a href=\"https://kael.top/2019/07/04/tilestrata-vtile/\">tilestrata-vtile 插件浅析</a>对比观看。</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/v-tile-raster-result-20190704172822.png\" alt></p>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>核心仍然是 mapnik 的功能，过程上大体是和 tilestrata-vtile 插件类似的，不同的地方在当请求图层的时候，不再单纯的使用<a href=\"http://mapnik.org/documentation/node-mapnik/3.6/#VectorTile\" target=\"_blank\" rel=\"noopener\">VectorTile</a>的<code>getData</code>方法，首先代码会依据是否可交互属性<code>interactivity</code>来构造一个类型是<code>mapnik.Image</code>的<code>surface</code>参数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (self.interactivity) &#123;</span><br><span class=\"line\">  surface = <span class=\"keyword\">new</span> mapnik.Grid(dim, dim)</span><br><span class=\"line\">  <span class=\"comment\">// ... 省略</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  surface = <span class=\"keyword\">new</span> mapnik.Image(dim, dim)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后使用<a href=\"http://mapnik.org/documentation/node-mapnik/3.6/#VectorTile.render\" target=\"_blank\" rel=\"noopener\">VectorTile.render</a>这个方法，通过 xml 构建出来的 map 和上面的 surface 参数，就可以将矢量数据转化为栅格图片：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">vectorTile.render(self.map, surface, options, callback)</span><br></pre></td></tr></table></figure>"},{"title":"tilestrata-vtile 插件使用及浅析","date":"2019-07-04T09:39:41.000Z","_content":"\n[tilestrata-vtile](https://github.com/naturalatlas/tilestrata-vtile)插件可以通过 mapnik 数据源生成`pbf`格式的矢量瓦片。如果需要对瓦片做放大倍数，交互这些操作，矢量瓦片不需要再额外的请求数据，使用起来非常方便。后续还可以通过配套的[tilestrata-vtile-raster](https://github.com/naturalatlas/tilestrata-vtile-raster)插件来将矢量数据渲染成普通的图片瓦片。使用这个插件必须安装依赖[node-mapnik](https://github.com/mapnik/node-mapnik)。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-vtile --save\n```\n\n# 2. 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst vtile = require('tilestrata-vtile')\nconst headers = require('tilestrata-headers')\n\nconst server = tilestrata()\n\n// 定义省界边界数据源\nconst common = {\n  xml: 'style/province.xml',\n  tileSize: 256,\n  metatile: 1,\n  bufferSize: 128\n}\n\n// 开启跨域，定义图层\nserver\n  .layer('province_pbf')\n  .route('tile.pbf')\n  .use(\n    headers({\n      'Access-Control-Allow-Origin': '*'\n    })\n  )\n  .use(vtile(common))\n\n// 启动服务\nserver.listen(9527)\n```\n\n插件还提供了`overrideRenderOptions`配置项，用来做层级的精确控制，控制瓦片的返回内容\n\n```js\nserver\n  .layer('mylayer')\n  .route('t.pbf')\n  .use(\n    vtile({\n      xml: '/path/to/map.xml',\n      tileSize: 256,\n      metatile: 1,\n      bufferSize: 128,\n      overrideRenderOptions: function(opts, z, maxz) {\n        opts.simplify_distance = z < maxz ? 8 : 1\n        return opts\n      }\n    })\n  )\n```\n\n回调函数的第一个参数`opts`包含了以下内容，可以在[第四节](#4-代码浅析)的代码分析中看到这些值是怎么来的：\n\n```js\n{\n  simplify_distance,\n  path_multiplier, \n  buffer_size, \n  scale_denominator\n}\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/v-tile-result-20190704171541.png)\n\n# 4. 代码浅析\n\n原理上很简单，从代码上就能看出来，传入了 mapnik 需要的`xml`配置文件，所以其实是利用了 mapnik 的[VectorTile](http://mapnik.org/documentation/node-mapnik/3.6/#VectorTile)功能，代码如下：\n\n```js\n// 新建VectorTile源，options也和传入的otps息息相关\nmap.render(new mapnik.VectorTile(z, x, y), options, function(err, image) {\n  self.pool.release(map)\n  if (err) return callback(err)\n\n  if (image.empty()) {\n    err = new Error('No data')\n    err.statusCode = 204\n    return callback(err)\n  }\n\n  // 通过getdata方法获取数据并返回给tilestrata\n  var buffer = image.getData(self.dataopts)\n  buffer.metatile = self.metatile\n  buffer._vtile = image\n  buffer._vx = x\n  buffer._vy = y\n  buffer._vz = z\n\n  callback(null, buffer)\n})\n```\n\n第二节使用中提到的`opts`的参数实际上是 mapnik 中[Map.render](http://mapnik.org/documentation/node-mapnik/3.6/#Map.render)方法的几个可选参数，他们会在 tilestrata-vtile 中被合并使用：\n\n```js\nvar options = self.overrideRenderOptions(\n  {\n    simplify_distance: real_z < self.maxzoom ? 8 : 1,\n    path_multiplier: 16 * self.metatile,\n    buffer_size: self.bufferSize,\n    scale_denominator: 559082264.028 / (1 << real_z)\n  },\n  real_z,\n  self.maxzoom\n)\n```\n","source":"_posts/2019/tilestrata-vtile.md","raw":"---\ntitle: tilestrata-vtile 插件使用及浅析\ndate: 2019-07-04 17:39:41\ntags: [GIS]\ncategories: TileStrata\n---\n\n[tilestrata-vtile](https://github.com/naturalatlas/tilestrata-vtile)插件可以通过 mapnik 数据源生成`pbf`格式的矢量瓦片。如果需要对瓦片做放大倍数，交互这些操作，矢量瓦片不需要再额外的请求数据，使用起来非常方便。后续还可以通过配套的[tilestrata-vtile-raster](https://github.com/naturalatlas/tilestrata-vtile-raster)插件来将矢量数据渲染成普通的图片瓦片。使用这个插件必须安装依赖[node-mapnik](https://github.com/mapnik/node-mapnik)。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-vtile --save\n```\n\n# 2. 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst vtile = require('tilestrata-vtile')\nconst headers = require('tilestrata-headers')\n\nconst server = tilestrata()\n\n// 定义省界边界数据源\nconst common = {\n  xml: 'style/province.xml',\n  tileSize: 256,\n  metatile: 1,\n  bufferSize: 128\n}\n\n// 开启跨域，定义图层\nserver\n  .layer('province_pbf')\n  .route('tile.pbf')\n  .use(\n    headers({\n      'Access-Control-Allow-Origin': '*'\n    })\n  )\n  .use(vtile(common))\n\n// 启动服务\nserver.listen(9527)\n```\n\n插件还提供了`overrideRenderOptions`配置项，用来做层级的精确控制，控制瓦片的返回内容\n\n```js\nserver\n  .layer('mylayer')\n  .route('t.pbf')\n  .use(\n    vtile({\n      xml: '/path/to/map.xml',\n      tileSize: 256,\n      metatile: 1,\n      bufferSize: 128,\n      overrideRenderOptions: function(opts, z, maxz) {\n        opts.simplify_distance = z < maxz ? 8 : 1\n        return opts\n      }\n    })\n  )\n```\n\n回调函数的第一个参数`opts`包含了以下内容，可以在[第四节](#4-代码浅析)的代码分析中看到这些值是怎么来的：\n\n```js\n{\n  simplify_distance,\n  path_multiplier, \n  buffer_size, \n  scale_denominator\n}\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/v-tile-result-20190704171541.png)\n\n# 4. 代码浅析\n\n原理上很简单，从代码上就能看出来，传入了 mapnik 需要的`xml`配置文件，所以其实是利用了 mapnik 的[VectorTile](http://mapnik.org/documentation/node-mapnik/3.6/#VectorTile)功能，代码如下：\n\n```js\n// 新建VectorTile源，options也和传入的otps息息相关\nmap.render(new mapnik.VectorTile(z, x, y), options, function(err, image) {\n  self.pool.release(map)\n  if (err) return callback(err)\n\n  if (image.empty()) {\n    err = new Error('No data')\n    err.statusCode = 204\n    return callback(err)\n  }\n\n  // 通过getdata方法获取数据并返回给tilestrata\n  var buffer = image.getData(self.dataopts)\n  buffer.metatile = self.metatile\n  buffer._vtile = image\n  buffer._vx = x\n  buffer._vy = y\n  buffer._vz = z\n\n  callback(null, buffer)\n})\n```\n\n第二节使用中提到的`opts`的参数实际上是 mapnik 中[Map.render](http://mapnik.org/documentation/node-mapnik/3.6/#Map.render)方法的几个可选参数，他们会在 tilestrata-vtile 中被合并使用：\n\n```js\nvar options = self.overrideRenderOptions(\n  {\n    simplify_distance: real_z < self.maxzoom ? 8 : 1,\n    path_multiplier: 16 * self.metatile,\n    buffer_size: self.bufferSize,\n    scale_denominator: 559082264.028 / (1 << real_z)\n  },\n  real_z,\n  self.maxzoom\n)\n```\n","slug":"tilestrata-vtile","published":1,"updated":"2019-07-04T09:42:27.139Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrkxgtc000vi83in12q15pf","content":"<p><a href=\"https://github.com/naturalatlas/tilestrata-vtile\" target=\"_blank\" rel=\"noopener\">tilestrata-vtile</a>插件可以通过 mapnik 数据源生成<code>pbf</code>格式的矢量瓦片。如果需要对瓦片做放大倍数，交互这些操作，矢量瓦片不需要再额外的请求数据，使用起来非常方便。后续还可以通过配套的<a href=\"https://github.com/naturalatlas/tilestrata-vtile-raster\" target=\"_blank\" rel=\"noopener\">tilestrata-vtile-raster</a>插件来将矢量数据渲染成普通的图片瓦片。使用这个插件必须安装依赖<a href=\"https://github.com/mapnik/node-mapnik\" target=\"_blank\" rel=\"noopener\">node-mapnik</a>。</p>\n<a id=\"more\"></a>\n<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-vtile --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> vtile = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-vtile'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> headers = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-headers'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义省界边界数据源</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> common = &#123;</span><br><span class=\"line\">  xml: <span class=\"string\">'style/province.xml'</span>,</span><br><span class=\"line\">  tileSize: <span class=\"number\">256</span>,</span><br><span class=\"line\">  metatile: <span class=\"number\">1</span>,</span><br><span class=\"line\">  bufferSize: <span class=\"number\">128</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开启跨域，定义图层</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'province_pbf'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.pbf'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">'Access-Control-Allow-Origin'</span>: <span class=\"string\">'*'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(vtile(common))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<p>插件还提供了<code>overrideRenderOptions</code>配置项，用来做层级的精确控制，控制瓦片的返回内容</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'mylayer'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'t.pbf'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    vtile(&#123;</span><br><span class=\"line\">      xml: <span class=\"string\">'/path/to/map.xml'</span>,</span><br><span class=\"line\">      tileSize: <span class=\"number\">256</span>,</span><br><span class=\"line\">      metatile: <span class=\"number\">1</span>,</span><br><span class=\"line\">      bufferSize: <span class=\"number\">128</span>,</span><br><span class=\"line\">      overrideRenderOptions: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">opts, z, maxz</span>) </span>&#123;</span><br><span class=\"line\">        opts.simplify_distance = z &lt; maxz ? <span class=\"number\">8</span> : <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> opts</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br></pre></td></tr></table></figure>\n<p>回调函数的第一个参数<code>opts</code>包含了以下内容，可以在<a href=\"#4-代码浅析\">第四节</a>的代码分析中看到这些值是怎么来的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  simplify_distance,</span><br><span class=\"line\">  path_multiplier, </span><br><span class=\"line\">  buffer_size, </span><br><span class=\"line\">  scale_denominator</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/v-tile-result-20190704171541.png\" alt></p>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>原理上很简单，从代码上就能看出来，传入了 mapnik 需要的<code>xml</code>配置文件，所以其实是利用了 mapnik 的<a href=\"http://mapnik.org/documentation/node-mapnik/3.6/#VectorTile\" target=\"_blank\" rel=\"noopener\">VectorTile</a>功能，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 新建VectorTile源，options也和传入的otps息息相关</span></span><br><span class=\"line\">map.render(<span class=\"keyword\">new</span> mapnik.VectorTile(z, x, y), options, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, image</span>) </span>&#123;</span><br><span class=\"line\">  self.pool.release(map)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> callback(err)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (image.empty()) &#123;</span><br><span class=\"line\">    err = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'No data'</span>)</span><br><span class=\"line\">    err.statusCode = <span class=\"number\">204</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> callback(err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 通过getdata方法获取数据并返回给tilestrata</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> buffer = image.getData(self.dataopts)</span><br><span class=\"line\">  buffer.metatile = self.metatile</span><br><span class=\"line\">  buffer._vtile = image</span><br><span class=\"line\">  buffer._vx = x</span><br><span class=\"line\">  buffer._vy = y</span><br><span class=\"line\">  buffer._vz = z</span><br><span class=\"line\"></span><br><span class=\"line\">  callback(<span class=\"literal\">null</span>, buffer)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>第二节使用中提到的<code>opts</code>的参数实际上是 mapnik 中<a href=\"http://mapnik.org/documentation/node-mapnik/3.6/#Map.render\" target=\"_blank\" rel=\"noopener\">Map.render</a>方法的几个可选参数，他们会在 tilestrata-vtile 中被合并使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> options = self.overrideRenderOptions(</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    simplify_distance: real_z &lt; self.maxzoom ? <span class=\"number\">8</span> : <span class=\"number\">1</span>,</span><br><span class=\"line\">    path_multiplier: <span class=\"number\">16</span> * self.metatile,</span><br><span class=\"line\">    buffer_size: self.bufferSize,</span><br><span class=\"line\">    scale_denominator: <span class=\"number\">559082264.028</span> / (<span class=\"number\">1</span> &lt;&lt; real_z)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  real_z,</span><br><span class=\"line\">  self.maxzoom</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/naturalatlas/tilestrata-vtile\" target=\"_blank\" rel=\"noopener\">tilestrata-vtile</a>插件可以通过 mapnik 数据源生成<code>pbf</code>格式的矢量瓦片。如果需要对瓦片做放大倍数，交互这些操作，矢量瓦片不需要再额外的请求数据，使用起来非常方便。后续还可以通过配套的<a href=\"https://github.com/naturalatlas/tilestrata-vtile-raster\" target=\"_blank\" rel=\"noopener\">tilestrata-vtile-raster</a>插件来将矢量数据渲染成普通的图片瓦片。使用这个插件必须安装依赖<a href=\"https://github.com/mapnik/node-mapnik\" target=\"_blank\" rel=\"noopener\">node-mapnik</a>。</p>","more":"<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-vtile --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> vtile = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-vtile'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> headers = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-headers'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义省界边界数据源</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> common = &#123;</span><br><span class=\"line\">  xml: <span class=\"string\">'style/province.xml'</span>,</span><br><span class=\"line\">  tileSize: <span class=\"number\">256</span>,</span><br><span class=\"line\">  metatile: <span class=\"number\">1</span>,</span><br><span class=\"line\">  bufferSize: <span class=\"number\">128</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开启跨域，定义图层</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'province_pbf'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.pbf'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">'Access-Control-Allow-Origin'</span>: <span class=\"string\">'*'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(vtile(common))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<p>插件还提供了<code>overrideRenderOptions</code>配置项，用来做层级的精确控制，控制瓦片的返回内容</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'mylayer'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'t.pbf'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    vtile(&#123;</span><br><span class=\"line\">      xml: <span class=\"string\">'/path/to/map.xml'</span>,</span><br><span class=\"line\">      tileSize: <span class=\"number\">256</span>,</span><br><span class=\"line\">      metatile: <span class=\"number\">1</span>,</span><br><span class=\"line\">      bufferSize: <span class=\"number\">128</span>,</span><br><span class=\"line\">      overrideRenderOptions: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">opts, z, maxz</span>) </span>&#123;</span><br><span class=\"line\">        opts.simplify_distance = z &lt; maxz ? <span class=\"number\">8</span> : <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> opts</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br></pre></td></tr></table></figure>\n<p>回调函数的第一个参数<code>opts</code>包含了以下内容，可以在<a href=\"#4-代码浅析\">第四节</a>的代码分析中看到这些值是怎么来的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  simplify_distance,</span><br><span class=\"line\">  path_multiplier, </span><br><span class=\"line\">  buffer_size, </span><br><span class=\"line\">  scale_denominator</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/v-tile-result-20190704171541.png\" alt></p>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>原理上很简单，从代码上就能看出来，传入了 mapnik 需要的<code>xml</code>配置文件，所以其实是利用了 mapnik 的<a href=\"http://mapnik.org/documentation/node-mapnik/3.6/#VectorTile\" target=\"_blank\" rel=\"noopener\">VectorTile</a>功能，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 新建VectorTile源，options也和传入的otps息息相关</span></span><br><span class=\"line\">map.render(<span class=\"keyword\">new</span> mapnik.VectorTile(z, x, y), options, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, image</span>) </span>&#123;</span><br><span class=\"line\">  self.pool.release(map)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> callback(err)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (image.empty()) &#123;</span><br><span class=\"line\">    err = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'No data'</span>)</span><br><span class=\"line\">    err.statusCode = <span class=\"number\">204</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> callback(err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 通过getdata方法获取数据并返回给tilestrata</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> buffer = image.getData(self.dataopts)</span><br><span class=\"line\">  buffer.metatile = self.metatile</span><br><span class=\"line\">  buffer._vtile = image</span><br><span class=\"line\">  buffer._vx = x</span><br><span class=\"line\">  buffer._vy = y</span><br><span class=\"line\">  buffer._vz = z</span><br><span class=\"line\"></span><br><span class=\"line\">  callback(<span class=\"literal\">null</span>, buffer)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>第二节使用中提到的<code>opts</code>的参数实际上是 mapnik 中<a href=\"http://mapnik.org/documentation/node-mapnik/3.6/#Map.render\" target=\"_blank\" rel=\"noopener\">Map.render</a>方法的几个可选参数，他们会在 tilestrata-vtile 中被合并使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> options = self.overrideRenderOptions(</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    simplify_distance: real_z &lt; self.maxzoom ? <span class=\"number\">8</span> : <span class=\"number\">1</span>,</span><br><span class=\"line\">    path_multiplier: <span class=\"number\">16</span> * self.metatile,</span><br><span class=\"line\">    buffer_size: self.bufferSize,</span><br><span class=\"line\">    scale_denominator: <span class=\"number\">559082264.028</span> / (<span class=\"number\">1</span> &lt;&lt; real_z)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  real_z,</span><br><span class=\"line\">  self.maxzoom</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>"},{"title":"tilestrata-vtile-composite 插件使用及浅析","date":"2019-07-07T08:56:34.000Z","_content":"\n[tilestrata-vtile-composite](https://github.com/naturalatlas/tilestrata-vtile-composite)插件用来合并多个矢量瓦片图层，这些矢量瓦片图层来自于[tilestrata-vtile](https://github.com/naturalatlas/tilestrata-vtile)插件。使用这个插件必须安装依赖[node-mapnik](https://github.com/mapnik/node-mapnik)。\n这个插件的作用和[tilestrata-blend](https://github.com/naturalatlas/tilestrata-blend)类似，只是适用对象是 vtile 生产出来的矢量瓦片。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-vtile-composite --save\n```\n\n# 2. 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst vtile = require('tilestrata-vtile')\nconst vtilecomposite = require('tilestrata-vtile-composite')\nconst headers = require('tilestrata-headers')\n\nconst server = tilestrata()\n\n// 省界边界源\nconst provinceXml = {\n  xml: 'style/province.xml',\n  tileSize: 256,\n  metatile: 1,\n  bufferSize: 128\n}\n\n// 世界边界源\nconst worldXml = {\n  xml: 'style/world.xml',\n  tileSize: 256,\n  metatile: 1,\n  bufferSize: 128\n}\n\n// 定义第一个数据源\nserver\n  .layer('province_pbf')\n  .route('t.pbf')\n  .use(vtile(provinceXml))\n\n// 定义第一个数据源\nserver\n  .layer('world_pbf')\n  .route('t.pbf')\n  .use(vtile(worldXml))\n\n// 合并两个数据源，开启跨域访问\nserver\n  .layer('combined_pbf')\n  .route('combined.pbf')\n  .use(\n    headers({\n      'Access-Control-Allow-Origin': '*'\n    })\n  )\n  .use(vtilecomposite([['world_pbf', 't.pbf'], ['province_pbf', 't.pbf']]))\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n这是单独的中国区域 pbf：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/v-tile-composite-pro-20190704173456.png)\n\n这是单独的世界区域 pbf：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/v-tile-composite-world-20190704173556.png)\n\n合并之后的图层：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/v-tile-composite-20190704173718.png)\n\n# 4. 代码浅析\n\n其实原理也就解释了为什么官方说明中一定要在依赖中加入`node-mapnik`。核心代码如下：\n\n```js\nfunction compositeTiles(callback) {\n  if (vtiles.length === 0) return callback()\n\n  var merged = new mapnik.VectorTile(req.z, req.x, req.y)\n  // 我是关键\n  merged.composite(vtiles, function(err) {\n    vtiles = null\n    if (err) return callback(err)\n\n    result = merged.getData(dataopts)\n    result._vtile = merged\n    result._vx = req.x\n    result._vy = req.y\n    result._vz = req.z\n    callback()\n  })\n}\n```\n\n在连续请求完两个数据源的数据之后，新建 mapnik 的`VectorTile`对象，并调用其[VectorTile.composite](http://mapnik.org/documentation/node-mapnik/3.6/#VectorTile.composite)方法，对两个数据源请求来的数据进行合并，最后再`getData`输出结果就好。\n","source":"_posts/2019/tilestrata-vtile-composite.md","raw":"---\ntitle: tilestrata-vtile-composite 插件使用及浅析\ndate: 2019-07-07 16:56:34\ntags: [GIS]\ncategories: TileStrata\n---\n\n[tilestrata-vtile-composite](https://github.com/naturalatlas/tilestrata-vtile-composite)插件用来合并多个矢量瓦片图层，这些矢量瓦片图层来自于[tilestrata-vtile](https://github.com/naturalatlas/tilestrata-vtile)插件。使用这个插件必须安装依赖[node-mapnik](https://github.com/mapnik/node-mapnik)。\n这个插件的作用和[tilestrata-blend](https://github.com/naturalatlas/tilestrata-blend)类似，只是适用对象是 vtile 生产出来的矢量瓦片。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-vtile-composite --save\n```\n\n# 2. 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst vtile = require('tilestrata-vtile')\nconst vtilecomposite = require('tilestrata-vtile-composite')\nconst headers = require('tilestrata-headers')\n\nconst server = tilestrata()\n\n// 省界边界源\nconst provinceXml = {\n  xml: 'style/province.xml',\n  tileSize: 256,\n  metatile: 1,\n  bufferSize: 128\n}\n\n// 世界边界源\nconst worldXml = {\n  xml: 'style/world.xml',\n  tileSize: 256,\n  metatile: 1,\n  bufferSize: 128\n}\n\n// 定义第一个数据源\nserver\n  .layer('province_pbf')\n  .route('t.pbf')\n  .use(vtile(provinceXml))\n\n// 定义第一个数据源\nserver\n  .layer('world_pbf')\n  .route('t.pbf')\n  .use(vtile(worldXml))\n\n// 合并两个数据源，开启跨域访问\nserver\n  .layer('combined_pbf')\n  .route('combined.pbf')\n  .use(\n    headers({\n      'Access-Control-Allow-Origin': '*'\n    })\n  )\n  .use(vtilecomposite([['world_pbf', 't.pbf'], ['province_pbf', 't.pbf']]))\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n这是单独的中国区域 pbf：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/v-tile-composite-pro-20190704173456.png)\n\n这是单独的世界区域 pbf：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/v-tile-composite-world-20190704173556.png)\n\n合并之后的图层：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/v-tile-composite-20190704173718.png)\n\n# 4. 代码浅析\n\n其实原理也就解释了为什么官方说明中一定要在依赖中加入`node-mapnik`。核心代码如下：\n\n```js\nfunction compositeTiles(callback) {\n  if (vtiles.length === 0) return callback()\n\n  var merged = new mapnik.VectorTile(req.z, req.x, req.y)\n  // 我是关键\n  merged.composite(vtiles, function(err) {\n    vtiles = null\n    if (err) return callback(err)\n\n    result = merged.getData(dataopts)\n    result._vtile = merged\n    result._vx = req.x\n    result._vy = req.y\n    result._vz = req.z\n    callback()\n  })\n}\n```\n\n在连续请求完两个数据源的数据之后，新建 mapnik 的`VectorTile`对象，并调用其[VectorTile.composite](http://mapnik.org/documentation/node-mapnik/3.6/#VectorTile.composite)方法，对两个数据源请求来的数据进行合并，最后再`getData`输出结果就好。\n","slug":"tilestrata-vtile-composite","published":1,"updated":"2019-07-07T08:58:20.921Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrkxgtc000wi83iyqhwnpfk","content":"<p><a href=\"https://github.com/naturalatlas/tilestrata-vtile-composite\" target=\"_blank\" rel=\"noopener\">tilestrata-vtile-composite</a>插件用来合并多个矢量瓦片图层，这些矢量瓦片图层来自于<a href=\"https://github.com/naturalatlas/tilestrata-vtile\" target=\"_blank\" rel=\"noopener\">tilestrata-vtile</a>插件。使用这个插件必须安装依赖<a href=\"https://github.com/mapnik/node-mapnik\" target=\"_blank\" rel=\"noopener\">node-mapnik</a>。<br>这个插件的作用和<a href=\"https://github.com/naturalatlas/tilestrata-blend\" target=\"_blank\" rel=\"noopener\">tilestrata-blend</a>类似，只是适用对象是 vtile 生产出来的矢量瓦片。</p>\n<a id=\"more\"></a>\n<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-vtile-composite --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> vtile = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-vtile'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> vtilecomposite = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-vtile-composite'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> headers = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-headers'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 省界边界源</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> provinceXml = &#123;</span><br><span class=\"line\">  xml: <span class=\"string\">'style/province.xml'</span>,</span><br><span class=\"line\">  tileSize: <span class=\"number\">256</span>,</span><br><span class=\"line\">  metatile: <span class=\"number\">1</span>,</span><br><span class=\"line\">  bufferSize: <span class=\"number\">128</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 世界边界源</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> worldXml = &#123;</span><br><span class=\"line\">  xml: <span class=\"string\">'style/world.xml'</span>,</span><br><span class=\"line\">  tileSize: <span class=\"number\">256</span>,</span><br><span class=\"line\">  metatile: <span class=\"number\">1</span>,</span><br><span class=\"line\">  bufferSize: <span class=\"number\">128</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义第一个数据源</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'province_pbf'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'t.pbf'</span>)</span><br><span class=\"line\">  .use(vtile(provinceXml))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义第一个数据源</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'world_pbf'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'t.pbf'</span>)</span><br><span class=\"line\">  .use(vtile(worldXml))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 合并两个数据源，开启跨域访问</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'combined_pbf'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'combined.pbf'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">'Access-Control-Allow-Origin'</span>: <span class=\"string\">'*'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(vtilecomposite([[<span class=\"string\">'world_pbf'</span>, <span class=\"string\">'t.pbf'</span>], [<span class=\"string\">'province_pbf'</span>, <span class=\"string\">'t.pbf'</span>]]))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>这是单独的中国区域 pbf：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/v-tile-composite-pro-20190704173456.png\" alt></p>\n<p>这是单独的世界区域 pbf：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/v-tile-composite-world-20190704173556.png\" alt></p>\n<p>合并之后的图层：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/v-tile-composite-20190704173718.png\" alt></p>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>其实原理也就解释了为什么官方说明中一定要在依赖中加入<code>node-mapnik</code>。核心代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compositeTiles</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (vtiles.length === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> callback()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> merged = <span class=\"keyword\">new</span> mapnik.VectorTile(req.z, req.x, req.y)</span><br><span class=\"line\">  <span class=\"comment\">// 我是关键</span></span><br><span class=\"line\">  merged.composite(vtiles, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    vtiles = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> callback(err)</span><br><span class=\"line\"></span><br><span class=\"line\">    result = merged.getData(dataopts)</span><br><span class=\"line\">    result._vtile = merged</span><br><span class=\"line\">    result._vx = req.x</span><br><span class=\"line\">    result._vy = req.y</span><br><span class=\"line\">    result._vz = req.z</span><br><span class=\"line\">    callback()</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在连续请求完两个数据源的数据之后，新建 mapnik 的<code>VectorTile</code>对象，并调用其<a href=\"http://mapnik.org/documentation/node-mapnik/3.6/#VectorTile.composite\" target=\"_blank\" rel=\"noopener\">VectorTile.composite</a>方法，对两个数据源请求来的数据进行合并，最后再<code>getData</code>输出结果就好。</p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/naturalatlas/tilestrata-vtile-composite\" target=\"_blank\" rel=\"noopener\">tilestrata-vtile-composite</a>插件用来合并多个矢量瓦片图层，这些矢量瓦片图层来自于<a href=\"https://github.com/naturalatlas/tilestrata-vtile\" target=\"_blank\" rel=\"noopener\">tilestrata-vtile</a>插件。使用这个插件必须安装依赖<a href=\"https://github.com/mapnik/node-mapnik\" target=\"_blank\" rel=\"noopener\">node-mapnik</a>。<br>这个插件的作用和<a href=\"https://github.com/naturalatlas/tilestrata-blend\" target=\"_blank\" rel=\"noopener\">tilestrata-blend</a>类似，只是适用对象是 vtile 生产出来的矢量瓦片。</p>","more":"<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-vtile-composite --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> vtile = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-vtile'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> vtilecomposite = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-vtile-composite'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> headers = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-headers'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 省界边界源</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> provinceXml = &#123;</span><br><span class=\"line\">  xml: <span class=\"string\">'style/province.xml'</span>,</span><br><span class=\"line\">  tileSize: <span class=\"number\">256</span>,</span><br><span class=\"line\">  metatile: <span class=\"number\">1</span>,</span><br><span class=\"line\">  bufferSize: <span class=\"number\">128</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 世界边界源</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> worldXml = &#123;</span><br><span class=\"line\">  xml: <span class=\"string\">'style/world.xml'</span>,</span><br><span class=\"line\">  tileSize: <span class=\"number\">256</span>,</span><br><span class=\"line\">  metatile: <span class=\"number\">1</span>,</span><br><span class=\"line\">  bufferSize: <span class=\"number\">128</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义第一个数据源</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'province_pbf'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'t.pbf'</span>)</span><br><span class=\"line\">  .use(vtile(provinceXml))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义第一个数据源</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'world_pbf'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'t.pbf'</span>)</span><br><span class=\"line\">  .use(vtile(worldXml))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 合并两个数据源，开启跨域访问</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'combined_pbf'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'combined.pbf'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">'Access-Control-Allow-Origin'</span>: <span class=\"string\">'*'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(vtilecomposite([[<span class=\"string\">'world_pbf'</span>, <span class=\"string\">'t.pbf'</span>], [<span class=\"string\">'province_pbf'</span>, <span class=\"string\">'t.pbf'</span>]]))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>这是单独的中国区域 pbf：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/v-tile-composite-pro-20190704173456.png\" alt></p>\n<p>这是单独的世界区域 pbf：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/v-tile-composite-world-20190704173556.png\" alt></p>\n<p>合并之后的图层：</p>\n<p><img src=\"http://blog-img-1255388623.cossh.myqcloud.com/v-tile-composite-20190704173718.png\" alt></p>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>其实原理也就解释了为什么官方说明中一定要在依赖中加入<code>node-mapnik</code>。核心代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compositeTiles</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (vtiles.length === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> callback()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> merged = <span class=\"keyword\">new</span> mapnik.VectorTile(req.z, req.x, req.y)</span><br><span class=\"line\">  <span class=\"comment\">// 我是关键</span></span><br><span class=\"line\">  merged.composite(vtiles, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    vtiles = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> callback(err)</span><br><span class=\"line\"></span><br><span class=\"line\">    result = merged.getData(dataopts)</span><br><span class=\"line\">    result._vtile = merged</span><br><span class=\"line\">    result._vx = req.x</span><br><span class=\"line\">    result._vy = req.y</span><br><span class=\"line\">    result._vz = req.z</span><br><span class=\"line\">    callback()</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在连续请求完两个数据源的数据之后，新建 mapnik 的<code>VectorTile</code>对象，并调用其<a href=\"http://mapnik.org/documentation/node-mapnik/3.6/#VectorTile.composite\" target=\"_blank\" rel=\"noopener\">VectorTile.composite</a>方法，对两个数据源请求来的数据进行合并，最后再<code>getData</code>输出结果就好。</p>"}],"PostAsset":[{"_id":"source/_posts/2019/osm-PostGIS-setup/distance.png","slug":"distance.png","post":"ckbrkxgt3000di83insx78rfv","modified":1,"renderable":0},{"_id":"source/_posts/2017/plugins/tileWMS.png","post":"ckbrkxgsw0007i83ie4ytvl72","slug":"tileWMS.png","modified":1,"renderable":1},{"_id":"source/_posts/2017/vector-tile-openlayers-try/network.png","post":"ckbrkxgsx0008i83idpjx5e8h","slug":"network.png","modified":1,"renderable":1},{"_id":"source/_posts/2018/Vue-Parent-and-Child-lifecycle-hooks/lifecircle.png","post":"ckbrkxgsp0002i83i043lelhl","slug":"lifecircle.png","modified":1,"renderable":1},{"_id":"source/_posts/2018/Vue-Parent-and-Child-lifecycle-hooks/parent-child-hooks.png","post":"ckbrkxgsp0002i83i043lelhl","slug":"parent-child-hooks.png","modified":1,"renderable":1},{"_id":"source/_posts/2017/openlayers-canvas-typhoon/canvasLayer.png","slug":"canvasLayer.png","post":"ckbrkxgsu0004i83inomsfozp","modified":1,"renderable":0},{"_id":"source/_posts/2017/openlayers-canvas-typhoon/canvasSymbol.png","post":"ckbrkxgsu0004i83inomsfozp","slug":"canvasSymbol.png","modified":1,"renderable":1},{"_id":"source/_posts/2017/openlayers-canvas-typhoon/goal.png","post":"ckbrkxgsu0004i83inomsfozp","slug":"goal.png","modified":1,"renderable":1},{"_id":"source/_posts/2019/osm-PostGIS-setup/point.png","slug":"point.png","post":"ckbrkxgt3000di83insx78rfv","modified":1,"renderable":0},{"_id":"source/_posts/2019/osm-PostGIS-setup/polygon.png","slug":"polygon.png","post":"ckbrkxgt3000di83insx78rfv","modified":1,"renderable":0}],"PostCategory":[{"post_id":"ckbrkxgsp0002i83i043lelhl","category_id":"ckbrkxgub000xi83il2q9nw3t","_id":"ckbrkxgvi002zi83ir51jaia4"},{"post_id":"ckbrkxgst0003i83iki074605","category_id":"ckbrkxguj000zi83ipu8stqwg","_id":"ckbrkxgvi0031i83it0sy7984"},{"post_id":"ckbrkxgsu0004i83inomsfozp","category_id":"ckbrkxguj000zi83ipu8stqwg","_id":"ckbrkxgvi0033i83ivrbxhquy"},{"post_id":"ckbrkxgsv0005i83i7hxm9leo","category_id":"ckbrkxguj000zi83ipu8stqwg","_id":"ckbrkxgvi0035i83ieiuzlpth"},{"post_id":"ckbrkxgsv0006i83iju1d8m79","category_id":"ckbrkxgub000xi83il2q9nw3t","_id":"ckbrkxgvi0037i83i0fqgifqh"},{"post_id":"ckbrkxgsw0007i83ie4ytvl72","category_id":"ckbrkxguj000zi83ipu8stqwg","_id":"ckbrkxgvj0039i83ik715nt2j"},{"post_id":"ckbrkxgsx0008i83idpjx5e8h","category_id":"ckbrkxguj000zi83ipu8stqwg","_id":"ckbrkxgvj003bi83iuzrcv5kg"},{"post_id":"ckbrkxgsy0009i83iyzu3p2dj","category_id":"ckbrkxguj000zi83ipu8stqwg","_id":"ckbrkxgvj003di83i2n7b15r0"},{"post_id":"ckbrkxgsz000ai83iilxncjoa","category_id":"ckbrkxgup001di83iw0l6q6al","_id":"ckbrkxgvj003fi83ih0ul6biy"},{"post_id":"ckbrkxgt1000bi83ibrzw8t04","category_id":"ckbrkxgup001fi83iush7rrb0","_id":"ckbrkxgvj003hi83i7ekaio10"},{"post_id":"ckbrkxgt2000ci83ig9f5qp1y","category_id":"ckbrkxguj000zi83ipu8stqwg","_id":"ckbrkxgvj003ji83ixwz52r7y"},{"post_id":"ckbrkxgt3000di83insx78rfv","category_id":"ckbrkxgup001di83iw0l6q6al","_id":"ckbrkxgvj003li83ibhsqhjyf"},{"post_id":"ckbrkxgt3000ei83inkjuhzr1","category_id":"ckbrkxgus001li83ig1vhqxv2","_id":"ckbrkxgvj003ni83iqdne7vu3"},{"post_id":"ckbrkxgt4000fi83i7qsgu23r","category_id":"ckbrkxgus001li83ig1vhqxv2","_id":"ckbrkxgvk003pi83iyeebje4h"},{"post_id":"ckbrkxgt4000gi83ikh73mun4","category_id":"ckbrkxgus001li83ig1vhqxv2","_id":"ckbrkxgvk003ri83i3dlhspdl"},{"post_id":"ckbrkxgt5000hi83i4owzzs9k","category_id":"ckbrkxgup001di83iw0l6q6al","_id":"ckbrkxgvk003ti83if0t566bm"},{"post_id":"ckbrkxgt6000ii83ilj8svgp8","category_id":"ckbrkxgus001li83ig1vhqxv2","_id":"ckbrkxgvk003vi83i4w1jt7zd"},{"post_id":"ckbrkxgt6000ji83ixj7f8io4","category_id":"ckbrkxgus001li83ig1vhqxv2","_id":"ckbrkxgvk003xi83ija2q2g1g"},{"post_id":"ckbrkxgt7000ki83icsb13631","category_id":"ckbrkxgus001li83ig1vhqxv2","_id":"ckbrkxgvk003zi83ilz97n71p"},{"post_id":"ckbrkxgt7000li83ihtgezhmr","category_id":"ckbrkxgus001li83ig1vhqxv2","_id":"ckbrkxgvk0041i83ic9z0y2ce"},{"post_id":"ckbrkxgt8000mi83ihlaclpmb","category_id":"ckbrkxgus001li83ig1vhqxv2","_id":"ckbrkxgvk0043i83i234nafh6"},{"post_id":"ckbrkxgt8000ni83i6rntyx3t","category_id":"ckbrkxgus001li83ig1vhqxv2","_id":"ckbrkxgvk0045i83i8wvllyrm"},{"post_id":"ckbrkxgt9000oi83idjw7821k","category_id":"ckbrkxgus001li83ig1vhqxv2","_id":"ckbrkxgvl0047i83ii6zso29m"},{"post_id":"ckbrkxgt9000pi83i8n2hbqr0","category_id":"ckbrkxgus001li83ig1vhqxv2","_id":"ckbrkxgvl0049i83i48psu0o9"},{"post_id":"ckbrkxgta000qi83inaowv78g","category_id":"ckbrkxgus001li83ig1vhqxv2","_id":"ckbrkxgvl004bi83i39cgnlfq"},{"post_id":"ckbrkxgta000ri83ifhmezpoj","category_id":"ckbrkxgus001li83ig1vhqxv2","_id":"ckbrkxgvl004di83izbpw48ki"},{"post_id":"ckbrkxgtb000si83i893if5jx","category_id":"ckbrkxgus001li83ig1vhqxv2","_id":"ckbrkxgvl004fi83iaax9bxqv"},{"post_id":"ckbrkxgtb000ti83iebon2kkk","category_id":"ckbrkxgus001li83ig1vhqxv2","_id":"ckbrkxgvl004hi83i34agu3pi"},{"post_id":"ckbrkxgtc000ui83ikh4x33x3","category_id":"ckbrkxgus001li83ig1vhqxv2","_id":"ckbrkxgvl004ji83izcupz2g0"},{"post_id":"ckbrkxgtc000vi83in12q15pf","category_id":"ckbrkxgus001li83ig1vhqxv2","_id":"ckbrkxgvm004li83i1qyd4fro"},{"post_id":"ckbrkxgtc000wi83iyqhwnpfk","category_id":"ckbrkxgus001li83ig1vhqxv2","_id":"ckbrkxgvm004ni83i1i7eymdc"}],"PostTag":[{"post_id":"ckbrkxgsp0002i83i043lelhl","tag_id":"ckbrkxguh000yi83i6d9hw0hl","_id":"ckbrkxgvi002yi83i45eeu5o9"},{"post_id":"ckbrkxgsp0002i83i043lelhl","tag_id":"ckbrkxguj0010i83injmkby2x","_id":"ckbrkxgvi0030i83ipdapfesr"},{"post_id":"ckbrkxgst0003i83iki074605","tag_id":"ckbrkxguh000yi83i6d9hw0hl","_id":"ckbrkxgvi0032i83ijqqf9plh"},{"post_id":"ckbrkxgst0003i83iki074605","tag_id":"ckbrkxgum0014i83ig2cbq2zh","_id":"ckbrkxgvi0034i83ibc1sc0l0"},{"post_id":"ckbrkxgst0003i83iki074605","tag_id":"ckbrkxgun0016i83ixnmyplm7","_id":"ckbrkxgvi0036i83ibuivfzcp"},{"post_id":"ckbrkxgsu0004i83inomsfozp","tag_id":"ckbrkxguh000yi83i6d9hw0hl","_id":"ckbrkxgvj0038i83ibour95ug"},{"post_id":"ckbrkxgsu0004i83inomsfozp","tag_id":"ckbrkxgum0014i83ig2cbq2zh","_id":"ckbrkxgvj003ai83idla9835l"},{"post_id":"ckbrkxgsu0004i83inomsfozp","tag_id":"ckbrkxgup001ci83i1iy5mm5m","_id":"ckbrkxgvj003ci83i07gh48ln"},{"post_id":"ckbrkxgsv0005i83i7hxm9leo","tag_id":"ckbrkxgum0014i83ig2cbq2zh","_id":"ckbrkxgvj003ei83iiyo9hzvq"},{"post_id":"ckbrkxgsv0006i83iju1d8m79","tag_id":"ckbrkxguh000yi83i6d9hw0hl","_id":"ckbrkxgvj003gi83ihfv7xmuj"},{"post_id":"ckbrkxgsv0006i83iju1d8m79","tag_id":"ckbrkxguj0010i83injmkby2x","_id":"ckbrkxgvj003ii83ilw2uynlm"},{"post_id":"ckbrkxgsw0007i83ie4ytvl72","tag_id":"ckbrkxguh000yi83i6d9hw0hl","_id":"ckbrkxgvj003ki83ilun3tdw4"},{"post_id":"ckbrkxgsw0007i83ie4ytvl72","tag_id":"ckbrkxgum0014i83ig2cbq2zh","_id":"ckbrkxgvj003mi83i6aljg8t2"},{"post_id":"ckbrkxgsw0007i83ie4ytvl72","tag_id":"ckbrkxgun0016i83ixnmyplm7","_id":"ckbrkxgvk003oi83ixjy7me3p"},{"post_id":"ckbrkxgsx0008i83idpjx5e8h","tag_id":"ckbrkxgum0014i83ig2cbq2zh","_id":"ckbrkxgvk003qi83i90sdkrdm"},{"post_id":"ckbrkxgsx0008i83idpjx5e8h","tag_id":"ckbrkxgup001ci83i1iy5mm5m","_id":"ckbrkxgvk003si83iyq5nkgp9"},{"post_id":"ckbrkxgsy0009i83iyzu3p2dj","tag_id":"ckbrkxgum0014i83ig2cbq2zh","_id":"ckbrkxgvk003ui83i27227z72"},{"post_id":"ckbrkxgsy0009i83iyzu3p2dj","tag_id":"ckbrkxgun0016i83ixnmyplm7","_id":"ckbrkxgvk003wi83irv4424u4"},{"post_id":"ckbrkxgsz000ai83iilxncjoa","tag_id":"ckbrkxgum0014i83ig2cbq2zh","_id":"ckbrkxgvk003yi83iij6g0kbk"},{"post_id":"ckbrkxgt1000bi83ibrzw8t04","tag_id":"ckbrkxgum0014i83ig2cbq2zh","_id":"ckbrkxgvk0040i83ic0582v5s"},{"post_id":"ckbrkxgt2000ci83ig9f5qp1y","tag_id":"ckbrkxgum0014i83ig2cbq2zh","_id":"ckbrkxgvk0042i83io0jtnyp3"},{"post_id":"ckbrkxgt2000ci83ig9f5qp1y","tag_id":"ckbrkxgun0016i83ixnmyplm7","_id":"ckbrkxgvk0044i83ipgtbj7it"},{"post_id":"ckbrkxgt3000di83insx78rfv","tag_id":"ckbrkxgum0014i83ig2cbq2zh","_id":"ckbrkxgvl0046i83iia8mz2oc"},{"post_id":"ckbrkxgt3000ei83inkjuhzr1","tag_id":"ckbrkxgum0014i83ig2cbq2zh","_id":"ckbrkxgvl0048i83iein79c77"},{"post_id":"ckbrkxgt4000fi83i7qsgu23r","tag_id":"ckbrkxgum0014i83ig2cbq2zh","_id":"ckbrkxgvl004ai83ioqnlqq9q"},{"post_id":"ckbrkxgt4000gi83ikh73mun4","tag_id":"ckbrkxgum0014i83ig2cbq2zh","_id":"ckbrkxgvl004ci83igk4fceu6"},{"post_id":"ckbrkxgt5000hi83i4owzzs9k","tag_id":"ckbrkxgum0014i83ig2cbq2zh","_id":"ckbrkxgvl004ei83ivsmtm0fd"},{"post_id":"ckbrkxgt6000ii83ilj8svgp8","tag_id":"ckbrkxgum0014i83ig2cbq2zh","_id":"ckbrkxgvl004gi83ixx1cjhhz"},{"post_id":"ckbrkxgt6000ji83ixj7f8io4","tag_id":"ckbrkxgum0014i83ig2cbq2zh","_id":"ckbrkxgvl004ii83i43fe4hj9"},{"post_id":"ckbrkxgt7000ki83icsb13631","tag_id":"ckbrkxgum0014i83ig2cbq2zh","_id":"ckbrkxgvm004ki83iwjb6php5"},{"post_id":"ckbrkxgt7000li83ihtgezhmr","tag_id":"ckbrkxgum0014i83ig2cbq2zh","_id":"ckbrkxgvm004mi83iow2uy033"},{"post_id":"ckbrkxgt8000mi83ihlaclpmb","tag_id":"ckbrkxgum0014i83ig2cbq2zh","_id":"ckbrkxgvm004oi83igog2to64"},{"post_id":"ckbrkxgt8000ni83i6rntyx3t","tag_id":"ckbrkxgum0014i83ig2cbq2zh","_id":"ckbrkxgvm004pi83i2kqsn6kb"},{"post_id":"ckbrkxgt9000oi83idjw7821k","tag_id":"ckbrkxgum0014i83ig2cbq2zh","_id":"ckbrkxgvm004qi83ikyhr4918"},{"post_id":"ckbrkxgt9000pi83i8n2hbqr0","tag_id":"ckbrkxgum0014i83ig2cbq2zh","_id":"ckbrkxgvm004ri83iksh1m4q2"},{"post_id":"ckbrkxgta000qi83inaowv78g","tag_id":"ckbrkxgum0014i83ig2cbq2zh","_id":"ckbrkxgvm004si83iqy6e369p"},{"post_id":"ckbrkxgta000ri83ifhmezpoj","tag_id":"ckbrkxgum0014i83ig2cbq2zh","_id":"ckbrkxgvm004ti83ijjncocfp"},{"post_id":"ckbrkxgtb000si83i893if5jx","tag_id":"ckbrkxgum0014i83ig2cbq2zh","_id":"ckbrkxgvm004ui83i9p1v83q6"},{"post_id":"ckbrkxgtb000ti83iebon2kkk","tag_id":"ckbrkxgum0014i83ig2cbq2zh","_id":"ckbrkxgvm004vi83idc9bj59h"},{"post_id":"ckbrkxgtc000ui83ikh4x33x3","tag_id":"ckbrkxgum0014i83ig2cbq2zh","_id":"ckbrkxgvm004wi83imxaegpid"},{"post_id":"ckbrkxgtc000vi83in12q15pf","tag_id":"ckbrkxgum0014i83ig2cbq2zh","_id":"ckbrkxgvm004xi83ika7mlcyy"},{"post_id":"ckbrkxgtc000wi83iyqhwnpfk","tag_id":"ckbrkxgum0014i83ig2cbq2zh","_id":"ckbrkxgvm004yi83ixpnr8anf"}],"Tag":[{"name":"FE","_id":"ckbrkxguh000yi83i6d9hw0hl"},{"name":"Vue","_id":"ckbrkxguj0010i83injmkby2x"},{"name":"GIS","_id":"ckbrkxgum0014i83ig2cbq2zh"},{"name":"Leaflet","_id":"ckbrkxgun0016i83ixnmyplm7"},{"name":"OpenLayers","_id":"ckbrkxgup001ci83i1iy5mm5m"}]}}