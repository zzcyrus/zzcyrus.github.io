{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/google56eca6eee2792f06.html","path":"google56eca6eee2792f06.html","modified":1,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":1,"renderable":0},{"_id":"themes/indigo/source/css/style.less","path":"css/style.less","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/img-err.png","path":"img/img-err.png","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/img-loading.png","path":"img/img-loading.png","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/cc.png","path":"img/cc.png","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/brand.jpg","path":"img/brand.jpg","modified":1,"renderable":1},{"_id":"themes/indigo/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/indigo/source/js/main.min.js","path":"js/main.min.js","modified":1,"renderable":1},{"_id":"themes/indigo/source/js/search.min.js","path":"js/search.min.js","modified":1,"renderable":1},{"_id":"themes/indigo/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.eot","path":"css/fonts/roboto/Roboto-Bold.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff2","path":"css/fonts/roboto/Roboto-Bold.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.eot","path":"css/fonts/roboto/Roboto-Light.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff","path":"css/fonts/roboto/Roboto-Bold.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff","path":"css/fonts/roboto/Roboto-Light.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff2","path":"css/fonts/roboto/Roboto-Light.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.eot","path":"css/fonts/roboto/Roboto-Medium.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff2","path":"css/fonts/roboto/Roboto-Medium.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.eot","path":"css/fonts/roboto/Roboto-Regular.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff","path":"css/fonts/roboto/Roboto-Medium.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.eot","path":"css/fonts/roboto/Roboto-Thin.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff2","path":"css/fonts/roboto/Roboto-Regular.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff","path":"css/fonts/roboto/Roboto-Regular.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff","path":"css/fonts/roboto/Roboto-Thin.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff2","path":"css/fonts/roboto/Roboto-Thin.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff","path":"css/fonts/fontawesome/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff2","path":"css/fonts/fontawesome/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/FontAwesome.otf","path":"css/fonts/fontawesome/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.ttf","path":"css/fonts/fontawesome/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.eot","path":"css/fonts/fontawesome/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.ttf","path":"css/fonts/roboto/Roboto-Light.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.ttf","path":"css/fonts/roboto/Roboto-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.ttf","path":"css/fonts/roboto/Roboto-Thin.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.ttf","path":"css/fonts/roboto/Roboto-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.ttf","path":"css/fonts/roboto/Roboto-Medium.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.svg","path":"css/fonts/fontawesome/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"70643c718cb37d38c76538362733dd69f1ced96a","modified":1548833343648},{"_id":"source/google56eca6eee2792f06.html","hash":"1a362462d2e6419a55873168085e6403c0ac265b","modified":1548833343654},{"_id":"source/robots.txt","hash":"7177acc8b0cf8d13f8e7e6f22b80c944a3736e68","modified":1548833343654},{"_id":"themes/indigo/LICENSE","hash":"9dd0f70bc72c9d575447655526aded395bb93754","modified":1548833343655},{"_id":"themes/indigo/.editorconfig","hash":"67a03b88eadd7810f2e01866e73814074ecd3b87","modified":1548833343655},{"_id":"themes/indigo/_config.yml","hash":"e7166b7613c56dafdf9883c08961319f14cb9ad0","modified":1548833343655},{"_id":"themes/indigo/README.md","hash":"480f6efbd0fcf50308b22bc3af7a8c79e56601f8","modified":1548833343655},{"_id":"themes/indigo/package.json","hash":"e49ac0d6d0028d1ec14a41bd1218c6ffa905c13f","modified":1548833343667},{"_id":"source/_posts/mongoDB-geospatial.md","hash":"e0512853ef2e32430f53751a5a9e20e41a6a02f9","modified":1548833343651},{"_id":"source/_posts/osm-PostGIS-setup.md","hash":"307560624f71f43592877db2aaa23fd1eebc609d","modified":1552391693880},{"_id":"source/_posts/Vue-Parent-and-Child-lifecycle-hooks.md","hash":"800ffe1fff67232b425e092a4d1ac8e88920b7c1","modified":1548833343649},{"_id":"source/_posts/plugins.md","hash":"001794d8f46cf637c5b3fee623b40272afde4e4c","modified":1548833343652},{"_id":"source/_posts/basemap.md","hash":"b952bf4f846d2ab7351ed9aa60d270385b0efdbd","modified":1548833343651},{"_id":"source/_posts/openlayers-canvas-typhoon.md","hash":"f67d57f408b8b98d7820ad9991f030b38e07f2b6","modified":1548833343651},{"_id":"source/_posts/vue-dialog-nested.md","hash":"aed35b6655fd4774c42b53a1071ae626e3879e03","modified":1548833343654},{"_id":"source/_posts/vector-tile-openlayers-try.md","hash":"857c4111a94f9d4745aa68c469b5833a92bf672d","modified":1548833343653},{"_id":"source/categories/index.md","hash":"498172edabec6245e809f4cacd923b611f1ddaf4","modified":1548833343654},{"_id":"source/tags/index.md","hash":"4230d358e4bac33c4ef402453064f9623ba41b55","modified":1548833343654},{"_id":"themes/indigo/languages/en.yml","hash":"ba78def0453d08172248e220a1f9e145e99b4f23","modified":1548833343655},{"_id":"themes/indigo/languages/zh-CN.yml","hash":"6806e4c305facf19cbe4e37ccc5d6b00cb56e199","modified":1548833343655},{"_id":"themes/indigo/languages/zh-TW.yml","hash":"9b8bdd9c8b68716f364503926dca6ba8571ee5ff","modified":1548833343655},{"_id":"themes/indigo/layout/archive.ejs","hash":"6897178ba358379d6a4b7c0ba1bc2ab97ad5303a","modified":1548833343665},{"_id":"themes/indigo/layout/categories.ejs","hash":"efae06b4d83aaf73ab93260381e891825bf404ac","modified":1548833343665},{"_id":"themes/indigo/layout/category.ejs","hash":"e5ba5cc2e092c199285b8097ef12ffe70bf84c91","modified":1548833343666},{"_id":"themes/indigo/layout/post.ejs","hash":"efc3352828351f8574c51e8a93dc56c66660c3b1","modified":1548833343667},{"_id":"themes/indigo/layout/page.ejs","hash":"567c42b978da4c39b8b4982df19b940c26bc32a4","modified":1548833343667},{"_id":"themes/indigo/layout/index.ejs","hash":"772c1985c7743e101598b4eddc253f9174c5605b","modified":1548833343666},{"_id":"themes/indigo/layout/tag.ejs","hash":"90a231dea3a364b329a740e5d6c49c8cf5664fe9","modified":1548833343667},{"_id":"themes/indigo/layout/tags.ejs","hash":"1fc0461e9602b53899ec756e4361beb8cce74740","modified":1548833343667},{"_id":"themes/indigo/layout/layout.ejs","hash":"770af84fff104c398ce8b6c995130cddd3e9a1e9","modified":1548833343666},{"_id":"themes/indigo/scripts/plugins.js","hash":"00ea278ea77733f546439aed507ce69a298da362","modified":1548833343667},{"_id":"source/_posts/Vue-Parent-and-Child-lifecycle-hooks/parent-child-hooks.png","hash":"d60fd1f5961cb7afbd5fc0710507d4ba3314dabb","modified":1548833343651},{"_id":"source/_posts/openlayers-canvas-typhoon/canvasSymbol.png","hash":"68cee9b60f04aa63d6ad864065e4ed5b65de0a93","modified":1548833343652},{"_id":"source/_posts/openlayers-canvas-typhoon/goal.png","hash":"b299febc94934b1afa2e69eef9dd587e9cfc7b55","modified":1548833343652},{"_id":"themes/indigo/layout/_partial/after-footer.ejs","hash":"1351dbfca311f0d50a939f9e1a91c4f65bbcdf5f","modified":1548833343656},{"_id":"themes/indigo/layout/_partial/archive.ejs","hash":"c294c98617ce14082f9b3d5eec83328f480f5597","modified":1548833343656},{"_id":"themes/indigo/layout/_partial/footer.ejs","hash":"c78444f5b350ca79b260361bf3e5b6361d2661ba","modified":1548833343656},{"_id":"themes/indigo/layout/_partial/head.ejs","hash":"acde2dd615512eb63d7a98e854d16b6cf2f5be86","modified":1548833343656},{"_id":"themes/indigo/layout/_partial/header.ejs","hash":"648db446567a81371b8a29d719d13636aa157012","modified":1548833343656},{"_id":"themes/indigo/layout/_partial/index-item.ejs","hash":"7208d4083ee3355aa969972a2ce249a67d56b3a6","modified":1548833343656},{"_id":"themes/indigo/layout/_partial/loading.ejs","hash":"8b3e037dd5f3d4564012689c5cd6f63caf73df0f","modified":1548833343656},{"_id":"themes/indigo/layout/_partial/menu.ejs","hash":"ea6aded24a68de0914f24b3760f766b5e1c9835a","modified":1548833343656},{"_id":"themes/indigo/layout/_partial/paginator.ejs","hash":"13952250463f70d1c1bbbfdd7f4ee8160dd6d99b","modified":1548833343656},{"_id":"themes/indigo/layout/_partial/post.ejs","hash":"20597ac0d547aea37680ecf195eb129fe5ee19d8","modified":1548833343659},{"_id":"themes/indigo/layout/_partial/script.ejs","hash":"31052bc524a10abd6871aed2415448ce585faff2","modified":1548833343664},{"_id":"themes/indigo/layout/_partial/search.ejs","hash":"752109904304fdb8e988ee1254df2af9c0701466","modified":1548833343664},{"_id":"themes/indigo/layout/_partial/tags-bar.ejs","hash":"30ec74f081cc4c273a7bcd5d57da99072e9f0755","modified":1548833343665},{"_id":"themes/indigo/source/css/style.less","hash":"27dc4b93b93e92824d748f66b85de343b6a68f71","modified":1548833343684},{"_id":"themes/indigo/source/img/avatar.jpg","hash":"c82500dae026277692ba0a6c3a38a92a65df2360","modified":1548833343684},{"_id":"themes/indigo/source/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1548833343685},{"_id":"themes/indigo/source/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1548833343685},{"_id":"themes/indigo/source/img/cc.png","hash":"ebce75a62b40976a72d43f0bd937d859ac24d87c","modified":1548833343685},{"_id":"themes/indigo/source/img/brand.jpg","hash":"0e237f1b433851c156e1f1cdaeb044054b3b9879","modified":1548833343685},{"_id":"themes/indigo/source/js/search.js","hash":"a4d6c9c566ec1ca71ddacfd14c58f7ddaf9db24d","modified":1548833343685},{"_id":"themes/indigo/source/js/main.min.js","hash":"70652f94832de4801ffe80bf59d09265ac84599f","modified":1548833343685},{"_id":"themes/indigo/source/js/search.min.js","hash":"a8a450bb8b1ca9ad577052addcbd3393f1af6c6a","modified":1548833343686},{"_id":"themes/indigo/source/js/main.js","hash":"78f3dd49bf34b29155f09c77fd9c7b2e9643bf98","modified":1548833343685},{"_id":"source/_posts/plugins/tileWMS.png","hash":"ba3e69080062ee93f14f735bb9cc06e6cf93de1c","modified":1548833343653},{"_id":"source/_posts/vector-tile-openlayers-try/network.png","hash":"3c247aaf66bdbc8a21e4865748d6816ff717402b","modified":1548833343654},{"_id":"source/_posts/Vue-Parent-and-Child-lifecycle-hooks/lifecircle.png","hash":"ab511f99adcdfd840e6b40c08ec78409dbae5f31","modified":1548833343651},{"_id":"themes/indigo/layout/_partial/plugins/dynamic-title.ejs","hash":"3b877868c4a6fc217ea6f3314544830280a77472","modified":1548833343657},{"_id":"themes/indigo/layout/_partial/plugins/disqus.ejs","hash":"86fe837ab16cb60754b0a73bb9efa38b04f3023f","modified":1548833343657},{"_id":"themes/indigo/layout/_partial/plugins/baidu.ejs","hash":"da1355eea131952031e54c45560555e6d3aa5a33","modified":1548833343657},{"_id":"themes/indigo/layout/_partial/plugins/gitment.ejs","hash":"5f6ceb7f4b9b579e8e3f87894447f556a53f9385","modified":1548833343657},{"_id":"themes/indigo/layout/_partial/plugins/google-analytics.ejs","hash":"b5b87761751a897949e085a8f1ace78b0b8babd5","modified":1548833343657},{"_id":"themes/indigo/layout/_partial/plugins/mathjax.ejs","hash":"3a5c9f7d22d30cd8ffa4e83a8d3976db22815994","modified":1548833343658},{"_id":"themes/indigo/layout/_partial/plugins/page-visit.ejs","hash":"bb9deb32c54ea6820f622b923e62592915e9f21f","modified":1548833343658},{"_id":"themes/indigo/layout/_partial/plugins/site-visit.ejs","hash":"a2c247c2e32016563dd6a22c21474072d93f4dbd","modified":1548833343658},{"_id":"themes/indigo/layout/_partial/plugins/tajs.ejs","hash":"ef9c77d8c6e004b014c83c5f9333e7174f8bafa3","modified":1548833343659},{"_id":"themes/indigo/layout/_partial/plugins/uyan.ejs","hash":"ddf290e90dc1c779f42a48e1bd852ca932148dfb","modified":1548833343659},{"_id":"themes/indigo/layout/_partial/post/category.ejs","hash":"c08e44cbd7315dec7afb6054b04d3c7b82c3bde8","modified":1548833343660},{"_id":"themes/indigo/layout/_partial/post/comment.ejs","hash":"8329bae496686e7754eed26dc94bc5676ab53f86","modified":1548833343660},{"_id":"themes/indigo/layout/_partial/post/copyright.ejs","hash":"ffd06f34b6d29d5306d1bb8965fcca0e41cdd5f7","modified":1548833343661},{"_id":"themes/indigo/layout/_partial/post/date.ejs","hash":"c5adcec8db1506c378d39855a697e1bb1165646c","modified":1548833343661},{"_id":"themes/indigo/layout/_partial/post/head-meta.ejs","hash":"f137c126672769e9571be2bb0a70ea8dda644b0e","modified":1548833343661},{"_id":"themes/indigo/layout/_partial/post/nav.ejs","hash":"03719097851575a2c1bb95774058b224f6402a1f","modified":1548833343662},{"_id":"themes/indigo/layout/_partial/post/reward-btn.ejs","hash":"b46160005224821a439dec9f1ff183e2f66d9f4b","modified":1548833343662},{"_id":"themes/indigo/layout/_partial/post/reward.ejs","hash":"097c0276a61665e5ee96e5d5d85a7d6ae5ab2f49","modified":1548833343662},{"_id":"themes/indigo/layout/_partial/post/share-fab.ejs","hash":"2ec7de870988cfbc8ea9872cddf7e4076ac64a57","modified":1548833343662},{"_id":"themes/indigo/layout/_partial/post/share.ejs","hash":"7d79a67b3e5e6989f22fb0e0904fa540bfca5fcc","modified":1548833343662},{"_id":"themes/indigo/layout/_partial/post/tag.ejs","hash":"412894001b1ac6e63012b26b1109a0856651c076","modified":1548833343663},{"_id":"themes/indigo/layout/_partial/post/title.ejs","hash":"eaad7af7888bddd7095243a43ff38f55ad8c494a","modified":1548833343663},{"_id":"themes/indigo/layout/_partial/post/toc.ejs","hash":"0d8f0a4ab14c227cd52802095fc4974b6a7aae67","modified":1548833343663},{"_id":"themes/indigo/layout/_partial/post/updated.ejs","hash":"00fedf7971c0bda0623d968bc0614e512d19a985","modified":1548833343664},{"_id":"themes/indigo/source/css/_partial/archives.less","hash":"382fc22cd5cc073e881768a65600d97eba9f1d21","modified":1548833343668},{"_id":"themes/indigo/source/css/_partial/article.less","hash":"9f8573ad56967befe7f7efd5e81ad4965de86914","modified":1548833343668},{"_id":"themes/indigo/source/css/_partial/header.less","hash":"880b4a28e97d556ed15b07642d25115f9b6ba4f6","modified":1548833343669},{"_id":"themes/indigo/source/css/_partial/gotop.less","hash":"bad63006b3bd4849bf53ad38482af0d9971061d3","modified":1548833343668},{"_id":"themes/indigo/source/css/_partial/highlight.less","hash":"99e48793dc0b4ffb66ecaf2d1315145872f9bb98","modified":1548833343669},{"_id":"themes/indigo/source/css/_partial/lightbox.less","hash":"38419aaf3c1832e84ade331f051f110fdc8b960f","modified":1548833343669},{"_id":"themes/indigo/source/css/_partial/layout.less","hash":"5f783f34bf093e654e8922ed4a2af8b7b2cd41c4","modified":1548833343669},{"_id":"themes/indigo/source/css/_partial/loading.less","hash":"85157ddf3877b5c58e8f1d737dda3dfb1bfd540b","modified":1548833343669},{"_id":"themes/indigo/source/css/_partial/page.less","hash":"33b0a5edcedc26a4c592c812c5785bb20d3c93db","modified":1548833343669},{"_id":"themes/indigo/source/css/_partial/postlist.less","hash":"516cded3c7f1db4cacfa898bcaf0adfae7f3a2e1","modified":1548833343669},{"_id":"themes/indigo/source/css/_partial/roboto.less","hash":"3e457942995da8840e7662fa6cb551a7e12ea294","modified":1548833343670},{"_id":"themes/indigo/source/css/_partial/reward.less","hash":"f5e89ea5414e3096a28c8c96e86c3f669040a892","modified":1548833343669},{"_id":"themes/indigo/source/css/_partial/share.less","hash":"a683c96a59470efd35722b763c55149a46e35156","modified":1548833343670},{"_id":"themes/indigo/source/css/_partial/search.less","hash":"dbc23e77e586ee682a21475f5eb568628ea6720f","modified":1548833343670},{"_id":"themes/indigo/source/css/_partial/tags.less","hash":"01eb7f84193180928a6ed4796ee8802f6c1628e7","modified":1548833343670},{"_id":"themes/indigo/source/css/_partial/waves.less","hash":"a02eaa601887f947257f6016679b62dc96a61c0c","modified":1548833343670},{"_id":"themes/indigo/source/css/_partial/variable.less","hash":"3232e75f4653402c9fbd7bda5b97c05ecc31db2b","modified":1548833343670},{"_id":"themes/indigo/source/css/_partial/fontawesome.less","hash":"a3ecbd6ccf5b56ac39df710c34a149b82989a498","modified":1548833343668},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1548833343676},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1548833343677},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1548833343678},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1548833343677},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1548833343679},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1548833343679},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1548833343679},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1548833343681},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1548833343681},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1548833343680},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1548833343682},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1548833343682},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1548833343682},{"_id":"source/_posts/openlayers-canvas-typhoon/canvasLayer.png","hash":"f105722102cab4559d9c8e2652d8f91e6ea89c8f","modified":1548833343652},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1548833343684},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1548833343684},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1548833343676},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1548833343676},{"_id":"themes/indigo/source/css/fonts/fontawesome/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1548833343671},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1548833343675},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1548833343672},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1548833343678},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1548833343682},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1548833343683},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1548833343677},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1548833343680},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1548833343674}],"Category":[{"name":"Node","_id":"cjt5pxo200004ul3i7z357k9h"},{"name":"PostGIS","_id":"cjt5pxo280009ul3iqo8b4qh7"},{"name":"前端","_id":"cjt5pxo2e000gul3i3611hex8"},{"name":"Leaflet","_id":"cjt5pxo2g000lul3inwlwa7tj"},{"name":"OpenLayers","_id":"cjt5pxo2i000sul3i3rpnowvm"}],"Data":[],"Page":[{"title":"Categories","date":"2017-06-21T12:55:51.000Z","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: Categories\ndate: 2017-06-21 20:55:51\nlayout: \"categories\"\n---\n","updated":"2019-01-30T07:29:03.654Z","path":"categories/index.html","comments":1,"_id":"cjt5pxo1x0001ul3igbaf295e","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Tags","date":"2017-06-21T12:55:39.000Z","layout":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: Tags\ndate: 2017-06-21 20:55:39\nlayout: \"tags\"\ncomments: false\n---\n","updated":"2019-01-30T07:29:03.654Z","path":"tags/index.html","_id":"cjt5pxo1z0003ul3iddp7vfgr","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"mongoDB中地理空间查询指北","date":"2019-01-20T09:41:24.000Z","_content":"\n\n现在地理空间查询是越来越常见的一种需求，实现的方式也有很多种，相较于PostGIS，mongoDB既可以直接存储GeoJSON对象，又支持地理空间索引，可以满足高效的常见地理空间服务。\n\n<!-- more -->\n\n\n[一个可供参考的案例仓库](https://github.com/zzcyrus/mongoDB-geospatial-demos)\n\n\n## 索引方式介绍\n\n### 2d 索引\n\n[官方介绍](https://docs.mongodb.com/manual/core/2d/)\n\n2d index 通常用在2维平面上的点数据，如果你的MongoDB 版本小于2.2或者你不使用一些GeoJSON类型的数据，官方推荐你使用2d index。\n\n### 2dsphere 索引\n\n[官方介绍](https://docs.mongodb.com/manual/core/2dsphere/)\n\n2dsphere index 支持所有的mongoDB空间查询，支持类地球的球面上几何要素的查询，支持数据存储为GeoJSON或者是传统坐标。\n\n\n*所以如果你正在做一个现代化的GIS应用，建议直接采取2dsphere索引，这将会非常方便，GeoJSON格式的直接导入，配合WebGIS的直接查询或插入*\n\n\n## 查询方法介绍\n\n[官方介绍](https://docs.mongodb.com/manual/reference/operator/query-geospatial/)\n\n\n下面这个表格包含了一些个人的总结和官方的说明，具体查询的作用其实通过查询方法的名字就能猜测出来，所以不详细介绍了\n\n\n|查询方式|2d索引|sphere索引|几何类型（2d/sphere）|\n| --- | :-: | :-: | :-: | --- |\n|$near| ✅ | ✅ | 平面/球面 |\n|$nearSphere | ✅ | ✅ | 球面 |\n|$geoWithin:{$center:...}| ✅ | ⚠️ | 平面 |\n|$geoWithin:{$centerSphere:...} | ✅ | ✅ | 球面 |\n|$geoWithin:{$box:...}| ✅ | ⚠️ | 平面 |\n|$geoWithin:{$polygon:...}| ✅ | ⚠️ | 平面 |\n|$geoWithin:{$geometry:...}| ❎ | ✅ | 球面 |\n|$geoIntersects | ❎ | ✅ | 球面 |\n\n> 说明： ✅ 支持 ❎ 不支持 ⚠️ 官方文档说不支持，但测试发现可以使用\n\n\n## 使用注意事项\n\n1. 在2dsphere索引中使用$geometry去查询，如果自己构造$geometry，要注意geometry的coordinates必须是一个`闭合`的数组，首尾两项要一致。\n2. 与此同时，在使用$polygon去查询时，`不必`是一个闭合的坐标数组列，mongoDB会自动帮我们关闭这个图形\n3. 在使用$near或者$geoWithin之类的查询中会涉及到距离、半径定义，这里如果你使用经纬度作为坐标，使用m（米）作为距离、半径单位，那么要进行`转换`，具体的转换规则可以参考下面两段代码示例：\n\n\n```js\n/**\n * 1度大致对应111千米，所以需要/111000,具体可以细化\n * @param {*} meter 米\n */\nconst m2degree = (meter) => {\n  return meter / 111000\n}\n\nconst query = {\n  location: {\n    $geoWithin: {\n      $center: [[lon, lat], m2degree(radius)]\n    }\n  }\n}\n```\n\n```js\n/**\n * 米转换成弧度，需要除以地球半径，大约6378100米\n * @param {*} meter\n */\nconst m2rad = (meter) => {\n  return meter / 6378100\n}\n\nconst query = {\n  location: {\n    $nearSphere: [lon, lat],\n    $maxDistance: m2rad(maxDistance)\n  }\n}\n\n```\n\n## demo\n\n这里提供[一个可供参考的简单的案例仓库](https://github.com/zzcyrus/mongoDB-geospatial-demos)\n案例中使用了中国天气网上的749个气象站点温度数据作为数据源，分别建立两种类型的索引，对每种地理查询都做了接口化，你可以**自行运行探索**，或者为其增加一个WebGIS的界面，直接进行操作，体验一下mongoDB地理查询的快捷。\n","source":"_posts/mongoDB-geospatial.md","raw":"---\ntitle: mongoDB中地理空间查询指北\ndate: 2019-01-20 17:41:24\ntags: [GIS]\ncategories: Node\n---\n\n\n现在地理空间查询是越来越常见的一种需求，实现的方式也有很多种，相较于PostGIS，mongoDB既可以直接存储GeoJSON对象，又支持地理空间索引，可以满足高效的常见地理空间服务。\n\n<!-- more -->\n\n\n[一个可供参考的案例仓库](https://github.com/zzcyrus/mongoDB-geospatial-demos)\n\n\n## 索引方式介绍\n\n### 2d 索引\n\n[官方介绍](https://docs.mongodb.com/manual/core/2d/)\n\n2d index 通常用在2维平面上的点数据，如果你的MongoDB 版本小于2.2或者你不使用一些GeoJSON类型的数据，官方推荐你使用2d index。\n\n### 2dsphere 索引\n\n[官方介绍](https://docs.mongodb.com/manual/core/2dsphere/)\n\n2dsphere index 支持所有的mongoDB空间查询，支持类地球的球面上几何要素的查询，支持数据存储为GeoJSON或者是传统坐标。\n\n\n*所以如果你正在做一个现代化的GIS应用，建议直接采取2dsphere索引，这将会非常方便，GeoJSON格式的直接导入，配合WebGIS的直接查询或插入*\n\n\n## 查询方法介绍\n\n[官方介绍](https://docs.mongodb.com/manual/reference/operator/query-geospatial/)\n\n\n下面这个表格包含了一些个人的总结和官方的说明，具体查询的作用其实通过查询方法的名字就能猜测出来，所以不详细介绍了\n\n\n|查询方式|2d索引|sphere索引|几何类型（2d/sphere）|\n| --- | :-: | :-: | :-: | --- |\n|$near| ✅ | ✅ | 平面/球面 |\n|$nearSphere | ✅ | ✅ | 球面 |\n|$geoWithin:{$center:...}| ✅ | ⚠️ | 平面 |\n|$geoWithin:{$centerSphere:...} | ✅ | ✅ | 球面 |\n|$geoWithin:{$box:...}| ✅ | ⚠️ | 平面 |\n|$geoWithin:{$polygon:...}| ✅ | ⚠️ | 平面 |\n|$geoWithin:{$geometry:...}| ❎ | ✅ | 球面 |\n|$geoIntersects | ❎ | ✅ | 球面 |\n\n> 说明： ✅ 支持 ❎ 不支持 ⚠️ 官方文档说不支持，但测试发现可以使用\n\n\n## 使用注意事项\n\n1. 在2dsphere索引中使用$geometry去查询，如果自己构造$geometry，要注意geometry的coordinates必须是一个`闭合`的数组，首尾两项要一致。\n2. 与此同时，在使用$polygon去查询时，`不必`是一个闭合的坐标数组列，mongoDB会自动帮我们关闭这个图形\n3. 在使用$near或者$geoWithin之类的查询中会涉及到距离、半径定义，这里如果你使用经纬度作为坐标，使用m（米）作为距离、半径单位，那么要进行`转换`，具体的转换规则可以参考下面两段代码示例：\n\n\n```js\n/**\n * 1度大致对应111千米，所以需要/111000,具体可以细化\n * @param {*} meter 米\n */\nconst m2degree = (meter) => {\n  return meter / 111000\n}\n\nconst query = {\n  location: {\n    $geoWithin: {\n      $center: [[lon, lat], m2degree(radius)]\n    }\n  }\n}\n```\n\n```js\n/**\n * 米转换成弧度，需要除以地球半径，大约6378100米\n * @param {*} meter\n */\nconst m2rad = (meter) => {\n  return meter / 6378100\n}\n\nconst query = {\n  location: {\n    $nearSphere: [lon, lat],\n    $maxDistance: m2rad(maxDistance)\n  }\n}\n\n```\n\n## demo\n\n这里提供[一个可供参考的简单的案例仓库](https://github.com/zzcyrus/mongoDB-geospatial-demos)\n案例中使用了中国天气网上的749个气象站点温度数据作为数据源，分别建立两种类型的索引，对每种地理查询都做了接口化，你可以**自行运行探索**，或者为其增加一个WebGIS的界面，直接进行操作，体验一下mongoDB地理查询的快捷。\n","slug":"mongoDB-geospatial","published":1,"updated":"2019-01-30T07:29:03.651Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5pxo1t0000ul3i099bbbvb","content":"<p>现在地理空间查询是越来越常见的一种需求，实现的方式也有很多种，相较于PostGIS，mongoDB既可以直接存储GeoJSON对象，又支持地理空间索引，可以满足高效的常见地理空间服务。</p>\n<a id=\"more\"></a>\n<p><a href=\"https://github.com/zzcyrus/mongoDB-geospatial-demos\" target=\"_blank\" rel=\"noopener\">一个可供参考的案例仓库</a></p>\n<h2 id=\"索引方式介绍\"><a href=\"#索引方式介绍\" class=\"headerlink\" title=\"索引方式介绍\"></a>索引方式介绍</h2><h3 id=\"2d-索引\"><a href=\"#2d-索引\" class=\"headerlink\" title=\"2d 索引\"></a>2d 索引</h3><p><a href=\"https://docs.mongodb.com/manual/core/2d/\" target=\"_blank\" rel=\"noopener\">官方介绍</a></p>\n<p>2d index 通常用在2维平面上的点数据，如果你的MongoDB 版本小于2.2或者你不使用一些GeoJSON类型的数据，官方推荐你使用2d index。</p>\n<h3 id=\"2dsphere-索引\"><a href=\"#2dsphere-索引\" class=\"headerlink\" title=\"2dsphere 索引\"></a>2dsphere 索引</h3><p><a href=\"https://docs.mongodb.com/manual/core/2dsphere/\" target=\"_blank\" rel=\"noopener\">官方介绍</a></p>\n<p>2dsphere index 支持所有的mongoDB空间查询，支持类地球的球面上几何要素的查询，支持数据存储为GeoJSON或者是传统坐标。</p>\n<p><em>所以如果你正在做一个现代化的GIS应用，建议直接采取2dsphere索引，这将会非常方便，GeoJSON格式的直接导入，配合WebGIS的直接查询或插入</em></p>\n<h2 id=\"查询方法介绍\"><a href=\"#查询方法介绍\" class=\"headerlink\" title=\"查询方法介绍\"></a>查询方法介绍</h2><p><a href=\"https://docs.mongodb.com/manual/reference/operator/query-geospatial/\" target=\"_blank\" rel=\"noopener\">官方介绍</a></p>\n<p>下面这个表格包含了一些个人的总结和官方的说明，具体查询的作用其实通过查询方法的名字就能猜测出来，所以不详细介绍了</p>\n<table>\n<thead>\n<tr>\n<th>查询方式</th>\n<th style=\"text-align:center\">2d索引</th>\n<th style=\"text-align:center\">sphere索引</th>\n<th style=\"text-align:center\">几何类型（2d/sphere）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$near</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">平面/球面</td>\n</tr>\n<tr>\n<td>$nearSphere</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">球面</td>\n</tr>\n<tr>\n<td>$geoWithin:{$center:…}</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">⚠️</td>\n<td style=\"text-align:center\">平面</td>\n</tr>\n<tr>\n<td>$geoWithin:{$centerSphere:…}</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">球面</td>\n</tr>\n<tr>\n<td>$geoWithin:{$box:…}</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">⚠️</td>\n<td style=\"text-align:center\">平面</td>\n</tr>\n<tr>\n<td>$geoWithin:{$polygon:…}</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">⚠️</td>\n<td style=\"text-align:center\">平面</td>\n</tr>\n<tr>\n<td>$geoWithin:{$geometry:…}</td>\n<td style=\"text-align:center\">❎</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">球面</td>\n</tr>\n<tr>\n<td>$geoIntersects</td>\n<td style=\"text-align:center\">❎</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">球面</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>说明： ✅ 支持 ❎ 不支持 ⚠️ 官方文档说不支持，但测试发现可以使用</p>\n</blockquote>\n<h2 id=\"使用注意事项\"><a href=\"#使用注意事项\" class=\"headerlink\" title=\"使用注意事项\"></a>使用注意事项</h2><ol>\n<li>在2dsphere索引中使用$geometry去查询，如果自己构造$geometry，要注意geometry的coordinates必须是一个<code>闭合</code>的数组，首尾两项要一致。</li>\n<li>与此同时，在使用$polygon去查询时，<code>不必</code>是一个闭合的坐标数组列，mongoDB会自动帮我们关闭这个图形</li>\n<li>在使用$near或者$geoWithin之类的查询中会涉及到距离、半径定义，这里如果你使用经纬度作为坐标，使用m（米）作为距离、半径单位，那么要进行<code>转换</code>，具体的转换规则可以参考下面两段代码示例：</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 1度大致对应111千米，所以需要/111000,具体可以细化</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;*&#125; meter 米</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> m2degree = <span class=\"function\">(<span class=\"params\">meter</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> meter / <span class=\"number\">111000</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> query = &#123;</span><br><span class=\"line\">  location: &#123;</span><br><span class=\"line\">    $geoWithin: &#123;</span><br><span class=\"line\">      $center: [[lon, lat], m2degree(radius)]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 米转换成弧度，需要除以地球半径，大约6378100米</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;*&#125; meter</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> m2rad = <span class=\"function\">(<span class=\"params\">meter</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> meter / <span class=\"number\">6378100</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> query = &#123;</span><br><span class=\"line\">  location: &#123;</span><br><span class=\"line\">    $nearSphere: [lon, lat],</span><br><span class=\"line\">    $maxDistance: m2rad(maxDistance)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h2><p>这里提供<a href=\"https://github.com/zzcyrus/mongoDB-geospatial-demos\" target=\"_blank\" rel=\"noopener\">一个可供参考的简单的案例仓库</a><br>案例中使用了中国天气网上的749个气象站点温度数据作为数据源，分别建立两种类型的索引，对每种地理查询都做了接口化，你可以<strong>自行运行探索</strong>，或者为其增加一个WebGIS的界面，直接进行操作，体验一下mongoDB地理查询的快捷。</p>\n","site":{"data":{}},"excerpt":"<p>现在地理空间查询是越来越常见的一种需求，实现的方式也有很多种，相较于PostGIS，mongoDB既可以直接存储GeoJSON对象，又支持地理空间索引，可以满足高效的常见地理空间服务。</p>","more":"<p><a href=\"https://github.com/zzcyrus/mongoDB-geospatial-demos\" target=\"_blank\" rel=\"noopener\">一个可供参考的案例仓库</a></p>\n<h2 id=\"索引方式介绍\"><a href=\"#索引方式介绍\" class=\"headerlink\" title=\"索引方式介绍\"></a>索引方式介绍</h2><h3 id=\"2d-索引\"><a href=\"#2d-索引\" class=\"headerlink\" title=\"2d 索引\"></a>2d 索引</h3><p><a href=\"https://docs.mongodb.com/manual/core/2d/\" target=\"_blank\" rel=\"noopener\">官方介绍</a></p>\n<p>2d index 通常用在2维平面上的点数据，如果你的MongoDB 版本小于2.2或者你不使用一些GeoJSON类型的数据，官方推荐你使用2d index。</p>\n<h3 id=\"2dsphere-索引\"><a href=\"#2dsphere-索引\" class=\"headerlink\" title=\"2dsphere 索引\"></a>2dsphere 索引</h3><p><a href=\"https://docs.mongodb.com/manual/core/2dsphere/\" target=\"_blank\" rel=\"noopener\">官方介绍</a></p>\n<p>2dsphere index 支持所有的mongoDB空间查询，支持类地球的球面上几何要素的查询，支持数据存储为GeoJSON或者是传统坐标。</p>\n<p><em>所以如果你正在做一个现代化的GIS应用，建议直接采取2dsphere索引，这将会非常方便，GeoJSON格式的直接导入，配合WebGIS的直接查询或插入</em></p>\n<h2 id=\"查询方法介绍\"><a href=\"#查询方法介绍\" class=\"headerlink\" title=\"查询方法介绍\"></a>查询方法介绍</h2><p><a href=\"https://docs.mongodb.com/manual/reference/operator/query-geospatial/\" target=\"_blank\" rel=\"noopener\">官方介绍</a></p>\n<p>下面这个表格包含了一些个人的总结和官方的说明，具体查询的作用其实通过查询方法的名字就能猜测出来，所以不详细介绍了</p>\n<table>\n<thead>\n<tr>\n<th>查询方式</th>\n<th style=\"text-align:center\">2d索引</th>\n<th style=\"text-align:center\">sphere索引</th>\n<th style=\"text-align:center\">几何类型（2d/sphere）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$near</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">平面/球面</td>\n</tr>\n<tr>\n<td>$nearSphere</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">球面</td>\n</tr>\n<tr>\n<td>$geoWithin:{$center:…}</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">⚠️</td>\n<td style=\"text-align:center\">平面</td>\n</tr>\n<tr>\n<td>$geoWithin:{$centerSphere:…}</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">球面</td>\n</tr>\n<tr>\n<td>$geoWithin:{$box:…}</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">⚠️</td>\n<td style=\"text-align:center\">平面</td>\n</tr>\n<tr>\n<td>$geoWithin:{$polygon:…}</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">⚠️</td>\n<td style=\"text-align:center\">平面</td>\n</tr>\n<tr>\n<td>$geoWithin:{$geometry:…}</td>\n<td style=\"text-align:center\">❎</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">球面</td>\n</tr>\n<tr>\n<td>$geoIntersects</td>\n<td style=\"text-align:center\">❎</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">球面</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>说明： ✅ 支持 ❎ 不支持 ⚠️ 官方文档说不支持，但测试发现可以使用</p>\n</blockquote>\n<h2 id=\"使用注意事项\"><a href=\"#使用注意事项\" class=\"headerlink\" title=\"使用注意事项\"></a>使用注意事项</h2><ol>\n<li>在2dsphere索引中使用$geometry去查询，如果自己构造$geometry，要注意geometry的coordinates必须是一个<code>闭合</code>的数组，首尾两项要一致。</li>\n<li>与此同时，在使用$polygon去查询时，<code>不必</code>是一个闭合的坐标数组列，mongoDB会自动帮我们关闭这个图形</li>\n<li>在使用$near或者$geoWithin之类的查询中会涉及到距离、半径定义，这里如果你使用经纬度作为坐标，使用m（米）作为距离、半径单位，那么要进行<code>转换</code>，具体的转换规则可以参考下面两段代码示例：</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 1度大致对应111千米，所以需要/111000,具体可以细化</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;*&#125; meter 米</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> m2degree = <span class=\"function\">(<span class=\"params\">meter</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> meter / <span class=\"number\">111000</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> query = &#123;</span><br><span class=\"line\">  location: &#123;</span><br><span class=\"line\">    $geoWithin: &#123;</span><br><span class=\"line\">      $center: [[lon, lat], m2degree(radius)]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 米转换成弧度，需要除以地球半径，大约6378100米</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;*&#125; meter</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> m2rad = <span class=\"function\">(<span class=\"params\">meter</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> meter / <span class=\"number\">6378100</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> query = &#123;</span><br><span class=\"line\">  location: &#123;</span><br><span class=\"line\">    $nearSphere: [lon, lat],</span><br><span class=\"line\">    $maxDistance: m2rad(maxDistance)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h2><p>这里提供<a href=\"https://github.com/zzcyrus/mongoDB-geospatial-demos\" target=\"_blank\" rel=\"noopener\">一个可供参考的简单的案例仓库</a><br>案例中使用了中国天气网上的749个气象站点温度数据作为数据源，分别建立两种类型的索引，对每种地理查询都做了接口化，你可以<strong>自行运行探索</strong>，或者为其增加一个WebGIS的界面，直接进行操作，体验一下mongoDB地理查询的快捷。</p>"},{"title":"使用osm数据做一个自己的PostGIS数据库","date":"2019-03-12T11:54:08.000Z","_content":"\nPostGIS是目前开源方案里面使用广泛的一种地理信息数据库，可玩性很强，实用性也很强，为了实现更多的地理信息操作，我们先来搭建一个简单的PostGIS数据库。\n\n<!-- more -->\n\n\n## 安装步骤\n\n1. 准备一个 CentOS 7.x x64 环境\n2. 安装数据库 PostgreSQL 9.6\n3. 安装对应版本的 PostGIS 2.2.2\n4. 导入openstreetmap的中国区域数据\n\n\n## PostgreSQL 9.6\n\n```bash\n# 安装数据库\nyum install https://download.postgresql.org/pub/repos/yum/9.6/redhat/rhel-7-x86_64/pgdg-centos96-9.6-3.noarch.rpm\n\nyum install postgresql96\n\nyum install postgresql96-server\n\n# 初始化数据库及服务\n/usr/pgsql-9.6/bin/postgresql96-setup initdb\nsystemctl enable postgresql-9.6\nsystemctl start postgresql-9.6\n\n# 配置环境变量\nexport PATH=/usr/pgsql-9.6/bin:$PATH\nexport LD_LIBRARY_PATH=/usr/pgsql-9.6/lib:$LD_LIBRARY_PATH\nexport PGDATA=/home/postgres/postgresql_data\n\n\n# 以下可选\n\n# 为数据库设置密码\nsu - postgres \npsql\npostgres=# ALTER USER postgres WITH PASSWORD 'postgres'; \npostgres=# \\q\n\n# 开放防火墙端口\nfirewall-cmd --permanent --add-port=5432/tcp  \nfirewall-cmd --reload  \n\n# 修改配置文件允许外部使用密码访问\nvim /var/lib/pgsql/9.6/data/postgresql.conf\nlisten_addresses = 'localhost'  为  listen_addresses='*'\n\nvim /var/lib/pgsql/9.6/data/pg_hba.conf\nhost    all            all      0.0.0.0/0      md5\n\n```\n\n## PostGIS\n\n```bash\n# 安装PostGIS\nsudo yum -y install epel-release\nsudo yum install postgis24_96\n\n# 初始化数据库osm\ncreatedb osm\n\npsql -h 127.0.0.1 -d osm -U postgres -f /usr/pgsql-9.6/share/contrib/postgis-2.4/postgis.sql\npsql -h 127.0.0.1 -d osm -U postgres -f /usr/pgsql-9.6/share/contrib/postgis-2.4/spatial_ref_sys.sql\n\n# 可以基于osm创建china数据库（把osm作为一个可重复备份的库）\ncreatedb -T osm china\n\n```\n\n## osm数据导入\n\n```bash\n# 安装导入工具osm2pgsql\nyum install osm2pgsql\n\n# 下载中国区域的公开数据\nwget http://download.gisgraphy.com/openstreetmap/pbf/CN.tar.bz2   \n\n# 解压数据通过工具导入数据到china数据库\ntar jxvf CN.tar.bz2\nosm2pgsql -c -d china --slim -C 2000 -p china -r pbf /home/parallels/Downloads/CN\n\n```\n\n\n## 测试\n至此，我们已经基于osm的数据有了一个地理信息库，我们可以通过以下sql做一些简单的测试\n\n\n```sql\nSELECT name FROM china_polygon WHERE name ~ '南京';\n```\n\n结果：\n![](polygon.png)\n\n\n```sql\nSELECT p1.name,p2.name,ST_Distance(p1.way,p2.way) FROM    \n(SELECT * FROM china_point WHERE place='city' AND name = '南京市') p1 ,     \n(SELECT * FROM china_point WHERE place='city' AND name = '北京市') p2\n```\n\n结果：\n![](distance.png)\n\n\n```sql\nSELECT name, ST_AsText(ST_Transform(way,4326)) FROM china_point WHERE place='city';\n```\n\n结果：\n![](point.png)\n\n\n当然数据库的功能不局限于此，基于此数据库我们可以做些更有趣的事情，今后我们会慢慢探讨。\n\n\n\n## 参考文档\n[digoal的博客](https://github.com/digoal/blog/blob/master/201609/20160906_01.md)","source":"_posts/osm-PostGIS-setup.md","raw":"---\ntitle: 使用osm数据做一个自己的PostGIS数据库\ndate: 2019-03-12 19:54:08\ntags: [GIS]\ncategories: PostGIS\n---\n\nPostGIS是目前开源方案里面使用广泛的一种地理信息数据库，可玩性很强，实用性也很强，为了实现更多的地理信息操作，我们先来搭建一个简单的PostGIS数据库。\n\n<!-- more -->\n\n\n## 安装步骤\n\n1. 准备一个 CentOS 7.x x64 环境\n2. 安装数据库 PostgreSQL 9.6\n3. 安装对应版本的 PostGIS 2.2.2\n4. 导入openstreetmap的中国区域数据\n\n\n## PostgreSQL 9.6\n\n```bash\n# 安装数据库\nyum install https://download.postgresql.org/pub/repos/yum/9.6/redhat/rhel-7-x86_64/pgdg-centos96-9.6-3.noarch.rpm\n\nyum install postgresql96\n\nyum install postgresql96-server\n\n# 初始化数据库及服务\n/usr/pgsql-9.6/bin/postgresql96-setup initdb\nsystemctl enable postgresql-9.6\nsystemctl start postgresql-9.6\n\n# 配置环境变量\nexport PATH=/usr/pgsql-9.6/bin:$PATH\nexport LD_LIBRARY_PATH=/usr/pgsql-9.6/lib:$LD_LIBRARY_PATH\nexport PGDATA=/home/postgres/postgresql_data\n\n\n# 以下可选\n\n# 为数据库设置密码\nsu - postgres \npsql\npostgres=# ALTER USER postgres WITH PASSWORD 'postgres'; \npostgres=# \\q\n\n# 开放防火墙端口\nfirewall-cmd --permanent --add-port=5432/tcp  \nfirewall-cmd --reload  \n\n# 修改配置文件允许外部使用密码访问\nvim /var/lib/pgsql/9.6/data/postgresql.conf\nlisten_addresses = 'localhost'  为  listen_addresses='*'\n\nvim /var/lib/pgsql/9.6/data/pg_hba.conf\nhost    all            all      0.0.0.0/0      md5\n\n```\n\n## PostGIS\n\n```bash\n# 安装PostGIS\nsudo yum -y install epel-release\nsudo yum install postgis24_96\n\n# 初始化数据库osm\ncreatedb osm\n\npsql -h 127.0.0.1 -d osm -U postgres -f /usr/pgsql-9.6/share/contrib/postgis-2.4/postgis.sql\npsql -h 127.0.0.1 -d osm -U postgres -f /usr/pgsql-9.6/share/contrib/postgis-2.4/spatial_ref_sys.sql\n\n# 可以基于osm创建china数据库（把osm作为一个可重复备份的库）\ncreatedb -T osm china\n\n```\n\n## osm数据导入\n\n```bash\n# 安装导入工具osm2pgsql\nyum install osm2pgsql\n\n# 下载中国区域的公开数据\nwget http://download.gisgraphy.com/openstreetmap/pbf/CN.tar.bz2   \n\n# 解压数据通过工具导入数据到china数据库\ntar jxvf CN.tar.bz2\nosm2pgsql -c -d china --slim -C 2000 -p china -r pbf /home/parallels/Downloads/CN\n\n```\n\n\n## 测试\n至此，我们已经基于osm的数据有了一个地理信息库，我们可以通过以下sql做一些简单的测试\n\n\n```sql\nSELECT name FROM china_polygon WHERE name ~ '南京';\n```\n\n结果：\n![](polygon.png)\n\n\n```sql\nSELECT p1.name,p2.name,ST_Distance(p1.way,p2.way) FROM    \n(SELECT * FROM china_point WHERE place='city' AND name = '南京市') p1 ,     \n(SELECT * FROM china_point WHERE place='city' AND name = '北京市') p2\n```\n\n结果：\n![](distance.png)\n\n\n```sql\nSELECT name, ST_AsText(ST_Transform(way,4326)) FROM china_point WHERE place='city';\n```\n\n结果：\n![](point.png)\n\n\n当然数据库的功能不局限于此，基于此数据库我们可以做些更有趣的事情，今后我们会慢慢探讨。\n\n\n\n## 参考文档\n[digoal的博客](https://github.com/digoal/blog/blob/master/201609/20160906_01.md)","slug":"osm-PostGIS-setup","published":1,"updated":"2019-03-12T12:05:52.070Z","_id":"cjt5pxo1y0002ul3i3521wrml","comments":1,"layout":"post","photos":[],"link":"","content":"<p>PostGIS是目前开源方案里面使用广泛的一种地理信息数据库，可玩性很强，实用性也很强，为了实现更多的地理信息操作，我们先来搭建一个简单的PostGIS数据库。</p>\n<a id=\"more\"></a>\n<h2 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h2><ol>\n<li>准备一个 CentOS 7.x x64 环境</li>\n<li>安装数据库 PostgreSQL 9.6</li>\n<li>安装对应版本的 PostGIS 2.2.2</li>\n<li>导入openstreetmap的中国区域数据</li>\n</ol>\n<h2 id=\"PostgreSQL-9-6\"><a href=\"#PostgreSQL-9-6\" class=\"headerlink\" title=\"PostgreSQL 9.6\"></a>PostgreSQL 9.6</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装数据库</span></span><br><span class=\"line\">yum install https://download.postgresql.org/pub/repos/yum/9.6/redhat/rhel-7-x86_64/pgdg-centos96-9.6-3.noarch.rpm</span><br><span class=\"line\"></span><br><span class=\"line\">yum install postgresql96</span><br><span class=\"line\"></span><br><span class=\"line\">yum install postgresql96-server</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化数据库及服务</span></span><br><span class=\"line\">/usr/pgsql-9.6/bin/postgresql96-setup initdb</span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> postgresql-9.6</span><br><span class=\"line\">systemctl start postgresql-9.6</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置环境变量</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=/usr/pgsql-9.6/bin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> LD_LIBRARY_PATH=/usr/pgsql-9.6/lib:<span class=\"variable\">$LD_LIBRARY_PATH</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PGDATA=/home/postgres/postgresql_data</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 以下可选</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 为数据库设置密码</span></span><br><span class=\"line\">su - postgres </span><br><span class=\"line\">psql</span><br><span class=\"line\">postgres=<span class=\"comment\"># ALTER USER postgres WITH PASSWORD 'postgres'; </span></span><br><span class=\"line\">postgres=<span class=\"comment\"># \\q</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开放防火墙端口</span></span><br><span class=\"line\">firewall-cmd --permanent --add-port=5432/tcp  </span><br><span class=\"line\">firewall-cmd --reload  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改配置文件允许外部使用密码访问</span></span><br><span class=\"line\">vim /var/lib/pgsql/9.6/data/postgresql.conf</span><br><span class=\"line\">listen_addresses = <span class=\"string\">'localhost'</span>  为  listen_addresses=<span class=\"string\">'*'</span></span><br><span class=\"line\"></span><br><span class=\"line\">vim /var/lib/pgsql/9.6/data/pg_hba.conf</span><br><span class=\"line\">host    all            all      0.0.0.0/0      md5</span><br></pre></td></tr></table></figure>\n<h2 id=\"PostGIS\"><a href=\"#PostGIS\" class=\"headerlink\" title=\"PostGIS\"></a>PostGIS</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装PostGIS</span></span><br><span class=\"line\">sudo yum -y install epel-release</span><br><span class=\"line\">sudo yum install postgis24_96</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化数据库osm</span></span><br><span class=\"line\">createdb osm</span><br><span class=\"line\"></span><br><span class=\"line\">psql -h 127.0.0.1 -d osm -U postgres -f /usr/pgsql-9.6/share/contrib/postgis-2.4/postgis.sql</span><br><span class=\"line\">psql -h 127.0.0.1 -d osm -U postgres -f /usr/pgsql-9.6/share/contrib/postgis-2.4/spatial_ref_sys.sql</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 可以基于osm创建china数据库（把osm作为一个可重复备份的库）</span></span><br><span class=\"line\">createdb -T osm china</span><br></pre></td></tr></table></figure>\n<h2 id=\"osm数据导入\"><a href=\"#osm数据导入\" class=\"headerlink\" title=\"osm数据导入\"></a>osm数据导入</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装导入工具osm2pgsql</span></span><br><span class=\"line\">yum install osm2pgsql</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载中国区域的公开数据</span></span><br><span class=\"line\">wget http://download.gisgraphy.com/openstreetmap/pbf/CN.tar.bz2   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 解压数据通过工具导入数据到china数据库</span></span><br><span class=\"line\">tar jxvf CN.tar.bz2</span><br><span class=\"line\">osm2pgsql -c -d china --slim -C 2000 -p china -r pbf /home/parallels/Downloads/CN</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>至此，我们已经基于osm的数据有了一个地理信息库，我们可以通过以下sql做一些简单的测试</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">name</span> <span class=\"keyword\">FROM</span> china_polygon <span class=\"keyword\">WHERE</span> <span class=\"keyword\">name</span> ~ <span class=\"string\">'南京'</span>;</span><br></pre></td></tr></table></figure>\n<p>结果：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"polygon.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> p1.name,p2.name,ST_Distance(p1.way,p2.way) <span class=\"keyword\">FROM</span>    </span><br><span class=\"line\">(<span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> china_point <span class=\"keyword\">WHERE</span> place=<span class=\"string\">'city'</span> <span class=\"keyword\">AND</span> <span class=\"keyword\">name</span> = <span class=\"string\">'南京市'</span>) p1 ,     </span><br><span class=\"line\">(<span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> china_point <span class=\"keyword\">WHERE</span> place=<span class=\"string\">'city'</span> <span class=\"keyword\">AND</span> <span class=\"keyword\">name</span> = <span class=\"string\">'北京市'</span>) p2</span><br></pre></td></tr></table></figure>\n<p>结果：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"distance.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">name</span>, ST_AsText(ST_Transform(way,<span class=\"number\">4326</span>)) <span class=\"keyword\">FROM</span> china_point <span class=\"keyword\">WHERE</span> place=<span class=\"string\">'city'</span>;</span><br></pre></td></tr></table></figure>\n<p>结果：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"point.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure></p>\n<p>当然数据库的功能不局限于此，基于此数据库我们可以做些更有趣的事情，今后我们会慢慢探讨。</p>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"https://github.com/digoal/blog/blob/master/201609/20160906_01.md\" target=\"_blank\" rel=\"noopener\">digoal的博客</a></p>\n","site":{"data":{}},"excerpt":"<p>PostGIS是目前开源方案里面使用广泛的一种地理信息数据库，可玩性很强，实用性也很强，为了实现更多的地理信息操作，我们先来搭建一个简单的PostGIS数据库。</p>","more":"<h2 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h2><ol>\n<li>准备一个 CentOS 7.x x64 环境</li>\n<li>安装数据库 PostgreSQL 9.6</li>\n<li>安装对应版本的 PostGIS 2.2.2</li>\n<li>导入openstreetmap的中国区域数据</li>\n</ol>\n<h2 id=\"PostgreSQL-9-6\"><a href=\"#PostgreSQL-9-6\" class=\"headerlink\" title=\"PostgreSQL 9.6\"></a>PostgreSQL 9.6</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装数据库</span></span><br><span class=\"line\">yum install https://download.postgresql.org/pub/repos/yum/9.6/redhat/rhel-7-x86_64/pgdg-centos96-9.6-3.noarch.rpm</span><br><span class=\"line\"></span><br><span class=\"line\">yum install postgresql96</span><br><span class=\"line\"></span><br><span class=\"line\">yum install postgresql96-server</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化数据库及服务</span></span><br><span class=\"line\">/usr/pgsql-9.6/bin/postgresql96-setup initdb</span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> postgresql-9.6</span><br><span class=\"line\">systemctl start postgresql-9.6</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置环境变量</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=/usr/pgsql-9.6/bin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> LD_LIBRARY_PATH=/usr/pgsql-9.6/lib:<span class=\"variable\">$LD_LIBRARY_PATH</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PGDATA=/home/postgres/postgresql_data</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 以下可选</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 为数据库设置密码</span></span><br><span class=\"line\">su - postgres </span><br><span class=\"line\">psql</span><br><span class=\"line\">postgres=<span class=\"comment\"># ALTER USER postgres WITH PASSWORD 'postgres'; </span></span><br><span class=\"line\">postgres=<span class=\"comment\"># \\q</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开放防火墙端口</span></span><br><span class=\"line\">firewall-cmd --permanent --add-port=5432/tcp  </span><br><span class=\"line\">firewall-cmd --reload  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改配置文件允许外部使用密码访问</span></span><br><span class=\"line\">vim /var/lib/pgsql/9.6/data/postgresql.conf</span><br><span class=\"line\">listen_addresses = <span class=\"string\">'localhost'</span>  为  listen_addresses=<span class=\"string\">'*'</span></span><br><span class=\"line\"></span><br><span class=\"line\">vim /var/lib/pgsql/9.6/data/pg_hba.conf</span><br><span class=\"line\">host    all            all      0.0.0.0/0      md5</span><br></pre></td></tr></table></figure>\n<h2 id=\"PostGIS\"><a href=\"#PostGIS\" class=\"headerlink\" title=\"PostGIS\"></a>PostGIS</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装PostGIS</span></span><br><span class=\"line\">sudo yum -y install epel-release</span><br><span class=\"line\">sudo yum install postgis24_96</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化数据库osm</span></span><br><span class=\"line\">createdb osm</span><br><span class=\"line\"></span><br><span class=\"line\">psql -h 127.0.0.1 -d osm -U postgres -f /usr/pgsql-9.6/share/contrib/postgis-2.4/postgis.sql</span><br><span class=\"line\">psql -h 127.0.0.1 -d osm -U postgres -f /usr/pgsql-9.6/share/contrib/postgis-2.4/spatial_ref_sys.sql</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 可以基于osm创建china数据库（把osm作为一个可重复备份的库）</span></span><br><span class=\"line\">createdb -T osm china</span><br></pre></td></tr></table></figure>\n<h2 id=\"osm数据导入\"><a href=\"#osm数据导入\" class=\"headerlink\" title=\"osm数据导入\"></a>osm数据导入</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装导入工具osm2pgsql</span></span><br><span class=\"line\">yum install osm2pgsql</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载中国区域的公开数据</span></span><br><span class=\"line\">wget http://download.gisgraphy.com/openstreetmap/pbf/CN.tar.bz2   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 解压数据通过工具导入数据到china数据库</span></span><br><span class=\"line\">tar jxvf CN.tar.bz2</span><br><span class=\"line\">osm2pgsql -c -d china --slim -C 2000 -p china -r pbf /home/parallels/Downloads/CN</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>至此，我们已经基于osm的数据有了一个地理信息库，我们可以通过以下sql做一些简单的测试</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">name</span> <span class=\"keyword\">FROM</span> china_polygon <span class=\"keyword\">WHERE</span> <span class=\"keyword\">name</span> ~ <span class=\"string\">'南京'</span>;</span><br></pre></td></tr></table></figure>\n<p>结果：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"polygon.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> p1.name,p2.name,ST_Distance(p1.way,p2.way) <span class=\"keyword\">FROM</span>    </span><br><span class=\"line\">(<span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> china_point <span class=\"keyword\">WHERE</span> place=<span class=\"string\">'city'</span> <span class=\"keyword\">AND</span> <span class=\"keyword\">name</span> = <span class=\"string\">'南京市'</span>) p1 ,     </span><br><span class=\"line\">(<span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> china_point <span class=\"keyword\">WHERE</span> place=<span class=\"string\">'city'</span> <span class=\"keyword\">AND</span> <span class=\"keyword\">name</span> = <span class=\"string\">'北京市'</span>) p2</span><br></pre></td></tr></table></figure>\n<p>结果：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"distance.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">name</span>, ST_AsText(ST_Transform(way,<span class=\"number\">4326</span>)) <span class=\"keyword\">FROM</span> china_point <span class=\"keyword\">WHERE</span> place=<span class=\"string\">'city'</span>;</span><br></pre></td></tr></table></figure>\n<p>结果：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"point.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure></p>\n<p>当然数据库的功能不局限于此，基于此数据库我们可以做些更有趣的事情，今后我们会慢慢探讨。</p>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"https://github.com/digoal/blog/blob/master/201609/20160906_01.md\" target=\"_blank\" rel=\"noopener\">digoal的博客</a></p>"},{"title":"【译】Vue中父子组件的生命周期函数","date":"2018-06-29T07:42:41.000Z","_content":"\n&nbsp;&nbsp;最近项目中遇到了\u001d地图模块挂载到DOM节点并进行初始化的问题，背后其实就是Vue中父子组件初始化的顺序问题，发现这篇文章的例子通俗易懂，遂翻译一下，如果错误还请指正。\n\n<!-- more -->\n\n[原文链接](https://medium.com/@brockreece/vue-parent-and-child-lifecycle-hooks-5d6236bd561f)\n\n\n如果你在项目中使用\bVue，那么我肯定你很熟悉组件生命周期内的钩子函数，但是你未必清楚父子组件内生命周期钩子触发的顺序和对属性（props）的影响\n\n<p style=\"text-align:center;\"><img src=\"lifecircle.png\" width=\"50%\" height=\"50%\"></p>\n\n## 父/子组件内的生命周期钩子\n\n下面的例子\b在父子组件的**Mounted**和**Created**两个钩子触发时会给出相应的提示。如你所见，**Created**是正常的先父后子的顺序触发，但**Mounted**钩子则正好相反\n\n<iframe src=\"https://codesandbox.io/embed/j38wnqjy65\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n一开始这可能很难很难理解，但如果我们通过逻辑的角度去遵循组件初始化工作流程，就能理解这种顺序。我们只要记住，父组件在其挂载template到DOM之前必须等待\b所有的子组件都完成挂载（mounted）操作。\n\n\n<p style=\"text-align:center;\"><img src=\"parent-child-hooks.png\" width=\"50%\" height=\"50%\"></p>\n\n若果你的组件通过属性（props）来通讯，以上钩子的执行顺序会很重要。\n\n## 属性（props）的响应式（reactivity）\n\n一个组件在**Created**钩子触发之前就可以是响应式的，这意味在其父组件的**Mounted**\b钩子触发之前它就能够开始追踪属性（props）的变化。如果你在父组件的**Mounted**钩子中去设置一些属性的值，你一定要牢记这一点。\n\n下面的例子展示了如果在父组件的**Created**和**Mounted**两个钩子中都去设置子组件的属性值会发生什么。如你所见，在子组件的**Mounted**钩子中我们监测到了两次对属性值的改变操作（个人补充：父组件\b**Mounted**\b之前的data里面对属性赋值触发了一次，父组件**Mounted**时候的改变属性值\b又让子组件触发了一次）\n\b\n<iframe src=\"https://codesandbox.io/embed/z2yonj9kq4\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n假设你的子组件在属性值改变的时候会进行一次Ajax请求，这样就会触发两次请求，甚至造成请求的未响应。\n\n## 总结\n\n如果你想深入的了解Vue的生命周期钩子，我强烈建议你读一下[这篇文章](https://alligator.io/vuejs/component-lifecycle/)。\n\n\n但通常来说，我建议如果你只在组件的**Mounted**钩子进行需要和DOM交互的操作，而其他的操作都放在**Created**钩子中\n\n\n### 个人总结\n\n从生命周期的角度来看： 父 Created - 子 Created - 子 Mounted - 父 Mounted\n对应过程Props的改变： 子 prop 改变 --------- 子 prop 改变 --------- 子 prop 改变  ","source":"_posts/Vue-Parent-and-Child-lifecycle-hooks.md","raw":"---\ntitle: 【译】Vue中父子组件的生命周期函数\ndate: 2018-6-29 15:42:41\ntags: [FE,Vue]\ncategories: 前端\n---\n\n&nbsp;&nbsp;最近项目中遇到了\u001d地图模块挂载到DOM节点并进行初始化的问题，背后其实就是Vue中父子组件初始化的顺序问题，发现这篇文章的例子通俗易懂，遂翻译一下，如果错误还请指正。\n\n<!-- more -->\n\n[原文链接](https://medium.com/@brockreece/vue-parent-and-child-lifecycle-hooks-5d6236bd561f)\n\n\n如果你在项目中使用\bVue，那么我肯定你很熟悉组件生命周期内的钩子函数，但是你未必清楚父子组件内生命周期钩子触发的顺序和对属性（props）的影响\n\n<p style=\"text-align:center;\"><img src=\"lifecircle.png\" width=\"50%\" height=\"50%\"></p>\n\n## 父/子组件内的生命周期钩子\n\n下面的例子\b在父子组件的**Mounted**和**Created**两个钩子触发时会给出相应的提示。如你所见，**Created**是正常的先父后子的顺序触发，但**Mounted**钩子则正好相反\n\n<iframe src=\"https://codesandbox.io/embed/j38wnqjy65\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n一开始这可能很难很难理解，但如果我们通过逻辑的角度去遵循组件初始化工作流程，就能理解这种顺序。我们只要记住，父组件在其挂载template到DOM之前必须等待\b所有的子组件都完成挂载（mounted）操作。\n\n\n<p style=\"text-align:center;\"><img src=\"parent-child-hooks.png\" width=\"50%\" height=\"50%\"></p>\n\n若果你的组件通过属性（props）来通讯，以上钩子的执行顺序会很重要。\n\n## 属性（props）的响应式（reactivity）\n\n一个组件在**Created**钩子触发之前就可以是响应式的，这意味在其父组件的**Mounted**\b钩子触发之前它就能够开始追踪属性（props）的变化。如果你在父组件的**Mounted**钩子中去设置一些属性的值，你一定要牢记这一点。\n\n下面的例子展示了如果在父组件的**Created**和**Mounted**两个钩子中都去设置子组件的属性值会发生什么。如你所见，在子组件的**Mounted**钩子中我们监测到了两次对属性值的改变操作（个人补充：父组件\b**Mounted**\b之前的data里面对属性赋值触发了一次，父组件**Mounted**时候的改变属性值\b又让子组件触发了一次）\n\b\n<iframe src=\"https://codesandbox.io/embed/z2yonj9kq4\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n假设你的子组件在属性值改变的时候会进行一次Ajax请求，这样就会触发两次请求，甚至造成请求的未响应。\n\n## 总结\n\n如果你想深入的了解Vue的生命周期钩子，我强烈建议你读一下[这篇文章](https://alligator.io/vuejs/component-lifecycle/)。\n\n\n但通常来说，我建议如果你只在组件的**Mounted**钩子进行需要和DOM交互的操作，而其他的操作都放在**Created**钩子中\n\n\n### 个人总结\n\n从生命周期的角度来看： 父 Created - 子 Created - 子 Mounted - 父 Mounted\n对应过程Props的改变： 子 prop 改变 --------- 子 prop 改变 --------- 子 prop 改变  ","slug":"Vue-Parent-and-Child-lifecycle-hooks","published":1,"updated":"2019-01-30T07:29:03.649Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5pxo220006ul3ifej2t5yd","content":"<p>&nbsp;&nbsp;最近项目中遇到了\u001d地图模块挂载到DOM节点并进行初始化的问题，背后其实就是Vue中父子组件初始化的顺序问题，发现这篇文章的例子通俗易懂，遂翻译一下，如果错误还请指正。</p>\n<a id=\"more\"></a>\n<p><a href=\"https://medium.com/@brockreece/vue-parent-and-child-lifecycle-hooks-5d6236bd561f\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<p>如果你在项目中使用\bVue，那么我肯定你很熟悉组件生命周期内的钩子函数，但是你未必清楚父子组件内生命周期钩子触发的顺序和对属性（props）的影响</p>\n<p style=\"text-align:center;\"><img src=\"lifecircle.png\" width=\"50%\" height=\"50%\"></p>\n\n<h2 id=\"父-子组件内的生命周期钩子\"><a href=\"#父-子组件内的生命周期钩子\" class=\"headerlink\" title=\"父/子组件内的生命周期钩子\"></a>父/子组件内的生命周期钩子</h2><p>下面的例子\b在父子组件的<strong>Mounted</strong>和<strong>Created</strong>两个钩子触发时会给出相应的提示。如你所见，<strong>Created</strong>是正常的先父后子的顺序触发，但<strong>Mounted</strong>钩子则正好相反</p>\n<iframe src=\"https://codesandbox.io/embed/j38wnqjy65\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n<p>一开始这可能很难很难理解，但如果我们通过逻辑的角度去遵循组件初始化工作流程，就能理解这种顺序。我们只要记住，父组件在其挂载template到DOM之前必须等待\b所有的子组件都完成挂载（mounted）操作。</p>\n<p style=\"text-align:center;\"><img src=\"parent-child-hooks.png\" width=\"50%\" height=\"50%\"></p>\n\n<p>若果你的组件通过属性（props）来通讯，以上钩子的执行顺序会很重要。</p>\n<h2 id=\"属性（props）的响应式（reactivity）\"><a href=\"#属性（props）的响应式（reactivity）\" class=\"headerlink\" title=\"属性（props）的响应式（reactivity）\"></a>属性（props）的响应式（reactivity）</h2><p>一个组件在<strong>Created</strong>钩子触发之前就可以是响应式的，这意味在其父组件的<strong>Mounted</strong>\b钩子触发之前它就能够开始追踪属性（props）的变化。如果你在父组件的<strong>Mounted</strong>钩子中去设置一些属性的值，你一定要牢记这一点。</p>\n<p>下面的例子展示了如果在父组件的<strong>Created</strong>和<strong>Mounted</strong>两个钩子中都去设置子组件的属性值会发生什么。如你所见，在子组件的<strong>Mounted</strong>钩子中我们监测到了两次对属性值的改变操作（个人补充：父组件\b<strong>Mounted</strong>\b之前的data里面对属性赋值触发了一次，父组件<strong>Mounted</strong>时候的改变属性值\b又让子组件触发了一次）<br>\b</p>\n<iframe src=\"https://codesandbox.io/embed/z2yonj9kq4\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n<p>假设你的子组件在属性值改变的时候会进行一次Ajax请求，这样就会触发两次请求，甚至造成请求的未响应。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>如果你想深入的了解Vue的生命周期钩子，我强烈建议你读一下<a href=\"https://alligator.io/vuejs/component-lifecycle/\" target=\"_blank\" rel=\"noopener\">这篇文章</a>。</p>\n<p>但通常来说，我建议如果你只在组件的<strong>Mounted</strong>钩子进行需要和DOM交互的操作，而其他的操作都放在<strong>Created</strong>钩子中</p>\n<h3 id=\"个人总结\"><a href=\"#个人总结\" class=\"headerlink\" title=\"个人总结\"></a>个人总结</h3><p>从生命周期的角度来看： 父 Created - 子 Created - 子 Mounted - 父 Mounted<br>对应过程Props的改变： 子 prop 改变 ——— 子 prop 改变 ——— 子 prop 改变  </p>\n","site":{"data":{}},"excerpt":"<p>&nbsp;&nbsp;最近项目中遇到了\u001d地图模块挂载到DOM节点并进行初始化的问题，背后其实就是Vue中父子组件初始化的顺序问题，发现这篇文章的例子通俗易懂，遂翻译一下，如果错误还请指正。</p>","more":"<p><a href=\"https://medium.com/@brockreece/vue-parent-and-child-lifecycle-hooks-5d6236bd561f\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<p>如果你在项目中使用\bVue，那么我肯定你很熟悉组件生命周期内的钩子函数，但是你未必清楚父子组件内生命周期钩子触发的顺序和对属性（props）的影响</p>\n<p style=\"text-align:center;\"><img src=\"lifecircle.png\" width=\"50%\" height=\"50%\"></p>\n\n<h2 id=\"父-子组件内的生命周期钩子\"><a href=\"#父-子组件内的生命周期钩子\" class=\"headerlink\" title=\"父/子组件内的生命周期钩子\"></a>父/子组件内的生命周期钩子</h2><p>下面的例子\b在父子组件的<strong>Mounted</strong>和<strong>Created</strong>两个钩子触发时会给出相应的提示。如你所见，<strong>Created</strong>是正常的先父后子的顺序触发，但<strong>Mounted</strong>钩子则正好相反</p>\n<iframe src=\"https://codesandbox.io/embed/j38wnqjy65\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n<p>一开始这可能很难很难理解，但如果我们通过逻辑的角度去遵循组件初始化工作流程，就能理解这种顺序。我们只要记住，父组件在其挂载template到DOM之前必须等待\b所有的子组件都完成挂载（mounted）操作。</p>\n<p style=\"text-align:center;\"><img src=\"parent-child-hooks.png\" width=\"50%\" height=\"50%\"></p>\n\n<p>若果你的组件通过属性（props）来通讯，以上钩子的执行顺序会很重要。</p>\n<h2 id=\"属性（props）的响应式（reactivity）\"><a href=\"#属性（props）的响应式（reactivity）\" class=\"headerlink\" title=\"属性（props）的响应式（reactivity）\"></a>属性（props）的响应式（reactivity）</h2><p>一个组件在<strong>Created</strong>钩子触发之前就可以是响应式的，这意味在其父组件的<strong>Mounted</strong>\b钩子触发之前它就能够开始追踪属性（props）的变化。如果你在父组件的<strong>Mounted</strong>钩子中去设置一些属性的值，你一定要牢记这一点。</p>\n<p>下面的例子展示了如果在父组件的<strong>Created</strong>和<strong>Mounted</strong>两个钩子中都去设置子组件的属性值会发生什么。如你所见，在子组件的<strong>Mounted</strong>钩子中我们监测到了两次对属性值的改变操作（个人补充：父组件\b<strong>Mounted</strong>\b之前的data里面对属性赋值触发了一次，父组件<strong>Mounted</strong>时候的改变属性值\b又让子组件触发了一次）<br>\b</p>\n<iframe src=\"https://codesandbox.io/embed/z2yonj9kq4\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n<p>假设你的子组件在属性值改变的时候会进行一次Ajax请求，这样就会触发两次请求，甚至造成请求的未响应。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>如果你想深入的了解Vue的生命周期钩子，我强烈建议你读一下<a href=\"https://alligator.io/vuejs/component-lifecycle/\" target=\"_blank\" rel=\"noopener\">这篇文章</a>。</p>\n<p>但通常来说，我建议如果你只在组件的<strong>Mounted</strong>钩子进行需要和DOM交互的操作，而其他的操作都放在<strong>Created</strong>钩子中</p>\n<h3 id=\"个人总结\"><a href=\"#个人总结\" class=\"headerlink\" title=\"个人总结\"></a>个人总结</h3><p>从生命周期的角度来看： 父 Created - 子 Created - 子 Mounted - 父 Mounted<br>对应过程Props的改变： 子 prop 改变 ——— 子 prop 改变 ——— 子 prop 改变  </p>"},{"title":"Leaflet常用的一些插件","date":"2017-09-17T05:48:15.000Z","_content":"\n\n\n\nLeaflet中常用的gis功能可以满足一般使用，有些特殊需求，官方也有[插件系统](http://leafletjs.com/plugins.html)，本文会挑选一些常用的，经过测试可用的插件单独放出来使用方法和一些注意事项，希望能够帮助到同僚们。\n\n\n<!-- more -->\n\n[Leaflet系列地址](https://github.com/zzcyrus/Leaflet-demos)\n[本文demo地址](https://github.com/zzcyrus/Leaflet-demos/blob/master/1.plugins/plugins.html)\n\n\n# ImageWMS\n\n&nbsp;&nbsp;在openlayers中，wms图层的调用了提供了IamgeWMS和tileWMS两种方式，通常情况下，如果wms服务作为底图，由于数据量大，我们采用瓦片的方式加载十分有利，如果数据量小，我们采用单张image的方式无论从请求发送上和显示的效果上都更好。\n![](tileWMS.png)\n&nbsp;&nbsp;~~可以发现，瓦片会发出多次请求，每次请求都会包含该瓦片上涉及到的信息，数据量小十分没必要~~\n\n\n&nbsp;&nbsp;Leaflet中只提供了tile瓦片的方式加载WMS图层，在使用了很多第三方解决方案后，我发现了这款插件[nonTiledLayer](https://github.com/ptv-logistics/Leaflet.NonTiledLayer)，使用之后的效果基本上可以达到openlaysers中的要求，更多情况可以点击链接进去了解。\n\n调用方式\n````js\n    var layer = L.nonTiledLayer.wms(url, {\n        maxZoom: 19,\n        minZoom: 0,\n        opacity: 1.0,\n        layers: 'xmap-gravelpit-fg',\n        format: 'image/png',\n        transparent: true,\n        attribution: '',\n        pane: 'tilePane',\n        zIndex: 3\n    }).addTo(map);\n````\n[nonTiledLayer](https://github.com/ptv-logistics/Leaflet.NonTiledLayer)调用方式基本沿用Leaflet自身的wms调用，提供的属性也很全面\n\n````\n    attribution - 图层数据来源.Default:'\n    opacity - 透明度.Default: 1\n    minZoom - 最小缩放. Default: 0\n    maxZoom - 最大缩放. Default: 18\n    bounds - 边界条件. Default: L.latLngBounds([-180, -85.05], [180, 85.05])\n    zIndex - 位置. Default: undefined\n    pane - 插入的div的名称. Default: 'overlayPane'\n    pointerEvents - 鼠标事件的样式. Default: null\n    errorImageUrl - 默认错误图层. Default: 1px transparent gif data:image/gif;base64,R0lGODlhAQABAHAAACH5BAUAAAAALAAAAAABAAEAAAICRAEAOw==\n    useCanvas - 渲染方式. Default: undefined\n````\n\n具体的使用效果可以移步demo\n\n\n# WKT数据插件\n\n&nbsp;&nbsp;wkt作为GIS常用的一种地理数据格式，因为通用性需求度也很高,Leaflet官方插件中提供了许多支持wkt的第三方解决方案，使用下来，发现mapbox出品的[leaflet-omnivore](https://github.com/mapbox/leaflet-omnivore)效果可以说是目前最满足要求的了。\n\n`omnivore`支持的功能比较强大\n````js\n    omnivore.csv('a.csv').addTo(map);\n    omnivore.gpx('a.gpx').addTo(map);\n    omnivore.kml('a.kml').addTo(map);\n    omnivore.wkt('a.wkt').addTo(map);\n    omnivore.topojson('a.topojson').addTo(map);\n    omnivore.geojson('a.geojson').addTo(map);\n    omnivore.polyline('a.txt').addTo(map);\n````\n\n其中对于wkt的加载有两种方式。\n其中，`customlayer`是通过`L.geojson`图层来为加载进来的wkt数据设置样式\n````js\n    let customLayer = L.geoJson(null, {\n        style: function () {\n            return {color: \"#0ff\"};\n        }\n    });\n\n````\n\n* `omnivore.wkt(url, parser_options?, customLayer?)`: 通过url加载\n\n* `omnivore.wkt.parse(wktString，parser_options?, customLayer?)`: 通过转换wkt字符串加载\n\n\n具体的使用效果可以移步[demo](https://github.com/zzcyrus/Leaflet-demos/blob/master/1.plugins/plugins.html)","source":"_posts/plugins.md","raw":"---\ntitle: Leaflet常用的一些插件\ndate: 2017-09-17 13:48:15\ntags: [FE,GIS,Leaflet]\ncategories: Leaflet\n---\n\n\n\n\nLeaflet中常用的gis功能可以满足一般使用，有些特殊需求，官方也有[插件系统](http://leafletjs.com/plugins.html)，本文会挑选一些常用的，经过测试可用的插件单独放出来使用方法和一些注意事项，希望能够帮助到同僚们。\n\n\n<!-- more -->\n\n[Leaflet系列地址](https://github.com/zzcyrus/Leaflet-demos)\n[本文demo地址](https://github.com/zzcyrus/Leaflet-demos/blob/master/1.plugins/plugins.html)\n\n\n# ImageWMS\n\n&nbsp;&nbsp;在openlayers中，wms图层的调用了提供了IamgeWMS和tileWMS两种方式，通常情况下，如果wms服务作为底图，由于数据量大，我们采用瓦片的方式加载十分有利，如果数据量小，我们采用单张image的方式无论从请求发送上和显示的效果上都更好。\n![](tileWMS.png)\n&nbsp;&nbsp;~~可以发现，瓦片会发出多次请求，每次请求都会包含该瓦片上涉及到的信息，数据量小十分没必要~~\n\n\n&nbsp;&nbsp;Leaflet中只提供了tile瓦片的方式加载WMS图层，在使用了很多第三方解决方案后，我发现了这款插件[nonTiledLayer](https://github.com/ptv-logistics/Leaflet.NonTiledLayer)，使用之后的效果基本上可以达到openlaysers中的要求，更多情况可以点击链接进去了解。\n\n调用方式\n````js\n    var layer = L.nonTiledLayer.wms(url, {\n        maxZoom: 19,\n        minZoom: 0,\n        opacity: 1.0,\n        layers: 'xmap-gravelpit-fg',\n        format: 'image/png',\n        transparent: true,\n        attribution: '',\n        pane: 'tilePane',\n        zIndex: 3\n    }).addTo(map);\n````\n[nonTiledLayer](https://github.com/ptv-logistics/Leaflet.NonTiledLayer)调用方式基本沿用Leaflet自身的wms调用，提供的属性也很全面\n\n````\n    attribution - 图层数据来源.Default:'\n    opacity - 透明度.Default: 1\n    minZoom - 最小缩放. Default: 0\n    maxZoom - 最大缩放. Default: 18\n    bounds - 边界条件. Default: L.latLngBounds([-180, -85.05], [180, 85.05])\n    zIndex - 位置. Default: undefined\n    pane - 插入的div的名称. Default: 'overlayPane'\n    pointerEvents - 鼠标事件的样式. Default: null\n    errorImageUrl - 默认错误图层. Default: 1px transparent gif data:image/gif;base64,R0lGODlhAQABAHAAACH5BAUAAAAALAAAAAABAAEAAAICRAEAOw==\n    useCanvas - 渲染方式. Default: undefined\n````\n\n具体的使用效果可以移步demo\n\n\n# WKT数据插件\n\n&nbsp;&nbsp;wkt作为GIS常用的一种地理数据格式，因为通用性需求度也很高,Leaflet官方插件中提供了许多支持wkt的第三方解决方案，使用下来，发现mapbox出品的[leaflet-omnivore](https://github.com/mapbox/leaflet-omnivore)效果可以说是目前最满足要求的了。\n\n`omnivore`支持的功能比较强大\n````js\n    omnivore.csv('a.csv').addTo(map);\n    omnivore.gpx('a.gpx').addTo(map);\n    omnivore.kml('a.kml').addTo(map);\n    omnivore.wkt('a.wkt').addTo(map);\n    omnivore.topojson('a.topojson').addTo(map);\n    omnivore.geojson('a.geojson').addTo(map);\n    omnivore.polyline('a.txt').addTo(map);\n````\n\n其中对于wkt的加载有两种方式。\n其中，`customlayer`是通过`L.geojson`图层来为加载进来的wkt数据设置样式\n````js\n    let customLayer = L.geoJson(null, {\n        style: function () {\n            return {color: \"#0ff\"};\n        }\n    });\n\n````\n\n* `omnivore.wkt(url, parser_options?, customLayer?)`: 通过url加载\n\n* `omnivore.wkt.parse(wktString，parser_options?, customLayer?)`: 通过转换wkt字符串加载\n\n\n具体的使用效果可以移步[demo](https://github.com/zzcyrus/Leaflet-demos/blob/master/1.plugins/plugins.html)","slug":"plugins","published":1,"updated":"2019-01-30T07:29:03.652Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5pxo250007ul3i0qzsooqs","content":"<p>Leaflet中常用的gis功能可以满足一般使用，有些特殊需求，官方也有<a href=\"http://leafletjs.com/plugins.html\" target=\"_blank\" rel=\"noopener\">插件系统</a>，本文会挑选一些常用的，经过测试可用的插件单独放出来使用方法和一些注意事项，希望能够帮助到同僚们。</p>\n<a id=\"more\"></a>\n<p><a href=\"https://github.com/zzcyrus/Leaflet-demos\" target=\"_blank\" rel=\"noopener\">Leaflet系列地址</a><br><a href=\"https://github.com/zzcyrus/Leaflet-demos/blob/master/1.plugins/plugins.html\" target=\"_blank\" rel=\"noopener\">本文demo地址</a></p>\n<h1 id=\"ImageWMS\"><a href=\"#ImageWMS\" class=\"headerlink\" title=\"ImageWMS\"></a>ImageWMS</h1><p>&nbsp;&nbsp;在openlayers中，wms图层的调用了提供了IamgeWMS和tileWMS两种方式，通常情况下，如果wms服务作为底图，由于数据量大，我们采用瓦片的方式加载十分有利，如果数据量小，我们采用单张image的方式无论从请求发送上和显示的效果上都更好。<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"tileWMS.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure><br>&nbsp;&nbsp;<del>可以发现，瓦片会发出多次请求，每次请求都会包含该瓦片上涉及到的信息，数据量小十分没必要</del></p>\n<p>&nbsp;&nbsp;Leaflet中只提供了tile瓦片的方式加载WMS图层，在使用了很多第三方解决方案后，我发现了这款插件<a href=\"https://github.com/ptv-logistics/Leaflet.NonTiledLayer\" target=\"_blank\" rel=\"noopener\">nonTiledLayer</a>，使用之后的效果基本上可以达到openlaysers中的要求，更多情况可以点击链接进去了解。</p>\n<p>调用方式<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> layer = L.nonTiledLayer.wms(url, &#123;</span><br><span class=\"line\">    maxZoom: <span class=\"number\">19</span>,</span><br><span class=\"line\">    minZoom: <span class=\"number\">0</span>,</span><br><span class=\"line\">    opacity: <span class=\"number\">1.0</span>,</span><br><span class=\"line\">    layers: <span class=\"string\">'xmap-gravelpit-fg'</span>,</span><br><span class=\"line\">    format: <span class=\"string\">'image/png'</span>,</span><br><span class=\"line\">    transparent: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    attribution: <span class=\"string\">''</span>,</span><br><span class=\"line\">    pane: <span class=\"string\">'tilePane'</span>,</span><br><span class=\"line\">    zIndex: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;).addTo(map);</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://github.com/ptv-logistics/Leaflet.NonTiledLayer\" target=\"_blank\" rel=\"noopener\">nonTiledLayer</a>调用方式基本沿用Leaflet自身的wms调用，提供的属性也很全面</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">attribution - 图层数据来源.Default:&apos;</span><br><span class=\"line\">opacity - 透明度.Default: 1</span><br><span class=\"line\">minZoom - 最小缩放. Default: 0</span><br><span class=\"line\">maxZoom - 最大缩放. Default: 18</span><br><span class=\"line\">bounds - 边界条件. Default: L.latLngBounds([-180, -85.05], [180, 85.05])</span><br><span class=\"line\">zIndex - 位置. Default: undefined</span><br><span class=\"line\">pane - 插入的div的名称. Default: &apos;overlayPane&apos;</span><br><span class=\"line\">pointerEvents - 鼠标事件的样式. Default: null</span><br><span class=\"line\">errorImageUrl - 默认错误图层. Default: 1px transparent gif data:image/gif;base64,R0lGODlhAQABAHAAACH5BAUAAAAALAAAAAABAAEAAAICRAEAOw==</span><br><span class=\"line\">useCanvas - 渲染方式. Default: undefined</span><br></pre></td></tr></table></figure>\n<p>具体的使用效果可以移步demo</p>\n<h1 id=\"WKT数据插件\"><a href=\"#WKT数据插件\" class=\"headerlink\" title=\"WKT数据插件\"></a>WKT数据插件</h1><p>&nbsp;&nbsp;wkt作为GIS常用的一种地理数据格式，因为通用性需求度也很高,Leaflet官方插件中提供了许多支持wkt的第三方解决方案，使用下来，发现mapbox出品的<a href=\"https://github.com/mapbox/leaflet-omnivore\" target=\"_blank\" rel=\"noopener\">leaflet-omnivore</a>效果可以说是目前最满足要求的了。</p>\n<p><code>omnivore</code>支持的功能比较强大<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">omnivore.csv(<span class=\"string\">'a.csv'</span>).addTo(map);</span><br><span class=\"line\">omnivore.gpx(<span class=\"string\">'a.gpx'</span>).addTo(map);</span><br><span class=\"line\">omnivore.kml(<span class=\"string\">'a.kml'</span>).addTo(map);</span><br><span class=\"line\">omnivore.wkt(<span class=\"string\">'a.wkt'</span>).addTo(map);</span><br><span class=\"line\">omnivore.topojson(<span class=\"string\">'a.topojson'</span>).addTo(map);</span><br><span class=\"line\">omnivore.geojson(<span class=\"string\">'a.geojson'</span>).addTo(map);</span><br><span class=\"line\">omnivore.polyline(<span class=\"string\">'a.txt'</span>).addTo(map);</span><br></pre></td></tr></table></figure></p>\n<p>其中对于wkt的加载有两种方式。<br>其中，<code>customlayer</code>是通过<code>L.geojson</code>图层来为加载进来的wkt数据设置样式<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> customLayer = L.geoJson(<span class=\"literal\">null</span>, &#123;</span><br><span class=\"line\">    style: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;<span class=\"attr\">color</span>: <span class=\"string\">\"#0ff\"</span>&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p><code>omnivore.wkt(url, parser_options?, customLayer?)</code>: 通过url加载</p>\n</li>\n<li><p><code>omnivore.wkt.parse(wktString，parser_options?, customLayer?)</code>: 通过转换wkt字符串加载</p>\n</li>\n</ul>\n<p>具体的使用效果可以移步<a href=\"https://github.com/zzcyrus/Leaflet-demos/blob/master/1.plugins/plugins.html\" target=\"_blank\" rel=\"noopener\">demo</a></p>\n","site":{"data":{}},"excerpt":"<p>Leaflet中常用的gis功能可以满足一般使用，有些特殊需求，官方也有<a href=\"http://leafletjs.com/plugins.html\" target=\"_blank\" rel=\"noopener\">插件系统</a>，本文会挑选一些常用的，经过测试可用的插件单独放出来使用方法和一些注意事项，希望能够帮助到同僚们。</p>","more":"<p><a href=\"https://github.com/zzcyrus/Leaflet-demos\" target=\"_blank\" rel=\"noopener\">Leaflet系列地址</a><br><a href=\"https://github.com/zzcyrus/Leaflet-demos/blob/master/1.plugins/plugins.html\" target=\"_blank\" rel=\"noopener\">本文demo地址</a></p>\n<h1 id=\"ImageWMS\"><a href=\"#ImageWMS\" class=\"headerlink\" title=\"ImageWMS\"></a>ImageWMS</h1><p>&nbsp;&nbsp;在openlayers中，wms图层的调用了提供了IamgeWMS和tileWMS两种方式，通常情况下，如果wms服务作为底图，由于数据量大，我们采用瓦片的方式加载十分有利，如果数据量小，我们采用单张image的方式无论从请求发送上和显示的效果上都更好。<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"tileWMS.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure><br>&nbsp;&nbsp;<del>可以发现，瓦片会发出多次请求，每次请求都会包含该瓦片上涉及到的信息，数据量小十分没必要</del></p>\n<p>&nbsp;&nbsp;Leaflet中只提供了tile瓦片的方式加载WMS图层，在使用了很多第三方解决方案后，我发现了这款插件<a href=\"https://github.com/ptv-logistics/Leaflet.NonTiledLayer\" target=\"_blank\" rel=\"noopener\">nonTiledLayer</a>，使用之后的效果基本上可以达到openlaysers中的要求，更多情况可以点击链接进去了解。</p>\n<p>调用方式<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> layer = L.nonTiledLayer.wms(url, &#123;</span><br><span class=\"line\">    maxZoom: <span class=\"number\">19</span>,</span><br><span class=\"line\">    minZoom: <span class=\"number\">0</span>,</span><br><span class=\"line\">    opacity: <span class=\"number\">1.0</span>,</span><br><span class=\"line\">    layers: <span class=\"string\">'xmap-gravelpit-fg'</span>,</span><br><span class=\"line\">    format: <span class=\"string\">'image/png'</span>,</span><br><span class=\"line\">    transparent: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    attribution: <span class=\"string\">''</span>,</span><br><span class=\"line\">    pane: <span class=\"string\">'tilePane'</span>,</span><br><span class=\"line\">    zIndex: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;).addTo(map);</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://github.com/ptv-logistics/Leaflet.NonTiledLayer\" target=\"_blank\" rel=\"noopener\">nonTiledLayer</a>调用方式基本沿用Leaflet自身的wms调用，提供的属性也很全面</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">attribution - 图层数据来源.Default:&apos;</span><br><span class=\"line\">opacity - 透明度.Default: 1</span><br><span class=\"line\">minZoom - 最小缩放. Default: 0</span><br><span class=\"line\">maxZoom - 最大缩放. Default: 18</span><br><span class=\"line\">bounds - 边界条件. Default: L.latLngBounds([-180, -85.05], [180, 85.05])</span><br><span class=\"line\">zIndex - 位置. Default: undefined</span><br><span class=\"line\">pane - 插入的div的名称. Default: &apos;overlayPane&apos;</span><br><span class=\"line\">pointerEvents - 鼠标事件的样式. Default: null</span><br><span class=\"line\">errorImageUrl - 默认错误图层. Default: 1px transparent gif data:image/gif;base64,R0lGODlhAQABAHAAACH5BAUAAAAALAAAAAABAAEAAAICRAEAOw==</span><br><span class=\"line\">useCanvas - 渲染方式. Default: undefined</span><br></pre></td></tr></table></figure>\n<p>具体的使用效果可以移步demo</p>\n<h1 id=\"WKT数据插件\"><a href=\"#WKT数据插件\" class=\"headerlink\" title=\"WKT数据插件\"></a>WKT数据插件</h1><p>&nbsp;&nbsp;wkt作为GIS常用的一种地理数据格式，因为通用性需求度也很高,Leaflet官方插件中提供了许多支持wkt的第三方解决方案，使用下来，发现mapbox出品的<a href=\"https://github.com/mapbox/leaflet-omnivore\" target=\"_blank\" rel=\"noopener\">leaflet-omnivore</a>效果可以说是目前最满足要求的了。</p>\n<p><code>omnivore</code>支持的功能比较强大<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">omnivore.csv(<span class=\"string\">'a.csv'</span>).addTo(map);</span><br><span class=\"line\">omnivore.gpx(<span class=\"string\">'a.gpx'</span>).addTo(map);</span><br><span class=\"line\">omnivore.kml(<span class=\"string\">'a.kml'</span>).addTo(map);</span><br><span class=\"line\">omnivore.wkt(<span class=\"string\">'a.wkt'</span>).addTo(map);</span><br><span class=\"line\">omnivore.topojson(<span class=\"string\">'a.topojson'</span>).addTo(map);</span><br><span class=\"line\">omnivore.geojson(<span class=\"string\">'a.geojson'</span>).addTo(map);</span><br><span class=\"line\">omnivore.polyline(<span class=\"string\">'a.txt'</span>).addTo(map);</span><br></pre></td></tr></table></figure></p>\n<p>其中对于wkt的加载有两种方式。<br>其中，<code>customlayer</code>是通过<code>L.geojson</code>图层来为加载进来的wkt数据设置样式<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> customLayer = L.geoJson(<span class=\"literal\">null</span>, &#123;</span><br><span class=\"line\">    style: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;<span class=\"attr\">color</span>: <span class=\"string\">\"#0ff\"</span>&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p><code>omnivore.wkt(url, parser_options?, customLayer?)</code>: 通过url加载</p>\n</li>\n<li><p><code>omnivore.wkt.parse(wktString，parser_options?, customLayer?)</code>: 通过转换wkt字符串加载</p>\n</li>\n</ul>\n<p>具体的使用效果可以移步<a href=\"https://github.com/zzcyrus/Leaflet-demos/blob/master/1.plugins/plugins.html\" target=\"_blank\" rel=\"noopener\">demo</a></p>"},{"title":"Leaflet多种基础图层加载","date":"2017-09-17T05:46:08.000Z","_content":"\n\n\n\n&nbsp;&nbsp;最近项目中有移动端的开发需求，自然就用到了最轻量级的gis组件——Leaflet，100多k的体积，五脏俱全，丰富的第三方插件，虽然开发者数量上不及大哥级产品Arcigs，但也基本够用，对于esri的自家系统支持好，svg和canvas两种渲染方式，让数据量大的要素图层渲染也不是那么吃力。\n\n&nbsp;&nbsp;这里把自己对于Leaflet的一些探索研究记录一下，一方面便于自己后期回顾，另一方面也希望和大家一起探讨学习。\n\n<!-- more -->\n\n[Leaflet系列地址](https://github.com/zzcyrus/Leaflet-demos)\n[本文demo地址](https://github.com/zzcyrus/Leaflet-demos/blob/master/0.basemap/basemap.html)\n\n# 基础图层的加载\n\n基础图层的加载都是通过`L.tileLayer`的方式，所以加载的难点不在于api的使用，是一些常用的基础瓦片的收集，这里给出一些常用的地址\n\n````js\n\n    mapRadios: [\n        {\n            label: '高德地图',\n            value: '1',\n            url: 'http://webrd01.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x={x}&y={y}&z={z}'\n        }, {\n            label: 'Esri地图',\n            value: '2',\n            url: 'http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineCommunity/MapServer/tile/{z}/{y}/{x}'\n        }, {\n            label: '天地图道路',\n            value: '3',\n            url: 'http://t0.tianditu.cn/DataServer?T=vec_w&X={x}&Y={y}&L={z}'\n        }, {\n            label: '天地图标注',\n            value: '4',\n            url: 'http://t5.tianditu.cn/DataServer?T=cva_w&X={x}&Y={y}&L={z}'\n        }, {\n            label: '天地图影像',\n            value: '5',\n            url: 'http://t1.tianditu.cn/img_w/wmts?service=wmts&request=GetTile&version=1.0.0&LAYER=img&tileMatrixSet=w&TileMatrix={z}&TileRow={y}&TileCol={x}&style=default&format=tiles'\n        }, {\n            label: '谷歌地形',\n            value: '6',\n            url: 'http://mt3.google.cn/vt/lyrs=t@131&hl=zh-CN&gl=cn&x={x}&y={y}&z={z}&s=Ga'\n        }, {\n            label: '谷歌影像',\n            value: '7',\n            url: 'http://mt3.google.cn/vt/lyrs=s&hl=zh-CN&gl=cn&x={x}&y={y}&z={z}'\n        }, {\n            label: '谷歌标注',\n            value: '8',\n            url: 'http://mt2.google.cn/vt/lyrs=m@167000000&hl=zh-CN&gl=cn&x={x}&y={y}&z={z}'\n        }\n    ]\n````\n\n\n更多的瓦片地址可以在demo中找到，具体的使用效果也可以移步[demo](https://github.com/zzcyrus/Leaflet-demos/blob/master/0.basemap/basemap.html)\n\n\n\n","source":"_posts/basemap.md","raw":"---\ntitle: Leaflet多种基础图层加载\ndate: 2017-09-17 13:46:08\ntags: [FE,GIS,Leaflet]\ncategories: Leaflet\n---\n\n\n\n\n&nbsp;&nbsp;最近项目中有移动端的开发需求，自然就用到了最轻量级的gis组件——Leaflet，100多k的体积，五脏俱全，丰富的第三方插件，虽然开发者数量上不及大哥级产品Arcigs，但也基本够用，对于esri的自家系统支持好，svg和canvas两种渲染方式，让数据量大的要素图层渲染也不是那么吃力。\n\n&nbsp;&nbsp;这里把自己对于Leaflet的一些探索研究记录一下，一方面便于自己后期回顾，另一方面也希望和大家一起探讨学习。\n\n<!-- more -->\n\n[Leaflet系列地址](https://github.com/zzcyrus/Leaflet-demos)\n[本文demo地址](https://github.com/zzcyrus/Leaflet-demos/blob/master/0.basemap/basemap.html)\n\n# 基础图层的加载\n\n基础图层的加载都是通过`L.tileLayer`的方式，所以加载的难点不在于api的使用，是一些常用的基础瓦片的收集，这里给出一些常用的地址\n\n````js\n\n    mapRadios: [\n        {\n            label: '高德地图',\n            value: '1',\n            url: 'http://webrd01.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x={x}&y={y}&z={z}'\n        }, {\n            label: 'Esri地图',\n            value: '2',\n            url: 'http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineCommunity/MapServer/tile/{z}/{y}/{x}'\n        }, {\n            label: '天地图道路',\n            value: '3',\n            url: 'http://t0.tianditu.cn/DataServer?T=vec_w&X={x}&Y={y}&L={z}'\n        }, {\n            label: '天地图标注',\n            value: '4',\n            url: 'http://t5.tianditu.cn/DataServer?T=cva_w&X={x}&Y={y}&L={z}'\n        }, {\n            label: '天地图影像',\n            value: '5',\n            url: 'http://t1.tianditu.cn/img_w/wmts?service=wmts&request=GetTile&version=1.0.0&LAYER=img&tileMatrixSet=w&TileMatrix={z}&TileRow={y}&TileCol={x}&style=default&format=tiles'\n        }, {\n            label: '谷歌地形',\n            value: '6',\n            url: 'http://mt3.google.cn/vt/lyrs=t@131&hl=zh-CN&gl=cn&x={x}&y={y}&z={z}&s=Ga'\n        }, {\n            label: '谷歌影像',\n            value: '7',\n            url: 'http://mt3.google.cn/vt/lyrs=s&hl=zh-CN&gl=cn&x={x}&y={y}&z={z}'\n        }, {\n            label: '谷歌标注',\n            value: '8',\n            url: 'http://mt2.google.cn/vt/lyrs=m@167000000&hl=zh-CN&gl=cn&x={x}&y={y}&z={z}'\n        }\n    ]\n````\n\n\n更多的瓦片地址可以在demo中找到，具体的使用效果也可以移步[demo](https://github.com/zzcyrus/Leaflet-demos/blob/master/0.basemap/basemap.html)\n\n\n\n","slug":"basemap","published":1,"updated":"2019-01-30T07:29:03.651Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5pxo260008ul3ihwah7i93","content":"<p>&nbsp;&nbsp;最近项目中有移动端的开发需求，自然就用到了最轻量级的gis组件——Leaflet，100多k的体积，五脏俱全，丰富的第三方插件，虽然开发者数量上不及大哥级产品Arcigs，但也基本够用，对于esri的自家系统支持好，svg和canvas两种渲染方式，让数据量大的要素图层渲染也不是那么吃力。</p>\n<p>&nbsp;&nbsp;这里把自己对于Leaflet的一些探索研究记录一下，一方面便于自己后期回顾，另一方面也希望和大家一起探讨学习。</p>\n<a id=\"more\"></a>\n<p><a href=\"https://github.com/zzcyrus/Leaflet-demos\" target=\"_blank\" rel=\"noopener\">Leaflet系列地址</a><br><a href=\"https://github.com/zzcyrus/Leaflet-demos/blob/master/0.basemap/basemap.html\" target=\"_blank\" rel=\"noopener\">本文demo地址</a></p>\n<h1 id=\"基础图层的加载\"><a href=\"#基础图层的加载\" class=\"headerlink\" title=\"基础图层的加载\"></a>基础图层的加载</h1><p>基础图层的加载都是通过<code>L.tileLayer</code>的方式，所以加载的难点不在于api的使用，是一些常用的基础瓦片的收集，这里给出一些常用的地址</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">mapRadios: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        label: <span class=\"string\">'高德地图'</span>,</span><br><span class=\"line\">        value: <span class=\"string\">'1'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'http://webrd01.is.autonavi.com/appmaptile?lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;'</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        label: <span class=\"string\">'Esri地图'</span>,</span><br><span class=\"line\">        value: <span class=\"string\">'2'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineCommunity/MapServer/tile/&#123;z&#125;/&#123;y&#125;/&#123;x&#125;'</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        label: <span class=\"string\">'天地图道路'</span>,</span><br><span class=\"line\">        value: <span class=\"string\">'3'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'http://t0.tianditu.cn/DataServer?T=vec_w&amp;X=&#123;x&#125;&amp;Y=&#123;y&#125;&amp;L=&#123;z&#125;'</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        label: <span class=\"string\">'天地图标注'</span>,</span><br><span class=\"line\">        value: <span class=\"string\">'4'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'http://t5.tianditu.cn/DataServer?T=cva_w&amp;X=&#123;x&#125;&amp;Y=&#123;y&#125;&amp;L=&#123;z&#125;'</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        label: <span class=\"string\">'天地图影像'</span>,</span><br><span class=\"line\">        value: <span class=\"string\">'5'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'http://t1.tianditu.cn/img_w/wmts?service=wmts&amp;request=GetTile&amp;version=1.0.0&amp;LAYER=img&amp;tileMatrixSet=w&amp;TileMatrix=&#123;z&#125;&amp;TileRow=&#123;y&#125;&amp;TileCol=&#123;x&#125;&amp;style=default&amp;format=tiles'</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        label: <span class=\"string\">'谷歌地形'</span>,</span><br><span class=\"line\">        value: <span class=\"string\">'6'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'http://mt3.google.cn/vt/lyrs=t@131&amp;hl=zh-CN&amp;gl=cn&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;&amp;s=Ga'</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        label: <span class=\"string\">'谷歌影像'</span>,</span><br><span class=\"line\">        value: <span class=\"string\">'7'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'http://mt3.google.cn/vt/lyrs=s&amp;hl=zh-CN&amp;gl=cn&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;'</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        label: <span class=\"string\">'谷歌标注'</span>,</span><br><span class=\"line\">        value: <span class=\"string\">'8'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'http://mt2.google.cn/vt/lyrs=m@167000000&amp;hl=zh-CN&amp;gl=cn&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>更多的瓦片地址可以在demo中找到，具体的使用效果也可以移步<a href=\"https://github.com/zzcyrus/Leaflet-demos/blob/master/0.basemap/basemap.html\" target=\"_blank\" rel=\"noopener\">demo</a></p>\n","site":{"data":{}},"excerpt":"<p>&nbsp;&nbsp;最近项目中有移动端的开发需求，自然就用到了最轻量级的gis组件——Leaflet，100多k的体积，五脏俱全，丰富的第三方插件，虽然开发者数量上不及大哥级产品Arcigs，但也基本够用，对于esri的自家系统支持好，svg和canvas两种渲染方式，让数据量大的要素图层渲染也不是那么吃力。</p>\n<p>&nbsp;&nbsp;这里把自己对于Leaflet的一些探索研究记录一下，一方面便于自己后期回顾，另一方面也希望和大家一起探讨学习。</p>","more":"<p><a href=\"https://github.com/zzcyrus/Leaflet-demos\" target=\"_blank\" rel=\"noopener\">Leaflet系列地址</a><br><a href=\"https://github.com/zzcyrus/Leaflet-demos/blob/master/0.basemap/basemap.html\" target=\"_blank\" rel=\"noopener\">本文demo地址</a></p>\n<h1 id=\"基础图层的加载\"><a href=\"#基础图层的加载\" class=\"headerlink\" title=\"基础图层的加载\"></a>基础图层的加载</h1><p>基础图层的加载都是通过<code>L.tileLayer</code>的方式，所以加载的难点不在于api的使用，是一些常用的基础瓦片的收集，这里给出一些常用的地址</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">mapRadios: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        label: <span class=\"string\">'高德地图'</span>,</span><br><span class=\"line\">        value: <span class=\"string\">'1'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'http://webrd01.is.autonavi.com/appmaptile?lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;'</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        label: <span class=\"string\">'Esri地图'</span>,</span><br><span class=\"line\">        value: <span class=\"string\">'2'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineCommunity/MapServer/tile/&#123;z&#125;/&#123;y&#125;/&#123;x&#125;'</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        label: <span class=\"string\">'天地图道路'</span>,</span><br><span class=\"line\">        value: <span class=\"string\">'3'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'http://t0.tianditu.cn/DataServer?T=vec_w&amp;X=&#123;x&#125;&amp;Y=&#123;y&#125;&amp;L=&#123;z&#125;'</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        label: <span class=\"string\">'天地图标注'</span>,</span><br><span class=\"line\">        value: <span class=\"string\">'4'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'http://t5.tianditu.cn/DataServer?T=cva_w&amp;X=&#123;x&#125;&amp;Y=&#123;y&#125;&amp;L=&#123;z&#125;'</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        label: <span class=\"string\">'天地图影像'</span>,</span><br><span class=\"line\">        value: <span class=\"string\">'5'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'http://t1.tianditu.cn/img_w/wmts?service=wmts&amp;request=GetTile&amp;version=1.0.0&amp;LAYER=img&amp;tileMatrixSet=w&amp;TileMatrix=&#123;z&#125;&amp;TileRow=&#123;y&#125;&amp;TileCol=&#123;x&#125;&amp;style=default&amp;format=tiles'</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        label: <span class=\"string\">'谷歌地形'</span>,</span><br><span class=\"line\">        value: <span class=\"string\">'6'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'http://mt3.google.cn/vt/lyrs=t@131&amp;hl=zh-CN&amp;gl=cn&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;&amp;s=Ga'</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        label: <span class=\"string\">'谷歌影像'</span>,</span><br><span class=\"line\">        value: <span class=\"string\">'7'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'http://mt3.google.cn/vt/lyrs=s&amp;hl=zh-CN&amp;gl=cn&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;'</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        label: <span class=\"string\">'谷歌标注'</span>,</span><br><span class=\"line\">        value: <span class=\"string\">'8'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'http://mt2.google.cn/vt/lyrs=m@167000000&amp;hl=zh-CN&amp;gl=cn&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>更多的瓦片地址可以在demo中找到，具体的使用效果也可以移步<a href=\"https://github.com/zzcyrus/Leaflet-demos/blob/master/0.basemap/basemap.html\" target=\"_blank\" rel=\"noopener\">demo</a></p>"},{"title":"openlayers 从台风风圈绘制到canvas样式和图层的应用","date":"2017-07-31T14:31:02.000Z","_content":"本文中所使用的数据来源于[温州台风网](http://www.wztf121.com/typhoon.html)，通过F12抓取，你可以在我的[GitHub](\nhttps://github.com/zzcyrus/openlayers-demos\n)上查看数据和本文源代码\n\n&nbsp;&nbsp;台风的风圈是一种不常见但算的上规则的图形，在上面的网站可以看到最终效果，简单的解剖下其实就是四个1/4圆\n\n![](goal.png)\n\n从数据结构上也可以看出来：\n```js\n        var radius_quad = {\n            \"ne\": 250, //单位为KM\n            \"se\": 250,\n            \"sw\": 180,\n            \"nw\": 150\n        }\n```\n在某个固定经纬度点上，以此点为圆心组合成了一个所谓的风圈形状，四个方向分别代表每个1/4圆的半径。刚开始是为了实现这种效果进行了研究，后来发现openlayers对于这种效果的支持还挺有意思，记录下来已做分享。\n\n<!-- more -->\n\n\n# 通过自定义geometry的实现\n&nbsp;&nbsp;最原始的思路也是最容易切入的点，就是去看openlayers中怎么实现圆形的画法，在ol中，有`createRegularPolygon`这个类，原理就是给定一些参数，用点去填充我们想要的形状，当填进去点达到一定密集度，自然就能得到一个近似的圆。\n&nbsp;&nbsp;通过这个思路我们可以计算台风风圈的每个1/4圆的坐标，用点去占位，最终实现绘制出想要的图形。\n\n具体代码可以去看某大牛的博客，这里只给出一个传送门，写的很详细了：\n[点我乘坐飞机](http://blog.csdn.net/gisshixisheng/article/details/76397068) **这个算法还有些不完善，就是在每个1/4圆结束时候少计算了一个点，导致看着有点不对劲**\n\n\n**特点:** 这种方式画出来的图形是一个图层中的一个feature，好处自然不用多说，基本上feature支持的功能都能满足！\n\n\n# 通过canvas类型的symbol实现\n&nbsp;&nbsp;在点密集的情况下，用上面的方式其实效果已经很不错了，但是有些细（tiao）心（ci）的使用者，非要放大到一定程度，然后说你这个不够圆，那。。。。。\n\n&nbsp;&nbsp;那我们就用canvas画出来，openlayers中，要素的样式是有这么一种方式`ol.style.Icon`来实现，我们可以把绘制好的元素作为`Icon`的参数\n```js\n        var style = new ol.style.Style({\n            image: new ol.style.Icon({\n                opacity: 0.3,\n                img: canvas,\n                imgSize: [canvas.width, canvas.height],\n            })\n        })\n```\ncanvans绘制的方法：\n```js\n        function createTyphoon(radius, radius_quad) {\n            var canvas = document.createElement('canvas');\n            canvas.width = canvas.height = 2 * radius;\n            var context = canvas.getContext(\"2d\");\n            context.fillStyle = \"#0000ff\";\n            context.strokeStyle = \"#ff0000\";\n            context.lineWidth = 3;\n            context.beginPath();\n            context.arc(radius, radius, radius_quad.se, 0, 0.5 * Math.PI);\n            context.lineTo(radius, radius + radius_quad.sw);\n            context.arc(radius, radius, radius_quad.sw, 0.5 * Math.PI, Math.PI);\n            context.lineTo(radius - radius_quad.nw, radius);\n            context.arc(radius, radius, radius_quad.nw, Math.PI, 1.5 * Math.PI);\n            context.lineTo(radius, radius - radius_quad.ne);\n            context.arc(radius, radius, radius_quad.ne, 1.5 * Math.PI, 0);\n            context.lineTo(radius + radius_quad.se, radius);\n            context.fill();\n            context.stroke();\n            return canvas;\n        }\n```\n效果如下图：\n![](canvasSymbol.png)\n\n\n[本方法完整代码](\nhttps://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasSymbol.html\n)\n\n**特点：** 这种方式，绘制出来的台风风圈其实只是一个symbol符号，需要把这个符号赋给一个具体的要素，比如一个点，一个圆之类的，而且根据分辨率还要去调整样式的缩放\n```js\n        map.getView().on('change:resolution', function () {\n            var style = shape.getStyle();\n            // 重新设置图标的缩放率\n            style.getImage().setScale(this.getZoom() / 8);\n            shape.setStyle(style);\n        })\n```\n\n# 通过canvas图层的方式实现\n&nbsp;&nbsp;再后来转念一想，既然支持canvas的symbol，为何不直接使用canvas绘制固定元素呢，果然在API中找到了`ol.source.ImageCanvas`，直接把canvas要素当作图层来使用！\n\n`ol.source.ImageCanvas`的绘制有点需要特别注意的点，这里给出重要代码片段，完整demo可以去[GitHub](\nhttps://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasLayer.html\n)查看\n\n## 创建图层，在canvasFunction中写具体的绘图方法\n```js\n        var canvasLayer = new ol.layer.Image({\n            source: new ol.source.ImageCanvas({\n                canvasFunction: canvasFunction,\n                projection: 'EPSG:3857'\n            })\n        });\n```\n\n## canvasFunction中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小\n\n```js\n        //计算画布和地图四至的偏移量\n        var mapExtent = map.getView().calculateExtent(map.getSize())\n        var canvasOrigin = map.getPixelFromCoordinate([extent[0], extent[3]]);\n        var mapOrigin = map.getPixelFromCoordinate([mapExtent[0], mapExtent[3]]);\n        var delta = [mapOrigin[0] - canvasOrigin[0], mapOrigin[1] - canvasOrigin[1]]\n```\n```js\n        //在计算台风风圈的中心点时要补充计算偏移量\n        var point = ol.proj.transform(coordinate, 'EPSG:4326', 'EPSG:3857');\n        var pixel = map.getPixelFromCoordinate(point);\n        var cX = pixel[0] + delta[0], cY = pixel[1] + delta[1];\n```\n```js\n        //利用canvasFunction提供的默认参数分辨率，计算准确的坐标\n        var radius_quad = {\n            \"ne\": 250000 / resolution,\n            \"se\": 250000 / resolution,\n            \"sw\": 180000 / resolution,\n            \"nw\": 150000 / resolution\n        }\n```\n最终效果如下，我在同一图层中绘制了多个：\n![](canvasLayer.png)\n\n\n至于绘制canvas的方法和上面的symbol是一样的。具体代码还请移步[GitHub](\nhttps://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasLayer.html\n)(原谅我厚颜无耻的屡次打广告！)\n\n**特点：**这种方式可以在一个图层中添加多个风圈要素，同时图层支持的功能也比较多，基本满足需求，效果也还行\n\n\n&nbsp;&nbsp;这篇应用主要是从一个基本的需求所拓展开来的，canvas图层的应用我想应该很强大，刚开始研究openlyaers，相比于arcgis，ol很多功能可能要自己实现，但似乎效果上还是能让人满意的，欢迎大家讨论。","source":"_posts/openlayers-canvas-typhoon.md","raw":"---\ntitle: openlayers 从台风风圈绘制到canvas样式和图层的应用\ndate: 2017-07-31 22:31:02\ntags: [FE,GIS,OpenLayers]\ncategories: OpenLayers\n---\n本文中所使用的数据来源于[温州台风网](http://www.wztf121.com/typhoon.html)，通过F12抓取，你可以在我的[GitHub](\nhttps://github.com/zzcyrus/openlayers-demos\n)上查看数据和本文源代码\n\n&nbsp;&nbsp;台风的风圈是一种不常见但算的上规则的图形，在上面的网站可以看到最终效果，简单的解剖下其实就是四个1/4圆\n\n![](goal.png)\n\n从数据结构上也可以看出来：\n```js\n        var radius_quad = {\n            \"ne\": 250, //单位为KM\n            \"se\": 250,\n            \"sw\": 180,\n            \"nw\": 150\n        }\n```\n在某个固定经纬度点上，以此点为圆心组合成了一个所谓的风圈形状，四个方向分别代表每个1/4圆的半径。刚开始是为了实现这种效果进行了研究，后来发现openlayers对于这种效果的支持还挺有意思，记录下来已做分享。\n\n<!-- more -->\n\n\n# 通过自定义geometry的实现\n&nbsp;&nbsp;最原始的思路也是最容易切入的点，就是去看openlayers中怎么实现圆形的画法，在ol中，有`createRegularPolygon`这个类，原理就是给定一些参数，用点去填充我们想要的形状，当填进去点达到一定密集度，自然就能得到一个近似的圆。\n&nbsp;&nbsp;通过这个思路我们可以计算台风风圈的每个1/4圆的坐标，用点去占位，最终实现绘制出想要的图形。\n\n具体代码可以去看某大牛的博客，这里只给出一个传送门，写的很详细了：\n[点我乘坐飞机](http://blog.csdn.net/gisshixisheng/article/details/76397068) **这个算法还有些不完善，就是在每个1/4圆结束时候少计算了一个点，导致看着有点不对劲**\n\n\n**特点:** 这种方式画出来的图形是一个图层中的一个feature，好处自然不用多说，基本上feature支持的功能都能满足！\n\n\n# 通过canvas类型的symbol实现\n&nbsp;&nbsp;在点密集的情况下，用上面的方式其实效果已经很不错了，但是有些细（tiao）心（ci）的使用者，非要放大到一定程度，然后说你这个不够圆，那。。。。。\n\n&nbsp;&nbsp;那我们就用canvas画出来，openlayers中，要素的样式是有这么一种方式`ol.style.Icon`来实现，我们可以把绘制好的元素作为`Icon`的参数\n```js\n        var style = new ol.style.Style({\n            image: new ol.style.Icon({\n                opacity: 0.3,\n                img: canvas,\n                imgSize: [canvas.width, canvas.height],\n            })\n        })\n```\ncanvans绘制的方法：\n```js\n        function createTyphoon(radius, radius_quad) {\n            var canvas = document.createElement('canvas');\n            canvas.width = canvas.height = 2 * radius;\n            var context = canvas.getContext(\"2d\");\n            context.fillStyle = \"#0000ff\";\n            context.strokeStyle = \"#ff0000\";\n            context.lineWidth = 3;\n            context.beginPath();\n            context.arc(radius, radius, radius_quad.se, 0, 0.5 * Math.PI);\n            context.lineTo(radius, radius + radius_quad.sw);\n            context.arc(radius, radius, radius_quad.sw, 0.5 * Math.PI, Math.PI);\n            context.lineTo(radius - radius_quad.nw, radius);\n            context.arc(radius, radius, radius_quad.nw, Math.PI, 1.5 * Math.PI);\n            context.lineTo(radius, radius - radius_quad.ne);\n            context.arc(radius, radius, radius_quad.ne, 1.5 * Math.PI, 0);\n            context.lineTo(radius + radius_quad.se, radius);\n            context.fill();\n            context.stroke();\n            return canvas;\n        }\n```\n效果如下图：\n![](canvasSymbol.png)\n\n\n[本方法完整代码](\nhttps://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasSymbol.html\n)\n\n**特点：** 这种方式，绘制出来的台风风圈其实只是一个symbol符号，需要把这个符号赋给一个具体的要素，比如一个点，一个圆之类的，而且根据分辨率还要去调整样式的缩放\n```js\n        map.getView().on('change:resolution', function () {\n            var style = shape.getStyle();\n            // 重新设置图标的缩放率\n            style.getImage().setScale(this.getZoom() / 8);\n            shape.setStyle(style);\n        })\n```\n\n# 通过canvas图层的方式实现\n&nbsp;&nbsp;再后来转念一想，既然支持canvas的symbol，为何不直接使用canvas绘制固定元素呢，果然在API中找到了`ol.source.ImageCanvas`，直接把canvas要素当作图层来使用！\n\n`ol.source.ImageCanvas`的绘制有点需要特别注意的点，这里给出重要代码片段，完整demo可以去[GitHub](\nhttps://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasLayer.html\n)查看\n\n## 创建图层，在canvasFunction中写具体的绘图方法\n```js\n        var canvasLayer = new ol.layer.Image({\n            source: new ol.source.ImageCanvas({\n                canvasFunction: canvasFunction,\n                projection: 'EPSG:3857'\n            })\n        });\n```\n\n## canvasFunction中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小\n\n```js\n        //计算画布和地图四至的偏移量\n        var mapExtent = map.getView().calculateExtent(map.getSize())\n        var canvasOrigin = map.getPixelFromCoordinate([extent[0], extent[3]]);\n        var mapOrigin = map.getPixelFromCoordinate([mapExtent[0], mapExtent[3]]);\n        var delta = [mapOrigin[0] - canvasOrigin[0], mapOrigin[1] - canvasOrigin[1]]\n```\n```js\n        //在计算台风风圈的中心点时要补充计算偏移量\n        var point = ol.proj.transform(coordinate, 'EPSG:4326', 'EPSG:3857');\n        var pixel = map.getPixelFromCoordinate(point);\n        var cX = pixel[0] + delta[0], cY = pixel[1] + delta[1];\n```\n```js\n        //利用canvasFunction提供的默认参数分辨率，计算准确的坐标\n        var radius_quad = {\n            \"ne\": 250000 / resolution,\n            \"se\": 250000 / resolution,\n            \"sw\": 180000 / resolution,\n            \"nw\": 150000 / resolution\n        }\n```\n最终效果如下，我在同一图层中绘制了多个：\n![](canvasLayer.png)\n\n\n至于绘制canvas的方法和上面的symbol是一样的。具体代码还请移步[GitHub](\nhttps://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasLayer.html\n)(原谅我厚颜无耻的屡次打广告！)\n\n**特点：**这种方式可以在一个图层中添加多个风圈要素，同时图层支持的功能也比较多，基本满足需求，效果也还行\n\n\n&nbsp;&nbsp;这篇应用主要是从一个基本的需求所拓展开来的，canvas图层的应用我想应该很强大，刚开始研究openlyaers，相比于arcgis，ol很多功能可能要自己实现，但似乎效果上还是能让人满意的，欢迎大家讨论。","slug":"openlayers-canvas-typhoon","published":1,"updated":"2019-01-30T07:29:03.651Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5pxo2a000cul3irnx111yv","content":"<p>本文中所使用的数据来源于<a href=\"http://www.wztf121.com/typhoon.html\" target=\"_blank\" rel=\"noopener\">温州台风网</a>，通过F12抓取，你可以在我的<a href=\"https://github.com/zzcyrus/openlayers-demos\" target=\"_blank\" rel=\"noopener\">GitHub</a>上查看数据和本文源代码</p>\n<p>&nbsp;&nbsp;台风的风圈是一种不常见但算的上规则的图形，在上面的网站可以看到最终效果，简单的解剖下其实就是四个1/4圆</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"goal.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>从数据结构上也可以看出来：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> radius_quad = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"ne\"</span>: <span class=\"number\">250</span>, <span class=\"comment\">//单位为KM</span></span><br><span class=\"line\">    <span class=\"string\">\"se\"</span>: <span class=\"number\">250</span>,</span><br><span class=\"line\">    <span class=\"string\">\"sw\"</span>: <span class=\"number\">180</span>,</span><br><span class=\"line\">    <span class=\"string\">\"nw\"</span>: <span class=\"number\">150</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在某个固定经纬度点上，以此点为圆心组合成了一个所谓的风圈形状，四个方向分别代表每个1/4圆的半径。刚开始是为了实现这种效果进行了研究，后来发现openlayers对于这种效果的支持还挺有意思，记录下来已做分享。</p>\n<a id=\"more\"></a>\n<h1 id=\"通过自定义geometry的实现\"><a href=\"#通过自定义geometry的实现\" class=\"headerlink\" title=\"通过自定义geometry的实现\"></a>通过自定义geometry的实现</h1><p>&nbsp;&nbsp;最原始的思路也是最容易切入的点，就是去看openlayers中怎么实现圆形的画法，在ol中，有<code>createRegularPolygon</code>这个类，原理就是给定一些参数，用点去填充我们想要的形状，当填进去点达到一定密集度，自然就能得到一个近似的圆。<br>&nbsp;&nbsp;通过这个思路我们可以计算台风风圈的每个1/4圆的坐标，用点去占位，最终实现绘制出想要的图形。</p>\n<p>具体代码可以去看某大牛的博客，这里只给出一个传送门，写的很详细了：<br><a href=\"http://blog.csdn.net/gisshixisheng/article/details/76397068\" target=\"_blank\" rel=\"noopener\">点我乘坐飞机</a> <strong>这个算法还有些不完善，就是在每个1/4圆结束时候少计算了一个点，导致看着有点不对劲</strong></p>\n<p><strong>特点:</strong> 这种方式画出来的图形是一个图层中的一个feature，好处自然不用多说，基本上feature支持的功能都能满足！</p>\n<h1 id=\"通过canvas类型的symbol实现\"><a href=\"#通过canvas类型的symbol实现\" class=\"headerlink\" title=\"通过canvas类型的symbol实现\"></a>通过canvas类型的symbol实现</h1><p>&nbsp;&nbsp;在点密集的情况下，用上面的方式其实效果已经很不错了，但是有些细（tiao）心（ci）的使用者，非要放大到一定程度，然后说你这个不够圆，那。。。。。</p>\n<p>&nbsp;&nbsp;那我们就用canvas画出来，openlayers中，要素的样式是有这么一种方式<code>ol.style.Icon</code>来实现，我们可以把绘制好的元素作为<code>Icon</code>的参数<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> style = <span class=\"keyword\">new</span> ol.style.Style(&#123;</span><br><span class=\"line\">    image: <span class=\"keyword\">new</span> ol.style.Icon(&#123;</span><br><span class=\"line\">        opacity: <span class=\"number\">0.3</span>,</span><br><span class=\"line\">        img: canvas,</span><br><span class=\"line\">        imgSize: [canvas.width, canvas.height],</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>canvans绘制的方法：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createTyphoon</span>(<span class=\"params\">radius, radius_quad</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> canvas = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'canvas'</span>);</span><br><span class=\"line\">    canvas.width = canvas.height = <span class=\"number\">2</span> * radius;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> context = canvas.getContext(<span class=\"string\">\"2d\"</span>);</span><br><span class=\"line\">    context.fillStyle = <span class=\"string\">\"#0000ff\"</span>;</span><br><span class=\"line\">    context.strokeStyle = <span class=\"string\">\"#ff0000\"</span>;</span><br><span class=\"line\">    context.lineWidth = <span class=\"number\">3</span>;</span><br><span class=\"line\">    context.beginPath();</span><br><span class=\"line\">    context.arc(radius, radius, radius_quad.se, <span class=\"number\">0</span>, <span class=\"number\">0.5</span> * <span class=\"built_in\">Math</span>.PI);</span><br><span class=\"line\">    context.lineTo(radius, radius + radius_quad.sw);</span><br><span class=\"line\">    context.arc(radius, radius, radius_quad.sw, <span class=\"number\">0.5</span> * <span class=\"built_in\">Math</span>.PI, <span class=\"built_in\">Math</span>.PI);</span><br><span class=\"line\">    context.lineTo(radius - radius_quad.nw, radius);</span><br><span class=\"line\">    context.arc(radius, radius, radius_quad.nw, <span class=\"built_in\">Math</span>.PI, <span class=\"number\">1.5</span> * <span class=\"built_in\">Math</span>.PI);</span><br><span class=\"line\">    context.lineTo(radius, radius - radius_quad.ne);</span><br><span class=\"line\">    context.arc(radius, radius, radius_quad.ne, <span class=\"number\">1.5</span> * <span class=\"built_in\">Math</span>.PI, <span class=\"number\">0</span>);</span><br><span class=\"line\">    context.lineTo(radius + radius_quad.se, radius);</span><br><span class=\"line\">    context.fill();</span><br><span class=\"line\">    context.stroke();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> canvas;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>效果如下图：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"canvasSymbol.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure></p>\n<p><a href=\"https://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasSymbol.html\" target=\"_blank\" rel=\"noopener\">本方法完整代码</a></p>\n<p><strong>特点：</strong> 这种方式，绘制出来的台风风圈其实只是一个symbol符号，需要把这个符号赋给一个具体的要素，比如一个点，一个圆之类的，而且根据分辨率还要去调整样式的缩放<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">map.getView().on(<span class=\"string\">'change:resolution'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> style = shape.getStyle();</span><br><span class=\"line\">    <span class=\"comment\">// 重新设置图标的缩放率</span></span><br><span class=\"line\">    style.getImage().setScale(<span class=\"keyword\">this</span>.getZoom() / <span class=\"number\">8</span>);</span><br><span class=\"line\">    shape.setStyle(style);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"通过canvas图层的方式实现\"><a href=\"#通过canvas图层的方式实现\" class=\"headerlink\" title=\"通过canvas图层的方式实现\"></a>通过canvas图层的方式实现</h1><p>&nbsp;&nbsp;再后来转念一想，既然支持canvas的symbol，为何不直接使用canvas绘制固定元素呢，果然在API中找到了<code>ol.source.ImageCanvas</code>，直接把canvas要素当作图层来使用！</p>\n<p><code>ol.source.ImageCanvas</code>的绘制有点需要特别注意的点，这里给出重要代码片段，完整demo可以去<a href=\"https://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasLayer.html\" target=\"_blank\" rel=\"noopener\">GitHub</a>查看</p>\n<h2 id=\"创建图层，在canvasFunction中写具体的绘图方法\"><a href=\"#创建图层，在canvasFunction中写具体的绘图方法\" class=\"headerlink\" title=\"创建图层，在canvasFunction中写具体的绘图方法\"></a>创建图层，在canvasFunction中写具体的绘图方法</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canvasLayer = <span class=\"keyword\">new</span> ol.layer.Image(&#123;</span><br><span class=\"line\">    source: <span class=\"keyword\">new</span> ol.source.ImageCanvas(&#123;</span><br><span class=\"line\">        canvasFunction: canvasFunction,</span><br><span class=\"line\">        projection: <span class=\"string\">'EPSG:3857'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"canvasFunction中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小\"><a href=\"#canvasFunction中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小\" class=\"headerlink\" title=\"canvasFunction中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小\"></a>canvasFunction中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//计算画布和地图四至的偏移量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mapExtent = map.getView().calculateExtent(map.getSize())</span><br><span class=\"line\"><span class=\"keyword\">var</span> canvasOrigin = map.getPixelFromCoordinate([extent[<span class=\"number\">0</span>], extent[<span class=\"number\">3</span>]]);</span><br><span class=\"line\"><span class=\"keyword\">var</span> mapOrigin = map.getPixelFromCoordinate([mapExtent[<span class=\"number\">0</span>], mapExtent[<span class=\"number\">3</span>]]);</span><br><span class=\"line\"><span class=\"keyword\">var</span> delta = [mapOrigin[<span class=\"number\">0</span>] - canvasOrigin[<span class=\"number\">0</span>], mapOrigin[<span class=\"number\">1</span>] - canvasOrigin[<span class=\"number\">1</span>]]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在计算台风风圈的中心点时要补充计算偏移量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> point = ol.proj.transform(coordinate, <span class=\"string\">'EPSG:4326'</span>, <span class=\"string\">'EPSG:3857'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> pixel = map.getPixelFromCoordinate(point);</span><br><span class=\"line\"><span class=\"keyword\">var</span> cX = pixel[<span class=\"number\">0</span>] + delta[<span class=\"number\">0</span>], cY = pixel[<span class=\"number\">1</span>] + delta[<span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//利用canvasFunction提供的默认参数分辨率，计算准确的坐标</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> radius_quad = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"ne\"</span>: <span class=\"number\">250000</span> / resolution,</span><br><span class=\"line\">    <span class=\"string\">\"se\"</span>: <span class=\"number\">250000</span> / resolution,</span><br><span class=\"line\">    <span class=\"string\">\"sw\"</span>: <span class=\"number\">180000</span> / resolution,</span><br><span class=\"line\">    <span class=\"string\">\"nw\"</span>: <span class=\"number\">150000</span> / resolution</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终效果如下，我在同一图层中绘制了多个：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"canvasLayer.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure></p>\n<p>至于绘制canvas的方法和上面的symbol是一样的。具体代码还请移步<a href=\"https://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasLayer.html\" target=\"_blank\" rel=\"noopener\">GitHub</a>(原谅我厚颜无耻的屡次打广告！)</p>\n<p><strong>特点：</strong>这种方式可以在一个图层中添加多个风圈要素，同时图层支持的功能也比较多，基本满足需求，效果也还行</p>\n<p>&nbsp;&nbsp;这篇应用主要是从一个基本的需求所拓展开来的，canvas图层的应用我想应该很强大，刚开始研究openlyaers，相比于arcgis，ol很多功能可能要自己实现，但似乎效果上还是能让人满意的，欢迎大家讨论。</p>\n","site":{"data":{}},"excerpt":"<p>本文中所使用的数据来源于<a href=\"http://www.wztf121.com/typhoon.html\" target=\"_blank\" rel=\"noopener\">温州台风网</a>，通过F12抓取，你可以在我的<a href=\"https://github.com/zzcyrus/openlayers-demos\" target=\"_blank\" rel=\"noopener\">GitHub</a>上查看数据和本文源代码</p>\n<p>&nbsp;&nbsp;台风的风圈是一种不常见但算的上规则的图形，在上面的网站可以看到最终效果，简单的解剖下其实就是四个1/4圆</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"goal.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>从数据结构上也可以看出来：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> radius_quad = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"ne\"</span>: <span class=\"number\">250</span>, <span class=\"comment\">//单位为KM</span></span><br><span class=\"line\">    <span class=\"string\">\"se\"</span>: <span class=\"number\">250</span>,</span><br><span class=\"line\">    <span class=\"string\">\"sw\"</span>: <span class=\"number\">180</span>,</span><br><span class=\"line\">    <span class=\"string\">\"nw\"</span>: <span class=\"number\">150</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在某个固定经纬度点上，以此点为圆心组合成了一个所谓的风圈形状，四个方向分别代表每个1/4圆的半径。刚开始是为了实现这种效果进行了研究，后来发现openlayers对于这种效果的支持还挺有意思，记录下来已做分享。</p>","more":"<h1 id=\"通过自定义geometry的实现\"><a href=\"#通过自定义geometry的实现\" class=\"headerlink\" title=\"通过自定义geometry的实现\"></a>通过自定义geometry的实现</h1><p>&nbsp;&nbsp;最原始的思路也是最容易切入的点，就是去看openlayers中怎么实现圆形的画法，在ol中，有<code>createRegularPolygon</code>这个类，原理就是给定一些参数，用点去填充我们想要的形状，当填进去点达到一定密集度，自然就能得到一个近似的圆。<br>&nbsp;&nbsp;通过这个思路我们可以计算台风风圈的每个1/4圆的坐标，用点去占位，最终实现绘制出想要的图形。</p>\n<p>具体代码可以去看某大牛的博客，这里只给出一个传送门，写的很详细了：<br><a href=\"http://blog.csdn.net/gisshixisheng/article/details/76397068\" target=\"_blank\" rel=\"noopener\">点我乘坐飞机</a> <strong>这个算法还有些不完善，就是在每个1/4圆结束时候少计算了一个点，导致看着有点不对劲</strong></p>\n<p><strong>特点:</strong> 这种方式画出来的图形是一个图层中的一个feature，好处自然不用多说，基本上feature支持的功能都能满足！</p>\n<h1 id=\"通过canvas类型的symbol实现\"><a href=\"#通过canvas类型的symbol实现\" class=\"headerlink\" title=\"通过canvas类型的symbol实现\"></a>通过canvas类型的symbol实现</h1><p>&nbsp;&nbsp;在点密集的情况下，用上面的方式其实效果已经很不错了，但是有些细（tiao）心（ci）的使用者，非要放大到一定程度，然后说你这个不够圆，那。。。。。</p>\n<p>&nbsp;&nbsp;那我们就用canvas画出来，openlayers中，要素的样式是有这么一种方式<code>ol.style.Icon</code>来实现，我们可以把绘制好的元素作为<code>Icon</code>的参数<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> style = <span class=\"keyword\">new</span> ol.style.Style(&#123;</span><br><span class=\"line\">    image: <span class=\"keyword\">new</span> ol.style.Icon(&#123;</span><br><span class=\"line\">        opacity: <span class=\"number\">0.3</span>,</span><br><span class=\"line\">        img: canvas,</span><br><span class=\"line\">        imgSize: [canvas.width, canvas.height],</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>canvans绘制的方法：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createTyphoon</span>(<span class=\"params\">radius, radius_quad</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> canvas = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'canvas'</span>);</span><br><span class=\"line\">    canvas.width = canvas.height = <span class=\"number\">2</span> * radius;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> context = canvas.getContext(<span class=\"string\">\"2d\"</span>);</span><br><span class=\"line\">    context.fillStyle = <span class=\"string\">\"#0000ff\"</span>;</span><br><span class=\"line\">    context.strokeStyle = <span class=\"string\">\"#ff0000\"</span>;</span><br><span class=\"line\">    context.lineWidth = <span class=\"number\">3</span>;</span><br><span class=\"line\">    context.beginPath();</span><br><span class=\"line\">    context.arc(radius, radius, radius_quad.se, <span class=\"number\">0</span>, <span class=\"number\">0.5</span> * <span class=\"built_in\">Math</span>.PI);</span><br><span class=\"line\">    context.lineTo(radius, radius + radius_quad.sw);</span><br><span class=\"line\">    context.arc(radius, radius, radius_quad.sw, <span class=\"number\">0.5</span> * <span class=\"built_in\">Math</span>.PI, <span class=\"built_in\">Math</span>.PI);</span><br><span class=\"line\">    context.lineTo(radius - radius_quad.nw, radius);</span><br><span class=\"line\">    context.arc(radius, radius, radius_quad.nw, <span class=\"built_in\">Math</span>.PI, <span class=\"number\">1.5</span> * <span class=\"built_in\">Math</span>.PI);</span><br><span class=\"line\">    context.lineTo(radius, radius - radius_quad.ne);</span><br><span class=\"line\">    context.arc(radius, radius, radius_quad.ne, <span class=\"number\">1.5</span> * <span class=\"built_in\">Math</span>.PI, <span class=\"number\">0</span>);</span><br><span class=\"line\">    context.lineTo(radius + radius_quad.se, radius);</span><br><span class=\"line\">    context.fill();</span><br><span class=\"line\">    context.stroke();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> canvas;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>效果如下图：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"canvasSymbol.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure></p>\n<p><a href=\"https://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasSymbol.html\" target=\"_blank\" rel=\"noopener\">本方法完整代码</a></p>\n<p><strong>特点：</strong> 这种方式，绘制出来的台风风圈其实只是一个symbol符号，需要把这个符号赋给一个具体的要素，比如一个点，一个圆之类的，而且根据分辨率还要去调整样式的缩放<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">map.getView().on(<span class=\"string\">'change:resolution'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> style = shape.getStyle();</span><br><span class=\"line\">    <span class=\"comment\">// 重新设置图标的缩放率</span></span><br><span class=\"line\">    style.getImage().setScale(<span class=\"keyword\">this</span>.getZoom() / <span class=\"number\">8</span>);</span><br><span class=\"line\">    shape.setStyle(style);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"通过canvas图层的方式实现\"><a href=\"#通过canvas图层的方式实现\" class=\"headerlink\" title=\"通过canvas图层的方式实现\"></a>通过canvas图层的方式实现</h1><p>&nbsp;&nbsp;再后来转念一想，既然支持canvas的symbol，为何不直接使用canvas绘制固定元素呢，果然在API中找到了<code>ol.source.ImageCanvas</code>，直接把canvas要素当作图层来使用！</p>\n<p><code>ol.source.ImageCanvas</code>的绘制有点需要特别注意的点，这里给出重要代码片段，完整demo可以去<a href=\"https://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasLayer.html\" target=\"_blank\" rel=\"noopener\">GitHub</a>查看</p>\n<h2 id=\"创建图层，在canvasFunction中写具体的绘图方法\"><a href=\"#创建图层，在canvasFunction中写具体的绘图方法\" class=\"headerlink\" title=\"创建图层，在canvasFunction中写具体的绘图方法\"></a>创建图层，在canvasFunction中写具体的绘图方法</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canvasLayer = <span class=\"keyword\">new</span> ol.layer.Image(&#123;</span><br><span class=\"line\">    source: <span class=\"keyword\">new</span> ol.source.ImageCanvas(&#123;</span><br><span class=\"line\">        canvasFunction: canvasFunction,</span><br><span class=\"line\">        projection: <span class=\"string\">'EPSG:3857'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"canvasFunction中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小\"><a href=\"#canvasFunction中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小\" class=\"headerlink\" title=\"canvasFunction中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小\"></a>canvasFunction中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//计算画布和地图四至的偏移量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mapExtent = map.getView().calculateExtent(map.getSize())</span><br><span class=\"line\"><span class=\"keyword\">var</span> canvasOrigin = map.getPixelFromCoordinate([extent[<span class=\"number\">0</span>], extent[<span class=\"number\">3</span>]]);</span><br><span class=\"line\"><span class=\"keyword\">var</span> mapOrigin = map.getPixelFromCoordinate([mapExtent[<span class=\"number\">0</span>], mapExtent[<span class=\"number\">3</span>]]);</span><br><span class=\"line\"><span class=\"keyword\">var</span> delta = [mapOrigin[<span class=\"number\">0</span>] - canvasOrigin[<span class=\"number\">0</span>], mapOrigin[<span class=\"number\">1</span>] - canvasOrigin[<span class=\"number\">1</span>]]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在计算台风风圈的中心点时要补充计算偏移量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> point = ol.proj.transform(coordinate, <span class=\"string\">'EPSG:4326'</span>, <span class=\"string\">'EPSG:3857'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> pixel = map.getPixelFromCoordinate(point);</span><br><span class=\"line\"><span class=\"keyword\">var</span> cX = pixel[<span class=\"number\">0</span>] + delta[<span class=\"number\">0</span>], cY = pixel[<span class=\"number\">1</span>] + delta[<span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//利用canvasFunction提供的默认参数分辨率，计算准确的坐标</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> radius_quad = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"ne\"</span>: <span class=\"number\">250000</span> / resolution,</span><br><span class=\"line\">    <span class=\"string\">\"se\"</span>: <span class=\"number\">250000</span> / resolution,</span><br><span class=\"line\">    <span class=\"string\">\"sw\"</span>: <span class=\"number\">180000</span> / resolution,</span><br><span class=\"line\">    <span class=\"string\">\"nw\"</span>: <span class=\"number\">150000</span> / resolution</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终效果如下，我在同一图层中绘制了多个：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"canvasLayer.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure></p>\n<p>至于绘制canvas的方法和上面的symbol是一样的。具体代码还请移步<a href=\"https://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasLayer.html\" target=\"_blank\" rel=\"noopener\">GitHub</a>(原谅我厚颜无耻的屡次打广告！)</p>\n<p><strong>特点：</strong>这种方式可以在一个图层中添加多个风圈要素，同时图层支持的功能也比较多，基本满足需求，效果也还行</p>\n<p>&nbsp;&nbsp;这篇应用主要是从一个基本的需求所拓展开来的，canvas图层的应用我想应该很强大，刚开始研究openlyaers，相比于arcgis，ol很多功能可能要自己实现，但似乎效果上还是能让人满意的，欢迎大家讨论。</p>"},{"title":"element dialog组件嵌套问题的临时方案","date":"2017-06-23T14:09:55.000Z","_content":"\n&emsp;&emsp;最近用 Vue+element 开发项目时，在dialog组件上嵌套使用dialog组件或是MessageBox这类弹框组件，发现会出现遮罩层重合之类的问题，导致很多人只能选择关闭遮罩层。GitHub上就此问题也出现过类似讨论。有几种解决方案：\n\n<!--more--> \n\n\n1. 按照官方所说，将多个dialog类组件全部移动至**<body**>标签下\n\n2. Github上某位大牛给出了不完全解决方案，基本思路仍然是将添加在**<el-dialog**>内的dom结构自动移动至**<body**>标签下。这个方式测试了下，似乎纯dialog嵌套问题不大，但是如果dialog内部包含了其他组件会有点问题，智者见智，自行探索了\n\n&emsp;&emsp;[附上连接](https://github.com/foolishchow/element-dialog2)\n\n3. 编写自己modal遮罩层，这里给出个不完全临时代码仅供参考\n\n```js\n    Vue.prototype.$Modal = {\n        open(element) {\n            var index = 1;\n            var wrapper = element.querySelector('.el-dialog__wrapper');\n            if (wrapper) {\n                index = wrapper.style.zIndex - 1;\n            }\n            var modalDom = document.createElement('div');\n            modalDom.className = 'v-modal';\n            element.appendChild(modalDom);\n            modalDom.style.zIndex = index;\n        },\n        close() {\n            var modal = document.getElementsByClassName('v-modal')[0;\n            modal.parentNode.removeChild(modal);\n        }\n    }\n\n```\n&emsp;&emsp;一般调用方法\n```js\n    mounted: function () {\n        var that = this;\n        this.$nextTick(function () {\n            //遮罩层\n            that.$nextTick(function () {\n                that.$Modal.open(that.$el);\n            });\n        });\n    },\n```\n\n&emsp;&emsp;主要想法就是在组件mounted完成的nextTick后，为页面中添加一个div，样式就直接采用element自己的了，因为遮罩层是添加在dialog组件下的，因此组件销毁后也会自己销毁，close方法也没用上，但也应该会遇到有用上的时候吧。\n","source":"_posts/vue-dialog-nested.md","raw":"---\ntitle: element dialog组件嵌套问题的临时方案\ndate: 2017-06-23 22:09:55\ntags: [FE,Vue]\ncategories: 前端\n---\n\n&emsp;&emsp;最近用 Vue+element 开发项目时，在dialog组件上嵌套使用dialog组件或是MessageBox这类弹框组件，发现会出现遮罩层重合之类的问题，导致很多人只能选择关闭遮罩层。GitHub上就此问题也出现过类似讨论。有几种解决方案：\n\n<!--more--> \n\n\n1. 按照官方所说，将多个dialog类组件全部移动至**<body**>标签下\n\n2. Github上某位大牛给出了不完全解决方案，基本思路仍然是将添加在**<el-dialog**>内的dom结构自动移动至**<body**>标签下。这个方式测试了下，似乎纯dialog嵌套问题不大，但是如果dialog内部包含了其他组件会有点问题，智者见智，自行探索了\n\n&emsp;&emsp;[附上连接](https://github.com/foolishchow/element-dialog2)\n\n3. 编写自己modal遮罩层，这里给出个不完全临时代码仅供参考\n\n```js\n    Vue.prototype.$Modal = {\n        open(element) {\n            var index = 1;\n            var wrapper = element.querySelector('.el-dialog__wrapper');\n            if (wrapper) {\n                index = wrapper.style.zIndex - 1;\n            }\n            var modalDom = document.createElement('div');\n            modalDom.className = 'v-modal';\n            element.appendChild(modalDom);\n            modalDom.style.zIndex = index;\n        },\n        close() {\n            var modal = document.getElementsByClassName('v-modal')[0;\n            modal.parentNode.removeChild(modal);\n        }\n    }\n\n```\n&emsp;&emsp;一般调用方法\n```js\n    mounted: function () {\n        var that = this;\n        this.$nextTick(function () {\n            //遮罩层\n            that.$nextTick(function () {\n                that.$Modal.open(that.$el);\n            });\n        });\n    },\n```\n\n&emsp;&emsp;主要想法就是在组件mounted完成的nextTick后，为页面中添加一个div，样式就直接采用element自己的了，因为遮罩层是添加在dialog组件下的，因此组件销毁后也会自己销毁，close方法也没用上，但也应该会遇到有用上的时候吧。\n","slug":"vue-dialog-nested","published":1,"updated":"2019-01-30T07:29:03.654Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5pxo2c000dul3ikjr9nbiw","content":"<p>&emsp;&emsp;最近用 Vue+element 开发项目时，在dialog组件上嵌套使用dialog组件或是MessageBox这类弹框组件，发现会出现遮罩层重合之类的问题，导致很多人只能选择关闭遮罩层。GitHub上就此问题也出现过类似讨论。有几种解决方案：</p>\n<a id=\"more\"></a> \n<ol>\n<li><p>按照官方所说，将多个dialog类组件全部移动至<strong>&lt;body</strong>&gt;标签下</p>\n</li>\n<li><p>Github上某位大牛给出了不完全解决方案，基本思路仍然是将添加在<strong>&lt;el-dialog</strong>&gt;内的dom结构自动移动至<strong>&lt;body</strong>&gt;标签下。这个方式测试了下，似乎纯dialog嵌套问题不大，但是如果dialog内部包含了其他组件会有点问题，智者见智，自行探索了</p>\n</li>\n</ol>\n<p>&emsp;&emsp;<a href=\"https://github.com/foolishchow/element-dialog2\" target=\"_blank\" rel=\"noopener\">附上连接</a></p>\n<ol start=\"3\">\n<li>编写自己modal遮罩层，这里给出个不完全临时代码仅供参考</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">Vue.prototype.$Modal = &#123;</span><br><span class=\"line\">    open(element) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> index = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> wrapper = element.querySelector(<span class=\"string\">'.el-dialog__wrapper'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (wrapper) &#123;</span><br><span class=\"line\">            index = wrapper.style.zIndex - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> modalDom = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'div'</span>);</span><br><span class=\"line\">        modalDom.className = <span class=\"string\">'v-modal'</span>;</span><br><span class=\"line\">        element.appendChild(modalDom);</span><br><span class=\"line\">        modalDom.style.zIndex = index;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    close() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> modal = <span class=\"built_in\">document</span>.getElementsByClassName(<span class=\"string\">'v-modal'</span>)[<span class=\"number\">0</span>;</span><br><span class=\"line\">        modal.parentNode.removeChild(modal);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;一般调用方法<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">mounted: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//遮罩层</span></span><br><span class=\"line\">        that.$nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            that.$Modal.open(that.$el);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;主要想法就是在组件mounted完成的nextTick后，为页面中添加一个div，样式就直接采用element自己的了，因为遮罩层是添加在dialog组件下的，因此组件销毁后也会自己销毁，close方法也没用上，但也应该会遇到有用上的时候吧。</p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;最近用 Vue+element 开发项目时，在dialog组件上嵌套使用dialog组件或是MessageBox这类弹框组件，发现会出现遮罩层重合之类的问题，导致很多人只能选择关闭遮罩层。GitHub上就此问题也出现过类似讨论。有几种解决方案：</p>","more":"<ol>\n<li><p>按照官方所说，将多个dialog类组件全部移动至<strong>&lt;body</strong>&gt;标签下</p>\n</li>\n<li><p>Github上某位大牛给出了不完全解决方案，基本思路仍然是将添加在<strong>&lt;el-dialog</strong>&gt;内的dom结构自动移动至<strong>&lt;body</strong>&gt;标签下。这个方式测试了下，似乎纯dialog嵌套问题不大，但是如果dialog内部包含了其他组件会有点问题，智者见智，自行探索了</p>\n</li>\n</ol>\n<p>&emsp;&emsp;<a href=\"https://github.com/foolishchow/element-dialog2\" target=\"_blank\" rel=\"noopener\">附上连接</a></p>\n<ol start=\"3\">\n<li>编写自己modal遮罩层，这里给出个不完全临时代码仅供参考</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">Vue.prototype.$Modal = &#123;</span><br><span class=\"line\">    open(element) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> index = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> wrapper = element.querySelector(<span class=\"string\">'.el-dialog__wrapper'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (wrapper) &#123;</span><br><span class=\"line\">            index = wrapper.style.zIndex - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> modalDom = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'div'</span>);</span><br><span class=\"line\">        modalDom.className = <span class=\"string\">'v-modal'</span>;</span><br><span class=\"line\">        element.appendChild(modalDom);</span><br><span class=\"line\">        modalDom.style.zIndex = index;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    close() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> modal = <span class=\"built_in\">document</span>.getElementsByClassName(<span class=\"string\">'v-modal'</span>)[<span class=\"number\">0</span>;</span><br><span class=\"line\">        modal.parentNode.removeChild(modal);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;一般调用方法<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">mounted: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//遮罩层</span></span><br><span class=\"line\">        that.$nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            that.$Modal.open(that.$el);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;主要想法就是在组件mounted完成的nextTick后，为页面中添加一个div，样式就直接采用element自己的了，因为遮罩层是添加在dialog组件下的，因此组件销毁后也会自己销毁，close方法也没用上，但也应该会遇到有用上的时候吧。</p>"},{"title":"矢量切片的使用尝试1—openlayers应用","date":"2017-11-12T02:54:57.000Z","_content":"\n&nbsp;&nbsp;对于GIS行业来说，栅格切片已经处于垄断地位很长时间了，但随着mapbox的发展，矢量切片越来越勾引起大家探究的欲望，最近我也小小的观望了下，发现现在技术还是比较成熟了，使用上却不是很广泛，遂分享下自己瞎折腾的一些路，想着帮助大家少踩点坑，本文将介绍下服务端和网页端中OpenLayers对于矢量切片的一些应用。\n\n<!-- more -->\n\n&nbsp;&nbsp;在项目实际使用中还是建议大家首先了解下矢量和栅格切片的优缺点，网上能搜到的很多，水平有限，这里不献丑了。对于我个人来说吸引我的无非三点：1.支持大数据；2.自定义渲染；3.要素交互。\n\n&nbsp;&nbsp;不多说了进入主题吧，OpenLayers中支持`ol.source.VectorTile`,对于我们来说想使用它无非就是创造这一类型的`source`，目前来说想要自定义矢量切片源我探索的有以下几种方式：\n\n# geoserver中的vectortiles-plugin插件\n\n这种方式网上教程很多，是大家目前常用的，优点是支持的数据格式比较多，输出的数据格式也很多，geojson、topojson、mvt都能做到，不做过多介绍\n\n# mapbox开发的geojson-vt库\n\n这个库可能大家不去仔细关注都不会发现，mapbox推出，[geojson-vt](https://github.com/mapbox/geojson-vt)，作用很简单，官方说明简单明了，把geojson转换成mvt格式的矢量数据源。\n\n翻译一下使用：\n\n````js\n// 通过geojson数据源构建切片索引\nvar tileIndex = geojsonvt(geoJSON);\n\n// 通过z,x,y来在切片索引中请求某个具体瓦片\nvar features = tileIndex.getTile(z, x, y).features;\n````\n\n拿到features后无非就是做样式调整之类的工作了。OpenLayers官方也有一个demo，叫做[geojson-vt integration](https://openlayers.org/en/latest/examples/geojson-vt.html)，详细介绍了怎么在OpenLayers中结合使用该库。\n\n我在实际使用中发现，这个库可以说很imba了，有测试200M以上的geojson源文件，都能流畅的展示出来。mapbox官方对于这个库的说明是，把geojson切割成矢量切片在**浏览器端**使用，所以我觉得因为**网络传输**的不确定性，对于**小一点**的数据量，可以考虑直接在浏览器端使用这个库。\n\n# geojson-vt的nodejs服务端实现\n\n(｡･∀･)ﾉﾞ嗨，既然是js，那就意味着，我们可以用nodejs搭建服务端呀，在浏览到某个层级时候，只请求当前需要的瓦片，不就能解决大数据的传输问题了，nodejs大法好！\n\n具体的代码可以移步[github](https://github.com/zzcyrus/openlayers-demos/tree/master/1.vector_tile)\n\n这里对一些主要部分做一些说明\n\n````js\n// 读取数据源文件，构建切片索引\nconst dataFile = \"./data/world.json\";\nconst dataSource = JSON.parse(fs.readFileSync(dataFile));\nconst tileIndex = geojsonvt(dataSource, {\n    extent: 4096,\n    debug: 1\n});\n````\n\n````js\n// 从url中解析瓦片请求位置的x，y，z\napp.use(async (ctx, next) => {\n    let path = ctx.request.path.toString()\n    ctx.response.type = 'application/json';\n    if (path.indexOf('.vector') !== -1) {\n        const pathArr = path.substring(1, path.indexOf('.vector')).split('/')\n        const z = pathArr[pathArr.length - 3]\n        const x = pathArr[pathArr.length - 2]\n        const y = pathArr[pathArr.length - 1]\n        const data = tileIndex.getTile(Number(z), Number(x), Number(y));\n        const features = JSON.stringify({\n            type: 'FeatureCollection',\n            features: data ? data.features : []\n        }, replacer)  // replacer 是geojson格式转换函数\n        ctx.response.body = features\n        await next()\n    } else {\n        ctx.response.body = 'Error'\n    }\n});\n````\n\n接下来是浏览器中的调用\n\n````js\nvar vectorSource = new ol.source.VectorTile({\n        // 因为转换函数是geojson格式，所以这里format为geojson\n        format: new ol.format.GeoJSON({\n            // 要定义数据源的坐标系为瓦片像素\n            defaultDataProjection: new ol.proj.Projection({\n                code: 'TILE_PIXELS',\n                units: 'tile-pixels'\n            })\n        }),\n        // 调用时候要注意z，x，y 的位置，实际上是与服务端相对应的\n        url: 'http://localhost:3000/gettile/{z}/{x}/{y}.vector',\n    });\n````\n\n你可以在 [github](https://github.com/zzcyrus/openlayers-demos) 上看到demo，执行安装启动\n\n````cl\ncd ./1.vector_tile\nnpm install\nnpm start\n````\n\n打开vectortile.hmtl可以在network中看到瓦片请求了。\n\n![](network.png)","source":"_posts/vector-tile-openlayers-try.md","raw":"---\ntitle: 矢量切片的使用尝试1—openlayers应用\ndate: 2017-11-12 10:54:57\ntags: [GIS,OpenLayers]\ncategories: OpenLayers\n---\n\n&nbsp;&nbsp;对于GIS行业来说，栅格切片已经处于垄断地位很长时间了，但随着mapbox的发展，矢量切片越来越勾引起大家探究的欲望，最近我也小小的观望了下，发现现在技术还是比较成熟了，使用上却不是很广泛，遂分享下自己瞎折腾的一些路，想着帮助大家少踩点坑，本文将介绍下服务端和网页端中OpenLayers对于矢量切片的一些应用。\n\n<!-- more -->\n\n&nbsp;&nbsp;在项目实际使用中还是建议大家首先了解下矢量和栅格切片的优缺点，网上能搜到的很多，水平有限，这里不献丑了。对于我个人来说吸引我的无非三点：1.支持大数据；2.自定义渲染；3.要素交互。\n\n&nbsp;&nbsp;不多说了进入主题吧，OpenLayers中支持`ol.source.VectorTile`,对于我们来说想使用它无非就是创造这一类型的`source`，目前来说想要自定义矢量切片源我探索的有以下几种方式：\n\n# geoserver中的vectortiles-plugin插件\n\n这种方式网上教程很多，是大家目前常用的，优点是支持的数据格式比较多，输出的数据格式也很多，geojson、topojson、mvt都能做到，不做过多介绍\n\n# mapbox开发的geojson-vt库\n\n这个库可能大家不去仔细关注都不会发现，mapbox推出，[geojson-vt](https://github.com/mapbox/geojson-vt)，作用很简单，官方说明简单明了，把geojson转换成mvt格式的矢量数据源。\n\n翻译一下使用：\n\n````js\n// 通过geojson数据源构建切片索引\nvar tileIndex = geojsonvt(geoJSON);\n\n// 通过z,x,y来在切片索引中请求某个具体瓦片\nvar features = tileIndex.getTile(z, x, y).features;\n````\n\n拿到features后无非就是做样式调整之类的工作了。OpenLayers官方也有一个demo，叫做[geojson-vt integration](https://openlayers.org/en/latest/examples/geojson-vt.html)，详细介绍了怎么在OpenLayers中结合使用该库。\n\n我在实际使用中发现，这个库可以说很imba了，有测试200M以上的geojson源文件，都能流畅的展示出来。mapbox官方对于这个库的说明是，把geojson切割成矢量切片在**浏览器端**使用，所以我觉得因为**网络传输**的不确定性，对于**小一点**的数据量，可以考虑直接在浏览器端使用这个库。\n\n# geojson-vt的nodejs服务端实现\n\n(｡･∀･)ﾉﾞ嗨，既然是js，那就意味着，我们可以用nodejs搭建服务端呀，在浏览到某个层级时候，只请求当前需要的瓦片，不就能解决大数据的传输问题了，nodejs大法好！\n\n具体的代码可以移步[github](https://github.com/zzcyrus/openlayers-demos/tree/master/1.vector_tile)\n\n这里对一些主要部分做一些说明\n\n````js\n// 读取数据源文件，构建切片索引\nconst dataFile = \"./data/world.json\";\nconst dataSource = JSON.parse(fs.readFileSync(dataFile));\nconst tileIndex = geojsonvt(dataSource, {\n    extent: 4096,\n    debug: 1\n});\n````\n\n````js\n// 从url中解析瓦片请求位置的x，y，z\napp.use(async (ctx, next) => {\n    let path = ctx.request.path.toString()\n    ctx.response.type = 'application/json';\n    if (path.indexOf('.vector') !== -1) {\n        const pathArr = path.substring(1, path.indexOf('.vector')).split('/')\n        const z = pathArr[pathArr.length - 3]\n        const x = pathArr[pathArr.length - 2]\n        const y = pathArr[pathArr.length - 1]\n        const data = tileIndex.getTile(Number(z), Number(x), Number(y));\n        const features = JSON.stringify({\n            type: 'FeatureCollection',\n            features: data ? data.features : []\n        }, replacer)  // replacer 是geojson格式转换函数\n        ctx.response.body = features\n        await next()\n    } else {\n        ctx.response.body = 'Error'\n    }\n});\n````\n\n接下来是浏览器中的调用\n\n````js\nvar vectorSource = new ol.source.VectorTile({\n        // 因为转换函数是geojson格式，所以这里format为geojson\n        format: new ol.format.GeoJSON({\n            // 要定义数据源的坐标系为瓦片像素\n            defaultDataProjection: new ol.proj.Projection({\n                code: 'TILE_PIXELS',\n                units: 'tile-pixels'\n            })\n        }),\n        // 调用时候要注意z，x，y 的位置，实际上是与服务端相对应的\n        url: 'http://localhost:3000/gettile/{z}/{x}/{y}.vector',\n    });\n````\n\n你可以在 [github](https://github.com/zzcyrus/openlayers-demos) 上看到demo，执行安装启动\n\n````cl\ncd ./1.vector_tile\nnpm install\nnpm start\n````\n\n打开vectortile.hmtl可以在network中看到瓦片请求了。\n\n![](network.png)","slug":"vector-tile-openlayers-try","published":1,"updated":"2019-01-30T07:29:03.653Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt5pxo2f000iul3i9a7cjjzd","content":"<p>&nbsp;&nbsp;对于GIS行业来说，栅格切片已经处于垄断地位很长时间了，但随着mapbox的发展，矢量切片越来越勾引起大家探究的欲望，最近我也小小的观望了下，发现现在技术还是比较成熟了，使用上却不是很广泛，遂分享下自己瞎折腾的一些路，想着帮助大家少踩点坑，本文将介绍下服务端和网页端中OpenLayers对于矢量切片的一些应用。</p>\n<a id=\"more\"></a>\n<p>&nbsp;&nbsp;在项目实际使用中还是建议大家首先了解下矢量和栅格切片的优缺点，网上能搜到的很多，水平有限，这里不献丑了。对于我个人来说吸引我的无非三点：1.支持大数据；2.自定义渲染；3.要素交互。</p>\n<p>&nbsp;&nbsp;不多说了进入主题吧，OpenLayers中支持<code>ol.source.VectorTile</code>,对于我们来说想使用它无非就是创造这一类型的<code>source</code>，目前来说想要自定义矢量切片源我探索的有以下几种方式：</p>\n<h1 id=\"geoserver中的vectortiles-plugin插件\"><a href=\"#geoserver中的vectortiles-plugin插件\" class=\"headerlink\" title=\"geoserver中的vectortiles-plugin插件\"></a>geoserver中的vectortiles-plugin插件</h1><p>这种方式网上教程很多，是大家目前常用的，优点是支持的数据格式比较多，输出的数据格式也很多，geojson、topojson、mvt都能做到，不做过多介绍</p>\n<h1 id=\"mapbox开发的geojson-vt库\"><a href=\"#mapbox开发的geojson-vt库\" class=\"headerlink\" title=\"mapbox开发的geojson-vt库\"></a>mapbox开发的geojson-vt库</h1><p>这个库可能大家不去仔细关注都不会发现，mapbox推出，<a href=\"https://github.com/mapbox/geojson-vt\" target=\"_blank\" rel=\"noopener\">geojson-vt</a>，作用很简单，官方说明简单明了，把geojson转换成mvt格式的矢量数据源。</p>\n<p>翻译一下使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过geojson数据源构建切片索引</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> tileIndex = geojsonvt(geoJSON);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过z,x,y来在切片索引中请求某个具体瓦片</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> features = tileIndex.getTile(z, x, y).features;</span><br></pre></td></tr></table></figure>\n<p>拿到features后无非就是做样式调整之类的工作了。OpenLayers官方也有一个demo，叫做<a href=\"https://openlayers.org/en/latest/examples/geojson-vt.html\" target=\"_blank\" rel=\"noopener\">geojson-vt integration</a>，详细介绍了怎么在OpenLayers中结合使用该库。</p>\n<p>我在实际使用中发现，这个库可以说很imba了，有测试200M以上的geojson源文件，都能流畅的展示出来。mapbox官方对于这个库的说明是，把geojson切割成矢量切片在<strong>浏览器端</strong>使用，所以我觉得因为<strong>网络传输</strong>的不确定性，对于<strong>小一点</strong>的数据量，可以考虑直接在浏览器端使用这个库。</p>\n<h1 id=\"geojson-vt的nodejs服务端实现\"><a href=\"#geojson-vt的nodejs服务端实现\" class=\"headerlink\" title=\"geojson-vt的nodejs服务端实现\"></a>geojson-vt的nodejs服务端实现</h1><p>(｡･∀･)ﾉﾞ嗨，既然是js，那就意味着，我们可以用nodejs搭建服务端呀，在浏览到某个层级时候，只请求当前需要的瓦片，不就能解决大数据的传输问题了，nodejs大法好！</p>\n<p>具体的代码可以移步<a href=\"https://github.com/zzcyrus/openlayers-demos/tree/master/1.vector_tile\" target=\"_blank\" rel=\"noopener\">github</a></p>\n<p>这里对一些主要部分做一些说明</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 读取数据源文件，构建切片索引</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> dataFile = <span class=\"string\">\"./data/world.json\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> dataSource = <span class=\"built_in\">JSON</span>.parse(fs.readFileSync(dataFile));</span><br><span class=\"line\"><span class=\"keyword\">const</span> tileIndex = geojsonvt(dataSource, &#123;</span><br><span class=\"line\">    extent: <span class=\"number\">4096</span>,</span><br><span class=\"line\">    debug: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从url中解析瓦片请求位置的x，y，z</span></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> path = ctx.request.path.toString()</span><br><span class=\"line\">    ctx.response.type = <span class=\"string\">'application/json'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (path.indexOf(<span class=\"string\">'.vector'</span>) !== <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> pathArr = path.substring(<span class=\"number\">1</span>, path.indexOf(<span class=\"string\">'.vector'</span>)).split(<span class=\"string\">'/'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">const</span> z = pathArr[pathArr.length - <span class=\"number\">3</span>]</span><br><span class=\"line\">        <span class=\"keyword\">const</span> x = pathArr[pathArr.length - <span class=\"number\">2</span>]</span><br><span class=\"line\">        <span class=\"keyword\">const</span> y = pathArr[pathArr.length - <span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">const</span> data = tileIndex.getTile(<span class=\"built_in\">Number</span>(z), <span class=\"built_in\">Number</span>(x), <span class=\"built_in\">Number</span>(y));</span><br><span class=\"line\">        <span class=\"keyword\">const</span> features = <span class=\"built_in\">JSON</span>.stringify(&#123;</span><br><span class=\"line\">            type: <span class=\"string\">'FeatureCollection'</span>,</span><br><span class=\"line\">            features: data ? data.features : []</span><br><span class=\"line\">        &#125;, replacer)  <span class=\"comment\">// replacer 是geojson格式转换函数</span></span><br><span class=\"line\">        ctx.response.body = features</span><br><span class=\"line\">        <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ctx.response.body = <span class=\"string\">'Error'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>接下来是浏览器中的调用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vectorSource = <span class=\"keyword\">new</span> ol.source.VectorTile(&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 因为转换函数是geojson格式，所以这里format为geojson</span></span><br><span class=\"line\">        format: <span class=\"keyword\">new</span> ol.format.GeoJSON(&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 要定义数据源的坐标系为瓦片像素</span></span><br><span class=\"line\">            defaultDataProjection: <span class=\"keyword\">new</span> ol.proj.Projection(&#123;</span><br><span class=\"line\">                code: <span class=\"string\">'TILE_PIXELS'</span>,</span><br><span class=\"line\">                units: <span class=\"string\">'tile-pixels'</span></span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">        <span class=\"comment\">// 调用时候要注意z，x，y 的位置，实际上是与服务端相对应的</span></span><br><span class=\"line\">        url: <span class=\"string\">'http://localhost:3000/gettile/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.vector'</span>,</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>你可以在 <a href=\"https://github.com/zzcyrus/openlayers-demos\" target=\"_blank\" rel=\"noopener\">github</a> 上看到demo，执行安装启动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd ./1.vector_tile</span><br><span class=\"line\">npm install</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<p>打开vectortile.hmtl可以在network中看到瓦片请求了。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"network.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>","site":{"data":{}},"excerpt":"<p>&nbsp;&nbsp;对于GIS行业来说，栅格切片已经处于垄断地位很长时间了，但随着mapbox的发展，矢量切片越来越勾引起大家探究的欲望，最近我也小小的观望了下，发现现在技术还是比较成熟了，使用上却不是很广泛，遂分享下自己瞎折腾的一些路，想着帮助大家少踩点坑，本文将介绍下服务端和网页端中OpenLayers对于矢量切片的一些应用。</p>","more":"<p>&nbsp;&nbsp;在项目实际使用中还是建议大家首先了解下矢量和栅格切片的优缺点，网上能搜到的很多，水平有限，这里不献丑了。对于我个人来说吸引我的无非三点：1.支持大数据；2.自定义渲染；3.要素交互。</p>\n<p>&nbsp;&nbsp;不多说了进入主题吧，OpenLayers中支持<code>ol.source.VectorTile</code>,对于我们来说想使用它无非就是创造这一类型的<code>source</code>，目前来说想要自定义矢量切片源我探索的有以下几种方式：</p>\n<h1 id=\"geoserver中的vectortiles-plugin插件\"><a href=\"#geoserver中的vectortiles-plugin插件\" class=\"headerlink\" title=\"geoserver中的vectortiles-plugin插件\"></a>geoserver中的vectortiles-plugin插件</h1><p>这种方式网上教程很多，是大家目前常用的，优点是支持的数据格式比较多，输出的数据格式也很多，geojson、topojson、mvt都能做到，不做过多介绍</p>\n<h1 id=\"mapbox开发的geojson-vt库\"><a href=\"#mapbox开发的geojson-vt库\" class=\"headerlink\" title=\"mapbox开发的geojson-vt库\"></a>mapbox开发的geojson-vt库</h1><p>这个库可能大家不去仔细关注都不会发现，mapbox推出，<a href=\"https://github.com/mapbox/geojson-vt\" target=\"_blank\" rel=\"noopener\">geojson-vt</a>，作用很简单，官方说明简单明了，把geojson转换成mvt格式的矢量数据源。</p>\n<p>翻译一下使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过geojson数据源构建切片索引</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> tileIndex = geojsonvt(geoJSON);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过z,x,y来在切片索引中请求某个具体瓦片</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> features = tileIndex.getTile(z, x, y).features;</span><br></pre></td></tr></table></figure>\n<p>拿到features后无非就是做样式调整之类的工作了。OpenLayers官方也有一个demo，叫做<a href=\"https://openlayers.org/en/latest/examples/geojson-vt.html\" target=\"_blank\" rel=\"noopener\">geojson-vt integration</a>，详细介绍了怎么在OpenLayers中结合使用该库。</p>\n<p>我在实际使用中发现，这个库可以说很imba了，有测试200M以上的geojson源文件，都能流畅的展示出来。mapbox官方对于这个库的说明是，把geojson切割成矢量切片在<strong>浏览器端</strong>使用，所以我觉得因为<strong>网络传输</strong>的不确定性，对于<strong>小一点</strong>的数据量，可以考虑直接在浏览器端使用这个库。</p>\n<h1 id=\"geojson-vt的nodejs服务端实现\"><a href=\"#geojson-vt的nodejs服务端实现\" class=\"headerlink\" title=\"geojson-vt的nodejs服务端实现\"></a>geojson-vt的nodejs服务端实现</h1><p>(｡･∀･)ﾉﾞ嗨，既然是js，那就意味着，我们可以用nodejs搭建服务端呀，在浏览到某个层级时候，只请求当前需要的瓦片，不就能解决大数据的传输问题了，nodejs大法好！</p>\n<p>具体的代码可以移步<a href=\"https://github.com/zzcyrus/openlayers-demos/tree/master/1.vector_tile\" target=\"_blank\" rel=\"noopener\">github</a></p>\n<p>这里对一些主要部分做一些说明</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 读取数据源文件，构建切片索引</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> dataFile = <span class=\"string\">\"./data/world.json\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> dataSource = <span class=\"built_in\">JSON</span>.parse(fs.readFileSync(dataFile));</span><br><span class=\"line\"><span class=\"keyword\">const</span> tileIndex = geojsonvt(dataSource, &#123;</span><br><span class=\"line\">    extent: <span class=\"number\">4096</span>,</span><br><span class=\"line\">    debug: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从url中解析瓦片请求位置的x，y，z</span></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> path = ctx.request.path.toString()</span><br><span class=\"line\">    ctx.response.type = <span class=\"string\">'application/json'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (path.indexOf(<span class=\"string\">'.vector'</span>) !== <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> pathArr = path.substring(<span class=\"number\">1</span>, path.indexOf(<span class=\"string\">'.vector'</span>)).split(<span class=\"string\">'/'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">const</span> z = pathArr[pathArr.length - <span class=\"number\">3</span>]</span><br><span class=\"line\">        <span class=\"keyword\">const</span> x = pathArr[pathArr.length - <span class=\"number\">2</span>]</span><br><span class=\"line\">        <span class=\"keyword\">const</span> y = pathArr[pathArr.length - <span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">const</span> data = tileIndex.getTile(<span class=\"built_in\">Number</span>(z), <span class=\"built_in\">Number</span>(x), <span class=\"built_in\">Number</span>(y));</span><br><span class=\"line\">        <span class=\"keyword\">const</span> features = <span class=\"built_in\">JSON</span>.stringify(&#123;</span><br><span class=\"line\">            type: <span class=\"string\">'FeatureCollection'</span>,</span><br><span class=\"line\">            features: data ? data.features : []</span><br><span class=\"line\">        &#125;, replacer)  <span class=\"comment\">// replacer 是geojson格式转换函数</span></span><br><span class=\"line\">        ctx.response.body = features</span><br><span class=\"line\">        <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ctx.response.body = <span class=\"string\">'Error'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>接下来是浏览器中的调用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vectorSource = <span class=\"keyword\">new</span> ol.source.VectorTile(&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 因为转换函数是geojson格式，所以这里format为geojson</span></span><br><span class=\"line\">        format: <span class=\"keyword\">new</span> ol.format.GeoJSON(&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 要定义数据源的坐标系为瓦片像素</span></span><br><span class=\"line\">            defaultDataProjection: <span class=\"keyword\">new</span> ol.proj.Projection(&#123;</span><br><span class=\"line\">                code: <span class=\"string\">'TILE_PIXELS'</span>,</span><br><span class=\"line\">                units: <span class=\"string\">'tile-pixels'</span></span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">        <span class=\"comment\">// 调用时候要注意z，x，y 的位置，实际上是与服务端相对应的</span></span><br><span class=\"line\">        url: <span class=\"string\">'http://localhost:3000/gettile/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.vector'</span>,</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>你可以在 <a href=\"https://github.com/zzcyrus/openlayers-demos\" target=\"_blank\" rel=\"noopener\">github</a> 上看到demo，执行安装启动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd ./1.vector_tile</span><br><span class=\"line\">npm install</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<p>打开vectortile.hmtl可以在network中看到瓦片请求了。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"network.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>"}],"PostAsset":[{"_id":"source/_posts/Vue-Parent-and-Child-lifecycle-hooks/lifecircle.png","slug":"lifecircle.png","post":"cjt5pxo220006ul3ifej2t5yd","modified":1,"renderable":0},{"_id":"source/_posts/plugins/tileWMS.png","post":"cjt5pxo250007ul3i0qzsooqs","slug":"tileWMS.png","modified":1,"renderable":1},{"_id":"source/_posts/vector-tile-openlayers-try/network.png","post":"cjt5pxo2f000iul3i9a7cjjzd","slug":"network.png","modified":1,"renderable":1},{"_id":"source/_posts/Vue-Parent-and-Child-lifecycle-hooks/parent-child-hooks.png","post":"cjt5pxo220006ul3ifej2t5yd","slug":"parent-child-hooks.png","modified":1,"renderable":1},{"_id":"source/_posts/openlayers-canvas-typhoon/canvasLayer.png","slug":"canvasLayer.png","post":"cjt5pxo2a000cul3irnx111yv","modified":1,"renderable":0},{"_id":"source/_posts/openlayers-canvas-typhoon/canvasSymbol.png","post":"cjt5pxo2a000cul3irnx111yv","slug":"canvasSymbol.png","modified":1,"renderable":1},{"_id":"source/_posts/openlayers-canvas-typhoon/goal.png","post":"cjt5pxo2a000cul3irnx111yv","slug":"goal.png","modified":1,"renderable":1},{"_id":"source/_posts/osm-PostGIS-setup/point.png","slug":"point.png","post":"cjt5pxo1y0002ul3i3521wrml","modified":1,"renderable":0},{"_id":"source/_posts/osm-PostGIS-setup/polygon.png","slug":"polygon.png","post":"cjt5pxo1y0002ul3i3521wrml","modified":1,"renderable":0},{"_id":"source/_posts/osm-PostGIS-setup/distance.png","slug":"distance.png","post":"cjt5pxo1y0002ul3i3521wrml","modified":1,"renderable":0}],"PostCategory":[{"post_id":"cjt5pxo1t0000ul3i099bbbvb","category_id":"cjt5pxo200004ul3i7z357k9h","_id":"cjt5pxo2d000eul3ip8jhzpsf"},{"post_id":"cjt5pxo1y0002ul3i3521wrml","category_id":"cjt5pxo280009ul3iqo8b4qh7","_id":"cjt5pxo2g000jul3ifj50kbk1"},{"post_id":"cjt5pxo220006ul3ifej2t5yd","category_id":"cjt5pxo2e000gul3i3611hex8","_id":"cjt5pxo2h000mul3ia0bu47fi"},{"post_id":"cjt5pxo250007ul3i0qzsooqs","category_id":"cjt5pxo2g000lul3inwlwa7tj","_id":"cjt5pxo2i000tul3i3sjyhxlp"},{"post_id":"cjt5pxo260008ul3ihwah7i93","category_id":"cjt5pxo2g000lul3inwlwa7tj","_id":"cjt5pxo2j000uul3i7gtb1yf1"},{"post_id":"cjt5pxo2a000cul3irnx111yv","category_id":"cjt5pxo2i000sul3i3rpnowvm","_id":"cjt5pxo2l0011ul3ipy73k01d"},{"post_id":"cjt5pxo2c000dul3ikjr9nbiw","category_id":"cjt5pxo2e000gul3i3611hex8","_id":"cjt5pxo2m0014ul3icklc3osf"},{"post_id":"cjt5pxo2f000iul3i9a7cjjzd","category_id":"cjt5pxo2i000sul3i3rpnowvm","_id":"cjt5pxo2n0018ul3iltctzdfa"}],"PostTag":[{"post_id":"cjt5pxo1t0000ul3i099bbbvb","tag_id":"cjt5pxo220005ul3im1r4wzi0","_id":"cjt5pxo2a000bul3isnt4vek8"},{"post_id":"cjt5pxo1y0002ul3i3521wrml","tag_id":"cjt5pxo220005ul3im1r4wzi0","_id":"cjt5pxo2e000hul3imdi6x8mn"},{"post_id":"cjt5pxo220006ul3ifej2t5yd","tag_id":"cjt5pxo2d000ful3iw3t3l1ac","_id":"cjt5pxo2i000pul3i96lx3d2t"},{"post_id":"cjt5pxo220006ul3ifej2t5yd","tag_id":"cjt5pxo2g000kul3iopuynfr6","_id":"cjt5pxo2i000qul3ipbj78h06"},{"post_id":"cjt5pxo250007ul3i0qzsooqs","tag_id":"cjt5pxo2d000ful3iw3t3l1ac","_id":"cjt5pxo2k000xul3iwqs1mlg2"},{"post_id":"cjt5pxo250007ul3i0qzsooqs","tag_id":"cjt5pxo220005ul3im1r4wzi0","_id":"cjt5pxo2k000yul3i9xwl0tul"},{"post_id":"cjt5pxo250007ul3i0qzsooqs","tag_id":"cjt5pxo2i000rul3i88378yec","_id":"cjt5pxo2l0012ul3iytobkcc1"},{"post_id":"cjt5pxo260008ul3ihwah7i93","tag_id":"cjt5pxo2d000ful3iw3t3l1ac","_id":"cjt5pxo2m0015ul3i6qeni8w4"},{"post_id":"cjt5pxo260008ul3ihwah7i93","tag_id":"cjt5pxo220005ul3im1r4wzi0","_id":"cjt5pxo2n0016ul3iylso4eup"},{"post_id":"cjt5pxo260008ul3ihwah7i93","tag_id":"cjt5pxo2i000rul3i88378yec","_id":"cjt5pxo2n0019ul3ilfk0jxr4"},{"post_id":"cjt5pxo2a000cul3irnx111yv","tag_id":"cjt5pxo2d000ful3iw3t3l1ac","_id":"cjt5pxo2o001bul3ibir3zpd9"},{"post_id":"cjt5pxo2a000cul3irnx111yv","tag_id":"cjt5pxo220005ul3im1r4wzi0","_id":"cjt5pxo2o001cul3i5bfxzsv5"},{"post_id":"cjt5pxo2a000cul3irnx111yv","tag_id":"cjt5pxo2n0017ul3i3bcn3t64","_id":"cjt5pxo2p001eul3iehk8lzt2"},{"post_id":"cjt5pxo2c000dul3ikjr9nbiw","tag_id":"cjt5pxo2d000ful3iw3t3l1ac","_id":"cjt5pxo2p001gul3i5b7y6sov"},{"post_id":"cjt5pxo2c000dul3ikjr9nbiw","tag_id":"cjt5pxo2g000kul3iopuynfr6","_id":"cjt5pxo2p001hul3ib6zshyp5"},{"post_id":"cjt5pxo2f000iul3i9a7cjjzd","tag_id":"cjt5pxo220005ul3im1r4wzi0","_id":"cjt5pxo2q001iul3ik43dc6xi"},{"post_id":"cjt5pxo2f000iul3i9a7cjjzd","tag_id":"cjt5pxo2n0017ul3i3bcn3t64","_id":"cjt5pxo2q001jul3ih8zat2r8"}],"Tag":[{"name":"GIS","_id":"cjt5pxo220005ul3im1r4wzi0"},{"name":"FE","_id":"cjt5pxo2d000ful3iw3t3l1ac"},{"name":"Vue","_id":"cjt5pxo2g000kul3iopuynfr6"},{"name":"Leaflet","_id":"cjt5pxo2i000rul3i88378yec"},{"name":"OpenLayers","_id":"cjt5pxo2n0017ul3i3bcn3t64"}]}}