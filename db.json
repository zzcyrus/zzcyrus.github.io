{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/google56eca6eee2792f06.html","path":"google56eca6eee2792f06.html","modified":1,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":1,"renderable":0},{"_id":"themes/indigo/source/css/style.less","path":"css/style.less","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/cc.png","path":"img/cc.png","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/img-err.png","path":"img/img-err.png","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/img-loading.png","path":"img/img-loading.png","modified":1,"renderable":1},{"_id":"themes/indigo/source/js/main.min.js","path":"js/main.min.js","modified":1,"renderable":1},{"_id":"themes/indigo/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/indigo/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/indigo/source/js/search.min.js","path":"js/search.min.js","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/brand.jpg","path":"img/brand.jpg","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.eot","path":"css/fonts/roboto/Roboto-Bold.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff2","path":"css/fonts/roboto/Roboto-Bold.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.eot","path":"css/fonts/roboto/Roboto-Light.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.eot","path":"css/fonts/roboto/Roboto-Medium.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff2","path":"css/fonts/roboto/Roboto-Light.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff2","path":"css/fonts/roboto/Roboto-Medium.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.eot","path":"css/fonts/roboto/Roboto-Regular.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff2","path":"css/fonts/roboto/Roboto-Regular.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff","path":"css/fonts/roboto/Roboto-Regular.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff","path":"css/fonts/roboto/Roboto-Thin.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.eot","path":"css/fonts/roboto/Roboto-Thin.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff2","path":"css/fonts/roboto/Roboto-Thin.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff","path":"css/fonts/fontawesome/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff2","path":"css/fonts/fontawesome/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff","path":"css/fonts/roboto/Roboto-Bold.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff","path":"css/fonts/roboto/Roboto-Light.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff","path":"css/fonts/roboto/Roboto-Medium.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.ttf","path":"css/fonts/roboto/Roboto-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.eot","path":"css/fonts/fontawesome/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/FontAwesome.otf","path":"css/fonts/fontawesome/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.ttf","path":"css/fonts/fontawesome/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.ttf","path":"css/fonts/roboto/Roboto-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.ttf","path":"css/fonts/roboto/Roboto-Light.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.ttf","path":"css/fonts/roboto/Roboto-Thin.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.ttf","path":"css/fonts/roboto/Roboto-Medium.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.svg","path":"css/fonts/fontawesome/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"70643c718cb37d38c76538362733dd69f1ced96a","modified":1548833343648},{"_id":"source/google56eca6eee2792f06.html","hash":"1a362462d2e6419a55873168085e6403c0ac265b","modified":1548833343654},{"_id":"source/robots.txt","hash":"fbc461c7d26b20c1da0d2e479947ebe76e839d8f","modified":1561689639368},{"_id":"themes/indigo/.editorconfig","hash":"67a03b88eadd7810f2e01866e73814074ecd3b87","modified":1548833343655},{"_id":"source/.DS_Store","hash":"b48c4f7d61a5928be717d4bd654481ff1eab36ee","modified":1552392158818},{"_id":"themes/indigo/LICENSE","hash":"9dd0f70bc72c9d575447655526aded395bb93754","modified":1548833343655},{"_id":"themes/indigo/README.md","hash":"480f6efbd0fcf50308b22bc3af7a8c79e56601f8","modified":1548833343655},{"_id":"themes/indigo/_config.yml","hash":"58c52b788c5c5334eba1b9f024869e747aa521d4","modified":1563109334192},{"_id":"themes/indigo/.DS_Store","hash":"9457f542cf2c3f2a50b9ecd64858fc6f50b0d0c4","modified":1562857081889},{"_id":"themes/indigo/package.json","hash":"e49ac0d6d0028d1ec14a41bd1218c6ffa905c13f","modified":1548833343667},{"_id":"source/_posts/.DS_Store","hash":"9b52df4fb81b91b7d8767a2e73f3df9ae21c060e","modified":1552392176581},{"_id":"source/categories/index.md","hash":"498172edabec6245e809f4cacd923b611f1ddaf4","modified":1548833343654},{"_id":"source/tags/index.md","hash":"4230d358e4bac33c4ef402453064f9623ba41b55","modified":1548833343654},{"_id":"themes/indigo/languages/en.yml","hash":"ba78def0453d08172248e220a1f9e145e99b4f23","modified":1548833343655},{"_id":"themes/indigo/languages/zh-CN.yml","hash":"6806e4c305facf19cbe4e37ccc5d6b00cb56e199","modified":1548833343655},{"_id":"themes/indigo/languages/zh-TW.yml","hash":"9b8bdd9c8b68716f364503926dca6ba8571ee5ff","modified":1548833343655},{"_id":"themes/indigo/layout/archive.ejs","hash":"6897178ba358379d6a4b7c0ba1bc2ab97ad5303a","modified":1548833343665},{"_id":"themes/indigo/layout/categories.ejs","hash":"efae06b4d83aaf73ab93260381e891825bf404ac","modified":1548833343665},{"_id":"themes/indigo/layout/category.ejs","hash":"e5ba5cc2e092c199285b8097ef12ffe70bf84c91","modified":1548833343666},{"_id":"themes/indigo/layout/index.ejs","hash":"772c1985c7743e101598b4eddc253f9174c5605b","modified":1548833343666},{"_id":"themes/indigo/layout/layout.ejs","hash":"770af84fff104c398ce8b6c995130cddd3e9a1e9","modified":1548833343666},{"_id":"themes/indigo/layout/page.ejs","hash":"567c42b978da4c39b8b4982df19b940c26bc32a4","modified":1548833343667},{"_id":"themes/indigo/layout/post.ejs","hash":"efc3352828351f8574c51e8a93dc56c66660c3b1","modified":1548833343667},{"_id":"themes/indigo/layout/tag.ejs","hash":"90a231dea3a364b329a740e5d6c49c8cf5664fe9","modified":1548833343667},{"_id":"themes/indigo/layout/tags.ejs","hash":"1fc0461e9602b53899ec756e4361beb8cce74740","modified":1548833343667},{"_id":"themes/indigo/scripts/plugins.js","hash":"3e512cd4340e2cbc452d662424e4cc97046d5cd8","modified":1561702961609},{"_id":"themes/indigo/source/.DS_Store","hash":"8983992a301632f377142eb0de9b7125c7a7c97a","modified":1562857960454},{"_id":"source/_posts/2017/basemap.md","hash":"b952bf4f846d2ab7351ed9aa60d270385b0efdbd","modified":1561701339272},{"_id":"source/_posts/2017/openlayers-canvas-typhoon.md","hash":"f67d57f408b8b98d7820ad9991f030b38e07f2b6","modified":1561701480056},{"_id":"source/_posts/2017/plugins.md","hash":"001794d8f46cf637c5b3fee623b40272afde4e4c","modified":1561701370121},{"_id":"source/_posts/2017/vector-tile-openlayers-try.md","hash":"857c4111a94f9d4745aa68c469b5833a92bf672d","modified":1561701469930},{"_id":"source/_posts/2017/vue-dialog-nested.md","hash":"aed35b6655fd4774c42b53a1071ae626e3879e03","modified":1561701401472},{"_id":"source/_posts/2018/Vue-Parent-and-Child-lifecycle-hooks.md","hash":"800ffe1fff67232b425e092a4d1ac8e88920b7c1","modified":1561701326943},{"_id":"source/_posts/2019/mongoDB-geospatial.md","hash":"e0512853ef2e32430f53751a5a9e20e41a6a02f9","modified":1561701348716},{"_id":"source/_posts/2019/openstreetmap-carto-map.md","hash":"950c8332c47cd2f5bcd99a295fa4590881913df4","modified":1563109406683},{"_id":"source/_posts/2019/osm-PostGIS-setup.md","hash":"c4ccb09edf5e1d42842f214e9af7a0fa8c57f70c","modified":1561701388441},{"_id":"source/_posts/2019/osm-postgis-mvt.md","hash":"15e8e04f6375c8b5da3efeb4556fe6afaa4b8ebc","modified":1563109449276},{"_id":"source/_posts/2019/tilestrata-blend.md","hash":"45aab393a2b4e085dca7f77b924b6322d36f823b","modified":1562570593198},{"_id":"source/_posts/2019/tilestrata-dependency.md","hash":"becc432e582a2846d294161e5e0e4b567275cd00","modified":1562490243888},{"_id":"source/_posts/2019/tilestrata-disk.md","hash":"451aacb95b66e54fef1704ab054d28324eb1f967","modified":1563197999800},{"_id":"source/_posts/2019/tilestrata-etag.md","hash":"7add990829c8d53361e6131e1b6e7711983fc1ee","modified":1563197995005},{"_id":"source/_posts/2019/tilestrata-gm.md","hash":"95bc4be17c45f024b7d50290087268164bfdc5a8","modified":1563109228449},{"_id":"source/_posts/2019/tilestrata-headers.md","hash":"93da9c621c628ebf94ce615042775754e7832169","modified":1561701388441},{"_id":"source/_posts/2019/tilestrata-jsonp.md","hash":"0db4037986b4b2b239dc3b66a1b4c19f5e8b4841","modified":1561701388441},{"_id":"source/_posts/2019/tilestrata-lru.md","hash":"04f9aa2835955446d442781c30797d8404506039","modified":1562856767660},{"_id":"source/_posts/2019/tilestrata-mapnik.md","hash":"4a27ebb0f8f4f9edcd3bb5cf2a27e41470c816ac","modified":1561701388441},{"_id":"source/_posts/2019/tilestrata-postgis-geojson-tiles.md","hash":"45faae302a9f4ae053bea14599262b40ad279325","modified":1562075151353},{"_id":"source/_posts/2019/tilestrata-postgismvt.md","hash":"9f6d1bf39c08a873da383de2abdcf3ba0b54e0dc","modified":1561701388441},{"_id":"source/_posts/2019/tilestrata-sharp.md","hash":"b3acbd0209e61709e28be382e7d3c97725cabfd1","modified":1563109139927},{"_id":"source/_posts/2019/tilestrata-underzoom.md","hash":"9cf6764c572e27613ac523e3fb608f5054d31487","modified":1562856599188},{"_id":"source/_posts/2019/tilestrata-vtile-composite.md","hash":"0ebf0c01c96ea7f6033e006a8b5894cf3a078dee","modified":1562489900921},{"_id":"source/_posts/2019/tilestrata-vtile-raster.md","hash":"52db933abebf2b0d780687f7260b00be15af2c69","modified":1562306936914},{"_id":"source/_posts/2019/tilestrata-vtile.md","hash":"7218777979725cf8d6896514d7fcee63a0d0e210","modified":1562233347139},{"_id":"themes/indigo/layout/_partial/after-footer.ejs","hash":"1351dbfca311f0d50a939f9e1a91c4f65bbcdf5f","modified":1548833343656},{"_id":"themes/indigo/layout/_partial/archive.ejs","hash":"c294c98617ce14082f9b3d5eec83328f480f5597","modified":1548833343656},{"_id":"themes/indigo/layout/_partial/footer.ejs","hash":"a89d74be73ed91d4b3a793bdbe1d00b4189aaa4e","modified":1561702851665},{"_id":"themes/indigo/layout/_partial/head.ejs","hash":"acde2dd615512eb63d7a98e854d16b6cf2f5be86","modified":1548833343656},{"_id":"themes/indigo/layout/_partial/header.ejs","hash":"648db446567a81371b8a29d719d13636aa157012","modified":1548833343656},{"_id":"themes/indigo/layout/_partial/index-item.ejs","hash":"7208d4083ee3355aa969972a2ce249a67d56b3a6","modified":1548833343656},{"_id":"themes/indigo/layout/_partial/loading.ejs","hash":"8b3e037dd5f3d4564012689c5cd6f63caf73df0f","modified":1548833343656},{"_id":"themes/indigo/layout/_partial/menu.ejs","hash":"ea6aded24a68de0914f24b3760f766b5e1c9835a","modified":1548833343656},{"_id":"themes/indigo/layout/_partial/paginator.ejs","hash":"13952250463f70d1c1bbbfdd7f4ee8160dd6d99b","modified":1548833343656},{"_id":"themes/indigo/layout/_partial/post.ejs","hash":"20597ac0d547aea37680ecf195eb129fe5ee19d8","modified":1548833343659},{"_id":"themes/indigo/layout/_partial/script.ejs","hash":"31052bc524a10abd6871aed2415448ce585faff2","modified":1548833343664},{"_id":"themes/indigo/layout/_partial/search.ejs","hash":"752109904304fdb8e988ee1254df2af9c0701466","modified":1548833343664},{"_id":"themes/indigo/layout/_partial/tags-bar.ejs","hash":"30ec74f081cc4c273a7bcd5d57da99072e9f0755","modified":1548833343665},{"_id":"themes/indigo/source/css/style.less","hash":"27dc4b93b93e92824d748f66b85de343b6a68f71","modified":1548833343684},{"_id":"themes/indigo/source/img/cc.png","hash":"ebce75a62b40976a72d43f0bd937d859ac24d87c","modified":1548833343685},{"_id":"themes/indigo/source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1562857183119},{"_id":"themes/indigo/source/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1548833343685},{"_id":"themes/indigo/source/img/avatar.jpg","hash":"d2b91187ed1dae2d6e10de0742063458b8cd54d1","modified":1562857180231},{"_id":"themes/indigo/source/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1548833343685},{"_id":"themes/indigo/source/js/main.min.js","hash":"70652f94832de4801ffe80bf59d09265ac84599f","modified":1548833343685},{"_id":"themes/indigo/source/js/search.js","hash":"a4d6c9c566ec1ca71ddacfd14c58f7ddaf9db24d","modified":1548833343685},{"_id":"themes/indigo/source/js/main.js","hash":"78f3dd49bf34b29155f09c77fd9c7b2e9643bf98","modified":1548833343685},{"_id":"themes/indigo/source/js/search.min.js","hash":"a8a450bb8b1ca9ad577052addcbd3393f1af6c6a","modified":1548833343686},{"_id":"source/_posts/2017/openlayers-canvas-typhoon/canvasSymbol.png","hash":"68cee9b60f04aa63d6ad864065e4ed5b65de0a93","modified":1548833343652},{"_id":"themes/indigo/source/img/favicon.ico","hash":"46701792b80cabc9ab9851fd00735abe180381c3","modified":1562857932375},{"_id":"source/_posts/2017/openlayers-canvas-typhoon/goal.png","hash":"b299febc94934b1afa2e69eef9dd587e9cfc7b55","modified":1548833343652},{"_id":"source/_posts/2018/Vue-Parent-and-Child-lifecycle-hooks/parent-child-hooks.png","hash":"d60fd1f5961cb7afbd5fc0710507d4ba3314dabb","modified":1548833343651},{"_id":"themes/indigo/layout/_partial/plugins/baidu.ejs","hash":"da1355eea131952031e54c45560555e6d3aa5a33","modified":1548833343657},{"_id":"themes/indigo/layout/_partial/plugins/disqus.ejs","hash":"86fe837ab16cb60754b0a73bb9efa38b04f3023f","modified":1548833343657},{"_id":"themes/indigo/layout/_partial/plugins/dynamic-title.ejs","hash":"3b877868c4a6fc217ea6f3314544830280a77472","modified":1548833343657},{"_id":"themes/indigo/layout/_partial/plugins/gitment.ejs","hash":"f502781dca9262469dfd26798a1eaa96fdd52014","modified":1561703011715},{"_id":"themes/indigo/layout/_partial/plugins/google-analytics.ejs","hash":"b5b87761751a897949e085a8f1ace78b0b8babd5","modified":1548833343657},{"_id":"themes/indigo/layout/_partial/plugins/mathjax.ejs","hash":"3a5c9f7d22d30cd8ffa4e83a8d3976db22815994","modified":1548833343658},{"_id":"themes/indigo/layout/_partial/plugins/page-visit.ejs","hash":"bb9deb32c54ea6820f622b923e62592915e9f21f","modified":1548833343658},{"_id":"themes/indigo/layout/_partial/plugins/site-visit.ejs","hash":"a2c247c2e32016563dd6a22c21474072d93f4dbd","modified":1548833343658},{"_id":"themes/indigo/layout/_partial/plugins/tajs.ejs","hash":"ef9c77d8c6e004b014c83c5f9333e7174f8bafa3","modified":1548833343659},{"_id":"themes/indigo/layout/_partial/plugins/uyan.ejs","hash":"ddf290e90dc1c779f42a48e1bd852ca932148dfb","modified":1548833343659},{"_id":"themes/indigo/layout/_partial/plugins/yoyo.ejs","hash":"345a5e21f6e937d23c7958d85b9a02876d0b5f82","modified":1562639877737},{"_id":"themes/indigo/layout/_partial/post/category.ejs","hash":"c08e44cbd7315dec7afb6054b04d3c7b82c3bde8","modified":1548833343660},{"_id":"themes/indigo/layout/_partial/post/comment.ejs","hash":"e4901bb979db7fa6f1c93d1177f5b3d7f445c0e1","modified":1562639893110},{"_id":"themes/indigo/layout/_partial/post/copyright.ejs","hash":"ffd06f34b6d29d5306d1bb8965fcca0e41cdd5f7","modified":1548833343661},{"_id":"themes/indigo/layout/_partial/post/date.ejs","hash":"c5adcec8db1506c378d39855a697e1bb1165646c","modified":1548833343661},{"_id":"themes/indigo/layout/_partial/post/head-meta.ejs","hash":"f137c126672769e9571be2bb0a70ea8dda644b0e","modified":1548833343661},{"_id":"themes/indigo/layout/_partial/post/nav.ejs","hash":"03719097851575a2c1bb95774058b224f6402a1f","modified":1548833343662},{"_id":"themes/indigo/layout/_partial/post/reward-btn.ejs","hash":"b46160005224821a439dec9f1ff183e2f66d9f4b","modified":1548833343662},{"_id":"themes/indigo/layout/_partial/post/reward.ejs","hash":"097c0276a61665e5ee96e5d5d85a7d6ae5ab2f49","modified":1548833343662},{"_id":"themes/indigo/layout/_partial/post/share-fab.ejs","hash":"2ec7de870988cfbc8ea9872cddf7e4076ac64a57","modified":1548833343662},{"_id":"themes/indigo/layout/_partial/post/share.ejs","hash":"7d79a67b3e5e6989f22fb0e0904fa540bfca5fcc","modified":1548833343662},{"_id":"themes/indigo/layout/_partial/post/tag.ejs","hash":"412894001b1ac6e63012b26b1109a0856651c076","modified":1548833343663},{"_id":"themes/indigo/layout/_partial/post/title.ejs","hash":"eaad7af7888bddd7095243a43ff38f55ad8c494a","modified":1548833343663},{"_id":"themes/indigo/layout/_partial/post/toc.ejs","hash":"0d8f0a4ab14c227cd52802095fc4974b6a7aae67","modified":1548833343663},{"_id":"themes/indigo/layout/_partial/post/updated.ejs","hash":"00fedf7971c0bda0623d968bc0614e512d19a985","modified":1561701197035},{"_id":"themes/indigo/source/css/_partial/archives.less","hash":"382fc22cd5cc073e881768a65600d97eba9f1d21","modified":1548833343668},{"_id":"themes/indigo/source/css/_partial/article.less","hash":"9f8573ad56967befe7f7efd5e81ad4965de86914","modified":1548833343668},{"_id":"themes/indigo/source/css/_partial/gotop.less","hash":"bad63006b3bd4849bf53ad38482af0d9971061d3","modified":1548833343668},{"_id":"themes/indigo/source/css/_partial/header.less","hash":"880b4a28e97d556ed15b07642d25115f9b6ba4f6","modified":1548833343669},{"_id":"themes/indigo/source/css/_partial/highlight.less","hash":"99e48793dc0b4ffb66ecaf2d1315145872f9bb98","modified":1562075511684},{"_id":"themes/indigo/source/css/_partial/layout.less","hash":"5f783f34bf093e654e8922ed4a2af8b7b2cd41c4","modified":1548833343669},{"_id":"themes/indigo/source/css/_partial/lightbox.less","hash":"38419aaf3c1832e84ade331f051f110fdc8b960f","modified":1548833343669},{"_id":"themes/indigo/source/css/_partial/loading.less","hash":"85157ddf3877b5c58e8f1d737dda3dfb1bfd540b","modified":1548833343669},{"_id":"themes/indigo/source/css/_partial/page.less","hash":"33b0a5edcedc26a4c592c812c5785bb20d3c93db","modified":1548833343669},{"_id":"themes/indigo/source/css/_partial/postlist.less","hash":"516cded3c7f1db4cacfa898bcaf0adfae7f3a2e1","modified":1548833343669},{"_id":"themes/indigo/source/css/_partial/reward.less","hash":"f5e89ea5414e3096a28c8c96e86c3f669040a892","modified":1548833343669},{"_id":"themes/indigo/source/css/_partial/roboto.less","hash":"3e457942995da8840e7662fa6cb551a7e12ea294","modified":1548833343670},{"_id":"themes/indigo/source/css/_partial/search.less","hash":"dbc23e77e586ee682a21475f5eb568628ea6720f","modified":1548833343670},{"_id":"themes/indigo/source/css/_partial/share.less","hash":"a683c96a59470efd35722b763c55149a46e35156","modified":1548833343670},{"_id":"themes/indigo/source/css/_partial/tags.less","hash":"01eb7f84193180928a6ed4796ee8802f6c1628e7","modified":1548833343670},{"_id":"themes/indigo/source/css/_partial/variable.less","hash":"3232e75f4653402c9fbd7bda5b97c05ecc31db2b","modified":1548833343670},{"_id":"themes/indigo/source/css/_partial/waves.less","hash":"a02eaa601887f947257f6016679b62dc96a61c0c","modified":1548833343670},{"_id":"themes/indigo/source/img/brand.jpg","hash":"5a77a7adadab5b0595da83f329728991724d7636","modified":1562857305772},{"_id":"source/_posts/2017/plugins/tileWMS.png","hash":"ba3e69080062ee93f14f735bb9cc06e6cf93de1c","modified":1548833343653},{"_id":"source/_posts/2017/vector-tile-openlayers-try/network.png","hash":"3c247aaf66bdbc8a21e4865748d6816ff717402b","modified":1548833343654},{"_id":"themes/indigo/source/css/_partial/fontawesome.less","hash":"a3ecbd6ccf5b56ac39df710c34a149b82989a498","modified":1548833343668},{"_id":"source/_posts/2018/Vue-Parent-and-Child-lifecycle-hooks/lifecircle.png","hash":"ab511f99adcdfd840e6b40c08ec78409dbae5f31","modified":1548833343651},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1548833343676},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1548833343677},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1548833343678},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1548833343679},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1548833343679},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1548833343681},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1548833343681},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1548833343682},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1548833343682},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1548833343684},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1548833343682},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1548833343684},{"_id":"source/_posts/2019/osm-PostGIS-setup/distance.png","hash":"7d394bc25962a976dbfa3486737521b7329894b4","modified":1552392035270},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1548833343676},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1548833343676},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1548833343677},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1548833343679},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1548833343680},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1548833343682},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1548833343672},{"_id":"themes/indigo/source/css/fonts/fontawesome/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1548833343671},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1548833343675},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1548833343677},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1548833343678},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1548833343683},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1548833343680},{"_id":"source/_posts/2017/openlayers-canvas-typhoon/canvasLayer.png","hash":"f105722102cab4559d9c8e2652d8f91e6ea89c8f","modified":1548833343652},{"_id":"source/_posts/2019/osm-PostGIS-setup/polygon.png","hash":"e5488fc7a817abe192d859819372e7293a57f1ed","modified":1552391985618},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1548833343674},{"_id":"source/_posts/2019/osm-PostGIS-setup/point.png","hash":"5374198300a2015738c9798c118f4c21b05944ef","modified":1552391957399}],"Category":[{"name":"Leaflet","_id":"cjy4fqa9d00040n3icwqh94fa"},{"name":"OpenLayers","_id":"cjy4fqa9k00090n3i0br3iuff"},{"name":"前端","_id":"cjy4fqa9t000q0n3iorqxdb7f"},{"name":"Node","_id":"cjy4fqa9w000y0n3iav680gza"},{"name":"PostGIS","_id":"cjy4fqaa0001c0n3isahvbnqh"},{"name":"TileStrata","_id":"cjy4fqaa9001z0n3iuoks3l1y"}],"Data":[],"Page":[{"title":"Categories","date":"2017-06-21T12:55:51.000Z","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: Categories\ndate: 2017-06-21 20:55:51\nlayout: \"categories\"\n---\n","updated":"2019-01-30T07:29:03.654Z","path":"categories/index.html","comments":1,"_id":"cjy4fqa8k00000n3iyhhx9pb4","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Tags","date":"2017-06-21T12:55:39.000Z","layout":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: Tags\ndate: 2017-06-21 20:55:39\nlayout: \"tags\"\ncomments: false\n---\n","updated":"2019-01-30T07:29:03.654Z","path":"tags/index.html","_id":"cjy4fqa8u00010n3i1n27dot8","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Leaflet多种基础图层加载","date":"2017-09-17T05:46:08.000Z","_content":"\n\n\n\n&nbsp;&nbsp;最近项目中有移动端的开发需求，自然就用到了最轻量级的gis组件——Leaflet，100多k的体积，五脏俱全，丰富的第三方插件，虽然开发者数量上不及大哥级产品Arcigs，但也基本够用，对于esri的自家系统支持好，svg和canvas两种渲染方式，让数据量大的要素图层渲染也不是那么吃力。\n\n&nbsp;&nbsp;这里把自己对于Leaflet的一些探索研究记录一下，一方面便于自己后期回顾，另一方面也希望和大家一起探讨学习。\n\n<!-- more -->\n\n[Leaflet系列地址](https://github.com/zzcyrus/Leaflet-demos)\n[本文demo地址](https://github.com/zzcyrus/Leaflet-demos/blob/master/0.basemap/basemap.html)\n\n# 基础图层的加载\n\n基础图层的加载都是通过`L.tileLayer`的方式，所以加载的难点不在于api的使用，是一些常用的基础瓦片的收集，这里给出一些常用的地址\n\n````js\n\n    mapRadios: [\n        {\n            label: '高德地图',\n            value: '1',\n            url: 'http://webrd01.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x={x}&y={y}&z={z}'\n        }, {\n            label: 'Esri地图',\n            value: '2',\n            url: 'http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineCommunity/MapServer/tile/{z}/{y}/{x}'\n        }, {\n            label: '天地图道路',\n            value: '3',\n            url: 'http://t0.tianditu.cn/DataServer?T=vec_w&X={x}&Y={y}&L={z}'\n        }, {\n            label: '天地图标注',\n            value: '4',\n            url: 'http://t5.tianditu.cn/DataServer?T=cva_w&X={x}&Y={y}&L={z}'\n        }, {\n            label: '天地图影像',\n            value: '5',\n            url: 'http://t1.tianditu.cn/img_w/wmts?service=wmts&request=GetTile&version=1.0.0&LAYER=img&tileMatrixSet=w&TileMatrix={z}&TileRow={y}&TileCol={x}&style=default&format=tiles'\n        }, {\n            label: '谷歌地形',\n            value: '6',\n            url: 'http://mt3.google.cn/vt/lyrs=t@131&hl=zh-CN&gl=cn&x={x}&y={y}&z={z}&s=Ga'\n        }, {\n            label: '谷歌影像',\n            value: '7',\n            url: 'http://mt3.google.cn/vt/lyrs=s&hl=zh-CN&gl=cn&x={x}&y={y}&z={z}'\n        }, {\n            label: '谷歌标注',\n            value: '8',\n            url: 'http://mt2.google.cn/vt/lyrs=m@167000000&hl=zh-CN&gl=cn&x={x}&y={y}&z={z}'\n        }\n    ]\n````\n\n\n更多的瓦片地址可以在demo中找到，具体的使用效果也可以移步[demo](https://github.com/zzcyrus/Leaflet-demos/blob/master/0.basemap/basemap.html)\n\n\n\n","source":"_posts/2017/basemap.md","raw":"---\ntitle: Leaflet多种基础图层加载\ndate: 2017-09-17 13:46:08\ntags: [FE,GIS,Leaflet]\ncategories: Leaflet\n---\n\n\n\n\n&nbsp;&nbsp;最近项目中有移动端的开发需求，自然就用到了最轻量级的gis组件——Leaflet，100多k的体积，五脏俱全，丰富的第三方插件，虽然开发者数量上不及大哥级产品Arcigs，但也基本够用，对于esri的自家系统支持好，svg和canvas两种渲染方式，让数据量大的要素图层渲染也不是那么吃力。\n\n&nbsp;&nbsp;这里把自己对于Leaflet的一些探索研究记录一下，一方面便于自己后期回顾，另一方面也希望和大家一起探讨学习。\n\n<!-- more -->\n\n[Leaflet系列地址](https://github.com/zzcyrus/Leaflet-demos)\n[本文demo地址](https://github.com/zzcyrus/Leaflet-demos/blob/master/0.basemap/basemap.html)\n\n# 基础图层的加载\n\n基础图层的加载都是通过`L.tileLayer`的方式，所以加载的难点不在于api的使用，是一些常用的基础瓦片的收集，这里给出一些常用的地址\n\n````js\n\n    mapRadios: [\n        {\n            label: '高德地图',\n            value: '1',\n            url: 'http://webrd01.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x={x}&y={y}&z={z}'\n        }, {\n            label: 'Esri地图',\n            value: '2',\n            url: 'http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineCommunity/MapServer/tile/{z}/{y}/{x}'\n        }, {\n            label: '天地图道路',\n            value: '3',\n            url: 'http://t0.tianditu.cn/DataServer?T=vec_w&X={x}&Y={y}&L={z}'\n        }, {\n            label: '天地图标注',\n            value: '4',\n            url: 'http://t5.tianditu.cn/DataServer?T=cva_w&X={x}&Y={y}&L={z}'\n        }, {\n            label: '天地图影像',\n            value: '5',\n            url: 'http://t1.tianditu.cn/img_w/wmts?service=wmts&request=GetTile&version=1.0.0&LAYER=img&tileMatrixSet=w&TileMatrix={z}&TileRow={y}&TileCol={x}&style=default&format=tiles'\n        }, {\n            label: '谷歌地形',\n            value: '6',\n            url: 'http://mt3.google.cn/vt/lyrs=t@131&hl=zh-CN&gl=cn&x={x}&y={y}&z={z}&s=Ga'\n        }, {\n            label: '谷歌影像',\n            value: '7',\n            url: 'http://mt3.google.cn/vt/lyrs=s&hl=zh-CN&gl=cn&x={x}&y={y}&z={z}'\n        }, {\n            label: '谷歌标注',\n            value: '8',\n            url: 'http://mt2.google.cn/vt/lyrs=m@167000000&hl=zh-CN&gl=cn&x={x}&y={y}&z={z}'\n        }\n    ]\n````\n\n\n更多的瓦片地址可以在demo中找到，具体的使用效果也可以移步[demo](https://github.com/zzcyrus/Leaflet-demos/blob/master/0.basemap/basemap.html)\n\n\n\n","slug":"basemap","published":1,"updated":"2019-06-28T05:55:39.272Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy4fqa9900020n3isq4tauus","content":"<p>&nbsp;&nbsp;最近项目中有移动端的开发需求，自然就用到了最轻量级的gis组件——Leaflet，100多k的体积，五脏俱全，丰富的第三方插件，虽然开发者数量上不及大哥级产品Arcigs，但也基本够用，对于esri的自家系统支持好，svg和canvas两种渲染方式，让数据量大的要素图层渲染也不是那么吃力。</p>\n<p>&nbsp;&nbsp;这里把自己对于Leaflet的一些探索研究记录一下，一方面便于自己后期回顾，另一方面也希望和大家一起探讨学习。</p>\n<a id=\"more\"></a>\n<p><a href=\"https://github.com/zzcyrus/Leaflet-demos\" target=\"_blank\" rel=\"noopener\">Leaflet系列地址</a><br><a href=\"https://github.com/zzcyrus/Leaflet-demos/blob/master/0.basemap/basemap.html\" target=\"_blank\" rel=\"noopener\">本文demo地址</a></p>\n<h1 id=\"基础图层的加载\"><a href=\"#基础图层的加载\" class=\"headerlink\" title=\"基础图层的加载\"></a>基础图层的加载</h1><p>基础图层的加载都是通过<code>L.tileLayer</code>的方式，所以加载的难点不在于api的使用，是一些常用的基础瓦片的收集，这里给出一些常用的地址</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">mapRadios: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        label: <span class=\"string\">'高德地图'</span>,</span><br><span class=\"line\">        value: <span class=\"string\">'1'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'http://webrd01.is.autonavi.com/appmaptile?lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;'</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        label: <span class=\"string\">'Esri地图'</span>,</span><br><span class=\"line\">        value: <span class=\"string\">'2'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineCommunity/MapServer/tile/&#123;z&#125;/&#123;y&#125;/&#123;x&#125;'</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        label: <span class=\"string\">'天地图道路'</span>,</span><br><span class=\"line\">        value: <span class=\"string\">'3'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'http://t0.tianditu.cn/DataServer?T=vec_w&amp;X=&#123;x&#125;&amp;Y=&#123;y&#125;&amp;L=&#123;z&#125;'</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        label: <span class=\"string\">'天地图标注'</span>,</span><br><span class=\"line\">        value: <span class=\"string\">'4'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'http://t5.tianditu.cn/DataServer?T=cva_w&amp;X=&#123;x&#125;&amp;Y=&#123;y&#125;&amp;L=&#123;z&#125;'</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        label: <span class=\"string\">'天地图影像'</span>,</span><br><span class=\"line\">        value: <span class=\"string\">'5'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'http://t1.tianditu.cn/img_w/wmts?service=wmts&amp;request=GetTile&amp;version=1.0.0&amp;LAYER=img&amp;tileMatrixSet=w&amp;TileMatrix=&#123;z&#125;&amp;TileRow=&#123;y&#125;&amp;TileCol=&#123;x&#125;&amp;style=default&amp;format=tiles'</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        label: <span class=\"string\">'谷歌地形'</span>,</span><br><span class=\"line\">        value: <span class=\"string\">'6'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'http://mt3.google.cn/vt/lyrs=t@131&amp;hl=zh-CN&amp;gl=cn&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;&amp;s=Ga'</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        label: <span class=\"string\">'谷歌影像'</span>,</span><br><span class=\"line\">        value: <span class=\"string\">'7'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'http://mt3.google.cn/vt/lyrs=s&amp;hl=zh-CN&amp;gl=cn&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;'</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        label: <span class=\"string\">'谷歌标注'</span>,</span><br><span class=\"line\">        value: <span class=\"string\">'8'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'http://mt2.google.cn/vt/lyrs=m@167000000&amp;hl=zh-CN&amp;gl=cn&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>更多的瓦片地址可以在demo中找到，具体的使用效果也可以移步<a href=\"https://github.com/zzcyrus/Leaflet-demos/blob/master/0.basemap/basemap.html\" target=\"_blank\" rel=\"noopener\">demo</a></p>\n","site":{"data":{}},"excerpt":"<p>&nbsp;&nbsp;最近项目中有移动端的开发需求，自然就用到了最轻量级的gis组件——Leaflet，100多k的体积，五脏俱全，丰富的第三方插件，虽然开发者数量上不及大哥级产品Arcigs，但也基本够用，对于esri的自家系统支持好，svg和canvas两种渲染方式，让数据量大的要素图层渲染也不是那么吃力。</p>\n<p>&nbsp;&nbsp;这里把自己对于Leaflet的一些探索研究记录一下，一方面便于自己后期回顾，另一方面也希望和大家一起探讨学习。</p>","more":"<p><a href=\"https://github.com/zzcyrus/Leaflet-demos\" target=\"_blank\" rel=\"noopener\">Leaflet系列地址</a><br><a href=\"https://github.com/zzcyrus/Leaflet-demos/blob/master/0.basemap/basemap.html\" target=\"_blank\" rel=\"noopener\">本文demo地址</a></p>\n<h1 id=\"基础图层的加载\"><a href=\"#基础图层的加载\" class=\"headerlink\" title=\"基础图层的加载\"></a>基础图层的加载</h1><p>基础图层的加载都是通过<code>L.tileLayer</code>的方式，所以加载的难点不在于api的使用，是一些常用的基础瓦片的收集，这里给出一些常用的地址</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">mapRadios: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        label: <span class=\"string\">'高德地图'</span>,</span><br><span class=\"line\">        value: <span class=\"string\">'1'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'http://webrd01.is.autonavi.com/appmaptile?lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;'</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        label: <span class=\"string\">'Esri地图'</span>,</span><br><span class=\"line\">        value: <span class=\"string\">'2'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineCommunity/MapServer/tile/&#123;z&#125;/&#123;y&#125;/&#123;x&#125;'</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        label: <span class=\"string\">'天地图道路'</span>,</span><br><span class=\"line\">        value: <span class=\"string\">'3'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'http://t0.tianditu.cn/DataServer?T=vec_w&amp;X=&#123;x&#125;&amp;Y=&#123;y&#125;&amp;L=&#123;z&#125;'</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        label: <span class=\"string\">'天地图标注'</span>,</span><br><span class=\"line\">        value: <span class=\"string\">'4'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'http://t5.tianditu.cn/DataServer?T=cva_w&amp;X=&#123;x&#125;&amp;Y=&#123;y&#125;&amp;L=&#123;z&#125;'</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        label: <span class=\"string\">'天地图影像'</span>,</span><br><span class=\"line\">        value: <span class=\"string\">'5'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'http://t1.tianditu.cn/img_w/wmts?service=wmts&amp;request=GetTile&amp;version=1.0.0&amp;LAYER=img&amp;tileMatrixSet=w&amp;TileMatrix=&#123;z&#125;&amp;TileRow=&#123;y&#125;&amp;TileCol=&#123;x&#125;&amp;style=default&amp;format=tiles'</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        label: <span class=\"string\">'谷歌地形'</span>,</span><br><span class=\"line\">        value: <span class=\"string\">'6'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'http://mt3.google.cn/vt/lyrs=t@131&amp;hl=zh-CN&amp;gl=cn&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;&amp;s=Ga'</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        label: <span class=\"string\">'谷歌影像'</span>,</span><br><span class=\"line\">        value: <span class=\"string\">'7'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'http://mt3.google.cn/vt/lyrs=s&amp;hl=zh-CN&amp;gl=cn&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;'</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        label: <span class=\"string\">'谷歌标注'</span>,</span><br><span class=\"line\">        value: <span class=\"string\">'8'</span>,</span><br><span class=\"line\">        url: <span class=\"string\">'http://mt2.google.cn/vt/lyrs=m@167000000&amp;hl=zh-CN&amp;gl=cn&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>更多的瓦片地址可以在demo中找到，具体的使用效果也可以移步<a href=\"https://github.com/zzcyrus/Leaflet-demos/blob/master/0.basemap/basemap.html\" target=\"_blank\" rel=\"noopener\">demo</a></p>"},{"title":"openlayers 从台风风圈绘制到canvas样式和图层的应用","date":"2017-07-31T14:31:02.000Z","_content":"本文中所使用的数据来源于[温州台风网](http://www.wztf121.com/typhoon.html)，通过F12抓取，你可以在我的[GitHub](\nhttps://github.com/zzcyrus/openlayers-demos\n)上查看数据和本文源代码\n\n&nbsp;&nbsp;台风的风圈是一种不常见但算的上规则的图形，在上面的网站可以看到最终效果，简单的解剖下其实就是四个1/4圆\n\n![](goal.png)\n\n从数据结构上也可以看出来：\n```js\n        var radius_quad = {\n            \"ne\": 250, //单位为KM\n            \"se\": 250,\n            \"sw\": 180,\n            \"nw\": 150\n        }\n```\n在某个固定经纬度点上，以此点为圆心组合成了一个所谓的风圈形状，四个方向分别代表每个1/4圆的半径。刚开始是为了实现这种效果进行了研究，后来发现openlayers对于这种效果的支持还挺有意思，记录下来已做分享。\n\n<!-- more -->\n\n\n# 通过自定义geometry的实现\n&nbsp;&nbsp;最原始的思路也是最容易切入的点，就是去看openlayers中怎么实现圆形的画法，在ol中，有`createRegularPolygon`这个类，原理就是给定一些参数，用点去填充我们想要的形状，当填进去点达到一定密集度，自然就能得到一个近似的圆。\n&nbsp;&nbsp;通过这个思路我们可以计算台风风圈的每个1/4圆的坐标，用点去占位，最终实现绘制出想要的图形。\n\n具体代码可以去看某大牛的博客，这里只给出一个传送门，写的很详细了：\n[点我乘坐飞机](http://blog.csdn.net/gisshixisheng/article/details/76397068) **这个算法还有些不完善，就是在每个1/4圆结束时候少计算了一个点，导致看着有点不对劲**\n\n\n**特点:** 这种方式画出来的图形是一个图层中的一个feature，好处自然不用多说，基本上feature支持的功能都能满足！\n\n\n# 通过canvas类型的symbol实现\n&nbsp;&nbsp;在点密集的情况下，用上面的方式其实效果已经很不错了，但是有些细（tiao）心（ci）的使用者，非要放大到一定程度，然后说你这个不够圆，那。。。。。\n\n&nbsp;&nbsp;那我们就用canvas画出来，openlayers中，要素的样式是有这么一种方式`ol.style.Icon`来实现，我们可以把绘制好的元素作为`Icon`的参数\n```js\n        var style = new ol.style.Style({\n            image: new ol.style.Icon({\n                opacity: 0.3,\n                img: canvas,\n                imgSize: [canvas.width, canvas.height],\n            })\n        })\n```\ncanvans绘制的方法：\n```js\n        function createTyphoon(radius, radius_quad) {\n            var canvas = document.createElement('canvas');\n            canvas.width = canvas.height = 2 * radius;\n            var context = canvas.getContext(\"2d\");\n            context.fillStyle = \"#0000ff\";\n            context.strokeStyle = \"#ff0000\";\n            context.lineWidth = 3;\n            context.beginPath();\n            context.arc(radius, radius, radius_quad.se, 0, 0.5 * Math.PI);\n            context.lineTo(radius, radius + radius_quad.sw);\n            context.arc(radius, radius, radius_quad.sw, 0.5 * Math.PI, Math.PI);\n            context.lineTo(radius - radius_quad.nw, radius);\n            context.arc(radius, radius, radius_quad.nw, Math.PI, 1.5 * Math.PI);\n            context.lineTo(radius, radius - radius_quad.ne);\n            context.arc(radius, radius, radius_quad.ne, 1.5 * Math.PI, 0);\n            context.lineTo(radius + radius_quad.se, radius);\n            context.fill();\n            context.stroke();\n            return canvas;\n        }\n```\n效果如下图：\n![](canvasSymbol.png)\n\n\n[本方法完整代码](\nhttps://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasSymbol.html\n)\n\n**特点：** 这种方式，绘制出来的台风风圈其实只是一个symbol符号，需要把这个符号赋给一个具体的要素，比如一个点，一个圆之类的，而且根据分辨率还要去调整样式的缩放\n```js\n        map.getView().on('change:resolution', function () {\n            var style = shape.getStyle();\n            // 重新设置图标的缩放率\n            style.getImage().setScale(this.getZoom() / 8);\n            shape.setStyle(style);\n        })\n```\n\n# 通过canvas图层的方式实现\n&nbsp;&nbsp;再后来转念一想，既然支持canvas的symbol，为何不直接使用canvas绘制固定元素呢，果然在API中找到了`ol.source.ImageCanvas`，直接把canvas要素当作图层来使用！\n\n`ol.source.ImageCanvas`的绘制有点需要特别注意的点，这里给出重要代码片段，完整demo可以去[GitHub](\nhttps://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasLayer.html\n)查看\n\n## 创建图层，在canvasFunction中写具体的绘图方法\n```js\n        var canvasLayer = new ol.layer.Image({\n            source: new ol.source.ImageCanvas({\n                canvasFunction: canvasFunction,\n                projection: 'EPSG:3857'\n            })\n        });\n```\n\n## canvasFunction中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小\n\n```js\n        //计算画布和地图四至的偏移量\n        var mapExtent = map.getView().calculateExtent(map.getSize())\n        var canvasOrigin = map.getPixelFromCoordinate([extent[0], extent[3]]);\n        var mapOrigin = map.getPixelFromCoordinate([mapExtent[0], mapExtent[3]]);\n        var delta = [mapOrigin[0] - canvasOrigin[0], mapOrigin[1] - canvasOrigin[1]]\n```\n```js\n        //在计算台风风圈的中心点时要补充计算偏移量\n        var point = ol.proj.transform(coordinate, 'EPSG:4326', 'EPSG:3857');\n        var pixel = map.getPixelFromCoordinate(point);\n        var cX = pixel[0] + delta[0], cY = pixel[1] + delta[1];\n```\n```js\n        //利用canvasFunction提供的默认参数分辨率，计算准确的坐标\n        var radius_quad = {\n            \"ne\": 250000 / resolution,\n            \"se\": 250000 / resolution,\n            \"sw\": 180000 / resolution,\n            \"nw\": 150000 / resolution\n        }\n```\n最终效果如下，我在同一图层中绘制了多个：\n![](canvasLayer.png)\n\n\n至于绘制canvas的方法和上面的symbol是一样的。具体代码还请移步[GitHub](\nhttps://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasLayer.html\n)(原谅我厚颜无耻的屡次打广告！)\n\n**特点：**这种方式可以在一个图层中添加多个风圈要素，同时图层支持的功能也比较多，基本满足需求，效果也还行\n\n\n&nbsp;&nbsp;这篇应用主要是从一个基本的需求所拓展开来的，canvas图层的应用我想应该很强大，刚开始研究openlyaers，相比于arcgis，ol很多功能可能要自己实现，但似乎效果上还是能让人满意的，欢迎大家讨论。","source":"_posts/2017/openlayers-canvas-typhoon.md","raw":"---\ntitle: openlayers 从台风风圈绘制到canvas样式和图层的应用\ndate: 2017-07-31 22:31:02\ntags: [FE,GIS,OpenLayers]\ncategories: OpenLayers\n---\n本文中所使用的数据来源于[温州台风网](http://www.wztf121.com/typhoon.html)，通过F12抓取，你可以在我的[GitHub](\nhttps://github.com/zzcyrus/openlayers-demos\n)上查看数据和本文源代码\n\n&nbsp;&nbsp;台风的风圈是一种不常见但算的上规则的图形，在上面的网站可以看到最终效果，简单的解剖下其实就是四个1/4圆\n\n![](goal.png)\n\n从数据结构上也可以看出来：\n```js\n        var radius_quad = {\n            \"ne\": 250, //单位为KM\n            \"se\": 250,\n            \"sw\": 180,\n            \"nw\": 150\n        }\n```\n在某个固定经纬度点上，以此点为圆心组合成了一个所谓的风圈形状，四个方向分别代表每个1/4圆的半径。刚开始是为了实现这种效果进行了研究，后来发现openlayers对于这种效果的支持还挺有意思，记录下来已做分享。\n\n<!-- more -->\n\n\n# 通过自定义geometry的实现\n&nbsp;&nbsp;最原始的思路也是最容易切入的点，就是去看openlayers中怎么实现圆形的画法，在ol中，有`createRegularPolygon`这个类，原理就是给定一些参数，用点去填充我们想要的形状，当填进去点达到一定密集度，自然就能得到一个近似的圆。\n&nbsp;&nbsp;通过这个思路我们可以计算台风风圈的每个1/4圆的坐标，用点去占位，最终实现绘制出想要的图形。\n\n具体代码可以去看某大牛的博客，这里只给出一个传送门，写的很详细了：\n[点我乘坐飞机](http://blog.csdn.net/gisshixisheng/article/details/76397068) **这个算法还有些不完善，就是在每个1/4圆结束时候少计算了一个点，导致看着有点不对劲**\n\n\n**特点:** 这种方式画出来的图形是一个图层中的一个feature，好处自然不用多说，基本上feature支持的功能都能满足！\n\n\n# 通过canvas类型的symbol实现\n&nbsp;&nbsp;在点密集的情况下，用上面的方式其实效果已经很不错了，但是有些细（tiao）心（ci）的使用者，非要放大到一定程度，然后说你这个不够圆，那。。。。。\n\n&nbsp;&nbsp;那我们就用canvas画出来，openlayers中，要素的样式是有这么一种方式`ol.style.Icon`来实现，我们可以把绘制好的元素作为`Icon`的参数\n```js\n        var style = new ol.style.Style({\n            image: new ol.style.Icon({\n                opacity: 0.3,\n                img: canvas,\n                imgSize: [canvas.width, canvas.height],\n            })\n        })\n```\ncanvans绘制的方法：\n```js\n        function createTyphoon(radius, radius_quad) {\n            var canvas = document.createElement('canvas');\n            canvas.width = canvas.height = 2 * radius;\n            var context = canvas.getContext(\"2d\");\n            context.fillStyle = \"#0000ff\";\n            context.strokeStyle = \"#ff0000\";\n            context.lineWidth = 3;\n            context.beginPath();\n            context.arc(radius, radius, radius_quad.se, 0, 0.5 * Math.PI);\n            context.lineTo(radius, radius + radius_quad.sw);\n            context.arc(radius, radius, radius_quad.sw, 0.5 * Math.PI, Math.PI);\n            context.lineTo(radius - radius_quad.nw, radius);\n            context.arc(radius, radius, radius_quad.nw, Math.PI, 1.5 * Math.PI);\n            context.lineTo(radius, radius - radius_quad.ne);\n            context.arc(radius, radius, radius_quad.ne, 1.5 * Math.PI, 0);\n            context.lineTo(radius + radius_quad.se, radius);\n            context.fill();\n            context.stroke();\n            return canvas;\n        }\n```\n效果如下图：\n![](canvasSymbol.png)\n\n\n[本方法完整代码](\nhttps://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasSymbol.html\n)\n\n**特点：** 这种方式，绘制出来的台风风圈其实只是一个symbol符号，需要把这个符号赋给一个具体的要素，比如一个点，一个圆之类的，而且根据分辨率还要去调整样式的缩放\n```js\n        map.getView().on('change:resolution', function () {\n            var style = shape.getStyle();\n            // 重新设置图标的缩放率\n            style.getImage().setScale(this.getZoom() / 8);\n            shape.setStyle(style);\n        })\n```\n\n# 通过canvas图层的方式实现\n&nbsp;&nbsp;再后来转念一想，既然支持canvas的symbol，为何不直接使用canvas绘制固定元素呢，果然在API中找到了`ol.source.ImageCanvas`，直接把canvas要素当作图层来使用！\n\n`ol.source.ImageCanvas`的绘制有点需要特别注意的点，这里给出重要代码片段，完整demo可以去[GitHub](\nhttps://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasLayer.html\n)查看\n\n## 创建图层，在canvasFunction中写具体的绘图方法\n```js\n        var canvasLayer = new ol.layer.Image({\n            source: new ol.source.ImageCanvas({\n                canvasFunction: canvasFunction,\n                projection: 'EPSG:3857'\n            })\n        });\n```\n\n## canvasFunction中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小\n\n```js\n        //计算画布和地图四至的偏移量\n        var mapExtent = map.getView().calculateExtent(map.getSize())\n        var canvasOrigin = map.getPixelFromCoordinate([extent[0], extent[3]]);\n        var mapOrigin = map.getPixelFromCoordinate([mapExtent[0], mapExtent[3]]);\n        var delta = [mapOrigin[0] - canvasOrigin[0], mapOrigin[1] - canvasOrigin[1]]\n```\n```js\n        //在计算台风风圈的中心点时要补充计算偏移量\n        var point = ol.proj.transform(coordinate, 'EPSG:4326', 'EPSG:3857');\n        var pixel = map.getPixelFromCoordinate(point);\n        var cX = pixel[0] + delta[0], cY = pixel[1] + delta[1];\n```\n```js\n        //利用canvasFunction提供的默认参数分辨率，计算准确的坐标\n        var radius_quad = {\n            \"ne\": 250000 / resolution,\n            \"se\": 250000 / resolution,\n            \"sw\": 180000 / resolution,\n            \"nw\": 150000 / resolution\n        }\n```\n最终效果如下，我在同一图层中绘制了多个：\n![](canvasLayer.png)\n\n\n至于绘制canvas的方法和上面的symbol是一样的。具体代码还请移步[GitHub](\nhttps://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasLayer.html\n)(原谅我厚颜无耻的屡次打广告！)\n\n**特点：**这种方式可以在一个图层中添加多个风圈要素，同时图层支持的功能也比较多，基本满足需求，效果也还行\n\n\n&nbsp;&nbsp;这篇应用主要是从一个基本的需求所拓展开来的，canvas图层的应用我想应该很强大，刚开始研究openlyaers，相比于arcgis，ol很多功能可能要自己实现，但似乎效果上还是能让人满意的，欢迎大家讨论。","slug":"openlayers-canvas-typhoon","published":1,"updated":"2019-06-28T05:58:00.056Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy4fqa9b00030n3ie44wq9ax","content":"<p>本文中所使用的数据来源于<a href=\"http://www.wztf121.com/typhoon.html\" target=\"_blank\" rel=\"noopener\">温州台风网</a>，通过F12抓取，你可以在我的<a href=\"https://github.com/zzcyrus/openlayers-demos\" target=\"_blank\" rel=\"noopener\">GitHub</a>上查看数据和本文源代码</p>\n<p>&nbsp;&nbsp;台风的风圈是一种不常见但算的上规则的图形，在上面的网站可以看到最终效果，简单的解剖下其实就是四个1/4圆</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"goal.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>从数据结构上也可以看出来：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> radius_quad = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"ne\"</span>: <span class=\"number\">250</span>, <span class=\"comment\">//单位为KM</span></span><br><span class=\"line\">    <span class=\"string\">\"se\"</span>: <span class=\"number\">250</span>,</span><br><span class=\"line\">    <span class=\"string\">\"sw\"</span>: <span class=\"number\">180</span>,</span><br><span class=\"line\">    <span class=\"string\">\"nw\"</span>: <span class=\"number\">150</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在某个固定经纬度点上，以此点为圆心组合成了一个所谓的风圈形状，四个方向分别代表每个1/4圆的半径。刚开始是为了实现这种效果进行了研究，后来发现openlayers对于这种效果的支持还挺有意思，记录下来已做分享。</p>\n<a id=\"more\"></a>\n<h1 id=\"通过自定义geometry的实现\"><a href=\"#通过自定义geometry的实现\" class=\"headerlink\" title=\"通过自定义geometry的实现\"></a>通过自定义geometry的实现</h1><p>&nbsp;&nbsp;最原始的思路也是最容易切入的点，就是去看openlayers中怎么实现圆形的画法，在ol中，有<code>createRegularPolygon</code>这个类，原理就是给定一些参数，用点去填充我们想要的形状，当填进去点达到一定密集度，自然就能得到一个近似的圆。<br>&nbsp;&nbsp;通过这个思路我们可以计算台风风圈的每个1/4圆的坐标，用点去占位，最终实现绘制出想要的图形。</p>\n<p>具体代码可以去看某大牛的博客，这里只给出一个传送门，写的很详细了：<br><a href=\"http://blog.csdn.net/gisshixisheng/article/details/76397068\" target=\"_blank\" rel=\"noopener\">点我乘坐飞机</a> <strong>这个算法还有些不完善，就是在每个1/4圆结束时候少计算了一个点，导致看着有点不对劲</strong></p>\n<p><strong>特点:</strong> 这种方式画出来的图形是一个图层中的一个feature，好处自然不用多说，基本上feature支持的功能都能满足！</p>\n<h1 id=\"通过canvas类型的symbol实现\"><a href=\"#通过canvas类型的symbol实现\" class=\"headerlink\" title=\"通过canvas类型的symbol实现\"></a>通过canvas类型的symbol实现</h1><p>&nbsp;&nbsp;在点密集的情况下，用上面的方式其实效果已经很不错了，但是有些细（tiao）心（ci）的使用者，非要放大到一定程度，然后说你这个不够圆，那。。。。。</p>\n<p>&nbsp;&nbsp;那我们就用canvas画出来，openlayers中，要素的样式是有这么一种方式<code>ol.style.Icon</code>来实现，我们可以把绘制好的元素作为<code>Icon</code>的参数<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> style = <span class=\"keyword\">new</span> ol.style.Style(&#123;</span><br><span class=\"line\">    image: <span class=\"keyword\">new</span> ol.style.Icon(&#123;</span><br><span class=\"line\">        opacity: <span class=\"number\">0.3</span>,</span><br><span class=\"line\">        img: canvas,</span><br><span class=\"line\">        imgSize: [canvas.width, canvas.height],</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>canvans绘制的方法：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createTyphoon</span>(<span class=\"params\">radius, radius_quad</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> canvas = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'canvas'</span>);</span><br><span class=\"line\">    canvas.width = canvas.height = <span class=\"number\">2</span> * radius;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> context = canvas.getContext(<span class=\"string\">\"2d\"</span>);</span><br><span class=\"line\">    context.fillStyle = <span class=\"string\">\"#0000ff\"</span>;</span><br><span class=\"line\">    context.strokeStyle = <span class=\"string\">\"#ff0000\"</span>;</span><br><span class=\"line\">    context.lineWidth = <span class=\"number\">3</span>;</span><br><span class=\"line\">    context.beginPath();</span><br><span class=\"line\">    context.arc(radius, radius, radius_quad.se, <span class=\"number\">0</span>, <span class=\"number\">0.5</span> * <span class=\"built_in\">Math</span>.PI);</span><br><span class=\"line\">    context.lineTo(radius, radius + radius_quad.sw);</span><br><span class=\"line\">    context.arc(radius, radius, radius_quad.sw, <span class=\"number\">0.5</span> * <span class=\"built_in\">Math</span>.PI, <span class=\"built_in\">Math</span>.PI);</span><br><span class=\"line\">    context.lineTo(radius - radius_quad.nw, radius);</span><br><span class=\"line\">    context.arc(radius, radius, radius_quad.nw, <span class=\"built_in\">Math</span>.PI, <span class=\"number\">1.5</span> * <span class=\"built_in\">Math</span>.PI);</span><br><span class=\"line\">    context.lineTo(radius, radius - radius_quad.ne);</span><br><span class=\"line\">    context.arc(radius, radius, radius_quad.ne, <span class=\"number\">1.5</span> * <span class=\"built_in\">Math</span>.PI, <span class=\"number\">0</span>);</span><br><span class=\"line\">    context.lineTo(radius + radius_quad.se, radius);</span><br><span class=\"line\">    context.fill();</span><br><span class=\"line\">    context.stroke();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> canvas;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>效果如下图：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"canvasSymbol.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure></p>\n<p><a href=\"https://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasSymbol.html\" target=\"_blank\" rel=\"noopener\">本方法完整代码</a></p>\n<p><strong>特点：</strong> 这种方式，绘制出来的台风风圈其实只是一个symbol符号，需要把这个符号赋给一个具体的要素，比如一个点，一个圆之类的，而且根据分辨率还要去调整样式的缩放<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">map.getView().on(<span class=\"string\">'change:resolution'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> style = shape.getStyle();</span><br><span class=\"line\">    <span class=\"comment\">// 重新设置图标的缩放率</span></span><br><span class=\"line\">    style.getImage().setScale(<span class=\"keyword\">this</span>.getZoom() / <span class=\"number\">8</span>);</span><br><span class=\"line\">    shape.setStyle(style);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"通过canvas图层的方式实现\"><a href=\"#通过canvas图层的方式实现\" class=\"headerlink\" title=\"通过canvas图层的方式实现\"></a>通过canvas图层的方式实现</h1><p>&nbsp;&nbsp;再后来转念一想，既然支持canvas的symbol，为何不直接使用canvas绘制固定元素呢，果然在API中找到了<code>ol.source.ImageCanvas</code>，直接把canvas要素当作图层来使用！</p>\n<p><code>ol.source.ImageCanvas</code>的绘制有点需要特别注意的点，这里给出重要代码片段，完整demo可以去<a href=\"https://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasLayer.html\" target=\"_blank\" rel=\"noopener\">GitHub</a>查看</p>\n<h2 id=\"创建图层，在canvasFunction中写具体的绘图方法\"><a href=\"#创建图层，在canvasFunction中写具体的绘图方法\" class=\"headerlink\" title=\"创建图层，在canvasFunction中写具体的绘图方法\"></a>创建图层，在canvasFunction中写具体的绘图方法</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canvasLayer = <span class=\"keyword\">new</span> ol.layer.Image(&#123;</span><br><span class=\"line\">    source: <span class=\"keyword\">new</span> ol.source.ImageCanvas(&#123;</span><br><span class=\"line\">        canvasFunction: canvasFunction,</span><br><span class=\"line\">        projection: <span class=\"string\">'EPSG:3857'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"canvasFunction中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小\"><a href=\"#canvasFunction中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小\" class=\"headerlink\" title=\"canvasFunction中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小\"></a>canvasFunction中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//计算画布和地图四至的偏移量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mapExtent = map.getView().calculateExtent(map.getSize())</span><br><span class=\"line\"><span class=\"keyword\">var</span> canvasOrigin = map.getPixelFromCoordinate([extent[<span class=\"number\">0</span>], extent[<span class=\"number\">3</span>]]);</span><br><span class=\"line\"><span class=\"keyword\">var</span> mapOrigin = map.getPixelFromCoordinate([mapExtent[<span class=\"number\">0</span>], mapExtent[<span class=\"number\">3</span>]]);</span><br><span class=\"line\"><span class=\"keyword\">var</span> delta = [mapOrigin[<span class=\"number\">0</span>] - canvasOrigin[<span class=\"number\">0</span>], mapOrigin[<span class=\"number\">1</span>] - canvasOrigin[<span class=\"number\">1</span>]]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在计算台风风圈的中心点时要补充计算偏移量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> point = ol.proj.transform(coordinate, <span class=\"string\">'EPSG:4326'</span>, <span class=\"string\">'EPSG:3857'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> pixel = map.getPixelFromCoordinate(point);</span><br><span class=\"line\"><span class=\"keyword\">var</span> cX = pixel[<span class=\"number\">0</span>] + delta[<span class=\"number\">0</span>], cY = pixel[<span class=\"number\">1</span>] + delta[<span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//利用canvasFunction提供的默认参数分辨率，计算准确的坐标</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> radius_quad = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"ne\"</span>: <span class=\"number\">250000</span> / resolution,</span><br><span class=\"line\">    <span class=\"string\">\"se\"</span>: <span class=\"number\">250000</span> / resolution,</span><br><span class=\"line\">    <span class=\"string\">\"sw\"</span>: <span class=\"number\">180000</span> / resolution,</span><br><span class=\"line\">    <span class=\"string\">\"nw\"</span>: <span class=\"number\">150000</span> / resolution</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终效果如下，我在同一图层中绘制了多个：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"canvasLayer.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure></p>\n<p>至于绘制canvas的方法和上面的symbol是一样的。具体代码还请移步<a href=\"https://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasLayer.html\" target=\"_blank\" rel=\"noopener\">GitHub</a>(原谅我厚颜无耻的屡次打广告！)</p>\n<p><strong>特点：</strong>这种方式可以在一个图层中添加多个风圈要素，同时图层支持的功能也比较多，基本满足需求，效果也还行</p>\n<p>&nbsp;&nbsp;这篇应用主要是从一个基本的需求所拓展开来的，canvas图层的应用我想应该很强大，刚开始研究openlyaers，相比于arcgis，ol很多功能可能要自己实现，但似乎效果上还是能让人满意的，欢迎大家讨论。</p>\n","site":{"data":{}},"excerpt":"<p>本文中所使用的数据来源于<a href=\"http://www.wztf121.com/typhoon.html\" target=\"_blank\" rel=\"noopener\">温州台风网</a>，通过F12抓取，你可以在我的<a href=\"https://github.com/zzcyrus/openlayers-demos\" target=\"_blank\" rel=\"noopener\">GitHub</a>上查看数据和本文源代码</p>\n<p>&nbsp;&nbsp;台风的风圈是一种不常见但算的上规则的图形，在上面的网站可以看到最终效果，简单的解剖下其实就是四个1/4圆</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"goal.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>从数据结构上也可以看出来：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> radius_quad = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"ne\"</span>: <span class=\"number\">250</span>, <span class=\"comment\">//单位为KM</span></span><br><span class=\"line\">    <span class=\"string\">\"se\"</span>: <span class=\"number\">250</span>,</span><br><span class=\"line\">    <span class=\"string\">\"sw\"</span>: <span class=\"number\">180</span>,</span><br><span class=\"line\">    <span class=\"string\">\"nw\"</span>: <span class=\"number\">150</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在某个固定经纬度点上，以此点为圆心组合成了一个所谓的风圈形状，四个方向分别代表每个1/4圆的半径。刚开始是为了实现这种效果进行了研究，后来发现openlayers对于这种效果的支持还挺有意思，记录下来已做分享。</p>","more":"<h1 id=\"通过自定义geometry的实现\"><a href=\"#通过自定义geometry的实现\" class=\"headerlink\" title=\"通过自定义geometry的实现\"></a>通过自定义geometry的实现</h1><p>&nbsp;&nbsp;最原始的思路也是最容易切入的点，就是去看openlayers中怎么实现圆形的画法，在ol中，有<code>createRegularPolygon</code>这个类，原理就是给定一些参数，用点去填充我们想要的形状，当填进去点达到一定密集度，自然就能得到一个近似的圆。<br>&nbsp;&nbsp;通过这个思路我们可以计算台风风圈的每个1/4圆的坐标，用点去占位，最终实现绘制出想要的图形。</p>\n<p>具体代码可以去看某大牛的博客，这里只给出一个传送门，写的很详细了：<br><a href=\"http://blog.csdn.net/gisshixisheng/article/details/76397068\" target=\"_blank\" rel=\"noopener\">点我乘坐飞机</a> <strong>这个算法还有些不完善，就是在每个1/4圆结束时候少计算了一个点，导致看着有点不对劲</strong></p>\n<p><strong>特点:</strong> 这种方式画出来的图形是一个图层中的一个feature，好处自然不用多说，基本上feature支持的功能都能满足！</p>\n<h1 id=\"通过canvas类型的symbol实现\"><a href=\"#通过canvas类型的symbol实现\" class=\"headerlink\" title=\"通过canvas类型的symbol实现\"></a>通过canvas类型的symbol实现</h1><p>&nbsp;&nbsp;在点密集的情况下，用上面的方式其实效果已经很不错了，但是有些细（tiao）心（ci）的使用者，非要放大到一定程度，然后说你这个不够圆，那。。。。。</p>\n<p>&nbsp;&nbsp;那我们就用canvas画出来，openlayers中，要素的样式是有这么一种方式<code>ol.style.Icon</code>来实现，我们可以把绘制好的元素作为<code>Icon</code>的参数<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> style = <span class=\"keyword\">new</span> ol.style.Style(&#123;</span><br><span class=\"line\">    image: <span class=\"keyword\">new</span> ol.style.Icon(&#123;</span><br><span class=\"line\">        opacity: <span class=\"number\">0.3</span>,</span><br><span class=\"line\">        img: canvas,</span><br><span class=\"line\">        imgSize: [canvas.width, canvas.height],</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>canvans绘制的方法：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createTyphoon</span>(<span class=\"params\">radius, radius_quad</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> canvas = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'canvas'</span>);</span><br><span class=\"line\">    canvas.width = canvas.height = <span class=\"number\">2</span> * radius;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> context = canvas.getContext(<span class=\"string\">\"2d\"</span>);</span><br><span class=\"line\">    context.fillStyle = <span class=\"string\">\"#0000ff\"</span>;</span><br><span class=\"line\">    context.strokeStyle = <span class=\"string\">\"#ff0000\"</span>;</span><br><span class=\"line\">    context.lineWidth = <span class=\"number\">3</span>;</span><br><span class=\"line\">    context.beginPath();</span><br><span class=\"line\">    context.arc(radius, radius, radius_quad.se, <span class=\"number\">0</span>, <span class=\"number\">0.5</span> * <span class=\"built_in\">Math</span>.PI);</span><br><span class=\"line\">    context.lineTo(radius, radius + radius_quad.sw);</span><br><span class=\"line\">    context.arc(radius, radius, radius_quad.sw, <span class=\"number\">0.5</span> * <span class=\"built_in\">Math</span>.PI, <span class=\"built_in\">Math</span>.PI);</span><br><span class=\"line\">    context.lineTo(radius - radius_quad.nw, radius);</span><br><span class=\"line\">    context.arc(radius, radius, radius_quad.nw, <span class=\"built_in\">Math</span>.PI, <span class=\"number\">1.5</span> * <span class=\"built_in\">Math</span>.PI);</span><br><span class=\"line\">    context.lineTo(radius, radius - radius_quad.ne);</span><br><span class=\"line\">    context.arc(radius, radius, radius_quad.ne, <span class=\"number\">1.5</span> * <span class=\"built_in\">Math</span>.PI, <span class=\"number\">0</span>);</span><br><span class=\"line\">    context.lineTo(radius + radius_quad.se, radius);</span><br><span class=\"line\">    context.fill();</span><br><span class=\"line\">    context.stroke();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> canvas;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>效果如下图：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"canvasSymbol.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure></p>\n<p><a href=\"https://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasSymbol.html\" target=\"_blank\" rel=\"noopener\">本方法完整代码</a></p>\n<p><strong>特点：</strong> 这种方式，绘制出来的台风风圈其实只是一个symbol符号，需要把这个符号赋给一个具体的要素，比如一个点，一个圆之类的，而且根据分辨率还要去调整样式的缩放<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">map.getView().on(<span class=\"string\">'change:resolution'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> style = shape.getStyle();</span><br><span class=\"line\">    <span class=\"comment\">// 重新设置图标的缩放率</span></span><br><span class=\"line\">    style.getImage().setScale(<span class=\"keyword\">this</span>.getZoom() / <span class=\"number\">8</span>);</span><br><span class=\"line\">    shape.setStyle(style);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"通过canvas图层的方式实现\"><a href=\"#通过canvas图层的方式实现\" class=\"headerlink\" title=\"通过canvas图层的方式实现\"></a>通过canvas图层的方式实现</h1><p>&nbsp;&nbsp;再后来转念一想，既然支持canvas的symbol，为何不直接使用canvas绘制固定元素呢，果然在API中找到了<code>ol.source.ImageCanvas</code>，直接把canvas要素当作图层来使用！</p>\n<p><code>ol.source.ImageCanvas</code>的绘制有点需要特别注意的点，这里给出重要代码片段，完整demo可以去<a href=\"https://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasLayer.html\" target=\"_blank\" rel=\"noopener\">GitHub</a>查看</p>\n<h2 id=\"创建图层，在canvasFunction中写具体的绘图方法\"><a href=\"#创建图层，在canvasFunction中写具体的绘图方法\" class=\"headerlink\" title=\"创建图层，在canvasFunction中写具体的绘图方法\"></a>创建图层，在canvasFunction中写具体的绘图方法</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canvasLayer = <span class=\"keyword\">new</span> ol.layer.Image(&#123;</span><br><span class=\"line\">    source: <span class=\"keyword\">new</span> ol.source.ImageCanvas(&#123;</span><br><span class=\"line\">        canvasFunction: canvasFunction,</span><br><span class=\"line\">        projection: <span class=\"string\">'EPSG:3857'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"canvasFunction中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小\"><a href=\"#canvasFunction中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小\" class=\"headerlink\" title=\"canvasFunction中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小\"></a>canvasFunction中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//计算画布和地图四至的偏移量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mapExtent = map.getView().calculateExtent(map.getSize())</span><br><span class=\"line\"><span class=\"keyword\">var</span> canvasOrigin = map.getPixelFromCoordinate([extent[<span class=\"number\">0</span>], extent[<span class=\"number\">3</span>]]);</span><br><span class=\"line\"><span class=\"keyword\">var</span> mapOrigin = map.getPixelFromCoordinate([mapExtent[<span class=\"number\">0</span>], mapExtent[<span class=\"number\">3</span>]]);</span><br><span class=\"line\"><span class=\"keyword\">var</span> delta = [mapOrigin[<span class=\"number\">0</span>] - canvasOrigin[<span class=\"number\">0</span>], mapOrigin[<span class=\"number\">1</span>] - canvasOrigin[<span class=\"number\">1</span>]]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在计算台风风圈的中心点时要补充计算偏移量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> point = ol.proj.transform(coordinate, <span class=\"string\">'EPSG:4326'</span>, <span class=\"string\">'EPSG:3857'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> pixel = map.getPixelFromCoordinate(point);</span><br><span class=\"line\"><span class=\"keyword\">var</span> cX = pixel[<span class=\"number\">0</span>] + delta[<span class=\"number\">0</span>], cY = pixel[<span class=\"number\">1</span>] + delta[<span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//利用canvasFunction提供的默认参数分辨率，计算准确的坐标</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> radius_quad = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"ne\"</span>: <span class=\"number\">250000</span> / resolution,</span><br><span class=\"line\">    <span class=\"string\">\"se\"</span>: <span class=\"number\">250000</span> / resolution,</span><br><span class=\"line\">    <span class=\"string\">\"sw\"</span>: <span class=\"number\">180000</span> / resolution,</span><br><span class=\"line\">    <span class=\"string\">\"nw\"</span>: <span class=\"number\">150000</span> / resolution</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终效果如下，我在同一图层中绘制了多个：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"canvasLayer.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure></p>\n<p>至于绘制canvas的方法和上面的symbol是一样的。具体代码还请移步<a href=\"https://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasLayer.html\" target=\"_blank\" rel=\"noopener\">GitHub</a>(原谅我厚颜无耻的屡次打广告！)</p>\n<p><strong>特点：</strong>这种方式可以在一个图层中添加多个风圈要素，同时图层支持的功能也比较多，基本满足需求，效果也还行</p>\n<p>&nbsp;&nbsp;这篇应用主要是从一个基本的需求所拓展开来的，canvas图层的应用我想应该很强大，刚开始研究openlyaers，相比于arcgis，ol很多功能可能要自己实现，但似乎效果上还是能让人满意的，欢迎大家讨论。</p>"},{"title":"Leaflet常用的一些插件","date":"2017-09-17T05:48:15.000Z","_content":"\n\n\n\nLeaflet中常用的gis功能可以满足一般使用，有些特殊需求，官方也有[插件系统](http://leafletjs.com/plugins.html)，本文会挑选一些常用的，经过测试可用的插件单独放出来使用方法和一些注意事项，希望能够帮助到同僚们。\n\n\n<!-- more -->\n\n[Leaflet系列地址](https://github.com/zzcyrus/Leaflet-demos)\n[本文demo地址](https://github.com/zzcyrus/Leaflet-demos/blob/master/1.plugins/plugins.html)\n\n\n# ImageWMS\n\n&nbsp;&nbsp;在openlayers中，wms图层的调用了提供了IamgeWMS和tileWMS两种方式，通常情况下，如果wms服务作为底图，由于数据量大，我们采用瓦片的方式加载十分有利，如果数据量小，我们采用单张image的方式无论从请求发送上和显示的效果上都更好。\n![](tileWMS.png)\n&nbsp;&nbsp;~~可以发现，瓦片会发出多次请求，每次请求都会包含该瓦片上涉及到的信息，数据量小十分没必要~~\n\n\n&nbsp;&nbsp;Leaflet中只提供了tile瓦片的方式加载WMS图层，在使用了很多第三方解决方案后，我发现了这款插件[nonTiledLayer](https://github.com/ptv-logistics/Leaflet.NonTiledLayer)，使用之后的效果基本上可以达到openlaysers中的要求，更多情况可以点击链接进去了解。\n\n调用方式\n````js\n    var layer = L.nonTiledLayer.wms(url, {\n        maxZoom: 19,\n        minZoom: 0,\n        opacity: 1.0,\n        layers: 'xmap-gravelpit-fg',\n        format: 'image/png',\n        transparent: true,\n        attribution: '',\n        pane: 'tilePane',\n        zIndex: 3\n    }).addTo(map);\n````\n[nonTiledLayer](https://github.com/ptv-logistics/Leaflet.NonTiledLayer)调用方式基本沿用Leaflet自身的wms调用，提供的属性也很全面\n\n````\n    attribution - 图层数据来源.Default:'\n    opacity - 透明度.Default: 1\n    minZoom - 最小缩放. Default: 0\n    maxZoom - 最大缩放. Default: 18\n    bounds - 边界条件. Default: L.latLngBounds([-180, -85.05], [180, 85.05])\n    zIndex - 位置. Default: undefined\n    pane - 插入的div的名称. Default: 'overlayPane'\n    pointerEvents - 鼠标事件的样式. Default: null\n    errorImageUrl - 默认错误图层. Default: 1px transparent gif data:image/gif;base64,R0lGODlhAQABAHAAACH5BAUAAAAALAAAAAABAAEAAAICRAEAOw==\n    useCanvas - 渲染方式. Default: undefined\n````\n\n具体的使用效果可以移步demo\n\n\n# WKT数据插件\n\n&nbsp;&nbsp;wkt作为GIS常用的一种地理数据格式，因为通用性需求度也很高,Leaflet官方插件中提供了许多支持wkt的第三方解决方案，使用下来，发现mapbox出品的[leaflet-omnivore](https://github.com/mapbox/leaflet-omnivore)效果可以说是目前最满足要求的了。\n\n`omnivore`支持的功能比较强大\n````js\n    omnivore.csv('a.csv').addTo(map);\n    omnivore.gpx('a.gpx').addTo(map);\n    omnivore.kml('a.kml').addTo(map);\n    omnivore.wkt('a.wkt').addTo(map);\n    omnivore.topojson('a.topojson').addTo(map);\n    omnivore.geojson('a.geojson').addTo(map);\n    omnivore.polyline('a.txt').addTo(map);\n````\n\n其中对于wkt的加载有两种方式。\n其中，`customlayer`是通过`L.geojson`图层来为加载进来的wkt数据设置样式\n````js\n    let customLayer = L.geoJson(null, {\n        style: function () {\n            return {color: \"#0ff\"};\n        }\n    });\n\n````\n\n* `omnivore.wkt(url, parser_options?, customLayer?)`: 通过url加载\n\n* `omnivore.wkt.parse(wktString，parser_options?, customLayer?)`: 通过转换wkt字符串加载\n\n\n具体的使用效果可以移步[demo](https://github.com/zzcyrus/Leaflet-demos/blob/master/1.plugins/plugins.html)","source":"_posts/2017/plugins.md","raw":"---\ntitle: Leaflet常用的一些插件\ndate: 2017-09-17 13:48:15\ntags: [FE,GIS,Leaflet]\ncategories: Leaflet\n---\n\n\n\n\nLeaflet中常用的gis功能可以满足一般使用，有些特殊需求，官方也有[插件系统](http://leafletjs.com/plugins.html)，本文会挑选一些常用的，经过测试可用的插件单独放出来使用方法和一些注意事项，希望能够帮助到同僚们。\n\n\n<!-- more -->\n\n[Leaflet系列地址](https://github.com/zzcyrus/Leaflet-demos)\n[本文demo地址](https://github.com/zzcyrus/Leaflet-demos/blob/master/1.plugins/plugins.html)\n\n\n# ImageWMS\n\n&nbsp;&nbsp;在openlayers中，wms图层的调用了提供了IamgeWMS和tileWMS两种方式，通常情况下，如果wms服务作为底图，由于数据量大，我们采用瓦片的方式加载十分有利，如果数据量小，我们采用单张image的方式无论从请求发送上和显示的效果上都更好。\n![](tileWMS.png)\n&nbsp;&nbsp;~~可以发现，瓦片会发出多次请求，每次请求都会包含该瓦片上涉及到的信息，数据量小十分没必要~~\n\n\n&nbsp;&nbsp;Leaflet中只提供了tile瓦片的方式加载WMS图层，在使用了很多第三方解决方案后，我发现了这款插件[nonTiledLayer](https://github.com/ptv-logistics/Leaflet.NonTiledLayer)，使用之后的效果基本上可以达到openlaysers中的要求，更多情况可以点击链接进去了解。\n\n调用方式\n````js\n    var layer = L.nonTiledLayer.wms(url, {\n        maxZoom: 19,\n        minZoom: 0,\n        opacity: 1.0,\n        layers: 'xmap-gravelpit-fg',\n        format: 'image/png',\n        transparent: true,\n        attribution: '',\n        pane: 'tilePane',\n        zIndex: 3\n    }).addTo(map);\n````\n[nonTiledLayer](https://github.com/ptv-logistics/Leaflet.NonTiledLayer)调用方式基本沿用Leaflet自身的wms调用，提供的属性也很全面\n\n````\n    attribution - 图层数据来源.Default:'\n    opacity - 透明度.Default: 1\n    minZoom - 最小缩放. Default: 0\n    maxZoom - 最大缩放. Default: 18\n    bounds - 边界条件. Default: L.latLngBounds([-180, -85.05], [180, 85.05])\n    zIndex - 位置. Default: undefined\n    pane - 插入的div的名称. Default: 'overlayPane'\n    pointerEvents - 鼠标事件的样式. Default: null\n    errorImageUrl - 默认错误图层. Default: 1px transparent gif data:image/gif;base64,R0lGODlhAQABAHAAACH5BAUAAAAALAAAAAABAAEAAAICRAEAOw==\n    useCanvas - 渲染方式. Default: undefined\n````\n\n具体的使用效果可以移步demo\n\n\n# WKT数据插件\n\n&nbsp;&nbsp;wkt作为GIS常用的一种地理数据格式，因为通用性需求度也很高,Leaflet官方插件中提供了许多支持wkt的第三方解决方案，使用下来，发现mapbox出品的[leaflet-omnivore](https://github.com/mapbox/leaflet-omnivore)效果可以说是目前最满足要求的了。\n\n`omnivore`支持的功能比较强大\n````js\n    omnivore.csv('a.csv').addTo(map);\n    omnivore.gpx('a.gpx').addTo(map);\n    omnivore.kml('a.kml').addTo(map);\n    omnivore.wkt('a.wkt').addTo(map);\n    omnivore.topojson('a.topojson').addTo(map);\n    omnivore.geojson('a.geojson').addTo(map);\n    omnivore.polyline('a.txt').addTo(map);\n````\n\n其中对于wkt的加载有两种方式。\n其中，`customlayer`是通过`L.geojson`图层来为加载进来的wkt数据设置样式\n````js\n    let customLayer = L.geoJson(null, {\n        style: function () {\n            return {color: \"#0ff\"};\n        }\n    });\n\n````\n\n* `omnivore.wkt(url, parser_options?, customLayer?)`: 通过url加载\n\n* `omnivore.wkt.parse(wktString，parser_options?, customLayer?)`: 通过转换wkt字符串加载\n\n\n具体的使用效果可以移步[demo](https://github.com/zzcyrus/Leaflet-demos/blob/master/1.plugins/plugins.html)","slug":"plugins","published":1,"updated":"2019-06-28T05:56:10.121Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy4fqa9e00060n3ii3gb04q9","content":"<p>Leaflet中常用的gis功能可以满足一般使用，有些特殊需求，官方也有<a href=\"http://leafletjs.com/plugins.html\" target=\"_blank\" rel=\"noopener\">插件系统</a>，本文会挑选一些常用的，经过测试可用的插件单独放出来使用方法和一些注意事项，希望能够帮助到同僚们。</p>\n<a id=\"more\"></a>\n<p><a href=\"https://github.com/zzcyrus/Leaflet-demos\" target=\"_blank\" rel=\"noopener\">Leaflet系列地址</a><br><a href=\"https://github.com/zzcyrus/Leaflet-demos/blob/master/1.plugins/plugins.html\" target=\"_blank\" rel=\"noopener\">本文demo地址</a></p>\n<h1 id=\"ImageWMS\"><a href=\"#ImageWMS\" class=\"headerlink\" title=\"ImageWMS\"></a>ImageWMS</h1><p>&nbsp;&nbsp;在openlayers中，wms图层的调用了提供了IamgeWMS和tileWMS两种方式，通常情况下，如果wms服务作为底图，由于数据量大，我们采用瓦片的方式加载十分有利，如果数据量小，我们采用单张image的方式无论从请求发送上和显示的效果上都更好。<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"tileWMS.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure><br>&nbsp;&nbsp;<del>可以发现，瓦片会发出多次请求，每次请求都会包含该瓦片上涉及到的信息，数据量小十分没必要</del></p>\n<p>&nbsp;&nbsp;Leaflet中只提供了tile瓦片的方式加载WMS图层，在使用了很多第三方解决方案后，我发现了这款插件<a href=\"https://github.com/ptv-logistics/Leaflet.NonTiledLayer\" target=\"_blank\" rel=\"noopener\">nonTiledLayer</a>，使用之后的效果基本上可以达到openlaysers中的要求，更多情况可以点击链接进去了解。</p>\n<p>调用方式<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> layer = L.nonTiledLayer.wms(url, &#123;</span><br><span class=\"line\">    maxZoom: <span class=\"number\">19</span>,</span><br><span class=\"line\">    minZoom: <span class=\"number\">0</span>,</span><br><span class=\"line\">    opacity: <span class=\"number\">1.0</span>,</span><br><span class=\"line\">    layers: <span class=\"string\">'xmap-gravelpit-fg'</span>,</span><br><span class=\"line\">    format: <span class=\"string\">'image/png'</span>,</span><br><span class=\"line\">    transparent: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    attribution: <span class=\"string\">''</span>,</span><br><span class=\"line\">    pane: <span class=\"string\">'tilePane'</span>,</span><br><span class=\"line\">    zIndex: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;).addTo(map);</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://github.com/ptv-logistics/Leaflet.NonTiledLayer\" target=\"_blank\" rel=\"noopener\">nonTiledLayer</a>调用方式基本沿用Leaflet自身的wms调用，提供的属性也很全面</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">attribution - 图层数据来源.Default:&apos;</span><br><span class=\"line\">opacity - 透明度.Default: 1</span><br><span class=\"line\">minZoom - 最小缩放. Default: 0</span><br><span class=\"line\">maxZoom - 最大缩放. Default: 18</span><br><span class=\"line\">bounds - 边界条件. Default: L.latLngBounds([-180, -85.05], [180, 85.05])</span><br><span class=\"line\">zIndex - 位置. Default: undefined</span><br><span class=\"line\">pane - 插入的div的名称. Default: &apos;overlayPane&apos;</span><br><span class=\"line\">pointerEvents - 鼠标事件的样式. Default: null</span><br><span class=\"line\">errorImageUrl - 默认错误图层. Default: 1px transparent gif data:image/gif;base64,R0lGODlhAQABAHAAACH5BAUAAAAALAAAAAABAAEAAAICRAEAOw==</span><br><span class=\"line\">useCanvas - 渲染方式. Default: undefined</span><br></pre></td></tr></table></figure>\n<p>具体的使用效果可以移步demo</p>\n<h1 id=\"WKT数据插件\"><a href=\"#WKT数据插件\" class=\"headerlink\" title=\"WKT数据插件\"></a>WKT数据插件</h1><p>&nbsp;&nbsp;wkt作为GIS常用的一种地理数据格式，因为通用性需求度也很高,Leaflet官方插件中提供了许多支持wkt的第三方解决方案，使用下来，发现mapbox出品的<a href=\"https://github.com/mapbox/leaflet-omnivore\" target=\"_blank\" rel=\"noopener\">leaflet-omnivore</a>效果可以说是目前最满足要求的了。</p>\n<p><code>omnivore</code>支持的功能比较强大<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">omnivore.csv(<span class=\"string\">'a.csv'</span>).addTo(map);</span><br><span class=\"line\">omnivore.gpx(<span class=\"string\">'a.gpx'</span>).addTo(map);</span><br><span class=\"line\">omnivore.kml(<span class=\"string\">'a.kml'</span>).addTo(map);</span><br><span class=\"line\">omnivore.wkt(<span class=\"string\">'a.wkt'</span>).addTo(map);</span><br><span class=\"line\">omnivore.topojson(<span class=\"string\">'a.topojson'</span>).addTo(map);</span><br><span class=\"line\">omnivore.geojson(<span class=\"string\">'a.geojson'</span>).addTo(map);</span><br><span class=\"line\">omnivore.polyline(<span class=\"string\">'a.txt'</span>).addTo(map);</span><br></pre></td></tr></table></figure></p>\n<p>其中对于wkt的加载有两种方式。<br>其中，<code>customlayer</code>是通过<code>L.geojson</code>图层来为加载进来的wkt数据设置样式<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> customLayer = L.geoJson(<span class=\"literal\">null</span>, &#123;</span><br><span class=\"line\">    style: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;<span class=\"attr\">color</span>: <span class=\"string\">\"#0ff\"</span>&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p><code>omnivore.wkt(url, parser_options?, customLayer?)</code>: 通过url加载</p>\n</li>\n<li><p><code>omnivore.wkt.parse(wktString，parser_options?, customLayer?)</code>: 通过转换wkt字符串加载</p>\n</li>\n</ul>\n<p>具体的使用效果可以移步<a href=\"https://github.com/zzcyrus/Leaflet-demos/blob/master/1.plugins/plugins.html\" target=\"_blank\" rel=\"noopener\">demo</a></p>\n","site":{"data":{}},"excerpt":"<p>Leaflet中常用的gis功能可以满足一般使用，有些特殊需求，官方也有<a href=\"http://leafletjs.com/plugins.html\" target=\"_blank\" rel=\"noopener\">插件系统</a>，本文会挑选一些常用的，经过测试可用的插件单独放出来使用方法和一些注意事项，希望能够帮助到同僚们。</p>","more":"<p><a href=\"https://github.com/zzcyrus/Leaflet-demos\" target=\"_blank\" rel=\"noopener\">Leaflet系列地址</a><br><a href=\"https://github.com/zzcyrus/Leaflet-demos/blob/master/1.plugins/plugins.html\" target=\"_blank\" rel=\"noopener\">本文demo地址</a></p>\n<h1 id=\"ImageWMS\"><a href=\"#ImageWMS\" class=\"headerlink\" title=\"ImageWMS\"></a>ImageWMS</h1><p>&nbsp;&nbsp;在openlayers中，wms图层的调用了提供了IamgeWMS和tileWMS两种方式，通常情况下，如果wms服务作为底图，由于数据量大，我们采用瓦片的方式加载十分有利，如果数据量小，我们采用单张image的方式无论从请求发送上和显示的效果上都更好。<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"tileWMS.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure><br>&nbsp;&nbsp;<del>可以发现，瓦片会发出多次请求，每次请求都会包含该瓦片上涉及到的信息，数据量小十分没必要</del></p>\n<p>&nbsp;&nbsp;Leaflet中只提供了tile瓦片的方式加载WMS图层，在使用了很多第三方解决方案后，我发现了这款插件<a href=\"https://github.com/ptv-logistics/Leaflet.NonTiledLayer\" target=\"_blank\" rel=\"noopener\">nonTiledLayer</a>，使用之后的效果基本上可以达到openlaysers中的要求，更多情况可以点击链接进去了解。</p>\n<p>调用方式<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> layer = L.nonTiledLayer.wms(url, &#123;</span><br><span class=\"line\">    maxZoom: <span class=\"number\">19</span>,</span><br><span class=\"line\">    minZoom: <span class=\"number\">0</span>,</span><br><span class=\"line\">    opacity: <span class=\"number\">1.0</span>,</span><br><span class=\"line\">    layers: <span class=\"string\">'xmap-gravelpit-fg'</span>,</span><br><span class=\"line\">    format: <span class=\"string\">'image/png'</span>,</span><br><span class=\"line\">    transparent: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    attribution: <span class=\"string\">''</span>,</span><br><span class=\"line\">    pane: <span class=\"string\">'tilePane'</span>,</span><br><span class=\"line\">    zIndex: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;).addTo(map);</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://github.com/ptv-logistics/Leaflet.NonTiledLayer\" target=\"_blank\" rel=\"noopener\">nonTiledLayer</a>调用方式基本沿用Leaflet自身的wms调用，提供的属性也很全面</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">attribution - 图层数据来源.Default:&apos;</span><br><span class=\"line\">opacity - 透明度.Default: 1</span><br><span class=\"line\">minZoom - 最小缩放. Default: 0</span><br><span class=\"line\">maxZoom - 最大缩放. Default: 18</span><br><span class=\"line\">bounds - 边界条件. Default: L.latLngBounds([-180, -85.05], [180, 85.05])</span><br><span class=\"line\">zIndex - 位置. Default: undefined</span><br><span class=\"line\">pane - 插入的div的名称. Default: &apos;overlayPane&apos;</span><br><span class=\"line\">pointerEvents - 鼠标事件的样式. Default: null</span><br><span class=\"line\">errorImageUrl - 默认错误图层. Default: 1px transparent gif data:image/gif;base64,R0lGODlhAQABAHAAACH5BAUAAAAALAAAAAABAAEAAAICRAEAOw==</span><br><span class=\"line\">useCanvas - 渲染方式. Default: undefined</span><br></pre></td></tr></table></figure>\n<p>具体的使用效果可以移步demo</p>\n<h1 id=\"WKT数据插件\"><a href=\"#WKT数据插件\" class=\"headerlink\" title=\"WKT数据插件\"></a>WKT数据插件</h1><p>&nbsp;&nbsp;wkt作为GIS常用的一种地理数据格式，因为通用性需求度也很高,Leaflet官方插件中提供了许多支持wkt的第三方解决方案，使用下来，发现mapbox出品的<a href=\"https://github.com/mapbox/leaflet-omnivore\" target=\"_blank\" rel=\"noopener\">leaflet-omnivore</a>效果可以说是目前最满足要求的了。</p>\n<p><code>omnivore</code>支持的功能比较强大<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">omnivore.csv(<span class=\"string\">'a.csv'</span>).addTo(map);</span><br><span class=\"line\">omnivore.gpx(<span class=\"string\">'a.gpx'</span>).addTo(map);</span><br><span class=\"line\">omnivore.kml(<span class=\"string\">'a.kml'</span>).addTo(map);</span><br><span class=\"line\">omnivore.wkt(<span class=\"string\">'a.wkt'</span>).addTo(map);</span><br><span class=\"line\">omnivore.topojson(<span class=\"string\">'a.topojson'</span>).addTo(map);</span><br><span class=\"line\">omnivore.geojson(<span class=\"string\">'a.geojson'</span>).addTo(map);</span><br><span class=\"line\">omnivore.polyline(<span class=\"string\">'a.txt'</span>).addTo(map);</span><br></pre></td></tr></table></figure></p>\n<p>其中对于wkt的加载有两种方式。<br>其中，<code>customlayer</code>是通过<code>L.geojson</code>图层来为加载进来的wkt数据设置样式<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> customLayer = L.geoJson(<span class=\"literal\">null</span>, &#123;</span><br><span class=\"line\">    style: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;<span class=\"attr\">color</span>: <span class=\"string\">\"#0ff\"</span>&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p><code>omnivore.wkt(url, parser_options?, customLayer?)</code>: 通过url加载</p>\n</li>\n<li><p><code>omnivore.wkt.parse(wktString，parser_options?, customLayer?)</code>: 通过转换wkt字符串加载</p>\n</li>\n</ul>\n<p>具体的使用效果可以移步<a href=\"https://github.com/zzcyrus/Leaflet-demos/blob/master/1.plugins/plugins.html\" target=\"_blank\" rel=\"noopener\">demo</a></p>"},{"title":"矢量切片的使用尝试1—openlayers应用","date":"2017-11-12T02:54:57.000Z","_content":"\n&nbsp;&nbsp;对于GIS行业来说，栅格切片已经处于垄断地位很长时间了，但随着mapbox的发展，矢量切片越来越勾引起大家探究的欲望，最近我也小小的观望了下，发现现在技术还是比较成熟了，使用上却不是很广泛，遂分享下自己瞎折腾的一些路，想着帮助大家少踩点坑，本文将介绍下服务端和网页端中OpenLayers对于矢量切片的一些应用。\n\n<!-- more -->\n\n&nbsp;&nbsp;在项目实际使用中还是建议大家首先了解下矢量和栅格切片的优缺点，网上能搜到的很多，水平有限，这里不献丑了。对于我个人来说吸引我的无非三点：1.支持大数据；2.自定义渲染；3.要素交互。\n\n&nbsp;&nbsp;不多说了进入主题吧，OpenLayers中支持`ol.source.VectorTile`,对于我们来说想使用它无非就是创造这一类型的`source`，目前来说想要自定义矢量切片源我探索的有以下几种方式：\n\n# geoserver中的vectortiles-plugin插件\n\n这种方式网上教程很多，是大家目前常用的，优点是支持的数据格式比较多，输出的数据格式也很多，geojson、topojson、mvt都能做到，不做过多介绍\n\n# mapbox开发的geojson-vt库\n\n这个库可能大家不去仔细关注都不会发现，mapbox推出，[geojson-vt](https://github.com/mapbox/geojson-vt)，作用很简单，官方说明简单明了，把geojson转换成mvt格式的矢量数据源。\n\n翻译一下使用：\n\n````js\n// 通过geojson数据源构建切片索引\nvar tileIndex = geojsonvt(geoJSON);\n\n// 通过z,x,y来在切片索引中请求某个具体瓦片\nvar features = tileIndex.getTile(z, x, y).features;\n````\n\n拿到features后无非就是做样式调整之类的工作了。OpenLayers官方也有一个demo，叫做[geojson-vt integration](https://openlayers.org/en/latest/examples/geojson-vt.html)，详细介绍了怎么在OpenLayers中结合使用该库。\n\n我在实际使用中发现，这个库可以说很imba了，有测试200M以上的geojson源文件，都能流畅的展示出来。mapbox官方对于这个库的说明是，把geojson切割成矢量切片在**浏览器端**使用，所以我觉得因为**网络传输**的不确定性，对于**小一点**的数据量，可以考虑直接在浏览器端使用这个库。\n\n# geojson-vt的nodejs服务端实现\n\n(｡･∀･)ﾉﾞ嗨，既然是js，那就意味着，我们可以用nodejs搭建服务端呀，在浏览到某个层级时候，只请求当前需要的瓦片，不就能解决大数据的传输问题了，nodejs大法好！\n\n具体的代码可以移步[github](https://github.com/zzcyrus/openlayers-demos/tree/master/1.vector_tile)\n\n这里对一些主要部分做一些说明\n\n````js\n// 读取数据源文件，构建切片索引\nconst dataFile = \"./data/world.json\";\nconst dataSource = JSON.parse(fs.readFileSync(dataFile));\nconst tileIndex = geojsonvt(dataSource, {\n    extent: 4096,\n    debug: 1\n});\n````\n\n````js\n// 从url中解析瓦片请求位置的x，y，z\napp.use(async (ctx, next) => {\n    let path = ctx.request.path.toString()\n    ctx.response.type = 'application/json';\n    if (path.indexOf('.vector') !== -1) {\n        const pathArr = path.substring(1, path.indexOf('.vector')).split('/')\n        const z = pathArr[pathArr.length - 3]\n        const x = pathArr[pathArr.length - 2]\n        const y = pathArr[pathArr.length - 1]\n        const data = tileIndex.getTile(Number(z), Number(x), Number(y));\n        const features = JSON.stringify({\n            type: 'FeatureCollection',\n            features: data ? data.features : []\n        }, replacer)  // replacer 是geojson格式转换函数\n        ctx.response.body = features\n        await next()\n    } else {\n        ctx.response.body = 'Error'\n    }\n});\n````\n\n接下来是浏览器中的调用\n\n````js\nvar vectorSource = new ol.source.VectorTile({\n        // 因为转换函数是geojson格式，所以这里format为geojson\n        format: new ol.format.GeoJSON({\n            // 要定义数据源的坐标系为瓦片像素\n            defaultDataProjection: new ol.proj.Projection({\n                code: 'TILE_PIXELS',\n                units: 'tile-pixels'\n            })\n        }),\n        // 调用时候要注意z，x，y 的位置，实际上是与服务端相对应的\n        url: 'http://localhost:3000/gettile/{z}/{x}/{y}.vector',\n    });\n````\n\n你可以在 [github](https://github.com/zzcyrus/openlayers-demos) 上看到demo，执行安装启动\n\n````cl\ncd ./1.vector_tile\nnpm install\nnpm start\n````\n\n打开vectortile.hmtl可以在network中看到瓦片请求了。\n\n![](network.png)","source":"_posts/2017/vector-tile-openlayers-try.md","raw":"---\ntitle: 矢量切片的使用尝试1—openlayers应用\ndate: 2017-11-12 10:54:57\ntags: [GIS,OpenLayers]\ncategories: OpenLayers\n---\n\n&nbsp;&nbsp;对于GIS行业来说，栅格切片已经处于垄断地位很长时间了，但随着mapbox的发展，矢量切片越来越勾引起大家探究的欲望，最近我也小小的观望了下，发现现在技术还是比较成熟了，使用上却不是很广泛，遂分享下自己瞎折腾的一些路，想着帮助大家少踩点坑，本文将介绍下服务端和网页端中OpenLayers对于矢量切片的一些应用。\n\n<!-- more -->\n\n&nbsp;&nbsp;在项目实际使用中还是建议大家首先了解下矢量和栅格切片的优缺点，网上能搜到的很多，水平有限，这里不献丑了。对于我个人来说吸引我的无非三点：1.支持大数据；2.自定义渲染；3.要素交互。\n\n&nbsp;&nbsp;不多说了进入主题吧，OpenLayers中支持`ol.source.VectorTile`,对于我们来说想使用它无非就是创造这一类型的`source`，目前来说想要自定义矢量切片源我探索的有以下几种方式：\n\n# geoserver中的vectortiles-plugin插件\n\n这种方式网上教程很多，是大家目前常用的，优点是支持的数据格式比较多，输出的数据格式也很多，geojson、topojson、mvt都能做到，不做过多介绍\n\n# mapbox开发的geojson-vt库\n\n这个库可能大家不去仔细关注都不会发现，mapbox推出，[geojson-vt](https://github.com/mapbox/geojson-vt)，作用很简单，官方说明简单明了，把geojson转换成mvt格式的矢量数据源。\n\n翻译一下使用：\n\n````js\n// 通过geojson数据源构建切片索引\nvar tileIndex = geojsonvt(geoJSON);\n\n// 通过z,x,y来在切片索引中请求某个具体瓦片\nvar features = tileIndex.getTile(z, x, y).features;\n````\n\n拿到features后无非就是做样式调整之类的工作了。OpenLayers官方也有一个demo，叫做[geojson-vt integration](https://openlayers.org/en/latest/examples/geojson-vt.html)，详细介绍了怎么在OpenLayers中结合使用该库。\n\n我在实际使用中发现，这个库可以说很imba了，有测试200M以上的geojson源文件，都能流畅的展示出来。mapbox官方对于这个库的说明是，把geojson切割成矢量切片在**浏览器端**使用，所以我觉得因为**网络传输**的不确定性，对于**小一点**的数据量，可以考虑直接在浏览器端使用这个库。\n\n# geojson-vt的nodejs服务端实现\n\n(｡･∀･)ﾉﾞ嗨，既然是js，那就意味着，我们可以用nodejs搭建服务端呀，在浏览到某个层级时候，只请求当前需要的瓦片，不就能解决大数据的传输问题了，nodejs大法好！\n\n具体的代码可以移步[github](https://github.com/zzcyrus/openlayers-demos/tree/master/1.vector_tile)\n\n这里对一些主要部分做一些说明\n\n````js\n// 读取数据源文件，构建切片索引\nconst dataFile = \"./data/world.json\";\nconst dataSource = JSON.parse(fs.readFileSync(dataFile));\nconst tileIndex = geojsonvt(dataSource, {\n    extent: 4096,\n    debug: 1\n});\n````\n\n````js\n// 从url中解析瓦片请求位置的x，y，z\napp.use(async (ctx, next) => {\n    let path = ctx.request.path.toString()\n    ctx.response.type = 'application/json';\n    if (path.indexOf('.vector') !== -1) {\n        const pathArr = path.substring(1, path.indexOf('.vector')).split('/')\n        const z = pathArr[pathArr.length - 3]\n        const x = pathArr[pathArr.length - 2]\n        const y = pathArr[pathArr.length - 1]\n        const data = tileIndex.getTile(Number(z), Number(x), Number(y));\n        const features = JSON.stringify({\n            type: 'FeatureCollection',\n            features: data ? data.features : []\n        }, replacer)  // replacer 是geojson格式转换函数\n        ctx.response.body = features\n        await next()\n    } else {\n        ctx.response.body = 'Error'\n    }\n});\n````\n\n接下来是浏览器中的调用\n\n````js\nvar vectorSource = new ol.source.VectorTile({\n        // 因为转换函数是geojson格式，所以这里format为geojson\n        format: new ol.format.GeoJSON({\n            // 要定义数据源的坐标系为瓦片像素\n            defaultDataProjection: new ol.proj.Projection({\n                code: 'TILE_PIXELS',\n                units: 'tile-pixels'\n            })\n        }),\n        // 调用时候要注意z，x，y 的位置，实际上是与服务端相对应的\n        url: 'http://localhost:3000/gettile/{z}/{x}/{y}.vector',\n    });\n````\n\n你可以在 [github](https://github.com/zzcyrus/openlayers-demos) 上看到demo，执行安装启动\n\n````cl\ncd ./1.vector_tile\nnpm install\nnpm start\n````\n\n打开vectortile.hmtl可以在network中看到瓦片请求了。\n\n![](network.png)","slug":"vector-tile-openlayers-try","published":1,"updated":"2019-06-28T05:57:49.930Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy4fqa9f00070n3icj77ad7h","content":"<p>&nbsp;&nbsp;对于GIS行业来说，栅格切片已经处于垄断地位很长时间了，但随着mapbox的发展，矢量切片越来越勾引起大家探究的欲望，最近我也小小的观望了下，发现现在技术还是比较成熟了，使用上却不是很广泛，遂分享下自己瞎折腾的一些路，想着帮助大家少踩点坑，本文将介绍下服务端和网页端中OpenLayers对于矢量切片的一些应用。</p>\n<a id=\"more\"></a>\n<p>&nbsp;&nbsp;在项目实际使用中还是建议大家首先了解下矢量和栅格切片的优缺点，网上能搜到的很多，水平有限，这里不献丑了。对于我个人来说吸引我的无非三点：1.支持大数据；2.自定义渲染；3.要素交互。</p>\n<p>&nbsp;&nbsp;不多说了进入主题吧，OpenLayers中支持<code>ol.source.VectorTile</code>,对于我们来说想使用它无非就是创造这一类型的<code>source</code>，目前来说想要自定义矢量切片源我探索的有以下几种方式：</p>\n<h1 id=\"geoserver中的vectortiles-plugin插件\"><a href=\"#geoserver中的vectortiles-plugin插件\" class=\"headerlink\" title=\"geoserver中的vectortiles-plugin插件\"></a>geoserver中的vectortiles-plugin插件</h1><p>这种方式网上教程很多，是大家目前常用的，优点是支持的数据格式比较多，输出的数据格式也很多，geojson、topojson、mvt都能做到，不做过多介绍</p>\n<h1 id=\"mapbox开发的geojson-vt库\"><a href=\"#mapbox开发的geojson-vt库\" class=\"headerlink\" title=\"mapbox开发的geojson-vt库\"></a>mapbox开发的geojson-vt库</h1><p>这个库可能大家不去仔细关注都不会发现，mapbox推出，<a href=\"https://github.com/mapbox/geojson-vt\" target=\"_blank\" rel=\"noopener\">geojson-vt</a>，作用很简单，官方说明简单明了，把geojson转换成mvt格式的矢量数据源。</p>\n<p>翻译一下使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过geojson数据源构建切片索引</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> tileIndex = geojsonvt(geoJSON);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过z,x,y来在切片索引中请求某个具体瓦片</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> features = tileIndex.getTile(z, x, y).features;</span><br></pre></td></tr></table></figure>\n<p>拿到features后无非就是做样式调整之类的工作了。OpenLayers官方也有一个demo，叫做<a href=\"https://openlayers.org/en/latest/examples/geojson-vt.html\" target=\"_blank\" rel=\"noopener\">geojson-vt integration</a>，详细介绍了怎么在OpenLayers中结合使用该库。</p>\n<p>我在实际使用中发现，这个库可以说很imba了，有测试200M以上的geojson源文件，都能流畅的展示出来。mapbox官方对于这个库的说明是，把geojson切割成矢量切片在<strong>浏览器端</strong>使用，所以我觉得因为<strong>网络传输</strong>的不确定性，对于<strong>小一点</strong>的数据量，可以考虑直接在浏览器端使用这个库。</p>\n<h1 id=\"geojson-vt的nodejs服务端实现\"><a href=\"#geojson-vt的nodejs服务端实现\" class=\"headerlink\" title=\"geojson-vt的nodejs服务端实现\"></a>geojson-vt的nodejs服务端实现</h1><p>(｡･∀･)ﾉﾞ嗨，既然是js，那就意味着，我们可以用nodejs搭建服务端呀，在浏览到某个层级时候，只请求当前需要的瓦片，不就能解决大数据的传输问题了，nodejs大法好！</p>\n<p>具体的代码可以移步<a href=\"https://github.com/zzcyrus/openlayers-demos/tree/master/1.vector_tile\" target=\"_blank\" rel=\"noopener\">github</a></p>\n<p>这里对一些主要部分做一些说明</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 读取数据源文件，构建切片索引</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> dataFile = <span class=\"string\">\"./data/world.json\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> dataSource = <span class=\"built_in\">JSON</span>.parse(fs.readFileSync(dataFile));</span><br><span class=\"line\"><span class=\"keyword\">const</span> tileIndex = geojsonvt(dataSource, &#123;</span><br><span class=\"line\">    extent: <span class=\"number\">4096</span>,</span><br><span class=\"line\">    debug: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从url中解析瓦片请求位置的x，y，z</span></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> path = ctx.request.path.toString()</span><br><span class=\"line\">    ctx.response.type = <span class=\"string\">'application/json'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (path.indexOf(<span class=\"string\">'.vector'</span>) !== <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> pathArr = path.substring(<span class=\"number\">1</span>, path.indexOf(<span class=\"string\">'.vector'</span>)).split(<span class=\"string\">'/'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">const</span> z = pathArr[pathArr.length - <span class=\"number\">3</span>]</span><br><span class=\"line\">        <span class=\"keyword\">const</span> x = pathArr[pathArr.length - <span class=\"number\">2</span>]</span><br><span class=\"line\">        <span class=\"keyword\">const</span> y = pathArr[pathArr.length - <span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">const</span> data = tileIndex.getTile(<span class=\"built_in\">Number</span>(z), <span class=\"built_in\">Number</span>(x), <span class=\"built_in\">Number</span>(y));</span><br><span class=\"line\">        <span class=\"keyword\">const</span> features = <span class=\"built_in\">JSON</span>.stringify(&#123;</span><br><span class=\"line\">            type: <span class=\"string\">'FeatureCollection'</span>,</span><br><span class=\"line\">            features: data ? data.features : []</span><br><span class=\"line\">        &#125;, replacer)  <span class=\"comment\">// replacer 是geojson格式转换函数</span></span><br><span class=\"line\">        ctx.response.body = features</span><br><span class=\"line\">        <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ctx.response.body = <span class=\"string\">'Error'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>接下来是浏览器中的调用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vectorSource = <span class=\"keyword\">new</span> ol.source.VectorTile(&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 因为转换函数是geojson格式，所以这里format为geojson</span></span><br><span class=\"line\">        format: <span class=\"keyword\">new</span> ol.format.GeoJSON(&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 要定义数据源的坐标系为瓦片像素</span></span><br><span class=\"line\">            defaultDataProjection: <span class=\"keyword\">new</span> ol.proj.Projection(&#123;</span><br><span class=\"line\">                code: <span class=\"string\">'TILE_PIXELS'</span>,</span><br><span class=\"line\">                units: <span class=\"string\">'tile-pixels'</span></span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">        <span class=\"comment\">// 调用时候要注意z，x，y 的位置，实际上是与服务端相对应的</span></span><br><span class=\"line\">        url: <span class=\"string\">'http://localhost:3000/gettile/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.vector'</span>,</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>你可以在 <a href=\"https://github.com/zzcyrus/openlayers-demos\" target=\"_blank\" rel=\"noopener\">github</a> 上看到demo，执行安装启动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd ./1.vector_tile</span><br><span class=\"line\">npm install</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<p>打开vectortile.hmtl可以在network中看到瓦片请求了。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"network.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>","site":{"data":{}},"excerpt":"<p>&nbsp;&nbsp;对于GIS行业来说，栅格切片已经处于垄断地位很长时间了，但随着mapbox的发展，矢量切片越来越勾引起大家探究的欲望，最近我也小小的观望了下，发现现在技术还是比较成熟了，使用上却不是很广泛，遂分享下自己瞎折腾的一些路，想着帮助大家少踩点坑，本文将介绍下服务端和网页端中OpenLayers对于矢量切片的一些应用。</p>","more":"<p>&nbsp;&nbsp;在项目实际使用中还是建议大家首先了解下矢量和栅格切片的优缺点，网上能搜到的很多，水平有限，这里不献丑了。对于我个人来说吸引我的无非三点：1.支持大数据；2.自定义渲染；3.要素交互。</p>\n<p>&nbsp;&nbsp;不多说了进入主题吧，OpenLayers中支持<code>ol.source.VectorTile</code>,对于我们来说想使用它无非就是创造这一类型的<code>source</code>，目前来说想要自定义矢量切片源我探索的有以下几种方式：</p>\n<h1 id=\"geoserver中的vectortiles-plugin插件\"><a href=\"#geoserver中的vectortiles-plugin插件\" class=\"headerlink\" title=\"geoserver中的vectortiles-plugin插件\"></a>geoserver中的vectortiles-plugin插件</h1><p>这种方式网上教程很多，是大家目前常用的，优点是支持的数据格式比较多，输出的数据格式也很多，geojson、topojson、mvt都能做到，不做过多介绍</p>\n<h1 id=\"mapbox开发的geojson-vt库\"><a href=\"#mapbox开发的geojson-vt库\" class=\"headerlink\" title=\"mapbox开发的geojson-vt库\"></a>mapbox开发的geojson-vt库</h1><p>这个库可能大家不去仔细关注都不会发现，mapbox推出，<a href=\"https://github.com/mapbox/geojson-vt\" target=\"_blank\" rel=\"noopener\">geojson-vt</a>，作用很简单，官方说明简单明了，把geojson转换成mvt格式的矢量数据源。</p>\n<p>翻译一下使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过geojson数据源构建切片索引</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> tileIndex = geojsonvt(geoJSON);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过z,x,y来在切片索引中请求某个具体瓦片</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> features = tileIndex.getTile(z, x, y).features;</span><br></pre></td></tr></table></figure>\n<p>拿到features后无非就是做样式调整之类的工作了。OpenLayers官方也有一个demo，叫做<a href=\"https://openlayers.org/en/latest/examples/geojson-vt.html\" target=\"_blank\" rel=\"noopener\">geojson-vt integration</a>，详细介绍了怎么在OpenLayers中结合使用该库。</p>\n<p>我在实际使用中发现，这个库可以说很imba了，有测试200M以上的geojson源文件，都能流畅的展示出来。mapbox官方对于这个库的说明是，把geojson切割成矢量切片在<strong>浏览器端</strong>使用，所以我觉得因为<strong>网络传输</strong>的不确定性，对于<strong>小一点</strong>的数据量，可以考虑直接在浏览器端使用这个库。</p>\n<h1 id=\"geojson-vt的nodejs服务端实现\"><a href=\"#geojson-vt的nodejs服务端实现\" class=\"headerlink\" title=\"geojson-vt的nodejs服务端实现\"></a>geojson-vt的nodejs服务端实现</h1><p>(｡･∀･)ﾉﾞ嗨，既然是js，那就意味着，我们可以用nodejs搭建服务端呀，在浏览到某个层级时候，只请求当前需要的瓦片，不就能解决大数据的传输问题了，nodejs大法好！</p>\n<p>具体的代码可以移步<a href=\"https://github.com/zzcyrus/openlayers-demos/tree/master/1.vector_tile\" target=\"_blank\" rel=\"noopener\">github</a></p>\n<p>这里对一些主要部分做一些说明</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 读取数据源文件，构建切片索引</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> dataFile = <span class=\"string\">\"./data/world.json\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> dataSource = <span class=\"built_in\">JSON</span>.parse(fs.readFileSync(dataFile));</span><br><span class=\"line\"><span class=\"keyword\">const</span> tileIndex = geojsonvt(dataSource, &#123;</span><br><span class=\"line\">    extent: <span class=\"number\">4096</span>,</span><br><span class=\"line\">    debug: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从url中解析瓦片请求位置的x，y，z</span></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> path = ctx.request.path.toString()</span><br><span class=\"line\">    ctx.response.type = <span class=\"string\">'application/json'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (path.indexOf(<span class=\"string\">'.vector'</span>) !== <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> pathArr = path.substring(<span class=\"number\">1</span>, path.indexOf(<span class=\"string\">'.vector'</span>)).split(<span class=\"string\">'/'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">const</span> z = pathArr[pathArr.length - <span class=\"number\">3</span>]</span><br><span class=\"line\">        <span class=\"keyword\">const</span> x = pathArr[pathArr.length - <span class=\"number\">2</span>]</span><br><span class=\"line\">        <span class=\"keyword\">const</span> y = pathArr[pathArr.length - <span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">const</span> data = tileIndex.getTile(<span class=\"built_in\">Number</span>(z), <span class=\"built_in\">Number</span>(x), <span class=\"built_in\">Number</span>(y));</span><br><span class=\"line\">        <span class=\"keyword\">const</span> features = <span class=\"built_in\">JSON</span>.stringify(&#123;</span><br><span class=\"line\">            type: <span class=\"string\">'FeatureCollection'</span>,</span><br><span class=\"line\">            features: data ? data.features : []</span><br><span class=\"line\">        &#125;, replacer)  <span class=\"comment\">// replacer 是geojson格式转换函数</span></span><br><span class=\"line\">        ctx.response.body = features</span><br><span class=\"line\">        <span class=\"keyword\">await</span> next()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ctx.response.body = <span class=\"string\">'Error'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>接下来是浏览器中的调用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vectorSource = <span class=\"keyword\">new</span> ol.source.VectorTile(&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 因为转换函数是geojson格式，所以这里format为geojson</span></span><br><span class=\"line\">        format: <span class=\"keyword\">new</span> ol.format.GeoJSON(&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 要定义数据源的坐标系为瓦片像素</span></span><br><span class=\"line\">            defaultDataProjection: <span class=\"keyword\">new</span> ol.proj.Projection(&#123;</span><br><span class=\"line\">                code: <span class=\"string\">'TILE_PIXELS'</span>,</span><br><span class=\"line\">                units: <span class=\"string\">'tile-pixels'</span></span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">        <span class=\"comment\">// 调用时候要注意z，x，y 的位置，实际上是与服务端相对应的</span></span><br><span class=\"line\">        url: <span class=\"string\">'http://localhost:3000/gettile/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.vector'</span>,</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>你可以在 <a href=\"https://github.com/zzcyrus/openlayers-demos\" target=\"_blank\" rel=\"noopener\">github</a> 上看到demo，执行安装启动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd ./1.vector_tile</span><br><span class=\"line\">npm install</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<p>打开vectortile.hmtl可以在network中看到瓦片请求了。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"network.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>"},{"title":"element dialog组件嵌套问题的临时方案","date":"2017-06-23T14:09:55.000Z","_content":"\n&emsp;&emsp;最近用 Vue+element 开发项目时，在dialog组件上嵌套使用dialog组件或是MessageBox这类弹框组件，发现会出现遮罩层重合之类的问题，导致很多人只能选择关闭遮罩层。GitHub上就此问题也出现过类似讨论。有几种解决方案：\n\n<!--more--> \n\n\n1. 按照官方所说，将多个dialog类组件全部移动至**<body**>标签下\n\n2. Github上某位大牛给出了不完全解决方案，基本思路仍然是将添加在**<el-dialog**>内的dom结构自动移动至**<body**>标签下。这个方式测试了下，似乎纯dialog嵌套问题不大，但是如果dialog内部包含了其他组件会有点问题，智者见智，自行探索了\n\n&emsp;&emsp;[附上连接](https://github.com/foolishchow/element-dialog2)\n\n3. 编写自己modal遮罩层，这里给出个不完全临时代码仅供参考\n\n```js\n    Vue.prototype.$Modal = {\n        open(element) {\n            var index = 1;\n            var wrapper = element.querySelector('.el-dialog__wrapper');\n            if (wrapper) {\n                index = wrapper.style.zIndex - 1;\n            }\n            var modalDom = document.createElement('div');\n            modalDom.className = 'v-modal';\n            element.appendChild(modalDom);\n            modalDom.style.zIndex = index;\n        },\n        close() {\n            var modal = document.getElementsByClassName('v-modal')[0;\n            modal.parentNode.removeChild(modal);\n        }\n    }\n\n```\n&emsp;&emsp;一般调用方法\n```js\n    mounted: function () {\n        var that = this;\n        this.$nextTick(function () {\n            //遮罩层\n            that.$nextTick(function () {\n                that.$Modal.open(that.$el);\n            });\n        });\n    },\n```\n\n&emsp;&emsp;主要想法就是在组件mounted完成的nextTick后，为页面中添加一个div，样式就直接采用element自己的了，因为遮罩层是添加在dialog组件下的，因此组件销毁后也会自己销毁，close方法也没用上，但也应该会遇到有用上的时候吧。\n","source":"_posts/2017/vue-dialog-nested.md","raw":"---\ntitle: element dialog组件嵌套问题的临时方案\ndate: 2017-06-23 22:09:55\ntags: [FE,Vue]\ncategories: 前端\n---\n\n&emsp;&emsp;最近用 Vue+element 开发项目时，在dialog组件上嵌套使用dialog组件或是MessageBox这类弹框组件，发现会出现遮罩层重合之类的问题，导致很多人只能选择关闭遮罩层。GitHub上就此问题也出现过类似讨论。有几种解决方案：\n\n<!--more--> \n\n\n1. 按照官方所说，将多个dialog类组件全部移动至**<body**>标签下\n\n2. Github上某位大牛给出了不完全解决方案，基本思路仍然是将添加在**<el-dialog**>内的dom结构自动移动至**<body**>标签下。这个方式测试了下，似乎纯dialog嵌套问题不大，但是如果dialog内部包含了其他组件会有点问题，智者见智，自行探索了\n\n&emsp;&emsp;[附上连接](https://github.com/foolishchow/element-dialog2)\n\n3. 编写自己modal遮罩层，这里给出个不完全临时代码仅供参考\n\n```js\n    Vue.prototype.$Modal = {\n        open(element) {\n            var index = 1;\n            var wrapper = element.querySelector('.el-dialog__wrapper');\n            if (wrapper) {\n                index = wrapper.style.zIndex - 1;\n            }\n            var modalDom = document.createElement('div');\n            modalDom.className = 'v-modal';\n            element.appendChild(modalDom);\n            modalDom.style.zIndex = index;\n        },\n        close() {\n            var modal = document.getElementsByClassName('v-modal')[0;\n            modal.parentNode.removeChild(modal);\n        }\n    }\n\n```\n&emsp;&emsp;一般调用方法\n```js\n    mounted: function () {\n        var that = this;\n        this.$nextTick(function () {\n            //遮罩层\n            that.$nextTick(function () {\n                that.$Modal.open(that.$el);\n            });\n        });\n    },\n```\n\n&emsp;&emsp;主要想法就是在组件mounted完成的nextTick后，为页面中添加一个div，样式就直接采用element自己的了，因为遮罩层是添加在dialog组件下的，因此组件销毁后也会自己销毁，close方法也没用上，但也应该会遇到有用上的时候吧。\n","slug":"vue-dialog-nested","published":1,"updated":"2019-06-28T05:56:41.472Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy4fqa9i00080n3iteqaru3e","content":"<p>&emsp;&emsp;最近用 Vue+element 开发项目时，在dialog组件上嵌套使用dialog组件或是MessageBox这类弹框组件，发现会出现遮罩层重合之类的问题，导致很多人只能选择关闭遮罩层。GitHub上就此问题也出现过类似讨论。有几种解决方案：</p>\n<a id=\"more\"></a> \n<ol>\n<li><p>按照官方所说，将多个dialog类组件全部移动至<strong>&lt;body</strong>&gt;标签下</p>\n</li>\n<li><p>Github上某位大牛给出了不完全解决方案，基本思路仍然是将添加在<strong>&lt;el-dialog</strong>&gt;内的dom结构自动移动至<strong>&lt;body</strong>&gt;标签下。这个方式测试了下，似乎纯dialog嵌套问题不大，但是如果dialog内部包含了其他组件会有点问题，智者见智，自行探索了</p>\n</li>\n</ol>\n<p>&emsp;&emsp;<a href=\"https://github.com/foolishchow/element-dialog2\" target=\"_blank\" rel=\"noopener\">附上连接</a></p>\n<ol start=\"3\">\n<li>编写自己modal遮罩层，这里给出个不完全临时代码仅供参考</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">Vue.prototype.$Modal = &#123;</span><br><span class=\"line\">    open(element) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> index = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> wrapper = element.querySelector(<span class=\"string\">'.el-dialog__wrapper'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (wrapper) &#123;</span><br><span class=\"line\">            index = wrapper.style.zIndex - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> modalDom = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'div'</span>);</span><br><span class=\"line\">        modalDom.className = <span class=\"string\">'v-modal'</span>;</span><br><span class=\"line\">        element.appendChild(modalDom);</span><br><span class=\"line\">        modalDom.style.zIndex = index;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    close() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> modal = <span class=\"built_in\">document</span>.getElementsByClassName(<span class=\"string\">'v-modal'</span>)[<span class=\"number\">0</span>;</span><br><span class=\"line\">        modal.parentNode.removeChild(modal);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;一般调用方法<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">mounted: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//遮罩层</span></span><br><span class=\"line\">        that.$nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            that.$Modal.open(that.$el);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;主要想法就是在组件mounted完成的nextTick后，为页面中添加一个div，样式就直接采用element自己的了，因为遮罩层是添加在dialog组件下的，因此组件销毁后也会自己销毁，close方法也没用上，但也应该会遇到有用上的时候吧。</p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;最近用 Vue+element 开发项目时，在dialog组件上嵌套使用dialog组件或是MessageBox这类弹框组件，发现会出现遮罩层重合之类的问题，导致很多人只能选择关闭遮罩层。GitHub上就此问题也出现过类似讨论。有几种解决方案：</p>","more":"<ol>\n<li><p>按照官方所说，将多个dialog类组件全部移动至<strong>&lt;body</strong>&gt;标签下</p>\n</li>\n<li><p>Github上某位大牛给出了不完全解决方案，基本思路仍然是将添加在<strong>&lt;el-dialog</strong>&gt;内的dom结构自动移动至<strong>&lt;body</strong>&gt;标签下。这个方式测试了下，似乎纯dialog嵌套问题不大，但是如果dialog内部包含了其他组件会有点问题，智者见智，自行探索了</p>\n</li>\n</ol>\n<p>&emsp;&emsp;<a href=\"https://github.com/foolishchow/element-dialog2\" target=\"_blank\" rel=\"noopener\">附上连接</a></p>\n<ol start=\"3\">\n<li>编写自己modal遮罩层，这里给出个不完全临时代码仅供参考</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">Vue.prototype.$Modal = &#123;</span><br><span class=\"line\">    open(element) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> index = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> wrapper = element.querySelector(<span class=\"string\">'.el-dialog__wrapper'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (wrapper) &#123;</span><br><span class=\"line\">            index = wrapper.style.zIndex - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> modalDom = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'div'</span>);</span><br><span class=\"line\">        modalDom.className = <span class=\"string\">'v-modal'</span>;</span><br><span class=\"line\">        element.appendChild(modalDom);</span><br><span class=\"line\">        modalDom.style.zIndex = index;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    close() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> modal = <span class=\"built_in\">document</span>.getElementsByClassName(<span class=\"string\">'v-modal'</span>)[<span class=\"number\">0</span>;</span><br><span class=\"line\">        modal.parentNode.removeChild(modal);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>&emsp;&emsp;一般调用方法<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">mounted: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//遮罩层</span></span><br><span class=\"line\">        that.$nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            that.$Modal.open(that.$el);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;主要想法就是在组件mounted完成的nextTick后，为页面中添加一个div，样式就直接采用element自己的了，因为遮罩层是添加在dialog组件下的，因此组件销毁后也会自己销毁，close方法也没用上，但也应该会遇到有用上的时候吧。</p>"},{"title":"mongoDB中地理空间查询指北","date":"2019-01-20T09:41:24.000Z","_content":"\n\n现在地理空间查询是越来越常见的一种需求，实现的方式也有很多种，相较于PostGIS，mongoDB既可以直接存储GeoJSON对象，又支持地理空间索引，可以满足高效的常见地理空间服务。\n\n<!-- more -->\n\n\n[一个可供参考的案例仓库](https://github.com/zzcyrus/mongoDB-geospatial-demos)\n\n\n## 索引方式介绍\n\n### 2d 索引\n\n[官方介绍](https://docs.mongodb.com/manual/core/2d/)\n\n2d index 通常用在2维平面上的点数据，如果你的MongoDB 版本小于2.2或者你不使用一些GeoJSON类型的数据，官方推荐你使用2d index。\n\n### 2dsphere 索引\n\n[官方介绍](https://docs.mongodb.com/manual/core/2dsphere/)\n\n2dsphere index 支持所有的mongoDB空间查询，支持类地球的球面上几何要素的查询，支持数据存储为GeoJSON或者是传统坐标。\n\n\n*所以如果你正在做一个现代化的GIS应用，建议直接采取2dsphere索引，这将会非常方便，GeoJSON格式的直接导入，配合WebGIS的直接查询或插入*\n\n\n## 查询方法介绍\n\n[官方介绍](https://docs.mongodb.com/manual/reference/operator/query-geospatial/)\n\n\n下面这个表格包含了一些个人的总结和官方的说明，具体查询的作用其实通过查询方法的名字就能猜测出来，所以不详细介绍了\n\n\n|查询方式|2d索引|sphere索引|几何类型（2d/sphere）|\n| --- | :-: | :-: | :-: | --- |\n|$near| ✅ | ✅ | 平面/球面 |\n|$nearSphere | ✅ | ✅ | 球面 |\n|$geoWithin:{$center:...}| ✅ | ⚠️ | 平面 |\n|$geoWithin:{$centerSphere:...} | ✅ | ✅ | 球面 |\n|$geoWithin:{$box:...}| ✅ | ⚠️ | 平面 |\n|$geoWithin:{$polygon:...}| ✅ | ⚠️ | 平面 |\n|$geoWithin:{$geometry:...}| ❎ | ✅ | 球面 |\n|$geoIntersects | ❎ | ✅ | 球面 |\n\n> 说明： ✅ 支持 ❎ 不支持 ⚠️ 官方文档说不支持，但测试发现可以使用\n\n\n## 使用注意事项\n\n1. 在2dsphere索引中使用$geometry去查询，如果自己构造$geometry，要注意geometry的coordinates必须是一个`闭合`的数组，首尾两项要一致。\n2. 与此同时，在使用$polygon去查询时，`不必`是一个闭合的坐标数组列，mongoDB会自动帮我们关闭这个图形\n3. 在使用$near或者$geoWithin之类的查询中会涉及到距离、半径定义，这里如果你使用经纬度作为坐标，使用m（米）作为距离、半径单位，那么要进行`转换`，具体的转换规则可以参考下面两段代码示例：\n\n\n```js\n/**\n * 1度大致对应111千米，所以需要/111000,具体可以细化\n * @param {*} meter 米\n */\nconst m2degree = (meter) => {\n  return meter / 111000\n}\n\nconst query = {\n  location: {\n    $geoWithin: {\n      $center: [[lon, lat], m2degree(radius)]\n    }\n  }\n}\n```\n\n```js\n/**\n * 米转换成弧度，需要除以地球半径，大约6378100米\n * @param {*} meter\n */\nconst m2rad = (meter) => {\n  return meter / 6378100\n}\n\nconst query = {\n  location: {\n    $nearSphere: [lon, lat],\n    $maxDistance: m2rad(maxDistance)\n  }\n}\n\n```\n\n## demo\n\n这里提供[一个可供参考的简单的案例仓库](https://github.com/zzcyrus/mongoDB-geospatial-demos)\n案例中使用了中国天气网上的749个气象站点温度数据作为数据源，分别建立两种类型的索引，对每种地理查询都做了接口化，你可以**自行运行探索**，或者为其增加一个WebGIS的界面，直接进行操作，体验一下mongoDB地理查询的快捷。\n","source":"_posts/2019/mongoDB-geospatial.md","raw":"---\ntitle: mongoDB中地理空间查询指北\ndate: 2019-01-20 17:41:24\ntags: [GIS]\ncategories: Node\n---\n\n\n现在地理空间查询是越来越常见的一种需求，实现的方式也有很多种，相较于PostGIS，mongoDB既可以直接存储GeoJSON对象，又支持地理空间索引，可以满足高效的常见地理空间服务。\n\n<!-- more -->\n\n\n[一个可供参考的案例仓库](https://github.com/zzcyrus/mongoDB-geospatial-demos)\n\n\n## 索引方式介绍\n\n### 2d 索引\n\n[官方介绍](https://docs.mongodb.com/manual/core/2d/)\n\n2d index 通常用在2维平面上的点数据，如果你的MongoDB 版本小于2.2或者你不使用一些GeoJSON类型的数据，官方推荐你使用2d index。\n\n### 2dsphere 索引\n\n[官方介绍](https://docs.mongodb.com/manual/core/2dsphere/)\n\n2dsphere index 支持所有的mongoDB空间查询，支持类地球的球面上几何要素的查询，支持数据存储为GeoJSON或者是传统坐标。\n\n\n*所以如果你正在做一个现代化的GIS应用，建议直接采取2dsphere索引，这将会非常方便，GeoJSON格式的直接导入，配合WebGIS的直接查询或插入*\n\n\n## 查询方法介绍\n\n[官方介绍](https://docs.mongodb.com/manual/reference/operator/query-geospatial/)\n\n\n下面这个表格包含了一些个人的总结和官方的说明，具体查询的作用其实通过查询方法的名字就能猜测出来，所以不详细介绍了\n\n\n|查询方式|2d索引|sphere索引|几何类型（2d/sphere）|\n| --- | :-: | :-: | :-: | --- |\n|$near| ✅ | ✅ | 平面/球面 |\n|$nearSphere | ✅ | ✅ | 球面 |\n|$geoWithin:{$center:...}| ✅ | ⚠️ | 平面 |\n|$geoWithin:{$centerSphere:...} | ✅ | ✅ | 球面 |\n|$geoWithin:{$box:...}| ✅ | ⚠️ | 平面 |\n|$geoWithin:{$polygon:...}| ✅ | ⚠️ | 平面 |\n|$geoWithin:{$geometry:...}| ❎ | ✅ | 球面 |\n|$geoIntersects | ❎ | ✅ | 球面 |\n\n> 说明： ✅ 支持 ❎ 不支持 ⚠️ 官方文档说不支持，但测试发现可以使用\n\n\n## 使用注意事项\n\n1. 在2dsphere索引中使用$geometry去查询，如果自己构造$geometry，要注意geometry的coordinates必须是一个`闭合`的数组，首尾两项要一致。\n2. 与此同时，在使用$polygon去查询时，`不必`是一个闭合的坐标数组列，mongoDB会自动帮我们关闭这个图形\n3. 在使用$near或者$geoWithin之类的查询中会涉及到距离、半径定义，这里如果你使用经纬度作为坐标，使用m（米）作为距离、半径单位，那么要进行`转换`，具体的转换规则可以参考下面两段代码示例：\n\n\n```js\n/**\n * 1度大致对应111千米，所以需要/111000,具体可以细化\n * @param {*} meter 米\n */\nconst m2degree = (meter) => {\n  return meter / 111000\n}\n\nconst query = {\n  location: {\n    $geoWithin: {\n      $center: [[lon, lat], m2degree(radius)]\n    }\n  }\n}\n```\n\n```js\n/**\n * 米转换成弧度，需要除以地球半径，大约6378100米\n * @param {*} meter\n */\nconst m2rad = (meter) => {\n  return meter / 6378100\n}\n\nconst query = {\n  location: {\n    $nearSphere: [lon, lat],\n    $maxDistance: m2rad(maxDistance)\n  }\n}\n\n```\n\n## demo\n\n这里提供[一个可供参考的简单的案例仓库](https://github.com/zzcyrus/mongoDB-geospatial-demos)\n案例中使用了中国天气网上的749个气象站点温度数据作为数据源，分别建立两种类型的索引，对每种地理查询都做了接口化，你可以**自行运行探索**，或者为其增加一个WebGIS的界面，直接进行操作，体验一下mongoDB地理查询的快捷。\n","slug":"mongoDB-geospatial","published":1,"updated":"2019-06-28T05:55:48.716Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy4fqa9l000b0n3i4j2xirbo","content":"<p>现在地理空间查询是越来越常见的一种需求，实现的方式也有很多种，相较于PostGIS，mongoDB既可以直接存储GeoJSON对象，又支持地理空间索引，可以满足高效的常见地理空间服务。</p>\n<a id=\"more\"></a>\n<p><a href=\"https://github.com/zzcyrus/mongoDB-geospatial-demos\" target=\"_blank\" rel=\"noopener\">一个可供参考的案例仓库</a></p>\n<h2 id=\"索引方式介绍\"><a href=\"#索引方式介绍\" class=\"headerlink\" title=\"索引方式介绍\"></a>索引方式介绍</h2><h3 id=\"2d-索引\"><a href=\"#2d-索引\" class=\"headerlink\" title=\"2d 索引\"></a>2d 索引</h3><p><a href=\"https://docs.mongodb.com/manual/core/2d/\" target=\"_blank\" rel=\"noopener\">官方介绍</a></p>\n<p>2d index 通常用在2维平面上的点数据，如果你的MongoDB 版本小于2.2或者你不使用一些GeoJSON类型的数据，官方推荐你使用2d index。</p>\n<h3 id=\"2dsphere-索引\"><a href=\"#2dsphere-索引\" class=\"headerlink\" title=\"2dsphere 索引\"></a>2dsphere 索引</h3><p><a href=\"https://docs.mongodb.com/manual/core/2dsphere/\" target=\"_blank\" rel=\"noopener\">官方介绍</a></p>\n<p>2dsphere index 支持所有的mongoDB空间查询，支持类地球的球面上几何要素的查询，支持数据存储为GeoJSON或者是传统坐标。</p>\n<p><em>所以如果你正在做一个现代化的GIS应用，建议直接采取2dsphere索引，这将会非常方便，GeoJSON格式的直接导入，配合WebGIS的直接查询或插入</em></p>\n<h2 id=\"查询方法介绍\"><a href=\"#查询方法介绍\" class=\"headerlink\" title=\"查询方法介绍\"></a>查询方法介绍</h2><p><a href=\"https://docs.mongodb.com/manual/reference/operator/query-geospatial/\" target=\"_blank\" rel=\"noopener\">官方介绍</a></p>\n<p>下面这个表格包含了一些个人的总结和官方的说明，具体查询的作用其实通过查询方法的名字就能猜测出来，所以不详细介绍了</p>\n<table>\n<thead>\n<tr>\n<th>查询方式</th>\n<th style=\"text-align:center\">2d索引</th>\n<th style=\"text-align:center\">sphere索引</th>\n<th style=\"text-align:center\">几何类型（2d/sphere）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$near</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">平面/球面</td>\n</tr>\n<tr>\n<td>$nearSphere</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">球面</td>\n</tr>\n<tr>\n<td>$geoWithin:{$center:…}</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">⚠️</td>\n<td style=\"text-align:center\">平面</td>\n</tr>\n<tr>\n<td>$geoWithin:{$centerSphere:…}</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">球面</td>\n</tr>\n<tr>\n<td>$geoWithin:{$box:…}</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">⚠️</td>\n<td style=\"text-align:center\">平面</td>\n</tr>\n<tr>\n<td>$geoWithin:{$polygon:…}</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">⚠️</td>\n<td style=\"text-align:center\">平面</td>\n</tr>\n<tr>\n<td>$geoWithin:{$geometry:…}</td>\n<td style=\"text-align:center\">❎</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">球面</td>\n</tr>\n<tr>\n<td>$geoIntersects</td>\n<td style=\"text-align:center\">❎</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">球面</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>说明： ✅ 支持 ❎ 不支持 ⚠️ 官方文档说不支持，但测试发现可以使用</p>\n</blockquote>\n<h2 id=\"使用注意事项\"><a href=\"#使用注意事项\" class=\"headerlink\" title=\"使用注意事项\"></a>使用注意事项</h2><ol>\n<li>在2dsphere索引中使用$geometry去查询，如果自己构造$geometry，要注意geometry的coordinates必须是一个<code>闭合</code>的数组，首尾两项要一致。</li>\n<li>与此同时，在使用$polygon去查询时，<code>不必</code>是一个闭合的坐标数组列，mongoDB会自动帮我们关闭这个图形</li>\n<li>在使用$near或者$geoWithin之类的查询中会涉及到距离、半径定义，这里如果你使用经纬度作为坐标，使用m（米）作为距离、半径单位，那么要进行<code>转换</code>，具体的转换规则可以参考下面两段代码示例：</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 1度大致对应111千米，所以需要/111000,具体可以细化</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;*&#125; meter 米</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> m2degree = <span class=\"function\">(<span class=\"params\">meter</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> meter / <span class=\"number\">111000</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> query = &#123;</span><br><span class=\"line\">  location: &#123;</span><br><span class=\"line\">    $geoWithin: &#123;</span><br><span class=\"line\">      $center: [[lon, lat], m2degree(radius)]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 米转换成弧度，需要除以地球半径，大约6378100米</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;*&#125; meter</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> m2rad = <span class=\"function\">(<span class=\"params\">meter</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> meter / <span class=\"number\">6378100</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> query = &#123;</span><br><span class=\"line\">  location: &#123;</span><br><span class=\"line\">    $nearSphere: [lon, lat],</span><br><span class=\"line\">    $maxDistance: m2rad(maxDistance)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h2><p>这里提供<a href=\"https://github.com/zzcyrus/mongoDB-geospatial-demos\" target=\"_blank\" rel=\"noopener\">一个可供参考的简单的案例仓库</a><br>案例中使用了中国天气网上的749个气象站点温度数据作为数据源，分别建立两种类型的索引，对每种地理查询都做了接口化，你可以<strong>自行运行探索</strong>，或者为其增加一个WebGIS的界面，直接进行操作，体验一下mongoDB地理查询的快捷。</p>\n","site":{"data":{}},"excerpt":"<p>现在地理空间查询是越来越常见的一种需求，实现的方式也有很多种，相较于PostGIS，mongoDB既可以直接存储GeoJSON对象，又支持地理空间索引，可以满足高效的常见地理空间服务。</p>","more":"<p><a href=\"https://github.com/zzcyrus/mongoDB-geospatial-demos\" target=\"_blank\" rel=\"noopener\">一个可供参考的案例仓库</a></p>\n<h2 id=\"索引方式介绍\"><a href=\"#索引方式介绍\" class=\"headerlink\" title=\"索引方式介绍\"></a>索引方式介绍</h2><h3 id=\"2d-索引\"><a href=\"#2d-索引\" class=\"headerlink\" title=\"2d 索引\"></a>2d 索引</h3><p><a href=\"https://docs.mongodb.com/manual/core/2d/\" target=\"_blank\" rel=\"noopener\">官方介绍</a></p>\n<p>2d index 通常用在2维平面上的点数据，如果你的MongoDB 版本小于2.2或者你不使用一些GeoJSON类型的数据，官方推荐你使用2d index。</p>\n<h3 id=\"2dsphere-索引\"><a href=\"#2dsphere-索引\" class=\"headerlink\" title=\"2dsphere 索引\"></a>2dsphere 索引</h3><p><a href=\"https://docs.mongodb.com/manual/core/2dsphere/\" target=\"_blank\" rel=\"noopener\">官方介绍</a></p>\n<p>2dsphere index 支持所有的mongoDB空间查询，支持类地球的球面上几何要素的查询，支持数据存储为GeoJSON或者是传统坐标。</p>\n<p><em>所以如果你正在做一个现代化的GIS应用，建议直接采取2dsphere索引，这将会非常方便，GeoJSON格式的直接导入，配合WebGIS的直接查询或插入</em></p>\n<h2 id=\"查询方法介绍\"><a href=\"#查询方法介绍\" class=\"headerlink\" title=\"查询方法介绍\"></a>查询方法介绍</h2><p><a href=\"https://docs.mongodb.com/manual/reference/operator/query-geospatial/\" target=\"_blank\" rel=\"noopener\">官方介绍</a></p>\n<p>下面这个表格包含了一些个人的总结和官方的说明，具体查询的作用其实通过查询方法的名字就能猜测出来，所以不详细介绍了</p>\n<table>\n<thead>\n<tr>\n<th>查询方式</th>\n<th style=\"text-align:center\">2d索引</th>\n<th style=\"text-align:center\">sphere索引</th>\n<th style=\"text-align:center\">几何类型（2d/sphere）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$near</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">平面/球面</td>\n</tr>\n<tr>\n<td>$nearSphere</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">球面</td>\n</tr>\n<tr>\n<td>$geoWithin:{$center:…}</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">⚠️</td>\n<td style=\"text-align:center\">平面</td>\n</tr>\n<tr>\n<td>$geoWithin:{$centerSphere:…}</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">球面</td>\n</tr>\n<tr>\n<td>$geoWithin:{$box:…}</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">⚠️</td>\n<td style=\"text-align:center\">平面</td>\n</tr>\n<tr>\n<td>$geoWithin:{$polygon:…}</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">⚠️</td>\n<td style=\"text-align:center\">平面</td>\n</tr>\n<tr>\n<td>$geoWithin:{$geometry:…}</td>\n<td style=\"text-align:center\">❎</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">球面</td>\n</tr>\n<tr>\n<td>$geoIntersects</td>\n<td style=\"text-align:center\">❎</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">球面</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>说明： ✅ 支持 ❎ 不支持 ⚠️ 官方文档说不支持，但测试发现可以使用</p>\n</blockquote>\n<h2 id=\"使用注意事项\"><a href=\"#使用注意事项\" class=\"headerlink\" title=\"使用注意事项\"></a>使用注意事项</h2><ol>\n<li>在2dsphere索引中使用$geometry去查询，如果自己构造$geometry，要注意geometry的coordinates必须是一个<code>闭合</code>的数组，首尾两项要一致。</li>\n<li>与此同时，在使用$polygon去查询时，<code>不必</code>是一个闭合的坐标数组列，mongoDB会自动帮我们关闭这个图形</li>\n<li>在使用$near或者$geoWithin之类的查询中会涉及到距离、半径定义，这里如果你使用经纬度作为坐标，使用m（米）作为距离、半径单位，那么要进行<code>转换</code>，具体的转换规则可以参考下面两段代码示例：</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 1度大致对应111千米，所以需要/111000,具体可以细化</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;*&#125; meter 米</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> m2degree = <span class=\"function\">(<span class=\"params\">meter</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> meter / <span class=\"number\">111000</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> query = &#123;</span><br><span class=\"line\">  location: &#123;</span><br><span class=\"line\">    $geoWithin: &#123;</span><br><span class=\"line\">      $center: [[lon, lat], m2degree(radius)]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 米转换成弧度，需要除以地球半径，大约6378100米</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;*&#125; meter</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> m2rad = <span class=\"function\">(<span class=\"params\">meter</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> meter / <span class=\"number\">6378100</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> query = &#123;</span><br><span class=\"line\">  location: &#123;</span><br><span class=\"line\">    $nearSphere: [lon, lat],</span><br><span class=\"line\">    $maxDistance: m2rad(maxDistance)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h2><p>这里提供<a href=\"https://github.com/zzcyrus/mongoDB-geospatial-demos\" target=\"_blank\" rel=\"noopener\">一个可供参考的简单的案例仓库</a><br>案例中使用了中国天气网上的749个气象站点温度数据作为数据源，分别建立两种类型的索引，对每种地理查询都做了接口化，你可以<strong>自行运行探索</strong>，或者为其增加一个WebGIS的界面，直接进行操作，体验一下mongoDB地理查询的快捷。</p>"},{"title":"【译】Vue中父子组件的生命周期函数","date":"2018-06-29T07:42:41.000Z","_content":"\n&nbsp;&nbsp;最近项目中遇到了\u001d地图模块挂载到DOM节点并进行初始化的问题，背后其实就是Vue中父子组件初始化的顺序问题，发现这篇文章的例子通俗易懂，遂翻译一下，如果错误还请指正。\n\n<!-- more -->\n\n[原文链接](https://medium.com/@brockreece/vue-parent-and-child-lifecycle-hooks-5d6236bd561f)\n\n\n如果你在项目中使用\bVue，那么我肯定你很熟悉组件生命周期内的钩子函数，但是你未必清楚父子组件内生命周期钩子触发的顺序和对属性（props）的影响\n\n<p style=\"text-align:center;\"><img src=\"lifecircle.png\" width=\"50%\" height=\"50%\"></p>\n\n## 父/子组件内的生命周期钩子\n\n下面的例子\b在父子组件的**Mounted**和**Created**两个钩子触发时会给出相应的提示。如你所见，**Created**是正常的先父后子的顺序触发，但**Mounted**钩子则正好相反\n\n<iframe src=\"https://codesandbox.io/embed/j38wnqjy65\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n一开始这可能很难很难理解，但如果我们通过逻辑的角度去遵循组件初始化工作流程，就能理解这种顺序。我们只要记住，父组件在其挂载template到DOM之前必须等待\b所有的子组件都完成挂载（mounted）操作。\n\n\n<p style=\"text-align:center;\"><img src=\"parent-child-hooks.png\" width=\"50%\" height=\"50%\"></p>\n\n若果你的组件通过属性（props）来通讯，以上钩子的执行顺序会很重要。\n\n## 属性（props）的响应式（reactivity）\n\n一个组件在**Created**钩子触发之前就可以是响应式的，这意味在其父组件的**Mounted**\b钩子触发之前它就能够开始追踪属性（props）的变化。如果你在父组件的**Mounted**钩子中去设置一些属性的值，你一定要牢记这一点。\n\n下面的例子展示了如果在父组件的**Created**和**Mounted**两个钩子中都去设置子组件的属性值会发生什么。如你所见，在子组件的**Mounted**钩子中我们监测到了两次对属性值的改变操作（个人补充：父组件\b**Mounted**\b之前的data里面对属性赋值触发了一次，父组件**Mounted**时候的改变属性值\b又让子组件触发了一次）\n\b\n<iframe src=\"https://codesandbox.io/embed/z2yonj9kq4\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n假设你的子组件在属性值改变的时候会进行一次Ajax请求，这样就会触发两次请求，甚至造成请求的未响应。\n\n## 总结\n\n如果你想深入的了解Vue的生命周期钩子，我强烈建议你读一下[这篇文章](https://alligator.io/vuejs/component-lifecycle/)。\n\n\n但通常来说，我建议如果你只在组件的**Mounted**钩子进行需要和DOM交互的操作，而其他的操作都放在**Created**钩子中\n\n\n### 个人总结\n\n从生命周期的角度来看： 父 Created - 子 Created - 子 Mounted - 父 Mounted\n对应过程Props的改变： 子 prop 改变 --------- 子 prop 改变 --------- 子 prop 改变  ","source":"_posts/2018/Vue-Parent-and-Child-lifecycle-hooks.md","raw":"---\ntitle: 【译】Vue中父子组件的生命周期函数\ndate: 2018-6-29 15:42:41\ntags: [FE,Vue]\ncategories: 前端\n---\n\n&nbsp;&nbsp;最近项目中遇到了\u001d地图模块挂载到DOM节点并进行初始化的问题，背后其实就是Vue中父子组件初始化的顺序问题，发现这篇文章的例子通俗易懂，遂翻译一下，如果错误还请指正。\n\n<!-- more -->\n\n[原文链接](https://medium.com/@brockreece/vue-parent-and-child-lifecycle-hooks-5d6236bd561f)\n\n\n如果你在项目中使用\bVue，那么我肯定你很熟悉组件生命周期内的钩子函数，但是你未必清楚父子组件内生命周期钩子触发的顺序和对属性（props）的影响\n\n<p style=\"text-align:center;\"><img src=\"lifecircle.png\" width=\"50%\" height=\"50%\"></p>\n\n## 父/子组件内的生命周期钩子\n\n下面的例子\b在父子组件的**Mounted**和**Created**两个钩子触发时会给出相应的提示。如你所见，**Created**是正常的先父后子的顺序触发，但**Mounted**钩子则正好相反\n\n<iframe src=\"https://codesandbox.io/embed/j38wnqjy65\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n一开始这可能很难很难理解，但如果我们通过逻辑的角度去遵循组件初始化工作流程，就能理解这种顺序。我们只要记住，父组件在其挂载template到DOM之前必须等待\b所有的子组件都完成挂载（mounted）操作。\n\n\n<p style=\"text-align:center;\"><img src=\"parent-child-hooks.png\" width=\"50%\" height=\"50%\"></p>\n\n若果你的组件通过属性（props）来通讯，以上钩子的执行顺序会很重要。\n\n## 属性（props）的响应式（reactivity）\n\n一个组件在**Created**钩子触发之前就可以是响应式的，这意味在其父组件的**Mounted**\b钩子触发之前它就能够开始追踪属性（props）的变化。如果你在父组件的**Mounted**钩子中去设置一些属性的值，你一定要牢记这一点。\n\n下面的例子展示了如果在父组件的**Created**和**Mounted**两个钩子中都去设置子组件的属性值会发生什么。如你所见，在子组件的**Mounted**钩子中我们监测到了两次对属性值的改变操作（个人补充：父组件\b**Mounted**\b之前的data里面对属性赋值触发了一次，父组件**Mounted**时候的改变属性值\b又让子组件触发了一次）\n\b\n<iframe src=\"https://codesandbox.io/embed/z2yonj9kq4\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n假设你的子组件在属性值改变的时候会进行一次Ajax请求，这样就会触发两次请求，甚至造成请求的未响应。\n\n## 总结\n\n如果你想深入的了解Vue的生命周期钩子，我强烈建议你读一下[这篇文章](https://alligator.io/vuejs/component-lifecycle/)。\n\n\n但通常来说，我建议如果你只在组件的**Mounted**钩子进行需要和DOM交互的操作，而其他的操作都放在**Created**钩子中\n\n\n### 个人总结\n\n从生命周期的角度来看： 父 Created - 子 Created - 子 Mounted - 父 Mounted\n对应过程Props的改变： 子 prop 改变 --------- 子 prop 改变 --------- 子 prop 改变  ","slug":"Vue-Parent-and-Child-lifecycle-hooks","published":1,"updated":"2019-06-28T05:55:26.943Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy4fqa9m000c0n3iaiq1m5wy","content":"<p>&nbsp;&nbsp;最近项目中遇到了\u001d地图模块挂载到DOM节点并进行初始化的问题，背后其实就是Vue中父子组件初始化的顺序问题，发现这篇文章的例子通俗易懂，遂翻译一下，如果错误还请指正。</p>\n<a id=\"more\"></a>\n<p><a href=\"https://medium.com/@brockreece/vue-parent-and-child-lifecycle-hooks-5d6236bd561f\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<p>如果你在项目中使用\bVue，那么我肯定你很熟悉组件生命周期内的钩子函数，但是你未必清楚父子组件内生命周期钩子触发的顺序和对属性（props）的影响</p>\n<p style=\"text-align:center;\"><img src=\"lifecircle.png\" width=\"50%\" height=\"50%\"></p>\n\n<h2 id=\"父-子组件内的生命周期钩子\"><a href=\"#父-子组件内的生命周期钩子\" class=\"headerlink\" title=\"父/子组件内的生命周期钩子\"></a>父/子组件内的生命周期钩子</h2><p>下面的例子\b在父子组件的<strong>Mounted</strong>和<strong>Created</strong>两个钩子触发时会给出相应的提示。如你所见，<strong>Created</strong>是正常的先父后子的顺序触发，但<strong>Mounted</strong>钩子则正好相反</p>\n<iframe src=\"https://codesandbox.io/embed/j38wnqjy65\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n<p>一开始这可能很难很难理解，但如果我们通过逻辑的角度去遵循组件初始化工作流程，就能理解这种顺序。我们只要记住，父组件在其挂载template到DOM之前必须等待\b所有的子组件都完成挂载（mounted）操作。</p>\n<p style=\"text-align:center;\"><img src=\"parent-child-hooks.png\" width=\"50%\" height=\"50%\"></p>\n\n<p>若果你的组件通过属性（props）来通讯，以上钩子的执行顺序会很重要。</p>\n<h2 id=\"属性（props）的响应式（reactivity）\"><a href=\"#属性（props）的响应式（reactivity）\" class=\"headerlink\" title=\"属性（props）的响应式（reactivity）\"></a>属性（props）的响应式（reactivity）</h2><p>一个组件在<strong>Created</strong>钩子触发之前就可以是响应式的，这意味在其父组件的<strong>Mounted</strong>\b钩子触发之前它就能够开始追踪属性（props）的变化。如果你在父组件的<strong>Mounted</strong>钩子中去设置一些属性的值，你一定要牢记这一点。</p>\n<p>下面的例子展示了如果在父组件的<strong>Created</strong>和<strong>Mounted</strong>两个钩子中都去设置子组件的属性值会发生什么。如你所见，在子组件的<strong>Mounted</strong>钩子中我们监测到了两次对属性值的改变操作（个人补充：父组件\b<strong>Mounted</strong>\b之前的data里面对属性赋值触发了一次，父组件<strong>Mounted</strong>时候的改变属性值\b又让子组件触发了一次）<br>\b</p>\n<iframe src=\"https://codesandbox.io/embed/z2yonj9kq4\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n<p>假设你的子组件在属性值改变的时候会进行一次Ajax请求，这样就会触发两次请求，甚至造成请求的未响应。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>如果你想深入的了解Vue的生命周期钩子，我强烈建议你读一下<a href=\"https://alligator.io/vuejs/component-lifecycle/\" target=\"_blank\" rel=\"noopener\">这篇文章</a>。</p>\n<p>但通常来说，我建议如果你只在组件的<strong>Mounted</strong>钩子进行需要和DOM交互的操作，而其他的操作都放在<strong>Created</strong>钩子中</p>\n<h3 id=\"个人总结\"><a href=\"#个人总结\" class=\"headerlink\" title=\"个人总结\"></a>个人总结</h3><p>从生命周期的角度来看： 父 Created - 子 Created - 子 Mounted - 父 Mounted<br>对应过程Props的改变： 子 prop 改变 ——— 子 prop 改变 ——— 子 prop 改变  </p>\n","site":{"data":{}},"excerpt":"<p>&nbsp;&nbsp;最近项目中遇到了\u001d地图模块挂载到DOM节点并进行初始化的问题，背后其实就是Vue中父子组件初始化的顺序问题，发现这篇文章的例子通俗易懂，遂翻译一下，如果错误还请指正。</p>","more":"<p><a href=\"https://medium.com/@brockreece/vue-parent-and-child-lifecycle-hooks-5d6236bd561f\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<p>如果你在项目中使用\bVue，那么我肯定你很熟悉组件生命周期内的钩子函数，但是你未必清楚父子组件内生命周期钩子触发的顺序和对属性（props）的影响</p>\n<p style=\"text-align:center;\"><img src=\"lifecircle.png\" width=\"50%\" height=\"50%\"></p>\n\n<h2 id=\"父-子组件内的生命周期钩子\"><a href=\"#父-子组件内的生命周期钩子\" class=\"headerlink\" title=\"父/子组件内的生命周期钩子\"></a>父/子组件内的生命周期钩子</h2><p>下面的例子\b在父子组件的<strong>Mounted</strong>和<strong>Created</strong>两个钩子触发时会给出相应的提示。如你所见，<strong>Created</strong>是正常的先父后子的顺序触发，但<strong>Mounted</strong>钩子则正好相反</p>\n<iframe src=\"https://codesandbox.io/embed/j38wnqjy65\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n<p>一开始这可能很难很难理解，但如果我们通过逻辑的角度去遵循组件初始化工作流程，就能理解这种顺序。我们只要记住，父组件在其挂载template到DOM之前必须等待\b所有的子组件都完成挂载（mounted）操作。</p>\n<p style=\"text-align:center;\"><img src=\"parent-child-hooks.png\" width=\"50%\" height=\"50%\"></p>\n\n<p>若果你的组件通过属性（props）来通讯，以上钩子的执行顺序会很重要。</p>\n<h2 id=\"属性（props）的响应式（reactivity）\"><a href=\"#属性（props）的响应式（reactivity）\" class=\"headerlink\" title=\"属性（props）的响应式（reactivity）\"></a>属性（props）的响应式（reactivity）</h2><p>一个组件在<strong>Created</strong>钩子触发之前就可以是响应式的，这意味在其父组件的<strong>Mounted</strong>\b钩子触发之前它就能够开始追踪属性（props）的变化。如果你在父组件的<strong>Mounted</strong>钩子中去设置一些属性的值，你一定要牢记这一点。</p>\n<p>下面的例子展示了如果在父组件的<strong>Created</strong>和<strong>Mounted</strong>两个钩子中都去设置子组件的属性值会发生什么。如你所见，在子组件的<strong>Mounted</strong>钩子中我们监测到了两次对属性值的改变操作（个人补充：父组件\b<strong>Mounted</strong>\b之前的data里面对属性赋值触发了一次，父组件<strong>Mounted</strong>时候的改变属性值\b又让子组件触发了一次）<br>\b</p>\n<iframe src=\"https://codesandbox.io/embed/z2yonj9kq4\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n<p>假设你的子组件在属性值改变的时候会进行一次Ajax请求，这样就会触发两次请求，甚至造成请求的未响应。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>如果你想深入的了解Vue的生命周期钩子，我强烈建议你读一下<a href=\"https://alligator.io/vuejs/component-lifecycle/\" target=\"_blank\" rel=\"noopener\">这篇文章</a>。</p>\n<p>但通常来说，我建议如果你只在组件的<strong>Mounted</strong>钩子进行需要和DOM交互的操作，而其他的操作都放在<strong>Created</strong>钩子中</p>\n<h3 id=\"个人总结\"><a href=\"#个人总结\" class=\"headerlink\" title=\"个人总结\"></a>个人总结</h3><p>从生命周期的角度来看： 父 Created - 子 Created - 子 Mounted - 父 Mounted<br>对应过程Props的改变： 子 prop 改变 ——— 子 prop 改变 ——— 子 prop 改变  </p>"},{"title":"使用osm数据做一个自己的PostGIS数据库","date":"2019-03-12T11:54:08.000Z","_content":"\nPostGIS 是目前开源方案里面使用广泛的一种地理信息数据库，可玩性很强，实用性也很强，为了实现更多的地理信息操作，我们先来搭建一个简单的 PostGIS 数据库。\n\n<!-- more -->\n\n# 1. 安装步骤\n\n1. 准备一个 CentOS 7.x x64 环境\n2. 安装数据库 PostgreSQL 9.6\n3. 安装对应版本的 PostGIS 2.2.2\n4. 导入 openstreetmap 的中国区域数据\n\n# 2. PostgreSQL 9.6\n\n```bash\n# 安装数据库\nyum install https://download.postgresql.org/pub/repos/yum/9.6/redhat/rhel-7-x86_64/pgdg-centos96-9.6-3.noarch.rpm\n\nyum install postgresql96\n\nyum install postgresql96-server\n\n# 初始化数据库及服务\n/usr/pgsql-9.6/bin/postgresql96-setup initdb\nsystemctl enable postgresql-9.6\nsystemctl start postgresql-9.6\n\n# 配置环境变量\nexport PATH=/usr/pgsql-9.6/bin:$PATH\nexport LD_LIBRARY_PATH=/usr/pgsql-9.6/lib:$LD_LIBRARY_PATH\nexport PGDATA=/home/postgres/postgresql_data\n\n\n# 以下可选\n\n# 为数据库设置密码\nsu - postgres\npsql\npostgres=# ALTER USER postgres WITH PASSWORD 'postgres';\npostgres=# \\q\n\n# 开放防火墙端口\nfirewall-cmd --permanent --add-port=5432/tcp\nfirewall-cmd --reload\n\n# 修改配置文件允许外部使用密码访问\nvim /var/lib/pgsql/9.6/data/postgresql.conf\nlisten_addresses = 'localhost'  为  listen_addresses='*'\n\nvim /var/lib/pgsql/9.6/data/pg_hba.conf\nhost    all            all      0.0.0.0/0      md5\n\n```\n\n# 3. PostGIS\n\n```bash\n# 安装PostGIS\nsudo yum -y install epel-release\nsudo yum install postgis24_96\n\n# 初始化数据库osm\ncreatedb osm\n\npsql -h 127.0.0.1 -d osm -U postgres -f /usr/pgsql-9.6/share/contrib/postgis-2.4/postgis.sql\npsql -h 127.0.0.1 -d osm -U postgres -f /usr/pgsql-9.6/share/contrib/postgis-2.4/spatial_ref_sys.sql\npsql -d osm -c 'CREATE EXTENSION postgis; CREATE EXTENSION hstore;'\n\n# 可以基于osm创建china数据库（把osm作为一个可重复备份的库）\ncreatedb -T osm china\n\n```\n\n# 4. osm 数据导入\n\n```bash\n# 安装导入工具osm2pgsql\nyum install osm2pgsql\n\n# 下载中国区域的公开数据\nwget http://download.gisgraphy.com/openstreetmap/pbf/CN.tar.bz2\n\n# 解压数据\ntar jxvf CN.tar.bz2\n\n# 开始导入数据到china数据库\nosm2pgsql -c -d china --slim --hstore -C 2000 -p china -r pbf /home/parallels/Downloads/CN\n```\n\n#5. 测试\n\n至此，我们已经基于 osm 的数据有了一个地理信息库，我们可以通过以下 sql 做一些简单的测试\n\n```sql\nSELECT name FROM china_polygon WHERE name ~ '南京';\n```\n\n结果：\n![](polygon.png)\n\n```sql\nSELECT p1.name,p2.name,ST_Distance(p1.way,p2.way) FROM\n(SELECT * FROM china_point WHERE place='city' AND name = '南京市') p1 ,\n(SELECT * FROM china_point WHERE place='city' AND name = '北京市') p2\n```\n\n结果：\n![](distance.png)\n\n```sql\nSELECT name, ST_AsText(ST_Transform(way,4326)) FROM china_point WHERE place='city';\n```\n\n结果：\n![](point.png)\n\n当然数据库的功能不局限于此，基于此数据库我们可以做些更有趣的事情，今后我们会慢慢探讨。\n\n# 参考文档\n\n[digoal 的博客](https://github.com/digoal/blog/blob/master/201609/20160906_01.md)\n","source":"_posts/2019/osm-PostGIS-setup.md","raw":"---\ntitle: 使用osm数据做一个自己的PostGIS数据库\ndate: 2019-03-12 19:54:08\ntags: [GIS]\ncategories: PostGIS\n---\n\nPostGIS 是目前开源方案里面使用广泛的一种地理信息数据库，可玩性很强，实用性也很强，为了实现更多的地理信息操作，我们先来搭建一个简单的 PostGIS 数据库。\n\n<!-- more -->\n\n# 1. 安装步骤\n\n1. 准备一个 CentOS 7.x x64 环境\n2. 安装数据库 PostgreSQL 9.6\n3. 安装对应版本的 PostGIS 2.2.2\n4. 导入 openstreetmap 的中国区域数据\n\n# 2. PostgreSQL 9.6\n\n```bash\n# 安装数据库\nyum install https://download.postgresql.org/pub/repos/yum/9.6/redhat/rhel-7-x86_64/pgdg-centos96-9.6-3.noarch.rpm\n\nyum install postgresql96\n\nyum install postgresql96-server\n\n# 初始化数据库及服务\n/usr/pgsql-9.6/bin/postgresql96-setup initdb\nsystemctl enable postgresql-9.6\nsystemctl start postgresql-9.6\n\n# 配置环境变量\nexport PATH=/usr/pgsql-9.6/bin:$PATH\nexport LD_LIBRARY_PATH=/usr/pgsql-9.6/lib:$LD_LIBRARY_PATH\nexport PGDATA=/home/postgres/postgresql_data\n\n\n# 以下可选\n\n# 为数据库设置密码\nsu - postgres\npsql\npostgres=# ALTER USER postgres WITH PASSWORD 'postgres';\npostgres=# \\q\n\n# 开放防火墙端口\nfirewall-cmd --permanent --add-port=5432/tcp\nfirewall-cmd --reload\n\n# 修改配置文件允许外部使用密码访问\nvim /var/lib/pgsql/9.6/data/postgresql.conf\nlisten_addresses = 'localhost'  为  listen_addresses='*'\n\nvim /var/lib/pgsql/9.6/data/pg_hba.conf\nhost    all            all      0.0.0.0/0      md5\n\n```\n\n# 3. PostGIS\n\n```bash\n# 安装PostGIS\nsudo yum -y install epel-release\nsudo yum install postgis24_96\n\n# 初始化数据库osm\ncreatedb osm\n\npsql -h 127.0.0.1 -d osm -U postgres -f /usr/pgsql-9.6/share/contrib/postgis-2.4/postgis.sql\npsql -h 127.0.0.1 -d osm -U postgres -f /usr/pgsql-9.6/share/contrib/postgis-2.4/spatial_ref_sys.sql\npsql -d osm -c 'CREATE EXTENSION postgis; CREATE EXTENSION hstore;'\n\n# 可以基于osm创建china数据库（把osm作为一个可重复备份的库）\ncreatedb -T osm china\n\n```\n\n# 4. osm 数据导入\n\n```bash\n# 安装导入工具osm2pgsql\nyum install osm2pgsql\n\n# 下载中国区域的公开数据\nwget http://download.gisgraphy.com/openstreetmap/pbf/CN.tar.bz2\n\n# 解压数据\ntar jxvf CN.tar.bz2\n\n# 开始导入数据到china数据库\nosm2pgsql -c -d china --slim --hstore -C 2000 -p china -r pbf /home/parallels/Downloads/CN\n```\n\n#5. 测试\n\n至此，我们已经基于 osm 的数据有了一个地理信息库，我们可以通过以下 sql 做一些简单的测试\n\n```sql\nSELECT name FROM china_polygon WHERE name ~ '南京';\n```\n\n结果：\n![](polygon.png)\n\n```sql\nSELECT p1.name,p2.name,ST_Distance(p1.way,p2.way) FROM\n(SELECT * FROM china_point WHERE place='city' AND name = '南京市') p1 ,\n(SELECT * FROM china_point WHERE place='city' AND name = '北京市') p2\n```\n\n结果：\n![](distance.png)\n\n```sql\nSELECT name, ST_AsText(ST_Transform(way,4326)) FROM china_point WHERE place='city';\n```\n\n结果：\n![](point.png)\n\n当然数据库的功能不局限于此，基于此数据库我们可以做些更有趣的事情，今后我们会慢慢探讨。\n\n# 参考文档\n\n[digoal 的博客](https://github.com/digoal/blog/blob/master/201609/20160906_01.md)\n","slug":"osm-PostGIS-setup","published":1,"updated":"2019-06-28T05:56:28.441Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy4fqa9p000h0n3iksaczgg0","content":"<p>PostGIS 是目前开源方案里面使用广泛的一种地理信息数据库，可玩性很强，实用性也很强，为了实现更多的地理信息操作，我们先来搭建一个简单的 PostGIS 数据库。</p>\n<a id=\"more\"></a>\n<h1 id=\"1-安装步骤\"><a href=\"#1-安装步骤\" class=\"headerlink\" title=\"1. 安装步骤\"></a>1. 安装步骤</h1><ol>\n<li>准备一个 CentOS 7.x x64 环境</li>\n<li>安装数据库 PostgreSQL 9.6</li>\n<li>安装对应版本的 PostGIS 2.2.2</li>\n<li>导入 openstreetmap 的中国区域数据</li>\n</ol>\n<h1 id=\"2-PostgreSQL-9-6\"><a href=\"#2-PostgreSQL-9-6\" class=\"headerlink\" title=\"2. PostgreSQL 9.6\"></a>2. PostgreSQL 9.6</h1><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装数据库</span></span><br><span class=\"line\">yum install https://download.postgresql.org/pub/repos/yum/9.6/redhat/rhel-7-x86_64/pgdg-centos96-9.6-3.noarch.rpm</span><br><span class=\"line\"></span><br><span class=\"line\">yum install postgresql96</span><br><span class=\"line\"></span><br><span class=\"line\">yum install postgresql96-server</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化数据库及服务</span></span><br><span class=\"line\">/usr/pgsql-9.6/bin/postgresql96-setup initdb</span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> postgresql-9.6</span><br><span class=\"line\">systemctl start postgresql-9.6</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置环境变量</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=/usr/pgsql-9.6/bin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> LD_LIBRARY_PATH=/usr/pgsql-9.6/lib:<span class=\"variable\">$LD_LIBRARY_PATH</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PGDATA=/home/postgres/postgresql_data</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 以下可选</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 为数据库设置密码</span></span><br><span class=\"line\">su - postgres</span><br><span class=\"line\">psql</span><br><span class=\"line\">postgres=<span class=\"comment\"># ALTER USER postgres WITH PASSWORD 'postgres';</span></span><br><span class=\"line\">postgres=<span class=\"comment\"># \\q</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开放防火墙端口</span></span><br><span class=\"line\">firewall-cmd --permanent --add-port=5432/tcp</span><br><span class=\"line\">firewall-cmd --reload</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改配置文件允许外部使用密码访问</span></span><br><span class=\"line\">vim /var/lib/pgsql/9.6/data/postgresql.conf</span><br><span class=\"line\">listen_addresses = <span class=\"string\">'localhost'</span>  为  listen_addresses=<span class=\"string\">'*'</span></span><br><span class=\"line\"></span><br><span class=\"line\">vim /var/lib/pgsql/9.6/data/pg_hba.conf</span><br><span class=\"line\">host    all            all      0.0.0.0/0      md5</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-PostGIS\"><a href=\"#3-PostGIS\" class=\"headerlink\" title=\"3. PostGIS\"></a>3. PostGIS</h1><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装PostGIS</span></span><br><span class=\"line\">sudo yum -y install epel-release</span><br><span class=\"line\">sudo yum install postgis24_96</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化数据库osm</span></span><br><span class=\"line\">createdb osm</span><br><span class=\"line\"></span><br><span class=\"line\">psql -h 127.0.0.1 -d osm -U postgres -f /usr/pgsql-9.6/share/contrib/postgis-2.4/postgis.sql</span><br><span class=\"line\">psql -h 127.0.0.1 -d osm -U postgres -f /usr/pgsql-9.6/share/contrib/postgis-2.4/spatial_ref_sys.sql</span><br><span class=\"line\">psql -d osm -c <span class=\"string\">'CREATE EXTENSION postgis; CREATE EXTENSION hstore;'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 可以基于osm创建china数据库（把osm作为一个可重复备份的库）</span></span><br><span class=\"line\">createdb -T osm china</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-osm-数据导入\"><a href=\"#4-osm-数据导入\" class=\"headerlink\" title=\"4. osm 数据导入\"></a>4. osm 数据导入</h1><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装导入工具osm2pgsql</span></span><br><span class=\"line\">yum install osm2pgsql</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载中国区域的公开数据</span></span><br><span class=\"line\">wget http://download.gisgraphy.com/openstreetmap/pbf/CN.tar.bz2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 解压数据</span></span><br><span class=\"line\">tar jxvf CN.tar.bz2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开始导入数据到china数据库</span></span><br><span class=\"line\">osm2pgsql -c -d china --slim --hstore -C 2000 -p china -r pbf /home/parallels/Downloads/CN</span><br></pre></td></tr></table></figure>\n<p>#5. 测试</p>\n<p>至此，我们已经基于 osm 的数据有了一个地理信息库，我们可以通过以下 sql 做一些简单的测试</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">name</span> <span class=\"keyword\">FROM</span> china_polygon <span class=\"keyword\">WHERE</span> <span class=\"keyword\">name</span> ~ <span class=\"string\">'南京'</span>;</span><br></pre></td></tr></table></figure>\n<p>结果：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"polygon.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> p1.name,p2.name,ST_Distance(p1.way,p2.way) <span class=\"keyword\">FROM</span></span><br><span class=\"line\">(<span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> china_point <span class=\"keyword\">WHERE</span> place=<span class=\"string\">'city'</span> <span class=\"keyword\">AND</span> <span class=\"keyword\">name</span> = <span class=\"string\">'南京市'</span>) p1 ,</span><br><span class=\"line\">(<span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> china_point <span class=\"keyword\">WHERE</span> place=<span class=\"string\">'city'</span> <span class=\"keyword\">AND</span> <span class=\"keyword\">name</span> = <span class=\"string\">'北京市'</span>) p2</span><br></pre></td></tr></table></figure>\n<p>结果：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"distance.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">name</span>, ST_AsText(ST_Transform(way,<span class=\"number\">4326</span>)) <span class=\"keyword\">FROM</span> china_point <span class=\"keyword\">WHERE</span> place=<span class=\"string\">'city'</span>;</span><br></pre></td></tr></table></figure>\n<p>结果：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"point.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure></p>\n<p>当然数据库的功能不局限于此，基于此数据库我们可以做些更有趣的事情，今后我们会慢慢探讨。</p>\n<h1 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h1><p><a href=\"https://github.com/digoal/blog/blob/master/201609/20160906_01.md\" target=\"_blank\" rel=\"noopener\">digoal 的博客</a></p>\n","site":{"data":{}},"excerpt":"<p>PostGIS 是目前开源方案里面使用广泛的一种地理信息数据库，可玩性很强，实用性也很强，为了实现更多的地理信息操作，我们先来搭建一个简单的 PostGIS 数据库。</p>","more":"<h1 id=\"1-安装步骤\"><a href=\"#1-安装步骤\" class=\"headerlink\" title=\"1. 安装步骤\"></a>1. 安装步骤</h1><ol>\n<li>准备一个 CentOS 7.x x64 环境</li>\n<li>安装数据库 PostgreSQL 9.6</li>\n<li>安装对应版本的 PostGIS 2.2.2</li>\n<li>导入 openstreetmap 的中国区域数据</li>\n</ol>\n<h1 id=\"2-PostgreSQL-9-6\"><a href=\"#2-PostgreSQL-9-6\" class=\"headerlink\" title=\"2. PostgreSQL 9.6\"></a>2. PostgreSQL 9.6</h1><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装数据库</span></span><br><span class=\"line\">yum install https://download.postgresql.org/pub/repos/yum/9.6/redhat/rhel-7-x86_64/pgdg-centos96-9.6-3.noarch.rpm</span><br><span class=\"line\"></span><br><span class=\"line\">yum install postgresql96</span><br><span class=\"line\"></span><br><span class=\"line\">yum install postgresql96-server</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化数据库及服务</span></span><br><span class=\"line\">/usr/pgsql-9.6/bin/postgresql96-setup initdb</span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> postgresql-9.6</span><br><span class=\"line\">systemctl start postgresql-9.6</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置环境变量</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=/usr/pgsql-9.6/bin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> LD_LIBRARY_PATH=/usr/pgsql-9.6/lib:<span class=\"variable\">$LD_LIBRARY_PATH</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PGDATA=/home/postgres/postgresql_data</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 以下可选</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 为数据库设置密码</span></span><br><span class=\"line\">su - postgres</span><br><span class=\"line\">psql</span><br><span class=\"line\">postgres=<span class=\"comment\"># ALTER USER postgres WITH PASSWORD 'postgres';</span></span><br><span class=\"line\">postgres=<span class=\"comment\"># \\q</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开放防火墙端口</span></span><br><span class=\"line\">firewall-cmd --permanent --add-port=5432/tcp</span><br><span class=\"line\">firewall-cmd --reload</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改配置文件允许外部使用密码访问</span></span><br><span class=\"line\">vim /var/lib/pgsql/9.6/data/postgresql.conf</span><br><span class=\"line\">listen_addresses = <span class=\"string\">'localhost'</span>  为  listen_addresses=<span class=\"string\">'*'</span></span><br><span class=\"line\"></span><br><span class=\"line\">vim /var/lib/pgsql/9.6/data/pg_hba.conf</span><br><span class=\"line\">host    all            all      0.0.0.0/0      md5</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-PostGIS\"><a href=\"#3-PostGIS\" class=\"headerlink\" title=\"3. PostGIS\"></a>3. PostGIS</h1><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装PostGIS</span></span><br><span class=\"line\">sudo yum -y install epel-release</span><br><span class=\"line\">sudo yum install postgis24_96</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化数据库osm</span></span><br><span class=\"line\">createdb osm</span><br><span class=\"line\"></span><br><span class=\"line\">psql -h 127.0.0.1 -d osm -U postgres -f /usr/pgsql-9.6/share/contrib/postgis-2.4/postgis.sql</span><br><span class=\"line\">psql -h 127.0.0.1 -d osm -U postgres -f /usr/pgsql-9.6/share/contrib/postgis-2.4/spatial_ref_sys.sql</span><br><span class=\"line\">psql -d osm -c <span class=\"string\">'CREATE EXTENSION postgis; CREATE EXTENSION hstore;'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 可以基于osm创建china数据库（把osm作为一个可重复备份的库）</span></span><br><span class=\"line\">createdb -T osm china</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-osm-数据导入\"><a href=\"#4-osm-数据导入\" class=\"headerlink\" title=\"4. osm 数据导入\"></a>4. osm 数据导入</h1><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装导入工具osm2pgsql</span></span><br><span class=\"line\">yum install osm2pgsql</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下载中国区域的公开数据</span></span><br><span class=\"line\">wget http://download.gisgraphy.com/openstreetmap/pbf/CN.tar.bz2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 解压数据</span></span><br><span class=\"line\">tar jxvf CN.tar.bz2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 开始导入数据到china数据库</span></span><br><span class=\"line\">osm2pgsql -c -d china --slim --hstore -C 2000 -p china -r pbf /home/parallels/Downloads/CN</span><br></pre></td></tr></table></figure>\n<p>#5. 测试</p>\n<p>至此，我们已经基于 osm 的数据有了一个地理信息库，我们可以通过以下 sql 做一些简单的测试</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">name</span> <span class=\"keyword\">FROM</span> china_polygon <span class=\"keyword\">WHERE</span> <span class=\"keyword\">name</span> ~ <span class=\"string\">'南京'</span>;</span><br></pre></td></tr></table></figure>\n<p>结果：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"polygon.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> p1.name,p2.name,ST_Distance(p1.way,p2.way) <span class=\"keyword\">FROM</span></span><br><span class=\"line\">(<span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> china_point <span class=\"keyword\">WHERE</span> place=<span class=\"string\">'city'</span> <span class=\"keyword\">AND</span> <span class=\"keyword\">name</span> = <span class=\"string\">'南京市'</span>) p1 ,</span><br><span class=\"line\">(<span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> china_point <span class=\"keyword\">WHERE</span> place=<span class=\"string\">'city'</span> <span class=\"keyword\">AND</span> <span class=\"keyword\">name</span> = <span class=\"string\">'北京市'</span>) p2</span><br></pre></td></tr></table></figure>\n<p>结果：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"distance.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">name</span>, ST_AsText(ST_Transform(way,<span class=\"number\">4326</span>)) <span class=\"keyword\">FROM</span> china_point <span class=\"keyword\">WHERE</span> place=<span class=\"string\">'city'</span>;</span><br></pre></td></tr></table></figure>\n<p>结果：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"point.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure></p>\n<p>当然数据库的功能不局限于此，基于此数据库我们可以做些更有趣的事情，今后我们会慢慢探讨。</p>\n<h1 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h1><p><a href=\"https://github.com/digoal/blog/blob/master/201609/20160906_01.md\" target=\"_blank\" rel=\"noopener\">digoal 的博客</a></p>"},{"title":"制作openstreetmap-carto风格离线瓦片地图","date":"2019-06-06T07:13:27.000Z","_content":"\n[openstreetmap-carto](https://github.com/gravitystorm/openstreetmap-carto)是[openstreetmap](https://www.openstreetmap.org)的默认地图风格，广受好评，各方面均衡，是离线地图的常用选择。\n\n<!-- more -->\n\n搭建的主要步骤基本围绕[使用 osm 数据做一个自己的 PostGIS 数据库](https://kael.top/2019/03/12/osm-PostGIS-setup/)这篇文章展开。\n\n我们完成**1、2、3**步骤后，再导入 osm 数据前要做一些修改\n\n# 4. 依据 openstreetmap-carto 样式导入数据\n\n仍然是安装好 osm2pgsql 工具，下载好中国区 pbf 数据，之后我们要准备样式包\n\n```bash\n# 下载openstreetmap-carto相关数据文件\ngit clone https://github.com/gravitystorm/openstreetmap-carto.git\n\n# 导入数据，手动指定carto样式文件\nosm2pgsql -c -d china -G --slim --hstore --style /home/openstreetmap-carto/openstreetmap-carto.style --tag-transform-script /home/openstreetmap-carto/openstreetmap-carto.lua -C 2000 -p china -r pbf /home/CN\n```\n\n# 5. 执行各种脚本\n\n进入 clone 下来的`openstreetmap-carto`文件夹\n\n## 5.1 索引\n\n首先是建立数据库索引，可以加快渲染访问的速度，这步是**可选**的\n\n```bash\npsql -d gis -f indexes.sql\n```\n\n## 5.2 下载 shapefile\n\n样式中用到了海岸线、水域等 shp 文件，需要手动下载，文件较大，`openstreetmap-carto`已经提供了下载脚本\n\n```bash\nscripts/get-shapefiles.py\n```\n\n如果下载出错，加上`-s`关闭 shapeindex\n\n```bash\nscripts/get-shapefiles.py -s\n```\n\n如果实在网络不行，可以根据[安装指南](https://github.com/gravitystorm/openstreetmap-carto/blob/master/INSTALL.md#manual-download)中说明手动下载这些文件，放在`openstreetmap-carto/data`目录下就好\n\n## 5.3 下载字体\n\n如果是用了 Ubuntu/Debian 服务器，可以直接安装\n\n```bash\nsudo apt-get install fonts-noto-cjk fonts-noto-hinted fonts-noto-unhinted fonts-hanazono ttf-unifont\n```\n\n其他系统也可以[手动下载字体文件并安装](https://github.com/gravitystorm/openstreetmap-carto/blob/master/INSTALL.md#installation-on-other-operation-systems)\n\n# 6. 渲染\n\n准备好`nodejs`环境，渲染工具使用 tilestrata 这个服务端工具，配合 tilestrata-mapnik 插件就可以生成供地图调用的瓦片。\n\n具体的 demo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n对应的文章可以看一下这篇[tilestrata-mapnik 使用](https://kael.top/2019/06/11/tilestrata-mapnik/)\n\n## 6.1 准备 mapnik 配置文件\n\n因为使用了 mapnik，要将`openstreetmap-carto`的[project.mml](https://github.com/gravitystorm/openstreetmap-carto/blob/master/project.mml)转换成 mapnik 可识别的 xml 文件\n\n打开文件夹下面的`project.mml`文件，找到如下字段，修改成你数据库的相关配置信息\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/carto_project_mml.png)\n\n安装`carto`工具包进行转换\n\n```\nsudo npm install -g carto\ncarto project.mml > osm.xml\n```\n\n## 6.2 准备服务端\n\nclone 项目[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)，将项目里面`/src/mapnik/`目录下[index.js](https://github.com/zzcyrus/tilestrata-sample-code/blob/master/src/mapnik/index.js)增加以下内容\n\n```\nserver\n  .layer('osm')\n  .route('tile.png')\n  .use(\n    mapnik({\n      pathname: 'style/osm.xml'\n    })\n  )\n```\n\n将`openstreetmap-carto`文件夹下面的`data，symbols，osm.xml（刚生成的）`三个文件（夹）拷贝到`tilestrata-sample-code`的`style`文件夹下，拷贝完成的目录结构如下所示：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/osm_mapnik_folder.png)\n\n安装相关依赖并启动项目\n\n```\nnpm install\nnpm start\n```\n\n将`/example/mapnik.html`文件里的 tileLayer 地址换成`\"http://127.0.0.1:9527/osm/{z}/{x}/{y}/tile.png\",`，打开文件即可看到效果\n\n# 7 对比结果\n\n官网\n![官网效果](http://blog-img-1255388623.cossh.myqcloud.com/osm.png)\n\n我们自己生成的\n![](http://blog-img-1255388623.cossh.myqcloud.com/osm_mapnik.png)\n","source":"_posts/2019/openstreetmap-carto-map.md","raw":"---\ntitle: 制作openstreetmap-carto风格离线瓦片地图\ndate: 2019-06-06 15:13:27\ntags: [GIS]\ncategories: PostGIS\n---\n\n[openstreetmap-carto](https://github.com/gravitystorm/openstreetmap-carto)是[openstreetmap](https://www.openstreetmap.org)的默认地图风格，广受好评，各方面均衡，是离线地图的常用选择。\n\n<!-- more -->\n\n搭建的主要步骤基本围绕[使用 osm 数据做一个自己的 PostGIS 数据库](https://kael.top/2019/03/12/osm-PostGIS-setup/)这篇文章展开。\n\n我们完成**1、2、3**步骤后，再导入 osm 数据前要做一些修改\n\n# 4. 依据 openstreetmap-carto 样式导入数据\n\n仍然是安装好 osm2pgsql 工具，下载好中国区 pbf 数据，之后我们要准备样式包\n\n```bash\n# 下载openstreetmap-carto相关数据文件\ngit clone https://github.com/gravitystorm/openstreetmap-carto.git\n\n# 导入数据，手动指定carto样式文件\nosm2pgsql -c -d china -G --slim --hstore --style /home/openstreetmap-carto/openstreetmap-carto.style --tag-transform-script /home/openstreetmap-carto/openstreetmap-carto.lua -C 2000 -p china -r pbf /home/CN\n```\n\n# 5. 执行各种脚本\n\n进入 clone 下来的`openstreetmap-carto`文件夹\n\n## 5.1 索引\n\n首先是建立数据库索引，可以加快渲染访问的速度，这步是**可选**的\n\n```bash\npsql -d gis -f indexes.sql\n```\n\n## 5.2 下载 shapefile\n\n样式中用到了海岸线、水域等 shp 文件，需要手动下载，文件较大，`openstreetmap-carto`已经提供了下载脚本\n\n```bash\nscripts/get-shapefiles.py\n```\n\n如果下载出错，加上`-s`关闭 shapeindex\n\n```bash\nscripts/get-shapefiles.py -s\n```\n\n如果实在网络不行，可以根据[安装指南](https://github.com/gravitystorm/openstreetmap-carto/blob/master/INSTALL.md#manual-download)中说明手动下载这些文件，放在`openstreetmap-carto/data`目录下就好\n\n## 5.3 下载字体\n\n如果是用了 Ubuntu/Debian 服务器，可以直接安装\n\n```bash\nsudo apt-get install fonts-noto-cjk fonts-noto-hinted fonts-noto-unhinted fonts-hanazono ttf-unifont\n```\n\n其他系统也可以[手动下载字体文件并安装](https://github.com/gravitystorm/openstreetmap-carto/blob/master/INSTALL.md#installation-on-other-operation-systems)\n\n# 6. 渲染\n\n准备好`nodejs`环境，渲染工具使用 tilestrata 这个服务端工具，配合 tilestrata-mapnik 插件就可以生成供地图调用的瓦片。\n\n具体的 demo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n对应的文章可以看一下这篇[tilestrata-mapnik 使用](https://kael.top/2019/06/11/tilestrata-mapnik/)\n\n## 6.1 准备 mapnik 配置文件\n\n因为使用了 mapnik，要将`openstreetmap-carto`的[project.mml](https://github.com/gravitystorm/openstreetmap-carto/blob/master/project.mml)转换成 mapnik 可识别的 xml 文件\n\n打开文件夹下面的`project.mml`文件，找到如下字段，修改成你数据库的相关配置信息\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/carto_project_mml.png)\n\n安装`carto`工具包进行转换\n\n```\nsudo npm install -g carto\ncarto project.mml > osm.xml\n```\n\n## 6.2 准备服务端\n\nclone 项目[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)，将项目里面`/src/mapnik/`目录下[index.js](https://github.com/zzcyrus/tilestrata-sample-code/blob/master/src/mapnik/index.js)增加以下内容\n\n```\nserver\n  .layer('osm')\n  .route('tile.png')\n  .use(\n    mapnik({\n      pathname: 'style/osm.xml'\n    })\n  )\n```\n\n将`openstreetmap-carto`文件夹下面的`data，symbols，osm.xml（刚生成的）`三个文件（夹）拷贝到`tilestrata-sample-code`的`style`文件夹下，拷贝完成的目录结构如下所示：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/osm_mapnik_folder.png)\n\n安装相关依赖并启动项目\n\n```\nnpm install\nnpm start\n```\n\n将`/example/mapnik.html`文件里的 tileLayer 地址换成`\"http://127.0.0.1:9527/osm/{z}/{x}/{y}/tile.png\",`，打开文件即可看到效果\n\n# 7 对比结果\n\n官网\n![官网效果](http://blog-img-1255388623.cossh.myqcloud.com/osm.png)\n\n我们自己生成的\n![](http://blog-img-1255388623.cossh.myqcloud.com/osm_mapnik.png)\n","slug":"openstreetmap-carto-map","published":1,"updated":"2019-07-14T13:03:26.683Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy4fqa9q000i0n3ijdt5cjuc","content":"<p><a href=\"https://github.com/gravitystorm/openstreetmap-carto\" target=\"_blank\" rel=\"noopener\">openstreetmap-carto</a>是<a href=\"https://www.openstreetmap.org\" target=\"_blank\" rel=\"noopener\">openstreetmap</a>的默认地图风格，广受好评，各方面均衡，是离线地图的常用选择。</p>\n<a id=\"more\"></a>\n<p>搭建的主要步骤基本围绕<a href=\"https://kael.top/2019/03/12/osm-PostGIS-setup/\">使用 osm 数据做一个自己的 PostGIS 数据库</a>这篇文章展开。</p>\n<p>我们完成<strong>1、2、3</strong>步骤后，再导入 osm 数据前要做一些修改</p>\n<h1 id=\"4-依据-openstreetmap-carto-样式导入数据\"><a href=\"#4-依据-openstreetmap-carto-样式导入数据\" class=\"headerlink\" title=\"4. 依据 openstreetmap-carto 样式导入数据\"></a>4. 依据 openstreetmap-carto 样式导入数据</h1><p>仍然是安装好 osm2pgsql 工具，下载好中国区 pbf 数据，之后我们要准备样式包</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载openstreetmap-carto相关数据文件</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/gravitystorm/openstreetmap-carto.git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 导入数据，手动指定carto样式文件</span></span><br><span class=\"line\">osm2pgsql -c -d china -G --slim --hstore --style /home/openstreetmap-carto/openstreetmap-carto.style --tag-transform-script /home/openstreetmap-carto/openstreetmap-carto.lua -C 2000 -p china -r pbf /home/CN</span><br></pre></td></tr></table></figure>\n<h1 id=\"5-执行各种脚本\"><a href=\"#5-执行各种脚本\" class=\"headerlink\" title=\"5. 执行各种脚本\"></a>5. 执行各种脚本</h1><p>进入 clone 下来的<code>openstreetmap-carto</code>文件夹</p>\n<h2 id=\"5-1-索引\"><a href=\"#5-1-索引\" class=\"headerlink\" title=\"5.1 索引\"></a>5.1 索引</h2><p>首先是建立数据库索引，可以加快渲染访问的速度，这步是<strong>可选</strong>的</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">psql -d gis -f indexes.sql</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-2-下载-shapefile\"><a href=\"#5-2-下载-shapefile\" class=\"headerlink\" title=\"5.2 下载 shapefile\"></a>5.2 下载 shapefile</h2><p>样式中用到了海岸线、水域等 shp 文件，需要手动下载，文件较大，<code>openstreetmap-carto</code>已经提供了下载脚本</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">scripts/get-shapefiles.py</span><br></pre></td></tr></table></figure>\n<p>如果下载出错，加上<code>-s</code>关闭 shapeindex</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">scripts/get-shapefiles.py -s</span><br></pre></td></tr></table></figure>\n<p>如果实在网络不行，可以根据<a href=\"https://github.com/gravitystorm/openstreetmap-carto/blob/master/INSTALL.md#manual-download\" target=\"_blank\" rel=\"noopener\">安装指南</a>中说明手动下载这些文件，放在<code>openstreetmap-carto/data</code>目录下就好</p>\n<h2 id=\"5-3-下载字体\"><a href=\"#5-3-下载字体\" class=\"headerlink\" title=\"5.3 下载字体\"></a>5.3 下载字体</h2><p>如果是用了 Ubuntu/Debian 服务器，可以直接安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get install fonts-noto-cjk fonts-noto-hinted fonts-noto-unhinted fonts-hanazono ttf-unifont</span><br></pre></td></tr></table></figure>\n<p>其他系统也可以<a href=\"https://github.com/gravitystorm/openstreetmap-carto/blob/master/INSTALL.md#installation-on-other-operation-systems\" target=\"_blank\" rel=\"noopener\">手动下载字体文件并安装</a></p>\n<h1 id=\"6-渲染\"><a href=\"#6-渲染\" class=\"headerlink\" title=\"6. 渲染\"></a>6. 渲染</h1><p>准备好<code>nodejs</code>环境，渲染工具使用 tilestrata 这个服务端工具，配合 tilestrata-mapnik 插件就可以生成供地图调用的瓦片。</p>\n<p>具体的 demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>对应的文章可以看一下这篇<a href=\"https://kael.top/2019/06/11/tilestrata-mapnik/\">tilestrata-mapnik 使用</a></p>\n<h2 id=\"6-1-准备-mapnik-配置文件\"><a href=\"#6-1-准备-mapnik-配置文件\" class=\"headerlink\" title=\"6.1 准备 mapnik 配置文件\"></a>6.1 准备 mapnik 配置文件</h2><p>因为使用了 mapnik，要将<code>openstreetmap-carto</code>的<a href=\"https://github.com/gravitystorm/openstreetmap-carto/blob/master/project.mml\" target=\"_blank\" rel=\"noopener\">project.mml</a>转换成 mapnik 可识别的 xml 文件</p>\n<p>打开文件夹下面的<code>project.mml</code>文件，找到如下字段，修改成你数据库的相关配置信息</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/carto_project_mml.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>安装<code>carto</code>工具包进行转换</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo npm install -g carto</span><br><span class=\"line\">carto project.mml &gt; osm.xml</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-2-准备服务端\"><a href=\"#6-2-准备服务端\" class=\"headerlink\" title=\"6.2 准备服务端\"></a>6.2 准备服务端</h2><p>clone 项目<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a>，将项目里面<code>/src/mapnik/</code>目录下<a href=\"https://github.com/zzcyrus/tilestrata-sample-code/blob/master/src/mapnik/index.js\" target=\"_blank\" rel=\"noopener\">index.js</a>增加以下内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">server</span><br><span class=\"line\">  .layer(&apos;osm&apos;)</span><br><span class=\"line\">  .route(&apos;tile.png&apos;)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: &apos;style/osm.xml&apos;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br></pre></td></tr></table></figure>\n<p>将<code>openstreetmap-carto</code>文件夹下面的<code>data，symbols，osm.xml（刚生成的）</code>三个文件（夹）拷贝到<code>tilestrata-sample-code</code>的<code>style</code>文件夹下，拷贝完成的目录结构如下所示：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/osm_mapnik_folder.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>安装相关依赖并启动项目</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<p>将<code>/example/mapnik.html</code>文件里的 tileLayer 地址换成<code>&quot;http://127.0.0.1:9527/osm/{z}/{x}/{y}/tile.png&quot;,</code>，打开文件即可看到效果</p>\n<h1 id=\"7-对比结果\"><a href=\"#7-对比结果\" class=\"headerlink\" title=\"7 对比结果\"></a>7 对比结果</h1><p>官网<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/osm.png\" alt=\"官网效果\" title=\"\">\n                </div>\n                <div class=\"image-caption\">官网效果</div>\n            </figure></p>\n<p>我们自己生成的<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/osm_mapnik.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure></p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/gravitystorm/openstreetmap-carto\" target=\"_blank\" rel=\"noopener\">openstreetmap-carto</a>是<a href=\"https://www.openstreetmap.org\" target=\"_blank\" rel=\"noopener\">openstreetmap</a>的默认地图风格，广受好评，各方面均衡，是离线地图的常用选择。</p>","more":"<p>搭建的主要步骤基本围绕<a href=\"https://kael.top/2019/03/12/osm-PostGIS-setup/\">使用 osm 数据做一个自己的 PostGIS 数据库</a>这篇文章展开。</p>\n<p>我们完成<strong>1、2、3</strong>步骤后，再导入 osm 数据前要做一些修改</p>\n<h1 id=\"4-依据-openstreetmap-carto-样式导入数据\"><a href=\"#4-依据-openstreetmap-carto-样式导入数据\" class=\"headerlink\" title=\"4. 依据 openstreetmap-carto 样式导入数据\"></a>4. 依据 openstreetmap-carto 样式导入数据</h1><p>仍然是安装好 osm2pgsql 工具，下载好中国区 pbf 数据，之后我们要准备样式包</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载openstreetmap-carto相关数据文件</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/gravitystorm/openstreetmap-carto.git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 导入数据，手动指定carto样式文件</span></span><br><span class=\"line\">osm2pgsql -c -d china -G --slim --hstore --style /home/openstreetmap-carto/openstreetmap-carto.style --tag-transform-script /home/openstreetmap-carto/openstreetmap-carto.lua -C 2000 -p china -r pbf /home/CN</span><br></pre></td></tr></table></figure>\n<h1 id=\"5-执行各种脚本\"><a href=\"#5-执行各种脚本\" class=\"headerlink\" title=\"5. 执行各种脚本\"></a>5. 执行各种脚本</h1><p>进入 clone 下来的<code>openstreetmap-carto</code>文件夹</p>\n<h2 id=\"5-1-索引\"><a href=\"#5-1-索引\" class=\"headerlink\" title=\"5.1 索引\"></a>5.1 索引</h2><p>首先是建立数据库索引，可以加快渲染访问的速度，这步是<strong>可选</strong>的</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">psql -d gis -f indexes.sql</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-2-下载-shapefile\"><a href=\"#5-2-下载-shapefile\" class=\"headerlink\" title=\"5.2 下载 shapefile\"></a>5.2 下载 shapefile</h2><p>样式中用到了海岸线、水域等 shp 文件，需要手动下载，文件较大，<code>openstreetmap-carto</code>已经提供了下载脚本</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">scripts/get-shapefiles.py</span><br></pre></td></tr></table></figure>\n<p>如果下载出错，加上<code>-s</code>关闭 shapeindex</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">scripts/get-shapefiles.py -s</span><br></pre></td></tr></table></figure>\n<p>如果实在网络不行，可以根据<a href=\"https://github.com/gravitystorm/openstreetmap-carto/blob/master/INSTALL.md#manual-download\" target=\"_blank\" rel=\"noopener\">安装指南</a>中说明手动下载这些文件，放在<code>openstreetmap-carto/data</code>目录下就好</p>\n<h2 id=\"5-3-下载字体\"><a href=\"#5-3-下载字体\" class=\"headerlink\" title=\"5.3 下载字体\"></a>5.3 下载字体</h2><p>如果是用了 Ubuntu/Debian 服务器，可以直接安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get install fonts-noto-cjk fonts-noto-hinted fonts-noto-unhinted fonts-hanazono ttf-unifont</span><br></pre></td></tr></table></figure>\n<p>其他系统也可以<a href=\"https://github.com/gravitystorm/openstreetmap-carto/blob/master/INSTALL.md#installation-on-other-operation-systems\" target=\"_blank\" rel=\"noopener\">手动下载字体文件并安装</a></p>\n<h1 id=\"6-渲染\"><a href=\"#6-渲染\" class=\"headerlink\" title=\"6. 渲染\"></a>6. 渲染</h1><p>准备好<code>nodejs</code>环境，渲染工具使用 tilestrata 这个服务端工具，配合 tilestrata-mapnik 插件就可以生成供地图调用的瓦片。</p>\n<p>具体的 demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>对应的文章可以看一下这篇<a href=\"https://kael.top/2019/06/11/tilestrata-mapnik/\">tilestrata-mapnik 使用</a></p>\n<h2 id=\"6-1-准备-mapnik-配置文件\"><a href=\"#6-1-准备-mapnik-配置文件\" class=\"headerlink\" title=\"6.1 准备 mapnik 配置文件\"></a>6.1 准备 mapnik 配置文件</h2><p>因为使用了 mapnik，要将<code>openstreetmap-carto</code>的<a href=\"https://github.com/gravitystorm/openstreetmap-carto/blob/master/project.mml\" target=\"_blank\" rel=\"noopener\">project.mml</a>转换成 mapnik 可识别的 xml 文件</p>\n<p>打开文件夹下面的<code>project.mml</code>文件，找到如下字段，修改成你数据库的相关配置信息</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/carto_project_mml.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>安装<code>carto</code>工具包进行转换</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo npm install -g carto</span><br><span class=\"line\">carto project.mml &gt; osm.xml</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-2-准备服务端\"><a href=\"#6-2-准备服务端\" class=\"headerlink\" title=\"6.2 准备服务端\"></a>6.2 准备服务端</h2><p>clone 项目<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a>，将项目里面<code>/src/mapnik/</code>目录下<a href=\"https://github.com/zzcyrus/tilestrata-sample-code/blob/master/src/mapnik/index.js\" target=\"_blank\" rel=\"noopener\">index.js</a>增加以下内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">server</span><br><span class=\"line\">  .layer(&apos;osm&apos;)</span><br><span class=\"line\">  .route(&apos;tile.png&apos;)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: &apos;style/osm.xml&apos;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br></pre></td></tr></table></figure>\n<p>将<code>openstreetmap-carto</code>文件夹下面的<code>data，symbols，osm.xml（刚生成的）</code>三个文件（夹）拷贝到<code>tilestrata-sample-code</code>的<code>style</code>文件夹下，拷贝完成的目录结构如下所示：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/osm_mapnik_folder.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>安装相关依赖并启动项目</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<p>将<code>/example/mapnik.html</code>文件里的 tileLayer 地址换成<code>&quot;http://127.0.0.1:9527/osm/{z}/{x}/{y}/tile.png&quot;,</code>，打开文件即可看到效果</p>\n<h1 id=\"7-对比结果\"><a href=\"#7-对比结果\" class=\"headerlink\" title=\"7 对比结果\"></a>7 对比结果</h1><p>官网<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/osm.png\" alt=\"官网效果\" title=\"\">\n                </div>\n                <div class=\"image-caption\">官网效果</div>\n            </figure></p>\n<p>我们自己生成的<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/osm_mapnik.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure></p>"},{"title":"用PostGIS生成mvt格式的矢量瓦片","date":"2019-06-10T07:05:16.000Z","_content":"\nPostGIS 从 2.4.0 版本开始支持通过 box 生成 mvt 数据，我们用尽可能简单的方法搭建一个生产 mvt 数据的测试数据库。\n\n<!-- more -->\n\n基础工作环境：\n\n1. [docker](https://docs.docker.com/install/)\n2. [nodejs 8](https://nodejs.org/en/)\n\n# 1. 数据源\n\n从[geofabrik](http://download.geofabrik.de/)上我们可以下载的分好地区的[OpenStreetMap](https://www.openstreetmap.org/)数据，这样可以得到一个比较小的测试数据集。可以通过下面的地址下载到最新的中国区域数据：\n\n```bash\n# 直接下载国区的数据\nhttp://download.geofabrik.de/asia/china-latest.osm.pbf\n```\n\n# 2. 准备 PostGIS 环境\n\n我们直接用[mdillon/postgis](https://hub.docker.com/r/mdillon/postgis/)的 docker 镜像跑一个 PostGIS 数据库：\n\n```bash\n# 创建一个名称为gis网络\ndocker network create gis\ndocker run -d --name postgis -e POSTGRES_USER=gis --network gis -p 6543:5432 mdillon/postgis:10\n```\n\n这个镜像可以通过`POSTGRES_PASSWORD`指定数据库密码，如果没指定的话，密码会和`POSTGRES_USER`即用户名保持一致。\n\n建议通过`-p 5432:5432`映射下端口，方便我们在宿主机上直接连接调试。\n\n# 3. 导入 osm 数据到 PostGIS\n\n我们用[imposm3](https://github.com/omniscale/imposm3)来导入 osm 数据到库中。\n\nimposm3 主要需要配置 cache 目录（可选），connection 链接地址（必须）和 mapping 映射文件（必须）三个参数，官方仓库提供了一个[mapping 样例](https://github.com/omniscale/imposm3/blob/master/example-mapping.json)供参考。这里我们方便测试，就用这个[简单版本](www.qq.com)，定义了`admim、amenities、buildings`三张表。\n\n准备一个文件夹，把下载的 pbf 和 mapping 文件丢进去，再创建 cache 目录\n\n依然用上强大的 docker，[jawg/imposm3](https://hub.docker.com/r/jawg/imposm3/)可以帮助我们方便的执行 imposm3 操作。\n\n```\ndocker run --network gis --rm \\\n-v $(pwd)/cache:/tmp/imposm3 \\\n-v $(pwd)/china-latest.osm.pbf:/opt/imposm3/china-latest.osm.pbf \\\n-v $(pwd)/mapping.json:/opt/imposm3/mapping.json \\\njawg/imposm3 import \\\n-mapping mapping.json \\\n-read china-latest.osm.pbf \\\n-overwritecache -write -connection 'postgis://gis:gis@postgis/gis'\n```\n\n耐心等待导入完成，可以直接进入 docker 查看数据情况：\n\n```\ndocker exec -it postgis psql gis gis\n```\n\n或者通过第三方软件连接数据库，可以看到 import 导入的三张表：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/osm_mvt_postgis.png)\n\n# 4. 执行 SQL 脚本\n\n在数据库中执行 mapbox 提供的[TileBBox](https://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql)脚本，创建 TileBBox 函数\n\n```\nhttps://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql\n```\n\n这个函数的作用就是传入指定的`x,y,z`瓦片序列，转换成 MVT 需要的`tile coordinate space`，通常是 4096x4096 的网格\n\n# 5. 测试数据结果\n\nmvt 瓦片生成的关键就是[ST_AsMVT](https://postgis.net/docs/ST_AsMVT.html)和[ST_AsMVTGeom](https://postgis.net/docs/ST_AsMVTGeom.html)两个函数，所以可以直接调用来做个测试，这里查询`z=14,y=12917,6430`的瓦片对应的 mvt 数据\n\n先查询出范围内的 geometry，并转化成 mvt 需要的格式\n\n```sql\nSELECT ST_AsMVTGeom(\n   ST_Transform(\n\t  import.osm_buildings.geometry, 3857),\n\t  TileBBox(14, 12917, 6430, 3857),\n\t  256,\n\t  10,\n      true\n   ) geom, name\nFROM import.osm_buildings\nWHERE ST_Intersects(TileBBox(14, 12917, 6430, 3857), import.osm_buildings.geometry)\n```\n\n得到结果应该如下：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/asmvtgeom_result.png)\n\n再使用 ST_AsMVT 进行转换就行，完成的合并后的 sql 如下：\n\n```sql\nSELECT ST_AsMVT(q, 'osm_mvt', 256, 'geom') AS mvt\nFROM (\n  SELECT ST_AsMVTGeom(\n    ST_Transform(\n\t  import.osm_buildings.geometry, 3857),\n\t  TileBBox(14, 12917, 6430, 3857),\n\t  256,\n\t  10,\n      true\n  ) geom , name\n  FROM import.osm_buildings\n  WHERE ST_Intersects(TileBBox(14, 12917, 6430, 3857), import.osm_buildings.geometry)\n) AS q\n```\n\n# 6. 数据展示\n\n完整的地图区域数据前端展示可以使用 tilestrata 这个服务端工具，配合 tilestrata-postgismvt 插件就可以生成供地图调用的瓦片。\n\n具体的 demo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n对应的文章可以看一下这篇[tilestrata-postgismvt 使用](http://kael.top/2019/06/13/tilestrata-postgismvt/)\n\nclone 项目[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)，将项目里面`src/mvt/`目录下[index.js](https://github.com/zzcyrus/tilestrata-sample-code/blob/master/src/mvt/index.js)的`pgConfig`改成你的设置\n\n安装依赖，启动项目\n\n```\nnpm install\nnpm start\n```\n\n访问`example/mvt.html`就可以看到结果了。\n\n我们导入了三张表，分别是边界数据（蓝色）、设施（红点）和建筑（紫色），全部叠加之后如下图所示：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/mvt_preview.png)\n\n# 参考文档\n\n[https://blog.jawg.io/how-to-make-mvt-with-postgis/](https://blog.jawg.io/how-to-make-mvt-with-postgis/)\n","source":"_posts/2019/osm-postgis-mvt.md","raw":"---\ntitle: 用PostGIS生成mvt格式的矢量瓦片\ndate: 2019-06-10 15:05:16\ntags: [GIS]\ncategories: PostGIS\n---\n\nPostGIS 从 2.4.0 版本开始支持通过 box 生成 mvt 数据，我们用尽可能简单的方法搭建一个生产 mvt 数据的测试数据库。\n\n<!-- more -->\n\n基础工作环境：\n\n1. [docker](https://docs.docker.com/install/)\n2. [nodejs 8](https://nodejs.org/en/)\n\n# 1. 数据源\n\n从[geofabrik](http://download.geofabrik.de/)上我们可以下载的分好地区的[OpenStreetMap](https://www.openstreetmap.org/)数据，这样可以得到一个比较小的测试数据集。可以通过下面的地址下载到最新的中国区域数据：\n\n```bash\n# 直接下载国区的数据\nhttp://download.geofabrik.de/asia/china-latest.osm.pbf\n```\n\n# 2. 准备 PostGIS 环境\n\n我们直接用[mdillon/postgis](https://hub.docker.com/r/mdillon/postgis/)的 docker 镜像跑一个 PostGIS 数据库：\n\n```bash\n# 创建一个名称为gis网络\ndocker network create gis\ndocker run -d --name postgis -e POSTGRES_USER=gis --network gis -p 6543:5432 mdillon/postgis:10\n```\n\n这个镜像可以通过`POSTGRES_PASSWORD`指定数据库密码，如果没指定的话，密码会和`POSTGRES_USER`即用户名保持一致。\n\n建议通过`-p 5432:5432`映射下端口，方便我们在宿主机上直接连接调试。\n\n# 3. 导入 osm 数据到 PostGIS\n\n我们用[imposm3](https://github.com/omniscale/imposm3)来导入 osm 数据到库中。\n\nimposm3 主要需要配置 cache 目录（可选），connection 链接地址（必须）和 mapping 映射文件（必须）三个参数，官方仓库提供了一个[mapping 样例](https://github.com/omniscale/imposm3/blob/master/example-mapping.json)供参考。这里我们方便测试，就用这个[简单版本](www.qq.com)，定义了`admim、amenities、buildings`三张表。\n\n准备一个文件夹，把下载的 pbf 和 mapping 文件丢进去，再创建 cache 目录\n\n依然用上强大的 docker，[jawg/imposm3](https://hub.docker.com/r/jawg/imposm3/)可以帮助我们方便的执行 imposm3 操作。\n\n```\ndocker run --network gis --rm \\\n-v $(pwd)/cache:/tmp/imposm3 \\\n-v $(pwd)/china-latest.osm.pbf:/opt/imposm3/china-latest.osm.pbf \\\n-v $(pwd)/mapping.json:/opt/imposm3/mapping.json \\\njawg/imposm3 import \\\n-mapping mapping.json \\\n-read china-latest.osm.pbf \\\n-overwritecache -write -connection 'postgis://gis:gis@postgis/gis'\n```\n\n耐心等待导入完成，可以直接进入 docker 查看数据情况：\n\n```\ndocker exec -it postgis psql gis gis\n```\n\n或者通过第三方软件连接数据库，可以看到 import 导入的三张表：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/osm_mvt_postgis.png)\n\n# 4. 执行 SQL 脚本\n\n在数据库中执行 mapbox 提供的[TileBBox](https://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql)脚本，创建 TileBBox 函数\n\n```\nhttps://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql\n```\n\n这个函数的作用就是传入指定的`x,y,z`瓦片序列，转换成 MVT 需要的`tile coordinate space`，通常是 4096x4096 的网格\n\n# 5. 测试数据结果\n\nmvt 瓦片生成的关键就是[ST_AsMVT](https://postgis.net/docs/ST_AsMVT.html)和[ST_AsMVTGeom](https://postgis.net/docs/ST_AsMVTGeom.html)两个函数，所以可以直接调用来做个测试，这里查询`z=14,y=12917,6430`的瓦片对应的 mvt 数据\n\n先查询出范围内的 geometry，并转化成 mvt 需要的格式\n\n```sql\nSELECT ST_AsMVTGeom(\n   ST_Transform(\n\t  import.osm_buildings.geometry, 3857),\n\t  TileBBox(14, 12917, 6430, 3857),\n\t  256,\n\t  10,\n      true\n   ) geom, name\nFROM import.osm_buildings\nWHERE ST_Intersects(TileBBox(14, 12917, 6430, 3857), import.osm_buildings.geometry)\n```\n\n得到结果应该如下：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/asmvtgeom_result.png)\n\n再使用 ST_AsMVT 进行转换就行，完成的合并后的 sql 如下：\n\n```sql\nSELECT ST_AsMVT(q, 'osm_mvt', 256, 'geom') AS mvt\nFROM (\n  SELECT ST_AsMVTGeom(\n    ST_Transform(\n\t  import.osm_buildings.geometry, 3857),\n\t  TileBBox(14, 12917, 6430, 3857),\n\t  256,\n\t  10,\n      true\n  ) geom , name\n  FROM import.osm_buildings\n  WHERE ST_Intersects(TileBBox(14, 12917, 6430, 3857), import.osm_buildings.geometry)\n) AS q\n```\n\n# 6. 数据展示\n\n完整的地图区域数据前端展示可以使用 tilestrata 这个服务端工具，配合 tilestrata-postgismvt 插件就可以生成供地图调用的瓦片。\n\n具体的 demo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n对应的文章可以看一下这篇[tilestrata-postgismvt 使用](http://kael.top/2019/06/13/tilestrata-postgismvt/)\n\nclone 项目[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)，将项目里面`src/mvt/`目录下[index.js](https://github.com/zzcyrus/tilestrata-sample-code/blob/master/src/mvt/index.js)的`pgConfig`改成你的设置\n\n安装依赖，启动项目\n\n```\nnpm install\nnpm start\n```\n\n访问`example/mvt.html`就可以看到结果了。\n\n我们导入了三张表，分别是边界数据（蓝色）、设施（红点）和建筑（紫色），全部叠加之后如下图所示：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/mvt_preview.png)\n\n# 参考文档\n\n[https://blog.jawg.io/how-to-make-mvt-with-postgis/](https://blog.jawg.io/how-to-make-mvt-with-postgis/)\n","slug":"osm-postgis-mvt","published":1,"updated":"2019-07-14T13:04:09.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy4fqa9s000n0n3iisorbh2p","content":"<p>PostGIS 从 2.4.0 版本开始支持通过 box 生成 mvt 数据，我们用尽可能简单的方法搭建一个生产 mvt 数据的测试数据库。</p>\n<a id=\"more\"></a>\n<p>基础工作环境：</p>\n<ol>\n<li><a href=\"https://docs.docker.com/install/\" target=\"_blank\" rel=\"noopener\">docker</a></li>\n<li><a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">nodejs 8</a></li>\n</ol>\n<h1 id=\"1-数据源\"><a href=\"#1-数据源\" class=\"headerlink\" title=\"1. 数据源\"></a>1. 数据源</h1><p>从<a href=\"http://download.geofabrik.de/\" target=\"_blank\" rel=\"noopener\">geofabrik</a>上我们可以下载的分好地区的<a href=\"https://www.openstreetmap.org/\" target=\"_blank\" rel=\"noopener\">OpenStreetMap</a>数据，这样可以得到一个比较小的测试数据集。可以通过下面的地址下载到最新的中国区域数据：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 直接下载国区的数据</span></span><br><span class=\"line\">http://download.geofabrik.de/asia/china-latest.osm.pbf</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-准备-PostGIS-环境\"><a href=\"#2-准备-PostGIS-环境\" class=\"headerlink\" title=\"2. 准备 PostGIS 环境\"></a>2. 准备 PostGIS 环境</h1><p>我们直接用<a href=\"https://hub.docker.com/r/mdillon/postgis/\" target=\"_blank\" rel=\"noopener\">mdillon/postgis</a>的 docker 镜像跑一个 PostGIS 数据库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建一个名称为gis网络</span></span><br><span class=\"line\">docker network create gis</span><br><span class=\"line\">docker run -d --name postgis -e POSTGRES_USER=gis --network gis -p 6543:5432 mdillon/postgis:10</span><br></pre></td></tr></table></figure>\n<p>这个镜像可以通过<code>POSTGRES_PASSWORD</code>指定数据库密码，如果没指定的话，密码会和<code>POSTGRES_USER</code>即用户名保持一致。</p>\n<p>建议通过<code>-p 5432:5432</code>映射下端口，方便我们在宿主机上直接连接调试。</p>\n<h1 id=\"3-导入-osm-数据到-PostGIS\"><a href=\"#3-导入-osm-数据到-PostGIS\" class=\"headerlink\" title=\"3. 导入 osm 数据到 PostGIS\"></a>3. 导入 osm 数据到 PostGIS</h1><p>我们用<a href=\"https://github.com/omniscale/imposm3\" target=\"_blank\" rel=\"noopener\">imposm3</a>来导入 osm 数据到库中。</p>\n<p>imposm3 主要需要配置 cache 目录（可选），connection 链接地址（必须）和 mapping 映射文件（必须）三个参数，官方仓库提供了一个<a href=\"https://github.com/omniscale/imposm3/blob/master/example-mapping.json\" target=\"_blank\" rel=\"noopener\">mapping 样例</a>供参考。这里我们方便测试，就用这个<a href=\"www.qq.com\">简单版本</a>，定义了<code>admim、amenities、buildings</code>三张表。</p>\n<p>准备一个文件夹，把下载的 pbf 和 mapping 文件丢进去，再创建 cache 目录</p>\n<p>依然用上强大的 docker，<a href=\"https://hub.docker.com/r/jawg/imposm3/\" target=\"_blank\" rel=\"noopener\">jawg/imposm3</a>可以帮助我们方便的执行 imposm3 操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run --network gis --rm \\</span><br><span class=\"line\">-v $(pwd)/cache:/tmp/imposm3 \\</span><br><span class=\"line\">-v $(pwd)/china-latest.osm.pbf:/opt/imposm3/china-latest.osm.pbf \\</span><br><span class=\"line\">-v $(pwd)/mapping.json:/opt/imposm3/mapping.json \\</span><br><span class=\"line\">jawg/imposm3 import \\</span><br><span class=\"line\">-mapping mapping.json \\</span><br><span class=\"line\">-read china-latest.osm.pbf \\</span><br><span class=\"line\">-overwritecache -write -connection &apos;postgis://gis:gis@postgis/gis&apos;</span><br></pre></td></tr></table></figure>\n<p>耐心等待导入完成，可以直接进入 docker 查看数据情况：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker exec -it postgis psql gis gis</span><br></pre></td></tr></table></figure>\n<p>或者通过第三方软件连接数据库，可以看到 import 导入的三张表：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/osm_mvt_postgis.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"4-执行-SQL-脚本\"><a href=\"#4-执行-SQL-脚本\" class=\"headerlink\" title=\"4. 执行 SQL 脚本\"></a>4. 执行 SQL 脚本</h1><p>在数据库中执行 mapbox 提供的<a href=\"https://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql\" target=\"_blank\" rel=\"noopener\">TileBBox</a>脚本，创建 TileBBox 函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql</span><br></pre></td></tr></table></figure>\n<p>这个函数的作用就是传入指定的<code>x,y,z</code>瓦片序列，转换成 MVT 需要的<code>tile coordinate space</code>，通常是 4096x4096 的网格</p>\n<h1 id=\"5-测试数据结果\"><a href=\"#5-测试数据结果\" class=\"headerlink\" title=\"5. 测试数据结果\"></a>5. 测试数据结果</h1><p>mvt 瓦片生成的关键就是<a href=\"https://postgis.net/docs/ST_AsMVT.html\" target=\"_blank\" rel=\"noopener\">ST_AsMVT</a>和<a href=\"https://postgis.net/docs/ST_AsMVTGeom.html\" target=\"_blank\" rel=\"noopener\">ST_AsMVTGeom</a>两个函数，所以可以直接调用来做个测试，这里查询<code>z=14,y=12917,6430</code>的瓦片对应的 mvt 数据</p>\n<p>先查询出范围内的 geometry，并转化成 mvt 需要的格式</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> ST_AsMVTGeom(</span><br><span class=\"line\">   ST_Transform(</span><br><span class=\"line\">\t  import.osm_buildings.geometry, <span class=\"number\">3857</span>),</span><br><span class=\"line\">\t  TileBBox(<span class=\"number\">14</span>, <span class=\"number\">12917</span>, <span class=\"number\">6430</span>, <span class=\"number\">3857</span>),</span><br><span class=\"line\">\t  <span class=\"number\">256</span>,</span><br><span class=\"line\">\t  <span class=\"number\">10</span>,</span><br><span class=\"line\">      <span class=\"literal\">true</span></span><br><span class=\"line\">   ) geom, <span class=\"keyword\">name</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> import.osm_buildings</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> ST_Intersects(TileBBox(<span class=\"number\">14</span>, <span class=\"number\">12917</span>, <span class=\"number\">6430</span>, <span class=\"number\">3857</span>), import.osm_buildings.geometry)</span><br></pre></td></tr></table></figure>\n<p>得到结果应该如下：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/asmvtgeom_result.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>再使用 ST_AsMVT 进行转换就行，完成的合并后的 sql 如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> ST_AsMVT(q, <span class=\"string\">'osm_mvt'</span>, <span class=\"number\">256</span>, <span class=\"string\">'geom'</span>) <span class=\"keyword\">AS</span> mvt</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> (</span><br><span class=\"line\">  <span class=\"keyword\">SELECT</span> ST_AsMVTGeom(</span><br><span class=\"line\">    ST_Transform(</span><br><span class=\"line\">\t  import.osm_buildings.geometry, <span class=\"number\">3857</span>),</span><br><span class=\"line\">\t  TileBBox(<span class=\"number\">14</span>, <span class=\"number\">12917</span>, <span class=\"number\">6430</span>, <span class=\"number\">3857</span>),</span><br><span class=\"line\">\t  <span class=\"number\">256</span>,</span><br><span class=\"line\">\t  <span class=\"number\">10</span>,</span><br><span class=\"line\">      <span class=\"literal\">true</span></span><br><span class=\"line\">  ) geom , <span class=\"keyword\">name</span></span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> import.osm_buildings</span><br><span class=\"line\">  <span class=\"keyword\">WHERE</span> ST_Intersects(TileBBox(<span class=\"number\">14</span>, <span class=\"number\">12917</span>, <span class=\"number\">6430</span>, <span class=\"number\">3857</span>), import.osm_buildings.geometry)</span><br><span class=\"line\">) <span class=\"keyword\">AS</span> q</span><br></pre></td></tr></table></figure>\n<h1 id=\"6-数据展示\"><a href=\"#6-数据展示\" class=\"headerlink\" title=\"6. 数据展示\"></a>6. 数据展示</h1><p>完整的地图区域数据前端展示可以使用 tilestrata 这个服务端工具，配合 tilestrata-postgismvt 插件就可以生成供地图调用的瓦片。</p>\n<p>具体的 demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>对应的文章可以看一下这篇<a href=\"http://kael.top/2019/06/13/tilestrata-postgismvt/\">tilestrata-postgismvt 使用</a></p>\n<p>clone 项目<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a>，将项目里面<code>src/mvt/</code>目录下<a href=\"https://github.com/zzcyrus/tilestrata-sample-code/blob/master/src/mvt/index.js\" target=\"_blank\" rel=\"noopener\">index.js</a>的<code>pgConfig</code>改成你的设置</p>\n<p>安装依赖，启动项目</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<p>访问<code>example/mvt.html</code>就可以看到结果了。</p>\n<p>我们导入了三张表，分别是边界数据（蓝色）、设施（红点）和建筑（紫色），全部叠加之后如下图所示：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/mvt_preview.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h1><p><a href=\"https://blog.jawg.io/how-to-make-mvt-with-postgis/\" target=\"_blank\" rel=\"noopener\">https://blog.jawg.io/how-to-make-mvt-with-postgis/</a></p>\n","site":{"data":{}},"excerpt":"<p>PostGIS 从 2.4.0 版本开始支持通过 box 生成 mvt 数据，我们用尽可能简单的方法搭建一个生产 mvt 数据的测试数据库。</p>","more":"<p>基础工作环境：</p>\n<ol>\n<li><a href=\"https://docs.docker.com/install/\" target=\"_blank\" rel=\"noopener\">docker</a></li>\n<li><a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">nodejs 8</a></li>\n</ol>\n<h1 id=\"1-数据源\"><a href=\"#1-数据源\" class=\"headerlink\" title=\"1. 数据源\"></a>1. 数据源</h1><p>从<a href=\"http://download.geofabrik.de/\" target=\"_blank\" rel=\"noopener\">geofabrik</a>上我们可以下载的分好地区的<a href=\"https://www.openstreetmap.org/\" target=\"_blank\" rel=\"noopener\">OpenStreetMap</a>数据，这样可以得到一个比较小的测试数据集。可以通过下面的地址下载到最新的中国区域数据：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 直接下载国区的数据</span></span><br><span class=\"line\">http://download.geofabrik.de/asia/china-latest.osm.pbf</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-准备-PostGIS-环境\"><a href=\"#2-准备-PostGIS-环境\" class=\"headerlink\" title=\"2. 准备 PostGIS 环境\"></a>2. 准备 PostGIS 环境</h1><p>我们直接用<a href=\"https://hub.docker.com/r/mdillon/postgis/\" target=\"_blank\" rel=\"noopener\">mdillon/postgis</a>的 docker 镜像跑一个 PostGIS 数据库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建一个名称为gis网络</span></span><br><span class=\"line\">docker network create gis</span><br><span class=\"line\">docker run -d --name postgis -e POSTGRES_USER=gis --network gis -p 6543:5432 mdillon/postgis:10</span><br></pre></td></tr></table></figure>\n<p>这个镜像可以通过<code>POSTGRES_PASSWORD</code>指定数据库密码，如果没指定的话，密码会和<code>POSTGRES_USER</code>即用户名保持一致。</p>\n<p>建议通过<code>-p 5432:5432</code>映射下端口，方便我们在宿主机上直接连接调试。</p>\n<h1 id=\"3-导入-osm-数据到-PostGIS\"><a href=\"#3-导入-osm-数据到-PostGIS\" class=\"headerlink\" title=\"3. 导入 osm 数据到 PostGIS\"></a>3. 导入 osm 数据到 PostGIS</h1><p>我们用<a href=\"https://github.com/omniscale/imposm3\" target=\"_blank\" rel=\"noopener\">imposm3</a>来导入 osm 数据到库中。</p>\n<p>imposm3 主要需要配置 cache 目录（可选），connection 链接地址（必须）和 mapping 映射文件（必须）三个参数，官方仓库提供了一个<a href=\"https://github.com/omniscale/imposm3/blob/master/example-mapping.json\" target=\"_blank\" rel=\"noopener\">mapping 样例</a>供参考。这里我们方便测试，就用这个<a href=\"www.qq.com\">简单版本</a>，定义了<code>admim、amenities、buildings</code>三张表。</p>\n<p>准备一个文件夹，把下载的 pbf 和 mapping 文件丢进去，再创建 cache 目录</p>\n<p>依然用上强大的 docker，<a href=\"https://hub.docker.com/r/jawg/imposm3/\" target=\"_blank\" rel=\"noopener\">jawg/imposm3</a>可以帮助我们方便的执行 imposm3 操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run --network gis --rm \\</span><br><span class=\"line\">-v $(pwd)/cache:/tmp/imposm3 \\</span><br><span class=\"line\">-v $(pwd)/china-latest.osm.pbf:/opt/imposm3/china-latest.osm.pbf \\</span><br><span class=\"line\">-v $(pwd)/mapping.json:/opt/imposm3/mapping.json \\</span><br><span class=\"line\">jawg/imposm3 import \\</span><br><span class=\"line\">-mapping mapping.json \\</span><br><span class=\"line\">-read china-latest.osm.pbf \\</span><br><span class=\"line\">-overwritecache -write -connection &apos;postgis://gis:gis@postgis/gis&apos;</span><br></pre></td></tr></table></figure>\n<p>耐心等待导入完成，可以直接进入 docker 查看数据情况：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker exec -it postgis psql gis gis</span><br></pre></td></tr></table></figure>\n<p>或者通过第三方软件连接数据库，可以看到 import 导入的三张表：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/osm_mvt_postgis.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"4-执行-SQL-脚本\"><a href=\"#4-执行-SQL-脚本\" class=\"headerlink\" title=\"4. 执行 SQL 脚本\"></a>4. 执行 SQL 脚本</h1><p>在数据库中执行 mapbox 提供的<a href=\"https://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql\" target=\"_blank\" rel=\"noopener\">TileBBox</a>脚本，创建 TileBBox 函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql</span><br></pre></td></tr></table></figure>\n<p>这个函数的作用就是传入指定的<code>x,y,z</code>瓦片序列，转换成 MVT 需要的<code>tile coordinate space</code>，通常是 4096x4096 的网格</p>\n<h1 id=\"5-测试数据结果\"><a href=\"#5-测试数据结果\" class=\"headerlink\" title=\"5. 测试数据结果\"></a>5. 测试数据结果</h1><p>mvt 瓦片生成的关键就是<a href=\"https://postgis.net/docs/ST_AsMVT.html\" target=\"_blank\" rel=\"noopener\">ST_AsMVT</a>和<a href=\"https://postgis.net/docs/ST_AsMVTGeom.html\" target=\"_blank\" rel=\"noopener\">ST_AsMVTGeom</a>两个函数，所以可以直接调用来做个测试，这里查询<code>z=14,y=12917,6430</code>的瓦片对应的 mvt 数据</p>\n<p>先查询出范围内的 geometry，并转化成 mvt 需要的格式</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> ST_AsMVTGeom(</span><br><span class=\"line\">   ST_Transform(</span><br><span class=\"line\">\t  import.osm_buildings.geometry, <span class=\"number\">3857</span>),</span><br><span class=\"line\">\t  TileBBox(<span class=\"number\">14</span>, <span class=\"number\">12917</span>, <span class=\"number\">6430</span>, <span class=\"number\">3857</span>),</span><br><span class=\"line\">\t  <span class=\"number\">256</span>,</span><br><span class=\"line\">\t  <span class=\"number\">10</span>,</span><br><span class=\"line\">      <span class=\"literal\">true</span></span><br><span class=\"line\">   ) geom, <span class=\"keyword\">name</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> import.osm_buildings</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> ST_Intersects(TileBBox(<span class=\"number\">14</span>, <span class=\"number\">12917</span>, <span class=\"number\">6430</span>, <span class=\"number\">3857</span>), import.osm_buildings.geometry)</span><br></pre></td></tr></table></figure>\n<p>得到结果应该如下：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/asmvtgeom_result.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>再使用 ST_AsMVT 进行转换就行，完成的合并后的 sql 如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> ST_AsMVT(q, <span class=\"string\">'osm_mvt'</span>, <span class=\"number\">256</span>, <span class=\"string\">'geom'</span>) <span class=\"keyword\">AS</span> mvt</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> (</span><br><span class=\"line\">  <span class=\"keyword\">SELECT</span> ST_AsMVTGeom(</span><br><span class=\"line\">    ST_Transform(</span><br><span class=\"line\">\t  import.osm_buildings.geometry, <span class=\"number\">3857</span>),</span><br><span class=\"line\">\t  TileBBox(<span class=\"number\">14</span>, <span class=\"number\">12917</span>, <span class=\"number\">6430</span>, <span class=\"number\">3857</span>),</span><br><span class=\"line\">\t  <span class=\"number\">256</span>,</span><br><span class=\"line\">\t  <span class=\"number\">10</span>,</span><br><span class=\"line\">      <span class=\"literal\">true</span></span><br><span class=\"line\">  ) geom , <span class=\"keyword\">name</span></span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> import.osm_buildings</span><br><span class=\"line\">  <span class=\"keyword\">WHERE</span> ST_Intersects(TileBBox(<span class=\"number\">14</span>, <span class=\"number\">12917</span>, <span class=\"number\">6430</span>, <span class=\"number\">3857</span>), import.osm_buildings.geometry)</span><br><span class=\"line\">) <span class=\"keyword\">AS</span> q</span><br></pre></td></tr></table></figure>\n<h1 id=\"6-数据展示\"><a href=\"#6-数据展示\" class=\"headerlink\" title=\"6. 数据展示\"></a>6. 数据展示</h1><p>完整的地图区域数据前端展示可以使用 tilestrata 这个服务端工具，配合 tilestrata-postgismvt 插件就可以生成供地图调用的瓦片。</p>\n<p>具体的 demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>对应的文章可以看一下这篇<a href=\"http://kael.top/2019/06/13/tilestrata-postgismvt/\">tilestrata-postgismvt 使用</a></p>\n<p>clone 项目<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a>，将项目里面<code>src/mvt/</code>目录下<a href=\"https://github.com/zzcyrus/tilestrata-sample-code/blob/master/src/mvt/index.js\" target=\"_blank\" rel=\"noopener\">index.js</a>的<code>pgConfig</code>改成你的设置</p>\n<p>安装依赖，启动项目</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install</span><br><span class=\"line\">npm start</span><br></pre></td></tr></table></figure>\n<p>访问<code>example/mvt.html</code>就可以看到结果了。</p>\n<p>我们导入了三张表，分别是边界数据（蓝色）、设施（红点）和建筑（紫色），全部叠加之后如下图所示：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/mvt_preview.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h1><p><a href=\"https://blog.jawg.io/how-to-make-mvt-with-postgis/\" target=\"_blank\" rel=\"noopener\">https://blog.jawg.io/how-to-make-mvt-with-postgis/</a></p>"},{"title":"tilestrata-blend 插件使用及浅析","date":"2019-07-08T07:19:26.000Z","_content":"\n[tilestrata-blend](https://github.com/naturalatlas/tilestrata-blend)插件可以将多个栅格瓦片图层合并成一个 png 图层，并且支持透明度、混合模式、图层过滤等选项。使用这个插件必须安装依赖[node-mapnik](https://github.com/mapnik/node-mapnik)。这个插件依然是一个利用 mapnik 强大的功能的`Provider`类型的插件，甚至可以基于 mapnik 增强它已有的功能。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-blend --save\n```\n\n# 2. 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst mapnik = require('tilestrata-mapnik')\nconst blend = require('tilestrata-blend')\nconst server = tilestrata()\n\n// 定义第一个世界边界图层\nserver\n  .layer('world_merc')\n  .route('tile.png')\n  .use(disk.cache({ dir: 'tilecache' }))\n  .use(\n    mapnik({\n      pathname: 'style/world.xml'\n    })\n  )\n\n// 定义第二个中国省界图层\nserver\n  .layer('province')\n  .route('tile.png')\n  .use(\n    mapnik({\n      pathname: 'style/province.xml'\n    })\n  )\n\n// 定义混合图层\nserver\n  .layer('blend_layer')\n  .route('combined.png')\n  .use(\n    blend(\n      [\n        ['world_merc', 'tile.png'],\n        [\n          'province',\n          'tile.png',\n          // 配置一些省界图层合并时候的参数\n          {\n            opacity: 0.5,\n            comp_op: 'multiply',\n            image_filters: 'agg-stack-blur(10,10)'\n          }\n        ]\n      ],\n      // 给合并后的图层设置一个可选的填充色\n      {\n        matte: 'ffffff'\n      }\n    )\n  )\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n可以在同一张瓦片上看到黄色的中国省界图层和世界边界图层，下图是没有配置仍和`options`：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-blend-no-option-20190705113008.png)\n\n下图是像上面演示的那样，给省界图层加入了一些`options`，例如 image_filters 和 opacity：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-blend-20190705102810.png)\n\n# 4. 代码浅析\n\n这个插件在背后依赖了[tilestrata-dependency](https://github.com/naturalatlas/tilestrata-dependency)，所以配置里面的`['world_merc', 'tile.png']`实际上是通过执行了`.use(dependency('world_merc_png', 'tile.png'))`操作来获取数据源：\n\n```js\n// 找到每个图层的数据源（代码有所精简）\nvar layers = layers.map(function(pair) {\n  var layer = pair[0]\n  var filename = pair[1]\n  var comp_options = pair[2] || {}\n  return [dependency(layer, filename), comp_options]\n})\n```\n\n当请求某个瓦片时候，对每个`layers`依次执行`fetchTile`获取对应图片和`prepareImage`预处理图片\n\n```js\n// 对每个数据源，获取数据，预处理图片（代码有所精简）\nasync.series(\n  [\n    function fetchTile(callback) {\n      callback(err)\n    },\n    function prepareImage(callback) {\n      // 这一步会创建new mapnik.Image\n      generateMatte(noop)\n    }\n  ],\n  function(err) {\n    callback(err, image ? [image, options] : null)\n  }\n)\n```\n\n完成每个数据源的单独处理后就是合并操作了，利用 mapnik 的[omposite](http://mapnik.org/documentation/node-mapnik/3.6/#Image.composite)方法来依次合并创建的每个`mapnik.Image`对象，最后再利用[demultiply](http://mapnik.org/documentation/node-mapnik/3.6/#Image.demultiply)解构为 buffer 返回给 tilestrata 就好了。\n\n```js\n// （代码有所精简）\nasync.eachSeries(images, function(res, callback) {\n    // 依次合并图片\n    intermediate.composite(image, res[1], callback);\n}, function(err) {\n    // 结构返回buffer\n    intermediate.demultiply(function(err) {\n            callback(null, buffer, {'Content-Type': 'image/png'});\n        });\n    });\n});\n```\n","source":"_posts/2019/tilestrata-blend.md","raw":"---\ntitle: tilestrata-blend 插件使用及浅析\ndate: 2019-07-08 15:19:26\ntags: [GIS]\ncategories: TileStrata\n---\n\n[tilestrata-blend](https://github.com/naturalatlas/tilestrata-blend)插件可以将多个栅格瓦片图层合并成一个 png 图层，并且支持透明度、混合模式、图层过滤等选项。使用这个插件必须安装依赖[node-mapnik](https://github.com/mapnik/node-mapnik)。这个插件依然是一个利用 mapnik 强大的功能的`Provider`类型的插件，甚至可以基于 mapnik 增强它已有的功能。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-blend --save\n```\n\n# 2. 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst mapnik = require('tilestrata-mapnik')\nconst blend = require('tilestrata-blend')\nconst server = tilestrata()\n\n// 定义第一个世界边界图层\nserver\n  .layer('world_merc')\n  .route('tile.png')\n  .use(disk.cache({ dir: 'tilecache' }))\n  .use(\n    mapnik({\n      pathname: 'style/world.xml'\n    })\n  )\n\n// 定义第二个中国省界图层\nserver\n  .layer('province')\n  .route('tile.png')\n  .use(\n    mapnik({\n      pathname: 'style/province.xml'\n    })\n  )\n\n// 定义混合图层\nserver\n  .layer('blend_layer')\n  .route('combined.png')\n  .use(\n    blend(\n      [\n        ['world_merc', 'tile.png'],\n        [\n          'province',\n          'tile.png',\n          // 配置一些省界图层合并时候的参数\n          {\n            opacity: 0.5,\n            comp_op: 'multiply',\n            image_filters: 'agg-stack-blur(10,10)'\n          }\n        ]\n      ],\n      // 给合并后的图层设置一个可选的填充色\n      {\n        matte: 'ffffff'\n      }\n    )\n  )\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n可以在同一张瓦片上看到黄色的中国省界图层和世界边界图层，下图是没有配置仍和`options`：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-blend-no-option-20190705113008.png)\n\n下图是像上面演示的那样，给省界图层加入了一些`options`，例如 image_filters 和 opacity：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-blend-20190705102810.png)\n\n# 4. 代码浅析\n\n这个插件在背后依赖了[tilestrata-dependency](https://github.com/naturalatlas/tilestrata-dependency)，所以配置里面的`['world_merc', 'tile.png']`实际上是通过执行了`.use(dependency('world_merc_png', 'tile.png'))`操作来获取数据源：\n\n```js\n// 找到每个图层的数据源（代码有所精简）\nvar layers = layers.map(function(pair) {\n  var layer = pair[0]\n  var filename = pair[1]\n  var comp_options = pair[2] || {}\n  return [dependency(layer, filename), comp_options]\n})\n```\n\n当请求某个瓦片时候，对每个`layers`依次执行`fetchTile`获取对应图片和`prepareImage`预处理图片\n\n```js\n// 对每个数据源，获取数据，预处理图片（代码有所精简）\nasync.series(\n  [\n    function fetchTile(callback) {\n      callback(err)\n    },\n    function prepareImage(callback) {\n      // 这一步会创建new mapnik.Image\n      generateMatte(noop)\n    }\n  ],\n  function(err) {\n    callback(err, image ? [image, options] : null)\n  }\n)\n```\n\n完成每个数据源的单独处理后就是合并操作了，利用 mapnik 的[omposite](http://mapnik.org/documentation/node-mapnik/3.6/#Image.composite)方法来依次合并创建的每个`mapnik.Image`对象，最后再利用[demultiply](http://mapnik.org/documentation/node-mapnik/3.6/#Image.demultiply)解构为 buffer 返回给 tilestrata 就好了。\n\n```js\n// （代码有所精简）\nasync.eachSeries(images, function(res, callback) {\n    // 依次合并图片\n    intermediate.composite(image, res[1], callback);\n}, function(err) {\n    // 结构返回buffer\n    intermediate.demultiply(function(err) {\n            callback(null, buffer, {'Content-Type': 'image/png'});\n        });\n    });\n});\n```\n","slug":"tilestrata-blend","published":1,"updated":"2019-07-08T07:23:13.198Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy4fqa9t000p0n3i4v8ks9n4","content":"<p><a href=\"https://github.com/naturalatlas/tilestrata-blend\" target=\"_blank\" rel=\"noopener\">tilestrata-blend</a>插件可以将多个栅格瓦片图层合并成一个 png 图层，并且支持透明度、混合模式、图层过滤等选项。使用这个插件必须安装依赖<a href=\"https://github.com/mapnik/node-mapnik\" target=\"_blank\" rel=\"noopener\">node-mapnik</a>。这个插件依然是一个利用 mapnik 强大的功能的<code>Provider</code>类型的插件，甚至可以基于 mapnik 增强它已有的功能。</p>\n<a id=\"more\"></a>\n<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-blend --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> blend = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-blend'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义第一个世界边界图层</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'world_merc'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(disk.cache(&#123; <span class=\"attr\">dir</span>: <span class=\"string\">'tilecache'</span> &#125;))</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/world.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义第二个中国省界图层</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'province'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/province.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义混合图层</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'blend_layer'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'combined.png'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    blend(</span><br><span class=\"line\">      [</span><br><span class=\"line\">        [<span class=\"string\">'world_merc'</span>, <span class=\"string\">'tile.png'</span>],</span><br><span class=\"line\">        [</span><br><span class=\"line\">          <span class=\"string\">'province'</span>,</span><br><span class=\"line\">          <span class=\"string\">'tile.png'</span>,</span><br><span class=\"line\">          <span class=\"comment\">// 配置一些省界图层合并时候的参数</span></span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            opacity: <span class=\"number\">0.5</span>,</span><br><span class=\"line\">            comp_op: <span class=\"string\">'multiply'</span>,</span><br><span class=\"line\">            image_filters: <span class=\"string\">'agg-stack-blur(10,10)'</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      ],</span><br><span class=\"line\">      <span class=\"comment\">// 给合并后的图层设置一个可选的填充色</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        matte: <span class=\"string\">'ffffff'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>可以在同一张瓦片上看到黄色的中国省界图层和世界边界图层，下图是没有配置仍和<code>options</code>：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-blend-no-option-20190705113008.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>下图是像上面演示的那样，给省界图层加入了一些<code>options</code>，例如 image_filters 和 opacity：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-blend-20190705102810.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>这个插件在背后依赖了<a href=\"https://github.com/naturalatlas/tilestrata-dependency\" target=\"_blank\" rel=\"noopener\">tilestrata-dependency</a>，所以配置里面的<code>[&#39;world_merc&#39;, &#39;tile.png&#39;]</code>实际上是通过执行了<code>.use(dependency(&#39;world_merc_png&#39;, &#39;tile.png&#39;))</code>操作来获取数据源：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 找到每个图层的数据源（代码有所精简）</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> layers = layers.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">pair</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> layer = pair[<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"keyword\">var</span> filename = pair[<span class=\"number\">1</span>]</span><br><span class=\"line\">  <span class=\"keyword\">var</span> comp_options = pair[<span class=\"number\">2</span>] || &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [dependency(layer, filename), comp_options]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>当请求某个瓦片时候，对每个<code>layers</code>依次执行<code>fetchTile</code>获取对应图片和<code>prepareImage</code>预处理图片</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对每个数据源，获取数据，预处理图片（代码有所精简）</span></span><br><span class=\"line\"><span class=\"keyword\">async</span>.series(</span><br><span class=\"line\">  [</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetchTile</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">      callback(err)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">prepareImage</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 这一步会创建new mapnik.Image</span></span><br><span class=\"line\">      generateMatte(noop)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    callback(err, image ? [image, options] : <span class=\"literal\">null</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>完成每个数据源的单独处理后就是合并操作了，利用 mapnik 的<a href=\"http://mapnik.org/documentation/node-mapnik/3.6/#Image.composite\" target=\"_blank\" rel=\"noopener\">omposite</a>方法来依次合并创建的每个<code>mapnik.Image</code>对象，最后再利用<a href=\"http://mapnik.org/documentation/node-mapnik/3.6/#Image.demultiply\" target=\"_blank\" rel=\"noopener\">demultiply</a>解构为 buffer 返回给 tilestrata 就好了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// （代码有所精简）</span></span><br><span class=\"line\"><span class=\"keyword\">async</span>.eachSeries(images, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 依次合并图片</span></span><br><span class=\"line\">    intermediate.composite(image, res[<span class=\"number\">1</span>], callback);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 结构返回buffer</span></span><br><span class=\"line\">    intermediate.demultiply(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">            callback(<span class=\"literal\">null</span>, buffer, &#123;<span class=\"string\">'Content-Type'</span>: <span class=\"string\">'image/png'</span>&#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/naturalatlas/tilestrata-blend\" target=\"_blank\" rel=\"noopener\">tilestrata-blend</a>插件可以将多个栅格瓦片图层合并成一个 png 图层，并且支持透明度、混合模式、图层过滤等选项。使用这个插件必须安装依赖<a href=\"https://github.com/mapnik/node-mapnik\" target=\"_blank\" rel=\"noopener\">node-mapnik</a>。这个插件依然是一个利用 mapnik 强大的功能的<code>Provider</code>类型的插件，甚至可以基于 mapnik 增强它已有的功能。</p>","more":"<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-blend --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> blend = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-blend'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义第一个世界边界图层</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'world_merc'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(disk.cache(&#123; <span class=\"attr\">dir</span>: <span class=\"string\">'tilecache'</span> &#125;))</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/world.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义第二个中国省界图层</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'province'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/province.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义混合图层</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'blend_layer'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'combined.png'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    blend(</span><br><span class=\"line\">      [</span><br><span class=\"line\">        [<span class=\"string\">'world_merc'</span>, <span class=\"string\">'tile.png'</span>],</span><br><span class=\"line\">        [</span><br><span class=\"line\">          <span class=\"string\">'province'</span>,</span><br><span class=\"line\">          <span class=\"string\">'tile.png'</span>,</span><br><span class=\"line\">          <span class=\"comment\">// 配置一些省界图层合并时候的参数</span></span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            opacity: <span class=\"number\">0.5</span>,</span><br><span class=\"line\">            comp_op: <span class=\"string\">'multiply'</span>,</span><br><span class=\"line\">            image_filters: <span class=\"string\">'agg-stack-blur(10,10)'</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      ],</span><br><span class=\"line\">      <span class=\"comment\">// 给合并后的图层设置一个可选的填充色</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        matte: <span class=\"string\">'ffffff'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>可以在同一张瓦片上看到黄色的中国省界图层和世界边界图层，下图是没有配置仍和<code>options</code>：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-blend-no-option-20190705113008.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>下图是像上面演示的那样，给省界图层加入了一些<code>options</code>，例如 image_filters 和 opacity：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-blend-20190705102810.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>这个插件在背后依赖了<a href=\"https://github.com/naturalatlas/tilestrata-dependency\" target=\"_blank\" rel=\"noopener\">tilestrata-dependency</a>，所以配置里面的<code>[&#39;world_merc&#39;, &#39;tile.png&#39;]</code>实际上是通过执行了<code>.use(dependency(&#39;world_merc_png&#39;, &#39;tile.png&#39;))</code>操作来获取数据源：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 找到每个图层的数据源（代码有所精简）</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> layers = layers.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">pair</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> layer = pair[<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"keyword\">var</span> filename = pair[<span class=\"number\">1</span>]</span><br><span class=\"line\">  <span class=\"keyword\">var</span> comp_options = pair[<span class=\"number\">2</span>] || &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [dependency(layer, filename), comp_options]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>当请求某个瓦片时候，对每个<code>layers</code>依次执行<code>fetchTile</code>获取对应图片和<code>prepareImage</code>预处理图片</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对每个数据源，获取数据，预处理图片（代码有所精简）</span></span><br><span class=\"line\"><span class=\"keyword\">async</span>.series(</span><br><span class=\"line\">  [</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetchTile</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">      callback(err)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">prepareImage</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 这一步会创建new mapnik.Image</span></span><br><span class=\"line\">      generateMatte(noop)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    callback(err, image ? [image, options] : <span class=\"literal\">null</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>完成每个数据源的单独处理后就是合并操作了，利用 mapnik 的<a href=\"http://mapnik.org/documentation/node-mapnik/3.6/#Image.composite\" target=\"_blank\" rel=\"noopener\">omposite</a>方法来依次合并创建的每个<code>mapnik.Image</code>对象，最后再利用<a href=\"http://mapnik.org/documentation/node-mapnik/3.6/#Image.demultiply\" target=\"_blank\" rel=\"noopener\">demultiply</a>解构为 buffer 返回给 tilestrata 就好了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// （代码有所精简）</span></span><br><span class=\"line\"><span class=\"keyword\">async</span>.eachSeries(images, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 依次合并图片</span></span><br><span class=\"line\">    intermediate.composite(image, res[<span class=\"number\">1</span>], callback);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 结构返回buffer</span></span><br><span class=\"line\">    intermediate.demultiply(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">            callback(<span class=\"literal\">null</span>, buffer, &#123;<span class=\"string\">'Content-Type'</span>: <span class=\"string\">'image/png'</span>&#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>"},{"title":"tilestrata-dependency 插件使用及浅析","date":"2019-07-07T09:02:17.000Z","_content":"\n[tilestrata-dependency](https://github.com/naturalatlas/tilestrata-dependency)插件其实就是共享其他图层的数据源，如果你想定义两个不同格式的图层，例如分别是 png 和 jpg，这个插件就会非常的便利。你甚至可以传入一个 function 来精确控制不同层级使用不同图层的数据源。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-dependency --save\n```\n\n# 2. 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst dependency = require('tilestrata-dependency')\nconst mapnik = require('tilestrata-mapnik')\n\nconst server = tilestrata()\n\nserver\n  // 定义世界边界png图层\n  .layer('world_merc_png')\n  .route('tile.png')\n  .use(\n    mapnik({\n      pathname: 'style/world.xml'\n    })\n  )\n\nserver\n  // 定义世界边界jpg图层\n  .layer('world_merc_jpg')\n  .route('tile.jpg')\n  // 直接用png的源\n  .use(dependency('world_merc_png', 'tile.png'))\n\nserver\n  .layer('function_layer')\n  .route('tile.jpg')\n  // 不同层级用不同的源\n  .use(dependency(function(req) {\n    if (req.z < 5) {\n      return ['world_merc_png', 'tile.png'];\n    }\n    return ['world_merc_jpg', 'tile.jpg'];\n  });\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n`world_merc_png`和`world_merc_jpg`使用了相同的源，展示的内容一模一样：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-dependency-20190705152851.png)\n\n# 4. 代码浅析\n\n要弄清楚`dependency`插件的实现，首先要弄清楚它的类型，dependency 源代码很简单，它属于`Providers`类型的插件:\n\n```js\n// Providers 类型插件需要提供serve方法\nserve: function(server, tile, callback) {\n    callback(err, buffer, headers);\n},\n```\n\n接下来的代码主要逻辑就是如何利用指定的图层源创造一个`buffer`返回给新图层，以下代码就是 server 函数，有所精简：\n\n```js\n// req 即上面的tile参数，包含请求的瓦片地址和类型，例如tile.jpg\nvar mock = req.clone()\n// source 即指定的其他图层的数据源['world_merc_png', 'tile.png']\nvar source = getSource(req)\n\n// 分别把当前tile的layer和filename替换成指定源的对应值\nmock.layer = source[0]\nmock.filename = source[1]\n\n// server 即上面的server参数，代表整个tilestrata服务\nserver.serve(mock, false, function(status, buffer, headers) {\n  if (status === 200) {\n    // 利用伪造出来的指定源的请求内容去向服务器请求数据，获取buffer后返回给当前源\n    callback(null, buffer, headers)\n  } else {\n    callback(err)\n  }\n})\n```\n\n当前图层拿到了 buffer 内容，只要再进入自己后续的加工逻辑，处理成指定格式返回就好了。\n","source":"_posts/2019/tilestrata-dependency.md","raw":"---\ntitle: tilestrata-dependency 插件使用及浅析\ndate: 2019-07-07 17:02:17\ntags: [GIS]\ncategories: TileStrata\n---\n\n[tilestrata-dependency](https://github.com/naturalatlas/tilestrata-dependency)插件其实就是共享其他图层的数据源，如果你想定义两个不同格式的图层，例如分别是 png 和 jpg，这个插件就会非常的便利。你甚至可以传入一个 function 来精确控制不同层级使用不同图层的数据源。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-dependency --save\n```\n\n# 2. 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst dependency = require('tilestrata-dependency')\nconst mapnik = require('tilestrata-mapnik')\n\nconst server = tilestrata()\n\nserver\n  // 定义世界边界png图层\n  .layer('world_merc_png')\n  .route('tile.png')\n  .use(\n    mapnik({\n      pathname: 'style/world.xml'\n    })\n  )\n\nserver\n  // 定义世界边界jpg图层\n  .layer('world_merc_jpg')\n  .route('tile.jpg')\n  // 直接用png的源\n  .use(dependency('world_merc_png', 'tile.png'))\n\nserver\n  .layer('function_layer')\n  .route('tile.jpg')\n  // 不同层级用不同的源\n  .use(dependency(function(req) {\n    if (req.z < 5) {\n      return ['world_merc_png', 'tile.png'];\n    }\n    return ['world_merc_jpg', 'tile.jpg'];\n  });\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n`world_merc_png`和`world_merc_jpg`使用了相同的源，展示的内容一模一样：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-dependency-20190705152851.png)\n\n# 4. 代码浅析\n\n要弄清楚`dependency`插件的实现，首先要弄清楚它的类型，dependency 源代码很简单，它属于`Providers`类型的插件:\n\n```js\n// Providers 类型插件需要提供serve方法\nserve: function(server, tile, callback) {\n    callback(err, buffer, headers);\n},\n```\n\n接下来的代码主要逻辑就是如何利用指定的图层源创造一个`buffer`返回给新图层，以下代码就是 server 函数，有所精简：\n\n```js\n// req 即上面的tile参数，包含请求的瓦片地址和类型，例如tile.jpg\nvar mock = req.clone()\n// source 即指定的其他图层的数据源['world_merc_png', 'tile.png']\nvar source = getSource(req)\n\n// 分别把当前tile的layer和filename替换成指定源的对应值\nmock.layer = source[0]\nmock.filename = source[1]\n\n// server 即上面的server参数，代表整个tilestrata服务\nserver.serve(mock, false, function(status, buffer, headers) {\n  if (status === 200) {\n    // 利用伪造出来的指定源的请求内容去向服务器请求数据，获取buffer后返回给当前源\n    callback(null, buffer, headers)\n  } else {\n    callback(err)\n  }\n})\n```\n\n当前图层拿到了 buffer 内容，只要再进入自己后续的加工逻辑，处理成指定格式返回就好了。\n","slug":"tilestrata-dependency","published":1,"updated":"2019-07-07T09:04:03.888Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy4fqa9u000u0n3iqck7r6tv","content":"<p><a href=\"https://github.com/naturalatlas/tilestrata-dependency\" target=\"_blank\" rel=\"noopener\">tilestrata-dependency</a>插件其实就是共享其他图层的数据源，如果你想定义两个不同格式的图层，例如分别是 png 和 jpg，这个插件就会非常的便利。你甚至可以传入一个 function 来精确控制不同层级使用不同图层的数据源。</p>\n<a id=\"more\"></a>\n<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-dependency --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> dependency = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-dependency'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  <span class=\"comment\">// 定义世界边界png图层</span></span><br><span class=\"line\">  .layer(<span class=\"string\">'world_merc_png'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/world.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  <span class=\"comment\">// 定义世界边界jpg图层</span></span><br><span class=\"line\">  .layer(<span class=\"string\">'world_merc_jpg'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.jpg'</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 直接用png的源</span></span><br><span class=\"line\">  .use(dependency(<span class=\"string\">'world_merc_png'</span>, <span class=\"string\">'tile.png'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'function_layer'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.jpg'</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 不同层级用不同的源</span></span><br><span class=\"line\">  .use(dependency(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (req.z &lt; <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> [<span class=\"string\">'world_merc_png'</span>, <span class=\"string\">'tile.png'</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"string\">'world_merc_jpg'</span>, <span class=\"string\">'tile.jpg'</span>];</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p><code>world_merc_png</code>和<code>world_merc_jpg</code>使用了相同的源，展示的内容一模一样：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-dependency-20190705152851.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>要弄清楚<code>dependency</code>插件的实现，首先要弄清楚它的类型，dependency 源代码很简单，它属于<code>Providers</code>类型的插件:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Providers 类型插件需要提供serve方法</span></span><br><span class=\"line\">serve: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, tile, callback</span>) </span>&#123;</span><br><span class=\"line\">    callback(err, buffer, headers);</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>接下来的代码主要逻辑就是如何利用指定的图层源创造一个<code>buffer</code>返回给新图层，以下代码就是 server 函数，有所精简：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// req 即上面的tile参数，包含请求的瓦片地址和类型，例如tile.jpg</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mock = req.clone()</span><br><span class=\"line\"><span class=\"comment\">// source 即指定的其他图层的数据源['world_merc_png', 'tile.png']</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> source = getSource(req)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 分别把当前tile的layer和filename替换成指定源的对应值</span></span><br><span class=\"line\">mock.layer = source[<span class=\"number\">0</span>]</span><br><span class=\"line\">mock.filename = source[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// server 即上面的server参数，代表整个tilestrata服务</span></span><br><span class=\"line\">server.serve(mock, <span class=\"literal\">false</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">status, buffer, headers</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (status === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 利用伪造出来的指定源的请求内容去向服务器请求数据，获取buffer后返回给当前源</span></span><br><span class=\"line\">    callback(<span class=\"literal\">null</span>, buffer, headers)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    callback(err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>当前图层拿到了 buffer 内容，只要再进入自己后续的加工逻辑，处理成指定格式返回就好了。</p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/naturalatlas/tilestrata-dependency\" target=\"_blank\" rel=\"noopener\">tilestrata-dependency</a>插件其实就是共享其他图层的数据源，如果你想定义两个不同格式的图层，例如分别是 png 和 jpg，这个插件就会非常的便利。你甚至可以传入一个 function 来精确控制不同层级使用不同图层的数据源。</p>","more":"<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-dependency --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> dependency = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-dependency'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  <span class=\"comment\">// 定义世界边界png图层</span></span><br><span class=\"line\">  .layer(<span class=\"string\">'world_merc_png'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/world.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  <span class=\"comment\">// 定义世界边界jpg图层</span></span><br><span class=\"line\">  .layer(<span class=\"string\">'world_merc_jpg'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.jpg'</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 直接用png的源</span></span><br><span class=\"line\">  .use(dependency(<span class=\"string\">'world_merc_png'</span>, <span class=\"string\">'tile.png'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'function_layer'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.jpg'</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 不同层级用不同的源</span></span><br><span class=\"line\">  .use(dependency(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (req.z &lt; <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> [<span class=\"string\">'world_merc_png'</span>, <span class=\"string\">'tile.png'</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"string\">'world_merc_jpg'</span>, <span class=\"string\">'tile.jpg'</span>];</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p><code>world_merc_png</code>和<code>world_merc_jpg</code>使用了相同的源，展示的内容一模一样：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-dependency-20190705152851.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>要弄清楚<code>dependency</code>插件的实现，首先要弄清楚它的类型，dependency 源代码很简单，它属于<code>Providers</code>类型的插件:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Providers 类型插件需要提供serve方法</span></span><br><span class=\"line\">serve: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, tile, callback</span>) </span>&#123;</span><br><span class=\"line\">    callback(err, buffer, headers);</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>接下来的代码主要逻辑就是如何利用指定的图层源创造一个<code>buffer</code>返回给新图层，以下代码就是 server 函数，有所精简：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// req 即上面的tile参数，包含请求的瓦片地址和类型，例如tile.jpg</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mock = req.clone()</span><br><span class=\"line\"><span class=\"comment\">// source 即指定的其他图层的数据源['world_merc_png', 'tile.png']</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> source = getSource(req)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 分别把当前tile的layer和filename替换成指定源的对应值</span></span><br><span class=\"line\">mock.layer = source[<span class=\"number\">0</span>]</span><br><span class=\"line\">mock.filename = source[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// server 即上面的server参数，代表整个tilestrata服务</span></span><br><span class=\"line\">server.serve(mock, <span class=\"literal\">false</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">status, buffer, headers</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (status === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 利用伪造出来的指定源的请求内容去向服务器请求数据，获取buffer后返回给当前源</span></span><br><span class=\"line\">    callback(<span class=\"literal\">null</span>, buffer, headers)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    callback(err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>当前图层拿到了 buffer 内容，只要再进入自己后续的加工逻辑，处理成指定格式返回就好了。</p>"},{"title":"tilestrata-disk 插件使用及浅析","date":"2019-07-15T13:39:59.000Z","_content":"\n[tilestrata-disk](https://github.com/naturalatlas/tilestrata-disk)插件可以在磁盘中存储/检索瓦片。它可以兼顾瓦片缓存和瓦片提供两个功能，代码虽简单，但是功能十分全面，个人感觉非常的实用，很值得推荐。\n\n用它来缓存瓦片时，一定要为每个图层使用不同的目录（例如：\"tiles/layer_a\", \"tiles/layer_b\"）。如果设置了`maxage`参数，插件会检查瓦片的最近一次修改时间，如果间隔过长，将返回`null`。如果 设置`maxage=0`，就相当于没有开启缓存功能。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-disk --save\n```\n\n# 2. 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst mapnik = require('tilestrata-mapnik')\nconst disk = require('tilestrata-disk')\nconst server = tilestrata()\n\nserver\n  .layer('world_merc')\n  .route('tile.png')\n  // 直接缓存\n  .use(disk.cache({ dir: 'tilecache/world' }))\n  .use(\n    mapnik({\n      pathname: 'style/world.xml'\n    })\n  )\n\nserver\n  .layer('province')\n  .route('tile.png')\n  // 不同图层使用不同目录，同时设置最大缓存时间3600秒\n  .use(disk.cache({ maxage: 3600, dir: 'tilecache/province' }))\n  .use(\n    mapnik({\n      pathname: 'style/province.xml'\n    })\n  )\n\nserver.listen(9527)\n```\n\n此外，disk 插件的功能远不止如此：\n\n```js\n// 设置maxage为function，控制不同层级的过期时间\nserver\n  .layer('mylayer')\n  .route('tile.png')\n  .use(/* some provider */)\n  .use(\n    disk.cache({\n      dir: './tiles/mylayer',\n      maxage: function(server, req) {\n        if (req.z > 15) return 0 // 不缓存\n        if (req.z > 13) return 3600\n        return 3600 * 24\n      }\n    })\n  )\n\n// 可以通过path自定义缓存的结构和文件名\nserver\n  .layer('mylayer')\n  .route('tile.png')\n  .use(/* some provider */)\n  .use(disk.cache({ path: './tiles/{layer}/{z}/{x}/{y}-{filename}' }))\n\n// 通过callback的方式来设置\nserver\n  .layer('mylayer')\n  .route('tile.png')\n  .use(/* some provider */)\n  .use(\n    disk.cache({\n      path: function(tile) {\n        return './tiles/' + tile.layer + '/' + tile.z + '/' /* ... */\n      }\n    })\n  )\n\n// 直接使用缓存下来的文件当作provider，这样就不调用服务器生成图片了\nserver\n  .layer('mylayer')\n  .route('tile.png')\n  .use(disk.provider('/path/to/dir/{z}/{x}/{y}/file.png'))\n```\n\n甚至在`0.6.0`及其以上的 tilestrata 版本中，你还可以通过设定`refreshage`来控制缓存数据的寿命，这个参数需要与`maxage`一起设设置：\n\n```js\n.use(disk.cache({\n    dir: './tiles/mylayer',\n    refreshage: 3600, // 1 hour\n    maxage: 3600*24*7 // 1 week\n}));\n\nrefreshage: null  // 永远不刷新缓存\nrefreshage: 0     // 命中一次后就刷新\nrefreshage: 1800  // 半小时后刷新\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n下图中设置了`tilecache`缓存目录，可以看到瓦片会按照层级建立对应的目录结构并保存图片：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-disk-20190705160620.png)\n\n# 4. 代码浅析\n\n因为插件即提供了`cache`功能，也提供了`Provider`功能，所以其实它是这两种类型插件的组合，作为`Provider`还是比较简单的，核心是 serve 方法:\n\n```js\nserve: function(server, tile, callback) {\n  // 解析路径\n  var file = template\n    .replace('{layer}', tile.layer)\n    .replace('{filename}', tile.filename)\n    .replace('{x}', tile.x)\n    .replace('{y}', tile.y)\n    .replace('{z}', tile.z);\n\n  // 根绝路径读取文件为buffer\n  fs.readFile(file, function(err, buffer) {\n    if (err) {\n      if (err.code === 'ENOENT') {\n        var err = new Error('File not found');\n        err.statusCode = 404;\n        return callback(err);\n      }\n      return callback(err);\n    }\n    // 返回buffer给tilestrata\n    callback(null, buffer, {'Content-Type': mime(file)});\n  });\n}\n```\n\n在`cache`功能中，需要提供 get 和 set 方法，主要就是在 set 方法中保存文件，在 get 方法中判断是否过期，是否文件名命中缓存，收否需要刷新，之后再返回对应结果的内容：\n\n```js\n// set 方法\nFileSystemCache.prototype.set = function(\n  server,\n  req,\n  buffer,\n  headers,\n  callback\n) {\n  var maxage = this.ageTolerance('maxage', req)\n  if (maxage === 0) return callback()\n  // 只要maxage不为0，就在文件系统上存储图片，this._file是根据path或者dir设置计算出来的存储路径\n  fs.outputFile(this._file(req), buffer, callback)\n}\n```\n\n```js\n// get 方法（有所精简）\nFileSystemCache.prototype.get = function(server, req, callback) {\n  var maxage = this.ageTolerance('maxage', req)\n  // maxage为0，直接结束\n  if (maxage === 0) return done()\n\n  var self = this\n  // 获取缓存文件路径\n  var file = this._file(req)\n  fs.open(file, 'r', function(err, fd) {\n    fs.fstat(fd, function(err, stats) {\n      if (err) return done(err)\n      var mtime = stats.mtime.getTime()\n\n      // 根据maxage是否过期判断是否直接结束\n      var shouldServe = self.shouldServe(mtime, req)\n      if (!shouldServe) return done()\n\n      // 根据refreshage判断是否刷新\n      var shouldRefresh = self.shouldRefresh(mtime, req)\n      var headers = { 'Content-Type': mime(file) }\n      var buffer = new Buffer(stats.size)\n\n      // 如果没有这个文件，直接结束\n      if (!stats.size) {\n        return done(null, buffer, headers, shouldRefresh)\n      }\n\n      // 如果前面的都通过则读取文件为buffer\n      fs.read(fd, buffer, 0, stats.size, 0, function(err) {\n        if (err) return done(err)\n        // 返回buffer\n        done(null, buffer, headers, shouldRefresh)\n      })\n    })\n  })\n}\n```\n","source":"_posts/2019/tilestrata-disk.md","raw":"---\ntitle: tilestrata-disk 插件使用及浅析\ndate: 2019-07-15 21:39:59\ntags: [GIS]\ncategories: TileStrata\n---\n\n[tilestrata-disk](https://github.com/naturalatlas/tilestrata-disk)插件可以在磁盘中存储/检索瓦片。它可以兼顾瓦片缓存和瓦片提供两个功能，代码虽简单，但是功能十分全面，个人感觉非常的实用，很值得推荐。\n\n用它来缓存瓦片时，一定要为每个图层使用不同的目录（例如：\"tiles/layer_a\", \"tiles/layer_b\"）。如果设置了`maxage`参数，插件会检查瓦片的最近一次修改时间，如果间隔过长，将返回`null`。如果 设置`maxage=0`，就相当于没有开启缓存功能。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-disk --save\n```\n\n# 2. 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst mapnik = require('tilestrata-mapnik')\nconst disk = require('tilestrata-disk')\nconst server = tilestrata()\n\nserver\n  .layer('world_merc')\n  .route('tile.png')\n  // 直接缓存\n  .use(disk.cache({ dir: 'tilecache/world' }))\n  .use(\n    mapnik({\n      pathname: 'style/world.xml'\n    })\n  )\n\nserver\n  .layer('province')\n  .route('tile.png')\n  // 不同图层使用不同目录，同时设置最大缓存时间3600秒\n  .use(disk.cache({ maxage: 3600, dir: 'tilecache/province' }))\n  .use(\n    mapnik({\n      pathname: 'style/province.xml'\n    })\n  )\n\nserver.listen(9527)\n```\n\n此外，disk 插件的功能远不止如此：\n\n```js\n// 设置maxage为function，控制不同层级的过期时间\nserver\n  .layer('mylayer')\n  .route('tile.png')\n  .use(/* some provider */)\n  .use(\n    disk.cache({\n      dir: './tiles/mylayer',\n      maxage: function(server, req) {\n        if (req.z > 15) return 0 // 不缓存\n        if (req.z > 13) return 3600\n        return 3600 * 24\n      }\n    })\n  )\n\n// 可以通过path自定义缓存的结构和文件名\nserver\n  .layer('mylayer')\n  .route('tile.png')\n  .use(/* some provider */)\n  .use(disk.cache({ path: './tiles/{layer}/{z}/{x}/{y}-{filename}' }))\n\n// 通过callback的方式来设置\nserver\n  .layer('mylayer')\n  .route('tile.png')\n  .use(/* some provider */)\n  .use(\n    disk.cache({\n      path: function(tile) {\n        return './tiles/' + tile.layer + '/' + tile.z + '/' /* ... */\n      }\n    })\n  )\n\n// 直接使用缓存下来的文件当作provider，这样就不调用服务器生成图片了\nserver\n  .layer('mylayer')\n  .route('tile.png')\n  .use(disk.provider('/path/to/dir/{z}/{x}/{y}/file.png'))\n```\n\n甚至在`0.6.0`及其以上的 tilestrata 版本中，你还可以通过设定`refreshage`来控制缓存数据的寿命，这个参数需要与`maxage`一起设设置：\n\n```js\n.use(disk.cache({\n    dir: './tiles/mylayer',\n    refreshage: 3600, // 1 hour\n    maxage: 3600*24*7 // 1 week\n}));\n\nrefreshage: null  // 永远不刷新缓存\nrefreshage: 0     // 命中一次后就刷新\nrefreshage: 1800  // 半小时后刷新\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n下图中设置了`tilecache`缓存目录，可以看到瓦片会按照层级建立对应的目录结构并保存图片：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-disk-20190705160620.png)\n\n# 4. 代码浅析\n\n因为插件即提供了`cache`功能，也提供了`Provider`功能，所以其实它是这两种类型插件的组合，作为`Provider`还是比较简单的，核心是 serve 方法:\n\n```js\nserve: function(server, tile, callback) {\n  // 解析路径\n  var file = template\n    .replace('{layer}', tile.layer)\n    .replace('{filename}', tile.filename)\n    .replace('{x}', tile.x)\n    .replace('{y}', tile.y)\n    .replace('{z}', tile.z);\n\n  // 根绝路径读取文件为buffer\n  fs.readFile(file, function(err, buffer) {\n    if (err) {\n      if (err.code === 'ENOENT') {\n        var err = new Error('File not found');\n        err.statusCode = 404;\n        return callback(err);\n      }\n      return callback(err);\n    }\n    // 返回buffer给tilestrata\n    callback(null, buffer, {'Content-Type': mime(file)});\n  });\n}\n```\n\n在`cache`功能中，需要提供 get 和 set 方法，主要就是在 set 方法中保存文件，在 get 方法中判断是否过期，是否文件名命中缓存，收否需要刷新，之后再返回对应结果的内容：\n\n```js\n// set 方法\nFileSystemCache.prototype.set = function(\n  server,\n  req,\n  buffer,\n  headers,\n  callback\n) {\n  var maxage = this.ageTolerance('maxage', req)\n  if (maxage === 0) return callback()\n  // 只要maxage不为0，就在文件系统上存储图片，this._file是根据path或者dir设置计算出来的存储路径\n  fs.outputFile(this._file(req), buffer, callback)\n}\n```\n\n```js\n// get 方法（有所精简）\nFileSystemCache.prototype.get = function(server, req, callback) {\n  var maxage = this.ageTolerance('maxage', req)\n  // maxage为0，直接结束\n  if (maxage === 0) return done()\n\n  var self = this\n  // 获取缓存文件路径\n  var file = this._file(req)\n  fs.open(file, 'r', function(err, fd) {\n    fs.fstat(fd, function(err, stats) {\n      if (err) return done(err)\n      var mtime = stats.mtime.getTime()\n\n      // 根据maxage是否过期判断是否直接结束\n      var shouldServe = self.shouldServe(mtime, req)\n      if (!shouldServe) return done()\n\n      // 根据refreshage判断是否刷新\n      var shouldRefresh = self.shouldRefresh(mtime, req)\n      var headers = { 'Content-Type': mime(file) }\n      var buffer = new Buffer(stats.size)\n\n      // 如果没有这个文件，直接结束\n      if (!stats.size) {\n        return done(null, buffer, headers, shouldRefresh)\n      }\n\n      // 如果前面的都通过则读取文件为buffer\n      fs.read(fd, buffer, 0, stats.size, 0, function(err) {\n        if (err) return done(err)\n        // 返回buffer\n        done(null, buffer, headers, shouldRefresh)\n      })\n    })\n  })\n}\n```\n","slug":"tilestrata-disk","published":1,"updated":"2019-07-15T13:41:40.872Z","_id":"cjy4fqa9v000w0n3ibndnjt0w","comments":1,"layout":"post","photos":[],"link":"","content":"<p><a href=\"https://github.com/naturalatlas/tilestrata-disk\" target=\"_blank\" rel=\"noopener\">tilestrata-disk</a>插件可以在磁盘中存储/检索瓦片。它可以兼顾瓦片缓存和瓦片提供两个功能，代码虽简单，但是功能十分全面，个人感觉非常的实用，很值得推荐。</p>\n<p>用它来缓存瓦片时，一定要为每个图层使用不同的目录（例如：”tiles/layer_a”, “tiles/layer_b”）。如果设置了<code>maxage</code>参数，插件会检查瓦片的最近一次修改时间，如果间隔过长，将返回<code>null</code>。如果 设置<code>maxage=0</code>，就相当于没有开启缓存功能。</p>\n<a id=\"more\"></a>\n<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-disk --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> disk = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-disk'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'world_merc'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 直接缓存</span></span><br><span class=\"line\">  .use(disk.cache(&#123; <span class=\"attr\">dir</span>: <span class=\"string\">'tilecache/world'</span> &#125;))</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/world.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'province'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 不同图层使用不同目录，同时设置最大缓存时间3600秒</span></span><br><span class=\"line\">  .use(disk.cache(&#123; <span class=\"attr\">maxage</span>: <span class=\"number\">3600</span>, <span class=\"attr\">dir</span>: <span class=\"string\">'tilecache/province'</span> &#125;))</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/province.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<p>此外，disk 插件的功能远不止如此：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置maxage为function，控制不同层级的过期时间</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'mylayer'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(<span class=\"comment\">/* some provider */</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    disk.cache(&#123;</span><br><span class=\"line\">      dir: <span class=\"string\">'./tiles/mylayer'</span>,</span><br><span class=\"line\">      maxage: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (req.z &gt; <span class=\"number\">15</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span> <span class=\"comment\">// 不缓存</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (req.z &gt; <span class=\"number\">13</span>) <span class=\"keyword\">return</span> <span class=\"number\">3600</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3600</span> * <span class=\"number\">24</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以通过path自定义缓存的结构和文件名</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'mylayer'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(<span class=\"comment\">/* some provider */</span>)</span><br><span class=\"line\">  .use(disk.cache(&#123; <span class=\"attr\">path</span>: <span class=\"string\">'./tiles/&#123;layer&#125;/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;-&#123;filename&#125;'</span> &#125;))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过callback的方式来设置</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'mylayer'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(<span class=\"comment\">/* some provider */</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    disk.cache(&#123;</span><br><span class=\"line\">      path: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tile</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'./tiles/'</span> + tile.layer + <span class=\"string\">'/'</span> + tile.z + <span class=\"string\">'/'</span> <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 直接使用缓存下来的文件当作provider，这样就不调用服务器生成图片了</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'mylayer'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(disk.provider(<span class=\"string\">'/path/to/dir/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;/file.png'</span>))</span><br></pre></td></tr></table></figure>\n<p>甚至在<code>0.6.0</code>及其以上的 tilestrata 版本中，你还可以通过设定<code>refreshage</code>来控制缓存数据的寿命，这个参数需要与<code>maxage</code>一起设设置：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">.use(disk.cache(&#123;</span><br><span class=\"line\">    dir: <span class=\"string\">'./tiles/mylayer'</span>,</span><br><span class=\"line\">    refreshage: <span class=\"number\">3600</span>, <span class=\"comment\">// 1 hour</span></span><br><span class=\"line\">    maxage: <span class=\"number\">3600</span>*<span class=\"number\">24</span>*<span class=\"number\">7</span> <span class=\"comment\">// 1 week</span></span><br><span class=\"line\">&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\">refreshage: <span class=\"literal\">null</span>  <span class=\"comment\">// 永远不刷新缓存</span></span><br><span class=\"line\">refreshage: <span class=\"number\">0</span>     <span class=\"comment\">// 命中一次后就刷新</span></span><br><span class=\"line\">refreshage: <span class=\"number\">1800</span>  <span class=\"comment\">// 半小时后刷新</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>下图中设置了<code>tilecache</code>缓存目录，可以看到瓦片会按照层级建立对应的目录结构并保存图片：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-disk-20190705160620.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>因为插件即提供了<code>cache</code>功能，也提供了<code>Provider</code>功能，所以其实它是这两种类型插件的组合，作为<code>Provider</code>还是比较简单的，核心是 serve 方法:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">serve: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, tile, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 解析路径</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> file = template</span><br><span class=\"line\">    .replace(<span class=\"string\">'&#123;layer&#125;'</span>, tile.layer)</span><br><span class=\"line\">    .replace(<span class=\"string\">'&#123;filename&#125;'</span>, tile.filename)</span><br><span class=\"line\">    .replace(<span class=\"string\">'&#123;x&#125;'</span>, tile.x)</span><br><span class=\"line\">    .replace(<span class=\"string\">'&#123;y&#125;'</span>, tile.y)</span><br><span class=\"line\">    .replace(<span class=\"string\">'&#123;z&#125;'</span>, tile.z);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 根绝路径读取文件为buffer</span></span><br><span class=\"line\">  fs.readFile(file, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, buffer</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (err.code === <span class=\"string\">'ENOENT'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> err = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'File not found'</span>);</span><br><span class=\"line\">        err.statusCode = <span class=\"number\">404</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> callback(err);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> callback(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回buffer给tilestrata</span></span><br><span class=\"line\">    callback(<span class=\"literal\">null</span>, buffer, &#123;<span class=\"string\">'Content-Type'</span>: mime(file)&#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>cache</code>功能中，需要提供 get 和 set 方法，主要就是在 set 方法中保存文件，在 get 方法中判断是否过期，是否文件名命中缓存，收否需要刷新，之后再返回对应结果的内容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// set 方法</span></span><br><span class=\"line\">FileSystemCache.prototype.set = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  server,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  req,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  buffer,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  headers,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  callback</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> maxage = <span class=\"keyword\">this</span>.ageTolerance(<span class=\"string\">'maxage'</span>, req)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (maxage === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> callback()</span><br><span class=\"line\">  <span class=\"comment\">// 只要maxage不为0，就在文件系统上存储图片，this._file是根据path或者dir设置计算出来的存储路径</span></span><br><span class=\"line\">  fs.outputFile(<span class=\"keyword\">this</span>._file(req), buffer, callback)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// get 方法（有所精简）</span></span><br><span class=\"line\">FileSystemCache.prototype.get = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> maxage = <span class=\"keyword\">this</span>.ageTolerance(<span class=\"string\">'maxage'</span>, req)</span><br><span class=\"line\">  <span class=\"comment\">// maxage为0，直接结束</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (maxage === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> done()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\">  <span class=\"comment\">// 获取缓存文件路径</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> file = <span class=\"keyword\">this</span>._file(req)</span><br><span class=\"line\">  fs.open(file, <span class=\"string\">'r'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, fd</span>) </span>&#123;</span><br><span class=\"line\">    fs.fstat(fd, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, stats</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> done(err)</span><br><span class=\"line\">      <span class=\"keyword\">var</span> mtime = stats.mtime.getTime()</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 根据maxage是否过期判断是否直接结束</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> shouldServe = self.shouldServe(mtime, req)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!shouldServe) <span class=\"keyword\">return</span> done()</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 根据refreshage判断是否刷新</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> shouldRefresh = self.shouldRefresh(mtime, req)</span><br><span class=\"line\">      <span class=\"keyword\">var</span> headers = &#123; <span class=\"string\">'Content-Type'</span>: mime(file) &#125;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> Buffer(stats.size)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 如果没有这个文件，直接结束</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!stats.size) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> done(<span class=\"literal\">null</span>, buffer, headers, shouldRefresh)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 如果前面的都通过则读取文件为buffer</span></span><br><span class=\"line\">      fs.read(fd, buffer, <span class=\"number\">0</span>, stats.size, <span class=\"number\">0</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> done(err)</span><br><span class=\"line\">        <span class=\"comment\">// 返回buffer</span></span><br><span class=\"line\">        done(<span class=\"literal\">null</span>, buffer, headers, shouldRefresh)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/naturalatlas/tilestrata-disk\" target=\"_blank\" rel=\"noopener\">tilestrata-disk</a>插件可以在磁盘中存储/检索瓦片。它可以兼顾瓦片缓存和瓦片提供两个功能，代码虽简单，但是功能十分全面，个人感觉非常的实用，很值得推荐。</p>\n<p>用它来缓存瓦片时，一定要为每个图层使用不同的目录（例如：”tiles/layer_a”, “tiles/layer_b”）。如果设置了<code>maxage</code>参数，插件会检查瓦片的最近一次修改时间，如果间隔过长，将返回<code>null</code>。如果 设置<code>maxage=0</code>，就相当于没有开启缓存功能。</p>","more":"<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-disk --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> disk = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-disk'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'world_merc'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 直接缓存</span></span><br><span class=\"line\">  .use(disk.cache(&#123; <span class=\"attr\">dir</span>: <span class=\"string\">'tilecache/world'</span> &#125;))</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/world.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'province'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 不同图层使用不同目录，同时设置最大缓存时间3600秒</span></span><br><span class=\"line\">  .use(disk.cache(&#123; <span class=\"attr\">maxage</span>: <span class=\"number\">3600</span>, <span class=\"attr\">dir</span>: <span class=\"string\">'tilecache/province'</span> &#125;))</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/province.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<p>此外，disk 插件的功能远不止如此：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置maxage为function，控制不同层级的过期时间</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'mylayer'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(<span class=\"comment\">/* some provider */</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    disk.cache(&#123;</span><br><span class=\"line\">      dir: <span class=\"string\">'./tiles/mylayer'</span>,</span><br><span class=\"line\">      maxage: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (req.z &gt; <span class=\"number\">15</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span> <span class=\"comment\">// 不缓存</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (req.z &gt; <span class=\"number\">13</span>) <span class=\"keyword\">return</span> <span class=\"number\">3600</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">3600</span> * <span class=\"number\">24</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以通过path自定义缓存的结构和文件名</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'mylayer'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(<span class=\"comment\">/* some provider */</span>)</span><br><span class=\"line\">  .use(disk.cache(&#123; <span class=\"attr\">path</span>: <span class=\"string\">'./tiles/&#123;layer&#125;/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;-&#123;filename&#125;'</span> &#125;))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过callback的方式来设置</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'mylayer'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(<span class=\"comment\">/* some provider */</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    disk.cache(&#123;</span><br><span class=\"line\">      path: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tile</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'./tiles/'</span> + tile.layer + <span class=\"string\">'/'</span> + tile.z + <span class=\"string\">'/'</span> <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 直接使用缓存下来的文件当作provider，这样就不调用服务器生成图片了</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'mylayer'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(disk.provider(<span class=\"string\">'/path/to/dir/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;/file.png'</span>))</span><br></pre></td></tr></table></figure>\n<p>甚至在<code>0.6.0</code>及其以上的 tilestrata 版本中，你还可以通过设定<code>refreshage</code>来控制缓存数据的寿命，这个参数需要与<code>maxage</code>一起设设置：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">.use(disk.cache(&#123;</span><br><span class=\"line\">    dir: <span class=\"string\">'./tiles/mylayer'</span>,</span><br><span class=\"line\">    refreshage: <span class=\"number\">3600</span>, <span class=\"comment\">// 1 hour</span></span><br><span class=\"line\">    maxage: <span class=\"number\">3600</span>*<span class=\"number\">24</span>*<span class=\"number\">7</span> <span class=\"comment\">// 1 week</span></span><br><span class=\"line\">&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\">refreshage: <span class=\"literal\">null</span>  <span class=\"comment\">// 永远不刷新缓存</span></span><br><span class=\"line\">refreshage: <span class=\"number\">0</span>     <span class=\"comment\">// 命中一次后就刷新</span></span><br><span class=\"line\">refreshage: <span class=\"number\">1800</span>  <span class=\"comment\">// 半小时后刷新</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>下图中设置了<code>tilecache</code>缓存目录，可以看到瓦片会按照层级建立对应的目录结构并保存图片：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-disk-20190705160620.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>因为插件即提供了<code>cache</code>功能，也提供了<code>Provider</code>功能，所以其实它是这两种类型插件的组合，作为<code>Provider</code>还是比较简单的，核心是 serve 方法:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">serve: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, tile, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 解析路径</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> file = template</span><br><span class=\"line\">    .replace(<span class=\"string\">'&#123;layer&#125;'</span>, tile.layer)</span><br><span class=\"line\">    .replace(<span class=\"string\">'&#123;filename&#125;'</span>, tile.filename)</span><br><span class=\"line\">    .replace(<span class=\"string\">'&#123;x&#125;'</span>, tile.x)</span><br><span class=\"line\">    .replace(<span class=\"string\">'&#123;y&#125;'</span>, tile.y)</span><br><span class=\"line\">    .replace(<span class=\"string\">'&#123;z&#125;'</span>, tile.z);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 根绝路径读取文件为buffer</span></span><br><span class=\"line\">  fs.readFile(file, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, buffer</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (err.code === <span class=\"string\">'ENOENT'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> err = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'File not found'</span>);</span><br><span class=\"line\">        err.statusCode = <span class=\"number\">404</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> callback(err);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> callback(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回buffer给tilestrata</span></span><br><span class=\"line\">    callback(<span class=\"literal\">null</span>, buffer, &#123;<span class=\"string\">'Content-Type'</span>: mime(file)&#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>cache</code>功能中，需要提供 get 和 set 方法，主要就是在 set 方法中保存文件，在 get 方法中判断是否过期，是否文件名命中缓存，收否需要刷新，之后再返回对应结果的内容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// set 方法</span></span><br><span class=\"line\">FileSystemCache.prototype.set = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  server,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  req,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  buffer,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  headers,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  callback</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> maxage = <span class=\"keyword\">this</span>.ageTolerance(<span class=\"string\">'maxage'</span>, req)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (maxage === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> callback()</span><br><span class=\"line\">  <span class=\"comment\">// 只要maxage不为0，就在文件系统上存储图片，this._file是根据path或者dir设置计算出来的存储路径</span></span><br><span class=\"line\">  fs.outputFile(<span class=\"keyword\">this</span>._file(req), buffer, callback)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// get 方法（有所精简）</span></span><br><span class=\"line\">FileSystemCache.prototype.get = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> maxage = <span class=\"keyword\">this</span>.ageTolerance(<span class=\"string\">'maxage'</span>, req)</span><br><span class=\"line\">  <span class=\"comment\">// maxage为0，直接结束</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (maxage === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> done()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\">  <span class=\"comment\">// 获取缓存文件路径</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> file = <span class=\"keyword\">this</span>._file(req)</span><br><span class=\"line\">  fs.open(file, <span class=\"string\">'r'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, fd</span>) </span>&#123;</span><br><span class=\"line\">    fs.fstat(fd, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, stats</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> done(err)</span><br><span class=\"line\">      <span class=\"keyword\">var</span> mtime = stats.mtime.getTime()</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 根据maxage是否过期判断是否直接结束</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> shouldServe = self.shouldServe(mtime, req)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!shouldServe) <span class=\"keyword\">return</span> done()</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 根据refreshage判断是否刷新</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> shouldRefresh = self.shouldRefresh(mtime, req)</span><br><span class=\"line\">      <span class=\"keyword\">var</span> headers = &#123; <span class=\"string\">'Content-Type'</span>: mime(file) &#125;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> Buffer(stats.size)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 如果没有这个文件，直接结束</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!stats.size) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> done(<span class=\"literal\">null</span>, buffer, headers, shouldRefresh)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 如果前面的都通过则读取文件为buffer</span></span><br><span class=\"line\">      fs.read(fd, buffer, <span class=\"number\">0</span>, stats.size, <span class=\"number\">0</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> done(err)</span><br><span class=\"line\">        <span class=\"comment\">// 返回buffer</span></span><br><span class=\"line\">        done(<span class=\"literal\">null</span>, buffer, headers, shouldRefresh)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"tilestrata-etag 插件使用及浅析","date":"2019-07-15T13:39:54.000Z","_content":"\n[tilestrata-etag](https://github.com/naturalatlas/tilestrata-etag)插件可以在 tilestrata 的请求中设置 ETag，可以让服务缓存变得更加高效可控，节省带宽。如果客户端的 ETag 的版本和服务器要发送的一致，则可以直接使用缓存中的数据，不再重新发送数据。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-etag --save\n```\n\n# 2. 使用\n\n默认情况下，插件不会对所有大于 512kb 的数据启用，因为在 large buffers 上 ETag 的计算会很占用 CPU 的时间。但你也可以通过`limit`选项来更改这一默认设置，例如设置为`null`将会无视文件的大小上限，设置为一个文件大小的字符串或者数字，则会以此为上限。\n\n```js\nconst tilestrata = require('tilestrata')\nconst etag = require('tilestrata-etag')\nconst dependency = require('tilestrata-dependency')\nconst mapnik = require('tilestrata-mapnik')\nconst server = tilestrata()\n\n// 用mapnik数据源做一个普通的图层来对比\nserver\n  .layer('world_merc')\n  .route('tile.png')\n  .use(disk.cache({ dir: 'tilecache' }))\n  .use(\n    mapnik({\n      pathname: 'style/world.xml'\n    })\n  )\n\n// 用相同的数据源设置etag后做一个新图层来对比\nserver\n  .layer('etag')\n  .route('tile.png')\n  .use(dependency('world_merc', 'tile.png'))\n  .use(etag({ limit: '1mb' }))\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n可以看到 etag 图层所有 response 中已经带上了`ETag`\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-etag-result-20190705101438.png)\n\n# 4. 代码浅析\n\n首先定义插件类型，这其实是一个`Response Hooks`类型的插件，劫持修改了正常的服务返回值。插件引入了`filesize-parser`用来计算文件大小，设置上限`max_length`，使用[etag](https://www.npmjs.com/package/etag)来生成 etag。\n\n```js\n// max_length由limit设置得出\nif (status_type === 2 && result.buffer && result.buffer.length < max_length) {\n  var resultEtag = result.headers['etag'] || result.headers['ETag']\n  // 如果没有etag，就使用etag库生成\n  if (!resultEtag) {\n    resultEtag = etag(result.buffer)\n    result.headers['ETag'] = resultEtag\n  }\n  // 插件还会判断是否有设置if-none-match\n  var ifnonematch = req.headers['if-none-match']\n  if (ifnonematch && ifnonematch === resultEtag) {\n    result.status = 304\n    result.buffer = new Buffer([])\n  }\n}\n```\n","source":"_posts/2019/tilestrata-etag.md","raw":"---\ntitle: tilestrata-etag 插件使用及浅析\ndate: 2019-07-15 21:39:54\ntags: [GIS]\ncategories: TileStrata\n---\n\n[tilestrata-etag](https://github.com/naturalatlas/tilestrata-etag)插件可以在 tilestrata 的请求中设置 ETag，可以让服务缓存变得更加高效可控，节省带宽。如果客户端的 ETag 的版本和服务器要发送的一致，则可以直接使用缓存中的数据，不再重新发送数据。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-etag --save\n```\n\n# 2. 使用\n\n默认情况下，插件不会对所有大于 512kb 的数据启用，因为在 large buffers 上 ETag 的计算会很占用 CPU 的时间。但你也可以通过`limit`选项来更改这一默认设置，例如设置为`null`将会无视文件的大小上限，设置为一个文件大小的字符串或者数字，则会以此为上限。\n\n```js\nconst tilestrata = require('tilestrata')\nconst etag = require('tilestrata-etag')\nconst dependency = require('tilestrata-dependency')\nconst mapnik = require('tilestrata-mapnik')\nconst server = tilestrata()\n\n// 用mapnik数据源做一个普通的图层来对比\nserver\n  .layer('world_merc')\n  .route('tile.png')\n  .use(disk.cache({ dir: 'tilecache' }))\n  .use(\n    mapnik({\n      pathname: 'style/world.xml'\n    })\n  )\n\n// 用相同的数据源设置etag后做一个新图层来对比\nserver\n  .layer('etag')\n  .route('tile.png')\n  .use(dependency('world_merc', 'tile.png'))\n  .use(etag({ limit: '1mb' }))\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n可以看到 etag 图层所有 response 中已经带上了`ETag`\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-etag-result-20190705101438.png)\n\n# 4. 代码浅析\n\n首先定义插件类型，这其实是一个`Response Hooks`类型的插件，劫持修改了正常的服务返回值。插件引入了`filesize-parser`用来计算文件大小，设置上限`max_length`，使用[etag](https://www.npmjs.com/package/etag)来生成 etag。\n\n```js\n// max_length由limit设置得出\nif (status_type === 2 && result.buffer && result.buffer.length < max_length) {\n  var resultEtag = result.headers['etag'] || result.headers['ETag']\n  // 如果没有etag，就使用etag库生成\n  if (!resultEtag) {\n    resultEtag = etag(result.buffer)\n    result.headers['ETag'] = resultEtag\n  }\n  // 插件还会判断是否有设置if-none-match\n  var ifnonematch = req.headers['if-none-match']\n  if (ifnonematch && ifnonematch === resultEtag) {\n    result.status = 304\n    result.buffer = new Buffer([])\n  }\n}\n```\n","slug":"tilestrata-etag","published":1,"updated":"2019-07-15T13:40:53.156Z","_id":"cjy4fqa9w00110n3irsgwa8n9","comments":1,"layout":"post","photos":[],"link":"","content":"<p><a href=\"https://github.com/naturalatlas/tilestrata-etag\" target=\"_blank\" rel=\"noopener\">tilestrata-etag</a>插件可以在 tilestrata 的请求中设置 ETag，可以让服务缓存变得更加高效可控，节省带宽。如果客户端的 ETag 的版本和服务器要发送的一致，则可以直接使用缓存中的数据，不再重新发送数据。</p>\n<a id=\"more\"></a>\n<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-etag --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><p>默认情况下，插件不会对所有大于 512kb 的数据启用，因为在 large buffers 上 ETag 的计算会很占用 CPU 的时间。但你也可以通过<code>limit</code>选项来更改这一默认设置，例如设置为<code>null</code>将会无视文件的大小上限，设置为一个文件大小的字符串或者数字，则会以此为上限。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> etag = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-etag'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> dependency = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-dependency'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用mapnik数据源做一个普通的图层来对比</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'world_merc'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(disk.cache(&#123; <span class=\"attr\">dir</span>: <span class=\"string\">'tilecache'</span> &#125;))</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/world.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用相同的数据源设置etag后做一个新图层来对比</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'etag'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(dependency(<span class=\"string\">'world_merc'</span>, <span class=\"string\">'tile.png'</span>))</span><br><span class=\"line\">  .use(etag(&#123; <span class=\"attr\">limit</span>: <span class=\"string\">'1mb'</span> &#125;))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>可以看到 etag 图层所有 response 中已经带上了<code>ETag</code></p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-etag-result-20190705101438.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>首先定义插件类型，这其实是一个<code>Response Hooks</code>类型的插件，劫持修改了正常的服务返回值。插件引入了<code>filesize-parser</code>用来计算文件大小，设置上限<code>max_length</code>，使用<a href=\"https://www.npmjs.com/package/etag\" target=\"_blank\" rel=\"noopener\">etag</a>来生成 etag。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// max_length由limit设置得出</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (status_type === <span class=\"number\">2</span> &amp;&amp; result.buffer &amp;&amp; result.buffer.length &lt; max_length) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> resultEtag = result.headers[<span class=\"string\">'etag'</span>] || result.headers[<span class=\"string\">'ETag'</span>]</span><br><span class=\"line\">  <span class=\"comment\">// 如果没有etag，就使用etag库生成</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!resultEtag) &#123;</span><br><span class=\"line\">    resultEtag = etag(result.buffer)</span><br><span class=\"line\">    result.headers[<span class=\"string\">'ETag'</span>] = resultEtag</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 插件还会判断是否有设置if-none-match</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> ifnonematch = req.headers[<span class=\"string\">'if-none-match'</span>]</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ifnonematch &amp;&amp; ifnonematch === resultEtag) &#123;</span><br><span class=\"line\">    result.status = <span class=\"number\">304</span></span><br><span class=\"line\">    result.buffer = <span class=\"keyword\">new</span> Buffer([])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/naturalatlas/tilestrata-etag\" target=\"_blank\" rel=\"noopener\">tilestrata-etag</a>插件可以在 tilestrata 的请求中设置 ETag，可以让服务缓存变得更加高效可控，节省带宽。如果客户端的 ETag 的版本和服务器要发送的一致，则可以直接使用缓存中的数据，不再重新发送数据。</p>","more":"<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-etag --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><p>默认情况下，插件不会对所有大于 512kb 的数据启用，因为在 large buffers 上 ETag 的计算会很占用 CPU 的时间。但你也可以通过<code>limit</code>选项来更改这一默认设置，例如设置为<code>null</code>将会无视文件的大小上限，设置为一个文件大小的字符串或者数字，则会以此为上限。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> etag = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-etag'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> dependency = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-dependency'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用mapnik数据源做一个普通的图层来对比</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'world_merc'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(disk.cache(&#123; <span class=\"attr\">dir</span>: <span class=\"string\">'tilecache'</span> &#125;))</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/world.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用相同的数据源设置etag后做一个新图层来对比</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'etag'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(dependency(<span class=\"string\">'world_merc'</span>, <span class=\"string\">'tile.png'</span>))</span><br><span class=\"line\">  .use(etag(&#123; <span class=\"attr\">limit</span>: <span class=\"string\">'1mb'</span> &#125;))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>可以看到 etag 图层所有 response 中已经带上了<code>ETag</code></p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-etag-result-20190705101438.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>首先定义插件类型，这其实是一个<code>Response Hooks</code>类型的插件，劫持修改了正常的服务返回值。插件引入了<code>filesize-parser</code>用来计算文件大小，设置上限<code>max_length</code>，使用<a href=\"https://www.npmjs.com/package/etag\" target=\"_blank\" rel=\"noopener\">etag</a>来生成 etag。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// max_length由limit设置得出</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (status_type === <span class=\"number\">2</span> &amp;&amp; result.buffer &amp;&amp; result.buffer.length &lt; max_length) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> resultEtag = result.headers[<span class=\"string\">'etag'</span>] || result.headers[<span class=\"string\">'ETag'</span>]</span><br><span class=\"line\">  <span class=\"comment\">// 如果没有etag，就使用etag库生成</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!resultEtag) &#123;</span><br><span class=\"line\">    resultEtag = etag(result.buffer)</span><br><span class=\"line\">    result.headers[<span class=\"string\">'ETag'</span>] = resultEtag</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 插件还会判断是否有设置if-none-match</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> ifnonematch = req.headers[<span class=\"string\">'if-none-match'</span>]</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ifnonematch &amp;&amp; ifnonematch === resultEtag) &#123;</span><br><span class=\"line\">    result.status = <span class=\"number\">304</span></span><br><span class=\"line\">    result.buffer = <span class=\"keyword\">new</span> Buffer([])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"tilestrata-gm 插件使用及浅析","date":"2019-07-14T12:54:50.000Z","_content":"\n[tilestrata-gm](https://github.com/naturalatlas/tilestrata-gm)插件和 tilestrata-sharp 功能上类似，背后使用的依赖[graphicsmagick](http://www.graphicsmagick.org/)的[gm](http://aheckmann.github.io/gm/docs.html)库来做图像处理，所以具体能够实现的哪些功可以去 gm 的文档中查询。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 安装\n\n由于插件依赖于[graphicsmagick](http://www.graphicsmagick.org/)，需要根据[安装指南](http://www.graphicsmagick.org/README.html)在各个平台下进行安装，MacOS 可以直接用 brew 安装\n\n```sh\n$ brew install graphicsmagick\n# 再安装插件\n$ npm install tilestrata-gm --save\n```\n\n# 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst mapnik = require('tilestrata-mapnik')\nconst gm = require('tilestrata-gm')\nconst server = tilestrata()\n\nserver\n  .layer('world_merc_gm')\n  .route('tile.png')\n  .use(\n    // 定义数据源\n    mapnik({\n      pathname: 'style/world.xml'\n    })\n  )\n  .use(\n    gm(function(image) {\n      return image\n        .blur(7, 3) // 模糊处理\n        .rotate('green', 45) // 旋转，配色\n    })\n  )\n\n// 可以同时能处理的任务的个数\ngm.setMaxConcurrency(2)\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n下图是原始的瓦片样式：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-sharp-original-20190705114413.png)\n\n使用 gm 插件进行了模糊处理，旋转了 45°，背景填充为绿色后的结果：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-gm-result-20190705135250.png)\n\n# 代码浅析\n\n插件的整体逻辑和 tilestrata-sharp 基本一致，在`toBuffer`阶段有所不同，gm 选择了在`async.queue`队列中逐步转化成 buffer 再返回给 tiletrata，这也是为什么会有`setMaxConcurrency`这个方法的原因。\n\n```js\n// 代码有所精简\n// toBuffer队列\nvar gmQueue = async.queue(function(image, callback) {\n\timage.toBuffer(function(err, buffer) {\n\t\tcallback(err, buffer);\n\t});\n}, concurrency);\n\ntransform: function(server, req, buffer, headers, callback) {\n    var image;\n\n    try {\n        // 创建gm对象\n        image = gm(buffer);\n        // 执行回调函数里面的处理规则\n        fn(image);\n    }\n    catch (err) { return callback(err); }\n\n    // 放入async.queue中，逐步执行\n    gmQueue.push(image, function(err, buffer) {\n        if (err) return callback(err);\n        if (image._outputFormat) {\n            headers['Content-Type'] = 'image/' + image._outputFormat;\n        }\n        callback(null, buffer, headers);\n    });\n}\n```\n","source":"_posts/2019/tilestrata-gm.md","raw":"---\ntitle: tilestrata-gm 插件使用及浅析\ndate: 2019-07-14 20:54:50\ntags: [GIS]\ncategories: TileStrata\n---\n\n[tilestrata-gm](https://github.com/naturalatlas/tilestrata-gm)插件和 tilestrata-sharp 功能上类似，背后使用的依赖[graphicsmagick](http://www.graphicsmagick.org/)的[gm](http://aheckmann.github.io/gm/docs.html)库来做图像处理，所以具体能够实现的哪些功可以去 gm 的文档中查询。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 安装\n\n由于插件依赖于[graphicsmagick](http://www.graphicsmagick.org/)，需要根据[安装指南](http://www.graphicsmagick.org/README.html)在各个平台下进行安装，MacOS 可以直接用 brew 安装\n\n```sh\n$ brew install graphicsmagick\n# 再安装插件\n$ npm install tilestrata-gm --save\n```\n\n# 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst mapnik = require('tilestrata-mapnik')\nconst gm = require('tilestrata-gm')\nconst server = tilestrata()\n\nserver\n  .layer('world_merc_gm')\n  .route('tile.png')\n  .use(\n    // 定义数据源\n    mapnik({\n      pathname: 'style/world.xml'\n    })\n  )\n  .use(\n    gm(function(image) {\n      return image\n        .blur(7, 3) // 模糊处理\n        .rotate('green', 45) // 旋转，配色\n    })\n  )\n\n// 可以同时能处理的任务的个数\ngm.setMaxConcurrency(2)\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n下图是原始的瓦片样式：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-sharp-original-20190705114413.png)\n\n使用 gm 插件进行了模糊处理，旋转了 45°，背景填充为绿色后的结果：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-gm-result-20190705135250.png)\n\n# 代码浅析\n\n插件的整体逻辑和 tilestrata-sharp 基本一致，在`toBuffer`阶段有所不同，gm 选择了在`async.queue`队列中逐步转化成 buffer 再返回给 tiletrata，这也是为什么会有`setMaxConcurrency`这个方法的原因。\n\n```js\n// 代码有所精简\n// toBuffer队列\nvar gmQueue = async.queue(function(image, callback) {\n\timage.toBuffer(function(err, buffer) {\n\t\tcallback(err, buffer);\n\t});\n}, concurrency);\n\ntransform: function(server, req, buffer, headers, callback) {\n    var image;\n\n    try {\n        // 创建gm对象\n        image = gm(buffer);\n        // 执行回调函数里面的处理规则\n        fn(image);\n    }\n    catch (err) { return callback(err); }\n\n    // 放入async.queue中，逐步执行\n    gmQueue.push(image, function(err, buffer) {\n        if (err) return callback(err);\n        if (image._outputFormat) {\n            headers['Content-Type'] = 'image/' + image._outputFormat;\n        }\n        callback(null, buffer, headers);\n    });\n}\n```\n","slug":"tilestrata-gm","published":1,"updated":"2019-07-14T13:00:28.449Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy4fqa9x00130n3i5ncnwvu2","content":"<p><a href=\"https://github.com/naturalatlas/tilestrata-gm\" target=\"_blank\" rel=\"noopener\">tilestrata-gm</a>插件和 tilestrata-sharp 功能上类似，背后使用的依赖<a href=\"http://www.graphicsmagick.org/\" target=\"_blank\" rel=\"noopener\">graphicsmagick</a>的<a href=\"http://aheckmann.github.io/gm/docs.html\" target=\"_blank\" rel=\"noopener\">gm</a>库来做图像处理，所以具体能够实现的哪些功可以去 gm 的文档中查询。</p>\n<a id=\"more\"></a>\n<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><p>由于插件依赖于<a href=\"http://www.graphicsmagick.org/\" target=\"_blank\" rel=\"noopener\">graphicsmagick</a>，需要根据<a href=\"http://www.graphicsmagick.org/README.html\" target=\"_blank\" rel=\"noopener\">安装指南</a>在各个平台下进行安装，MacOS 可以直接用 brew 安装</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ brew install graphicsmagick</span><br><span class=\"line\"><span class=\"comment\"># 再安装插件</span></span><br><span class=\"line\">$ npm install tilestrata-gm --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> gm = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-gm'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'world_merc_gm'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    <span class=\"comment\">// 定义数据源</span></span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/world.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    gm(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">image</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> image</span><br><span class=\"line\">        .blur(<span class=\"number\">7</span>, <span class=\"number\">3</span>) <span class=\"comment\">// 模糊处理</span></span><br><span class=\"line\">        .rotate(<span class=\"string\">'green'</span>, <span class=\"number\">45</span>) <span class=\"comment\">// 旋转，配色</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以同时能处理的任务的个数</span></span><br><span class=\"line\">gm.setMaxConcurrency(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>下图是原始的瓦片样式：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-sharp-original-20190705114413.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>使用 gm 插件进行了模糊处理，旋转了 45°，背景填充为绿色后的结果：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-gm-result-20190705135250.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"代码浅析\"><a href=\"#代码浅析\" class=\"headerlink\" title=\"代码浅析\"></a>代码浅析</h1><p>插件的整体逻辑和 tilestrata-sharp 基本一致，在<code>toBuffer</code>阶段有所不同，gm 选择了在<code>async.queue</code>队列中逐步转化成 buffer 再返回给 tiletrata，这也是为什么会有<code>setMaxConcurrency</code>这个方法的原因。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码有所精简</span></span><br><span class=\"line\"><span class=\"comment\">// toBuffer队列</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> gmQueue = <span class=\"keyword\">async</span>.queue(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">image, callback</span>) </span>&#123;</span><br><span class=\"line\">\timage.toBuffer(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, buffer</span>) </span>&#123;</span><br><span class=\"line\">\t\tcallback(err, buffer);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;, concurrency);</span><br><span class=\"line\"></span><br><span class=\"line\">transform: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req, buffer, headers, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> image;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建gm对象</span></span><br><span class=\"line\">        image = gm(buffer);</span><br><span class=\"line\">        <span class=\"comment\">// 执行回调函数里面的处理规则</span></span><br><span class=\"line\">        fn(image);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (err) &#123; <span class=\"keyword\">return</span> callback(err); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 放入async.queue中，逐步执行</span></span><br><span class=\"line\">    gmQueue.push(image, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, buffer</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> callback(err);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (image._outputFormat) &#123;</span><br><span class=\"line\">            headers[<span class=\"string\">'Content-Type'</span>] = <span class=\"string\">'image/'</span> + image._outputFormat;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        callback(<span class=\"literal\">null</span>, buffer, headers);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/naturalatlas/tilestrata-gm\" target=\"_blank\" rel=\"noopener\">tilestrata-gm</a>插件和 tilestrata-sharp 功能上类似，背后使用的依赖<a href=\"http://www.graphicsmagick.org/\" target=\"_blank\" rel=\"noopener\">graphicsmagick</a>的<a href=\"http://aheckmann.github.io/gm/docs.html\" target=\"_blank\" rel=\"noopener\">gm</a>库来做图像处理，所以具体能够实现的哪些功可以去 gm 的文档中查询。</p>","more":"<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><p>由于插件依赖于<a href=\"http://www.graphicsmagick.org/\" target=\"_blank\" rel=\"noopener\">graphicsmagick</a>，需要根据<a href=\"http://www.graphicsmagick.org/README.html\" target=\"_blank\" rel=\"noopener\">安装指南</a>在各个平台下进行安装，MacOS 可以直接用 brew 安装</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ brew install graphicsmagick</span><br><span class=\"line\"><span class=\"comment\"># 再安装插件</span></span><br><span class=\"line\">$ npm install tilestrata-gm --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> gm = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-gm'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'world_merc_gm'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    <span class=\"comment\">// 定义数据源</span></span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/world.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    gm(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">image</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> image</span><br><span class=\"line\">        .blur(<span class=\"number\">7</span>, <span class=\"number\">3</span>) <span class=\"comment\">// 模糊处理</span></span><br><span class=\"line\">        .rotate(<span class=\"string\">'green'</span>, <span class=\"number\">45</span>) <span class=\"comment\">// 旋转，配色</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以同时能处理的任务的个数</span></span><br><span class=\"line\">gm.setMaxConcurrency(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>下图是原始的瓦片样式：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-sharp-original-20190705114413.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>使用 gm 插件进行了模糊处理，旋转了 45°，背景填充为绿色后的结果：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-gm-result-20190705135250.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"代码浅析\"><a href=\"#代码浅析\" class=\"headerlink\" title=\"代码浅析\"></a>代码浅析</h1><p>插件的整体逻辑和 tilestrata-sharp 基本一致，在<code>toBuffer</code>阶段有所不同，gm 选择了在<code>async.queue</code>队列中逐步转化成 buffer 再返回给 tiletrata，这也是为什么会有<code>setMaxConcurrency</code>这个方法的原因。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码有所精简</span></span><br><span class=\"line\"><span class=\"comment\">// toBuffer队列</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> gmQueue = <span class=\"keyword\">async</span>.queue(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">image, callback</span>) </span>&#123;</span><br><span class=\"line\">\timage.toBuffer(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, buffer</span>) </span>&#123;</span><br><span class=\"line\">\t\tcallback(err, buffer);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;, concurrency);</span><br><span class=\"line\"></span><br><span class=\"line\">transform: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req, buffer, headers, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> image;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建gm对象</span></span><br><span class=\"line\">        image = gm(buffer);</span><br><span class=\"line\">        <span class=\"comment\">// 执行回调函数里面的处理规则</span></span><br><span class=\"line\">        fn(image);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (err) &#123; <span class=\"keyword\">return</span> callback(err); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 放入async.queue中，逐步执行</span></span><br><span class=\"line\">    gmQueue.push(image, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, buffer</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> callback(err);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (image._outputFormat) &#123;</span><br><span class=\"line\">            headers[<span class=\"string\">'Content-Type'</span>] = <span class=\"string\">'image/'</span> + image._outputFormat;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        callback(<span class=\"literal\">null</span>, buffer, headers);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"tilestrata-headers 插件使用及浅析","date":"2019-06-26T03:25:05.000Z","_content":"\n[tilestrata-headers](https://github.com/naturalatlas/tilestrata-headers)插件用来设置请求的响应头`response headers`，常用的可以解决缓存控制、跨域等问题，实用性很高。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```bash\nnpm install tilestrata-headers --save\n```\n\n# 2. 使用\n\n```js\nvar headers = require(\"tilestrata-headers\");\nvar tilestrata = require(\"tilestrata\");\n\nserver = tilestrata();\n\nserver\n  .layer(\"osm_mvt_amenities\")\n  .route(\"tile.mvt\")\n  .use(\n    headers({\n      \"Access-Control-Allow-Origin\": \"*\",\n      \"Cache-Control\": \"max-age=3600\"\n    })\n  );\n\nserver.listen(8080);\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n未开启\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-headers-null-20190606114255.png)\n\n开启\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-headers-result-20190606114432.png)\n\n# 4. 代码浅析\n\n原理比较简单，在`tilestrata`的设计中，会使用`use`去注册各种类型的插件，`tilestrata-headers`就是`reshook`类型的插件，在初始化的过程中会被注册\n\n```js\nTileRequestHandler.prototype.use = function(plugin) {\n  if (!plugin) return this;\n  // ...简化后的代码\n  if (plugin.reshook) return this._registerResponseHook(plugin);\n};\n\nTileRequestHandler.prototype._registerResponseHook = function(plugin) {\n  var id = \"reshook#\" + this.responseHooks.length;\n  if (!plugin) throw new Error(\"Falsy value passed to registerResponseHook()\");\n  if (typeof plugin.reshook !== \"function\")\n    throw new Error(\n      \"Attempted to register a response hook with no reshook() method\"\n    );\n  this.responseHooks.push({ id: id, plugin: plugin });\n  return this;\n};\n```\n\n通过这种方式，插件劫持每个 response，给每个 response header 加上我们自定义的内容。\n","source":"_posts/2019/tilestrata-headers.md","raw":"---\ntitle: tilestrata-headers 插件使用及浅析\ndate: 2019-06-26 11:25:05\ntags: [GIS]\ncategories: TileStrata\n---\n\n[tilestrata-headers](https://github.com/naturalatlas/tilestrata-headers)插件用来设置请求的响应头`response headers`，常用的可以解决缓存控制、跨域等问题，实用性很高。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```bash\nnpm install tilestrata-headers --save\n```\n\n# 2. 使用\n\n```js\nvar headers = require(\"tilestrata-headers\");\nvar tilestrata = require(\"tilestrata\");\n\nserver = tilestrata();\n\nserver\n  .layer(\"osm_mvt_amenities\")\n  .route(\"tile.mvt\")\n  .use(\n    headers({\n      \"Access-Control-Allow-Origin\": \"*\",\n      \"Cache-Control\": \"max-age=3600\"\n    })\n  );\n\nserver.listen(8080);\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n未开启\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-headers-null-20190606114255.png)\n\n开启\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-headers-result-20190606114432.png)\n\n# 4. 代码浅析\n\n原理比较简单，在`tilestrata`的设计中，会使用`use`去注册各种类型的插件，`tilestrata-headers`就是`reshook`类型的插件，在初始化的过程中会被注册\n\n```js\nTileRequestHandler.prototype.use = function(plugin) {\n  if (!plugin) return this;\n  // ...简化后的代码\n  if (plugin.reshook) return this._registerResponseHook(plugin);\n};\n\nTileRequestHandler.prototype._registerResponseHook = function(plugin) {\n  var id = \"reshook#\" + this.responseHooks.length;\n  if (!plugin) throw new Error(\"Falsy value passed to registerResponseHook()\");\n  if (typeof plugin.reshook !== \"function\")\n    throw new Error(\n      \"Attempted to register a response hook with no reshook() method\"\n    );\n  this.responseHooks.push({ id: id, plugin: plugin });\n  return this;\n};\n```\n\n通过这种方式，插件劫持每个 response，给每个 response header 加上我们自定义的内容。\n","slug":"tilestrata-headers","published":1,"updated":"2019-06-28T05:56:28.441Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy4fqa9y00180n3iuenf26dd","content":"<p><a href=\"https://github.com/naturalatlas/tilestrata-headers\" target=\"_blank\" rel=\"noopener\">tilestrata-headers</a>插件用来设置请求的响应头<code>response headers</code>，常用的可以解决缓存控制、跨域等问题，实用性很高。</p>\n<a id=\"more\"></a>\n<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install tilestrata-headers --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> headers = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata-headers\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">server = tilestrata();</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">\"osm_mvt_amenities\"</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">\"tile.mvt\"</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">\"Access-Control-Allow-Origin\"</span>: <span class=\"string\">\"*\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"Cache-Control\"</span>: <span class=\"string\">\"max-age=3600\"</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">8080</span>);</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>未开启</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-headers-null-20190606114255.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>开启</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-headers-result-20190606114432.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>原理比较简单，在<code>tilestrata</code>的设计中，会使用<code>use</code>去注册各种类型的插件，<code>tilestrata-headers</code>就是<code>reshook</code>类型的插件，在初始化的过程中会被注册</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">TileRequestHandler.prototype.use = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">plugin</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!plugin) <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ...简化后的代码</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (plugin.reshook) <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._registerResponseHook(plugin);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">TileRequestHandler.prototype._registerResponseHook = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">plugin</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> id = <span class=\"string\">\"reshook#\"</span> + <span class=\"keyword\">this</span>.responseHooks.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!plugin) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Falsy value passed to registerResponseHook()\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> plugin.reshook !== <span class=\"string\">\"function\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">      <span class=\"string\">\"Attempted to register a response hook with no reshook() method\"</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.responseHooks.push(&#123; <span class=\"attr\">id</span>: id, <span class=\"attr\">plugin</span>: plugin &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>通过这种方式，插件劫持每个 response，给每个 response header 加上我们自定义的内容。</p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/naturalatlas/tilestrata-headers\" target=\"_blank\" rel=\"noopener\">tilestrata-headers</a>插件用来设置请求的响应头<code>response headers</code>，常用的可以解决缓存控制、跨域等问题，实用性很高。</p>","more":"<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install tilestrata-headers --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> headers = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata-headers\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">server = tilestrata();</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">\"osm_mvt_amenities\"</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">\"tile.mvt\"</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">\"Access-Control-Allow-Origin\"</span>: <span class=\"string\">\"*\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"Cache-Control\"</span>: <span class=\"string\">\"max-age=3600\"</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">8080</span>);</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>未开启</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-headers-null-20190606114255.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>开启</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-headers-result-20190606114432.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>原理比较简单，在<code>tilestrata</code>的设计中，会使用<code>use</code>去注册各种类型的插件，<code>tilestrata-headers</code>就是<code>reshook</code>类型的插件，在初始化的过程中会被注册</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">TileRequestHandler.prototype.use = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">plugin</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!plugin) <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ...简化后的代码</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (plugin.reshook) <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._registerResponseHook(plugin);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">TileRequestHandler.prototype._registerResponseHook = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">plugin</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> id = <span class=\"string\">\"reshook#\"</span> + <span class=\"keyword\">this</span>.responseHooks.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!plugin) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Falsy value passed to registerResponseHook()\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> plugin.reshook !== <span class=\"string\">\"function\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">      <span class=\"string\">\"Attempted to register a response hook with no reshook() method\"</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.responseHooks.push(&#123; <span class=\"attr\">id</span>: id, <span class=\"attr\">plugin</span>: plugin &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>通过这种方式，插件劫持每个 response，给每个 response header 加上我们自定义的内容。</p>"},{"title":"tilestrata-jsonp 插件使用及浅析","date":"2019-06-23T12:15:44.000Z","_content":"\n[tilestrata-jsonp](https://github.com/naturalatlas/tilestrata-jsonp)插件可以将一些网格（utfgrids）的 json 请求包装成 jsonp，使你不必配置 CORS 也可以跨域访问这些资源。这是除了 tilestrata-headers 以外的另一个实用型插件。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```bash\nnpm install tilestrata-jsonp --save\n```\n\n# 2. 使用\n\n```js\nvar tilestrata = require(\"tilestrata\");\nvar jsonp = require(\"tilestrata-jsonp\");\nvar tilestrataPostGISGeoJSON = require(\"tilestrata-postgis-geojson-tiles\");\n\nserver = tilestrata();\n\nserver\n  .layer(\"geojson_tiles_jsonp\")\n  .route(\"tile.json\")\n  .use(jsonp({ variable: \"callback\" }))\n  .use(\n    // Provider 这里用tilestrataPostGISGeoJSON做示例\n    tilestrataPostGISGeoJSON({\n      geometryField: \"geom\",\n      sql: function(server, req) {\n        return \"select name, {geojson} from (select name, ST_Transform(way,4326) as geom from osm_polygon where name ~ '上海') as a1 WHERE ST_Intersects(geom, {bbox})\";\n      },\n      pgConfig: {\n        username: \"postgres\",\n        password: \"postgres\",\n        host: \"localhost\",\n        port: \"5432\",\n        database: \"osm\"\n      }\n    })\n  );\n\nserver.listen(9527);\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n在启动 server 后，我们可以直接用`jquery`请求某个固定层级的瓦片，来测试是否成功触发`callbak`函数\n\n```js\n$.ajax({\n  url: \"http://127.0.0.1:9527/geojson_tiles_jsonp/4/15/8/tile.json\",\n  type: \"GET\",\n  dataType: \"jsonp\",\n  success: function(data) {\n    console.log(\"jsonp使用成功\");\n  }\n});\n```\n\n结果\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-jsonp-result-20190606145036.png)\n\n# 4. 代码浅析\n\n原理比较简单，和 headers 插件类似，在`tilestrata`的设计中，会使用`use`去注册各种类型的插件，`tilestrata-headers`就是`reshook`类型的插件，在初始化的过程中会被注册\n\n```js\nTileRequestHandler.prototype.use = function(plugin) {\n  if (!plugin) return this;\n  // ...简化后的代码\n  if (plugin.reshook) return this._registerResponseHook(plugin);\n};\n\nTileRequestHandler.prototype._registerResponseHook = function(plugin) {\n  var id = \"reshook#\" + this.responseHooks.length;\n  if (!plugin) throw new Error(\"Falsy value passed to registerResponseHook()\");\n  if (typeof plugin.reshook !== \"function\")\n    throw new Error(\n      \"Attempted to register a response hook with no reshook() method\"\n    );\n  this.responseHooks.push({ id: id, plugin: plugin });\n  return this;\n};\n```\n\n通过这种方式，插件会设置响应内容为`Content-Type: text/javascript;`，给我们返回一段包含了回调函数的代码，来执行我们预先定义好的 callbak 函数。\n","source":"_posts/2019/tilestrata-jsonp.md","raw":"---\ntitle: tilestrata-jsonp 插件使用及浅析\ndate: 2019-06-23 20:15:44\ntags: [GIS]\ncategories: TileStrata\n---\n\n[tilestrata-jsonp](https://github.com/naturalatlas/tilestrata-jsonp)插件可以将一些网格（utfgrids）的 json 请求包装成 jsonp，使你不必配置 CORS 也可以跨域访问这些资源。这是除了 tilestrata-headers 以外的另一个实用型插件。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```bash\nnpm install tilestrata-jsonp --save\n```\n\n# 2. 使用\n\n```js\nvar tilestrata = require(\"tilestrata\");\nvar jsonp = require(\"tilestrata-jsonp\");\nvar tilestrataPostGISGeoJSON = require(\"tilestrata-postgis-geojson-tiles\");\n\nserver = tilestrata();\n\nserver\n  .layer(\"geojson_tiles_jsonp\")\n  .route(\"tile.json\")\n  .use(jsonp({ variable: \"callback\" }))\n  .use(\n    // Provider 这里用tilestrataPostGISGeoJSON做示例\n    tilestrataPostGISGeoJSON({\n      geometryField: \"geom\",\n      sql: function(server, req) {\n        return \"select name, {geojson} from (select name, ST_Transform(way,4326) as geom from osm_polygon where name ~ '上海') as a1 WHERE ST_Intersects(geom, {bbox})\";\n      },\n      pgConfig: {\n        username: \"postgres\",\n        password: \"postgres\",\n        host: \"localhost\",\n        port: \"5432\",\n        database: \"osm\"\n      }\n    })\n  );\n\nserver.listen(9527);\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n在启动 server 后，我们可以直接用`jquery`请求某个固定层级的瓦片，来测试是否成功触发`callbak`函数\n\n```js\n$.ajax({\n  url: \"http://127.0.0.1:9527/geojson_tiles_jsonp/4/15/8/tile.json\",\n  type: \"GET\",\n  dataType: \"jsonp\",\n  success: function(data) {\n    console.log(\"jsonp使用成功\");\n  }\n});\n```\n\n结果\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-jsonp-result-20190606145036.png)\n\n# 4. 代码浅析\n\n原理比较简单，和 headers 插件类似，在`tilestrata`的设计中，会使用`use`去注册各种类型的插件，`tilestrata-headers`就是`reshook`类型的插件，在初始化的过程中会被注册\n\n```js\nTileRequestHandler.prototype.use = function(plugin) {\n  if (!plugin) return this;\n  // ...简化后的代码\n  if (plugin.reshook) return this._registerResponseHook(plugin);\n};\n\nTileRequestHandler.prototype._registerResponseHook = function(plugin) {\n  var id = \"reshook#\" + this.responseHooks.length;\n  if (!plugin) throw new Error(\"Falsy value passed to registerResponseHook()\");\n  if (typeof plugin.reshook !== \"function\")\n    throw new Error(\n      \"Attempted to register a response hook with no reshook() method\"\n    );\n  this.responseHooks.push({ id: id, plugin: plugin });\n  return this;\n};\n```\n\n通过这种方式，插件会设置响应内容为`Content-Type: text/javascript;`，给我们返回一段包含了回调函数的代码，来执行我们预先定义好的 callbak 函数。\n","slug":"tilestrata-jsonp","published":1,"updated":"2019-06-28T05:56:28.441Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy4fqa9z001a0n3iidsi8gza","content":"<p><a href=\"https://github.com/naturalatlas/tilestrata-jsonp\" target=\"_blank\" rel=\"noopener\">tilestrata-jsonp</a>插件可以将一些网格（utfgrids）的 json 请求包装成 jsonp，使你不必配置 CORS 也可以跨域访问这些资源。这是除了 tilestrata-headers 以外的另一个实用型插件。</p>\n<a id=\"more\"></a>\n<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install tilestrata-jsonp --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> jsonp = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata-jsonp\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> tilestrataPostGISGeoJSON = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata-postgis-geojson-tiles\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">server = tilestrata();</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">\"geojson_tiles_jsonp\"</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">\"tile.json\"</span>)</span><br><span class=\"line\">  .use(jsonp(&#123; <span class=\"attr\">variable</span>: <span class=\"string\">\"callback\"</span> &#125;))</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    <span class=\"comment\">// Provider 这里用tilestrataPostGISGeoJSON做示例</span></span><br><span class=\"line\">    tilestrataPostGISGeoJSON(&#123;</span><br><span class=\"line\">      geometryField: <span class=\"string\">\"geom\"</span>,</span><br><span class=\"line\">      sql: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"select name, &#123;geojson&#125; from (select name, ST_Transform(way,4326) as geom from osm_polygon where name ~ '上海') as a1 WHERE ST_Intersects(geom, &#123;bbox&#125;)\"</span>;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      pgConfig: &#123;</span><br><span class=\"line\">        username: <span class=\"string\">\"postgres\"</span>,</span><br><span class=\"line\">        password: <span class=\"string\">\"postgres\"</span>,</span><br><span class=\"line\">        host: <span class=\"string\">\"localhost\"</span>,</span><br><span class=\"line\">        port: <span class=\"string\">\"5432\"</span>,</span><br><span class=\"line\">        database: <span class=\"string\">\"osm\"</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>);</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>在启动 server 后，我们可以直接用<code>jquery</code>请求某个固定层级的瓦片，来测试是否成功触发<code>callbak</code>函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">  url: <span class=\"string\">\"http://127.0.0.1:9527/geojson_tiles_jsonp/4/15/8/tile.json\"</span>,</span><br><span class=\"line\">  type: <span class=\"string\">\"GET\"</span>,</span><br><span class=\"line\">  dataType: <span class=\"string\">\"jsonp\"</span>,</span><br><span class=\"line\">  success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"jsonp使用成功\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>结果</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-jsonp-result-20190606145036.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>原理比较简单，和 headers 插件类似，在<code>tilestrata</code>的设计中，会使用<code>use</code>去注册各种类型的插件，<code>tilestrata-headers</code>就是<code>reshook</code>类型的插件，在初始化的过程中会被注册</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">TileRequestHandler.prototype.use = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">plugin</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!plugin) <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ...简化后的代码</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (plugin.reshook) <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._registerResponseHook(plugin);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">TileRequestHandler.prototype._registerResponseHook = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">plugin</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> id = <span class=\"string\">\"reshook#\"</span> + <span class=\"keyword\">this</span>.responseHooks.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!plugin) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Falsy value passed to registerResponseHook()\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> plugin.reshook !== <span class=\"string\">\"function\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">      <span class=\"string\">\"Attempted to register a response hook with no reshook() method\"</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.responseHooks.push(&#123; <span class=\"attr\">id</span>: id, <span class=\"attr\">plugin</span>: plugin &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>通过这种方式，插件会设置响应内容为<code>Content-Type: text/javascript;</code>，给我们返回一段包含了回调函数的代码，来执行我们预先定义好的 callbak 函数。</p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/naturalatlas/tilestrata-jsonp\" target=\"_blank\" rel=\"noopener\">tilestrata-jsonp</a>插件可以将一些网格（utfgrids）的 json 请求包装成 jsonp，使你不必配置 CORS 也可以跨域访问这些资源。这是除了 tilestrata-headers 以外的另一个实用型插件。</p>","more":"<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install tilestrata-jsonp --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> jsonp = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata-jsonp\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> tilestrataPostGISGeoJSON = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata-postgis-geojson-tiles\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">server = tilestrata();</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">\"geojson_tiles_jsonp\"</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">\"tile.json\"</span>)</span><br><span class=\"line\">  .use(jsonp(&#123; <span class=\"attr\">variable</span>: <span class=\"string\">\"callback\"</span> &#125;))</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    <span class=\"comment\">// Provider 这里用tilestrataPostGISGeoJSON做示例</span></span><br><span class=\"line\">    tilestrataPostGISGeoJSON(&#123;</span><br><span class=\"line\">      geometryField: <span class=\"string\">\"geom\"</span>,</span><br><span class=\"line\">      sql: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"select name, &#123;geojson&#125; from (select name, ST_Transform(way,4326) as geom from osm_polygon where name ~ '上海') as a1 WHERE ST_Intersects(geom, &#123;bbox&#125;)\"</span>;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      pgConfig: &#123;</span><br><span class=\"line\">        username: <span class=\"string\">\"postgres\"</span>,</span><br><span class=\"line\">        password: <span class=\"string\">\"postgres\"</span>,</span><br><span class=\"line\">        host: <span class=\"string\">\"localhost\"</span>,</span><br><span class=\"line\">        port: <span class=\"string\">\"5432\"</span>,</span><br><span class=\"line\">        database: <span class=\"string\">\"osm\"</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>);</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>在启动 server 后，我们可以直接用<code>jquery</code>请求某个固定层级的瓦片，来测试是否成功触发<code>callbak</code>函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">  url: <span class=\"string\">\"http://127.0.0.1:9527/geojson_tiles_jsonp/4/15/8/tile.json\"</span>,</span><br><span class=\"line\">  type: <span class=\"string\">\"GET\"</span>,</span><br><span class=\"line\">  dataType: <span class=\"string\">\"jsonp\"</span>,</span><br><span class=\"line\">  success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"jsonp使用成功\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>结果</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-jsonp-result-20190606145036.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>原理比较简单，和 headers 插件类似，在<code>tilestrata</code>的设计中，会使用<code>use</code>去注册各种类型的插件，<code>tilestrata-headers</code>就是<code>reshook</code>类型的插件，在初始化的过程中会被注册</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">TileRequestHandler.prototype.use = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">plugin</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!plugin) <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ...简化后的代码</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (plugin.reshook) <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._registerResponseHook(plugin);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">TileRequestHandler.prototype._registerResponseHook = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">plugin</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> id = <span class=\"string\">\"reshook#\"</span> + <span class=\"keyword\">this</span>.responseHooks.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!plugin) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Falsy value passed to registerResponseHook()\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> plugin.reshook !== <span class=\"string\">\"function\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">      <span class=\"string\">\"Attempted to register a response hook with no reshook() method\"</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.responseHooks.push(&#123; <span class=\"attr\">id</span>: id, <span class=\"attr\">plugin</span>: plugin &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>通过这种方式，插件会设置响应内容为<code>Content-Type: text/javascript;</code>，给我们返回一段包含了回调函数的代码，来执行我们预先定义好的 callbak 函数。</p>"},{"title":"tilestrata-lru  插件使用及浅析","date":"2019-07-11T14:51:22.000Z","_content":"\n[tilestrata-lru](https://github.com/naturalatlas/tilestrata-lru)插件使用内存来缓存瓦片。所以使用起来需要额外的小心，如果没有仔细的配置它有可能导致内存溢出。但若果你需要在不同的图层或者路径中共享某个资源，这个插件就是为此而生的。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-lru --save\n```\n\n# 2. 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst lru = require('tilestrata-lru')\nconst mapnik = require('tilestrata-mapnik')\nconst headers = require('tilestrata-headers')\n\nconst server = tilestrata()\n\nconst provider = mapnik({\n  pathname: 'style/province.xml'\n})\n\n// 设置最大占用20mb的内存\nserver\n  .layer('lru_layer_size')\n  .route('tile.png')\n  .use(provider)\n  .use(\n    headers({\n      'Access-Control-Allow-Origin': '*'\n    })\n  )\n  .use(lru({ size: '20mb', ttl: 30 })) // ttl in seconds\n\n// 设置最多缓存20个数据\nserver\n  .layer('lru_layer_number')\n  .route('tile.png')\n  .use(provider)\n  .use(\n    headers({\n      'Access-Control-Allow-Origin': '*'\n    })\n  )\n  .use(lru({ size: 20, ttl: 30 }))\n\n// 手动设置cache中数据对应key的结构\nserver\n  .layer('lru_layer_key')\n  .route('tile.png')\n  .use(provider)\n  .use(\n    headers({\n      'Access-Control-Allow-Origin': '*'\n    })\n  )\n  .use(\n    lru({\n      key: function(req) {\n        return (\n          req.z +\n          ',' +\n          req.x +\n          ',' +\n          req.y +\n          ',' +\n          req.layer +\n          ',' +\n          req.filename +\n          ',' +\n          'lru_layer_custom_key'\n        )\n      }\n    })\n  )\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n多次访问某个瓦片，如`http://127.0.0.1:9527/lru_layer_number/4/12/6/tile.png`，可以发现插件会在后几次从`cache`中直接 get 获取数据：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-lru-20190705162618.png)\n\n# 4. 代码浅析\n\n首先定义插件类型，`Caches`类型的插件需要给 tilestrata 提供`set`和`get`两个回调函数，核心是[lru-cache](https://www.npmjs.com/package/lru-cache)库\n\n```js\n// 代码有所精简\n// 设置缓存用到的key，如果没有自己设置key的结构，那默认将采用如下的结构\nvar key =\n  opts.key ||\n  function(req) {\n    return (\n      req.z + ',' + req.x + ',' + req.y + ',' + req.layer + ',' + req.filename\n    )\n  }\n\n// 判断设置的是数量还是内存大小\nif (typeof opts.size === 'string') {\n  lruopts.max = filesizeParser(opts.size)\n  lruopts.length = function(item) {\n    return item.buffer.length\n  }\n} else if (typeof opts.size === 'number') {\n  lruopts.max = opts.size\n}\n\n// 根据options创建lru-cache对象\nvar cache = new SyncCache(lruopts)\n\nreturn {\n  get: function(server, req, callback) {\n    // 获取数据\n    var item = cache.get(key(req))\n    if (item) return callback(null, item.buffer, item.headers)\n    callback()\n  },\n  set: function(server, req, buffer, headers, callback) {\n    // 缓存数据\n    cache.set(key(req), { buffer: buffer, headers: headers })\n    callback()\n  }\n}\n```\n","source":"_posts/2019/tilestrata-lru.md","raw":"---\ntitle: tilestrata-lru  插件使用及浅析\ndate: 2019-07-11 22:51:22\ntags: [GIS]\ncategories: TileStrata\n---\n\n[tilestrata-lru](https://github.com/naturalatlas/tilestrata-lru)插件使用内存来缓存瓦片。所以使用起来需要额外的小心，如果没有仔细的配置它有可能导致内存溢出。但若果你需要在不同的图层或者路径中共享某个资源，这个插件就是为此而生的。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-lru --save\n```\n\n# 2. 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst lru = require('tilestrata-lru')\nconst mapnik = require('tilestrata-mapnik')\nconst headers = require('tilestrata-headers')\n\nconst server = tilestrata()\n\nconst provider = mapnik({\n  pathname: 'style/province.xml'\n})\n\n// 设置最大占用20mb的内存\nserver\n  .layer('lru_layer_size')\n  .route('tile.png')\n  .use(provider)\n  .use(\n    headers({\n      'Access-Control-Allow-Origin': '*'\n    })\n  )\n  .use(lru({ size: '20mb', ttl: 30 })) // ttl in seconds\n\n// 设置最多缓存20个数据\nserver\n  .layer('lru_layer_number')\n  .route('tile.png')\n  .use(provider)\n  .use(\n    headers({\n      'Access-Control-Allow-Origin': '*'\n    })\n  )\n  .use(lru({ size: 20, ttl: 30 }))\n\n// 手动设置cache中数据对应key的结构\nserver\n  .layer('lru_layer_key')\n  .route('tile.png')\n  .use(provider)\n  .use(\n    headers({\n      'Access-Control-Allow-Origin': '*'\n    })\n  )\n  .use(\n    lru({\n      key: function(req) {\n        return (\n          req.z +\n          ',' +\n          req.x +\n          ',' +\n          req.y +\n          ',' +\n          req.layer +\n          ',' +\n          req.filename +\n          ',' +\n          'lru_layer_custom_key'\n        )\n      }\n    })\n  )\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n多次访问某个瓦片，如`http://127.0.0.1:9527/lru_layer_number/4/12/6/tile.png`，可以发现插件会在后几次从`cache`中直接 get 获取数据：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-lru-20190705162618.png)\n\n# 4. 代码浅析\n\n首先定义插件类型，`Caches`类型的插件需要给 tilestrata 提供`set`和`get`两个回调函数，核心是[lru-cache](https://www.npmjs.com/package/lru-cache)库\n\n```js\n// 代码有所精简\n// 设置缓存用到的key，如果没有自己设置key的结构，那默认将采用如下的结构\nvar key =\n  opts.key ||\n  function(req) {\n    return (\n      req.z + ',' + req.x + ',' + req.y + ',' + req.layer + ',' + req.filename\n    )\n  }\n\n// 判断设置的是数量还是内存大小\nif (typeof opts.size === 'string') {\n  lruopts.max = filesizeParser(opts.size)\n  lruopts.length = function(item) {\n    return item.buffer.length\n  }\n} else if (typeof opts.size === 'number') {\n  lruopts.max = opts.size\n}\n\n// 根据options创建lru-cache对象\nvar cache = new SyncCache(lruopts)\n\nreturn {\n  get: function(server, req, callback) {\n    // 获取数据\n    var item = cache.get(key(req))\n    if (item) return callback(null, item.buffer, item.headers)\n    callback()\n  },\n  set: function(server, req, buffer, headers, callback) {\n    // 缓存数据\n    cache.set(key(req), { buffer: buffer, headers: headers })\n    callback()\n  }\n}\n```\n","slug":"tilestrata-lru","published":1,"updated":"2019-07-11T14:52:47.660Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy4fqaa1001f0n3idq4mlort","content":"<p><a href=\"https://github.com/naturalatlas/tilestrata-lru\" target=\"_blank\" rel=\"noopener\">tilestrata-lru</a>插件使用内存来缓存瓦片。所以使用起来需要额外的小心，如果没有仔细的配置它有可能导致内存溢出。但若果你需要在不同的图层或者路径中共享某个资源，这个插件就是为此而生的。</p>\n<a id=\"more\"></a>\n<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-lru --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> lru = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-lru'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> headers = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-headers'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> provider = mapnik(&#123;</span><br><span class=\"line\">  pathname: <span class=\"string\">'style/province.xml'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置最大占用20mb的内存</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'lru_layer_size'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(provider)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">'Access-Control-Allow-Origin'</span>: <span class=\"string\">'*'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(lru(&#123; <span class=\"attr\">size</span>: <span class=\"string\">'20mb'</span>, <span class=\"attr\">ttl</span>: <span class=\"number\">30</span> &#125;)) <span class=\"comment\">// ttl in seconds</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置最多缓存20个数据</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'lru_layer_number'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(provider)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">'Access-Control-Allow-Origin'</span>: <span class=\"string\">'*'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(lru(&#123; <span class=\"attr\">size</span>: <span class=\"number\">20</span>, <span class=\"attr\">ttl</span>: <span class=\"number\">30</span> &#125;))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 手动设置cache中数据对应key的结构</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'lru_layer_key'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(provider)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">'Access-Control-Allow-Origin'</span>: <span class=\"string\">'*'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    lru(&#123;</span><br><span class=\"line\">      key: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">          req.z +</span><br><span class=\"line\">          <span class=\"string\">','</span> +</span><br><span class=\"line\">          req.x +</span><br><span class=\"line\">          <span class=\"string\">','</span> +</span><br><span class=\"line\">          req.y +</span><br><span class=\"line\">          <span class=\"string\">','</span> +</span><br><span class=\"line\">          req.layer +</span><br><span class=\"line\">          <span class=\"string\">','</span> +</span><br><span class=\"line\">          req.filename +</span><br><span class=\"line\">          <span class=\"string\">','</span> +</span><br><span class=\"line\">          <span class=\"string\">'lru_layer_custom_key'</span></span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>多次访问某个瓦片，如<code>http://127.0.0.1:9527/lru_layer_number/4/12/6/tile.png</code>，可以发现插件会在后几次从<code>cache</code>中直接 get 获取数据：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-lru-20190705162618.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>首先定义插件类型，<code>Caches</code>类型的插件需要给 tilestrata 提供<code>set</code>和<code>get</code>两个回调函数，核心是<a href=\"https://www.npmjs.com/package/lru-cache\" target=\"_blank\" rel=\"noopener\">lru-cache</a>库</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码有所精简</span></span><br><span class=\"line\"><span class=\"comment\">// 设置缓存用到的key，如果没有自己设置key的结构，那默认将采用如下的结构</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> key =</span><br><span class=\"line\">  opts.key ||</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      req.z + <span class=\"string\">','</span> + req.x + <span class=\"string\">','</span> + req.y + <span class=\"string\">','</span> + req.layer + <span class=\"string\">','</span> + req.filename</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断设置的是数量还是内存大小</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> opts.size === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">  lruopts.max = filesizeParser(opts.size)</span><br><span class=\"line\">  lruopts.length = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> item.buffer.length</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> opts.size === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">  lruopts.max = opts.size</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据options创建lru-cache对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cache = <span class=\"keyword\">new</span> SyncCache(lruopts)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">  get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取数据</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> item = cache.get(key(req))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (item) <span class=\"keyword\">return</span> callback(<span class=\"literal\">null</span>, item.buffer, item.headers)</span><br><span class=\"line\">    callback()</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req, buffer, headers, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 缓存数据</span></span><br><span class=\"line\">    cache.set(key(req), &#123; <span class=\"attr\">buffer</span>: buffer, <span class=\"attr\">headers</span>: headers &#125;)</span><br><span class=\"line\">    callback()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/naturalatlas/tilestrata-lru\" target=\"_blank\" rel=\"noopener\">tilestrata-lru</a>插件使用内存来缓存瓦片。所以使用起来需要额外的小心，如果没有仔细的配置它有可能导致内存溢出。但若果你需要在不同的图层或者路径中共享某个资源，这个插件就是为此而生的。</p>","more":"<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-lru --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> lru = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-lru'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> headers = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-headers'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> provider = mapnik(&#123;</span><br><span class=\"line\">  pathname: <span class=\"string\">'style/province.xml'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置最大占用20mb的内存</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'lru_layer_size'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(provider)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">'Access-Control-Allow-Origin'</span>: <span class=\"string\">'*'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(lru(&#123; <span class=\"attr\">size</span>: <span class=\"string\">'20mb'</span>, <span class=\"attr\">ttl</span>: <span class=\"number\">30</span> &#125;)) <span class=\"comment\">// ttl in seconds</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置最多缓存20个数据</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'lru_layer_number'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(provider)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">'Access-Control-Allow-Origin'</span>: <span class=\"string\">'*'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(lru(&#123; <span class=\"attr\">size</span>: <span class=\"number\">20</span>, <span class=\"attr\">ttl</span>: <span class=\"number\">30</span> &#125;))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 手动设置cache中数据对应key的结构</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'lru_layer_key'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(provider)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">'Access-Control-Allow-Origin'</span>: <span class=\"string\">'*'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    lru(&#123;</span><br><span class=\"line\">      key: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">          req.z +</span><br><span class=\"line\">          <span class=\"string\">','</span> +</span><br><span class=\"line\">          req.x +</span><br><span class=\"line\">          <span class=\"string\">','</span> +</span><br><span class=\"line\">          req.y +</span><br><span class=\"line\">          <span class=\"string\">','</span> +</span><br><span class=\"line\">          req.layer +</span><br><span class=\"line\">          <span class=\"string\">','</span> +</span><br><span class=\"line\">          req.filename +</span><br><span class=\"line\">          <span class=\"string\">','</span> +</span><br><span class=\"line\">          <span class=\"string\">'lru_layer_custom_key'</span></span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>多次访问某个瓦片，如<code>http://127.0.0.1:9527/lru_layer_number/4/12/6/tile.png</code>，可以发现插件会在后几次从<code>cache</code>中直接 get 获取数据：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-lru-20190705162618.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>首先定义插件类型，<code>Caches</code>类型的插件需要给 tilestrata 提供<code>set</code>和<code>get</code>两个回调函数，核心是<a href=\"https://www.npmjs.com/package/lru-cache\" target=\"_blank\" rel=\"noopener\">lru-cache</a>库</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码有所精简</span></span><br><span class=\"line\"><span class=\"comment\">// 设置缓存用到的key，如果没有自己设置key的结构，那默认将采用如下的结构</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> key =</span><br><span class=\"line\">  opts.key ||</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      req.z + <span class=\"string\">','</span> + req.x + <span class=\"string\">','</span> + req.y + <span class=\"string\">','</span> + req.layer + <span class=\"string\">','</span> + req.filename</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断设置的是数量还是内存大小</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> opts.size === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">  lruopts.max = filesizeParser(opts.size)</span><br><span class=\"line\">  lruopts.length = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> item.buffer.length</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> opts.size === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">  lruopts.max = opts.size</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据options创建lru-cache对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cache = <span class=\"keyword\">new</span> SyncCache(lruopts)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">  get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取数据</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> item = cache.get(key(req))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (item) <span class=\"keyword\">return</span> callback(<span class=\"literal\">null</span>, item.buffer, item.headers)</span><br><span class=\"line\">    callback()</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req, buffer, headers, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 缓存数据</span></span><br><span class=\"line\">    cache.set(key(req), &#123; <span class=\"attr\">buffer</span>: buffer, <span class=\"attr\">headers</span>: headers &#125;)</span><br><span class=\"line\">    callback()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"tilestrata-mapnik 插件使用及浅析","date":"2019-06-11T03:26:12.000Z","_content":"\n[tilestrata-mapnik](https://github.com/naturalatlas/tilestrata-mapnik)顾名思义，mapnik 作为地图数据源，tilestrata 负责瓦片化的一个插件。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```bash\nnpm install mapnik --save\nnpm install tilestrata-mapnik --save\n```\n\n虽然最新的 mapnik4.0 已经支持了 nodejs 10 版本，这里仍然建议采用**nodejs 8** 环境，更为稳定，如果安装失败可以考虑切换到**nodejs 8**\n\n# 2. 使用\n\n准备好 mapnik 的 xml 配置文件\n\n```js\nvar tilestrata = require(\"tilestrata\");\nvar mapnik = require(\"tilestrata-mapnik\");\n\nserver = tilestrata();\n\nserver\n  .layer(\"layer_name\")\n  .route(\"tile.png\")\n  .use(\n    mapnik({\n      pathname: \"style/china.xml\"\n    })\n  );\n\nserver.listen(8080);\n```\n\ntilestrata-mapnik 支持的`options`有\n\n```js\n{\n  interactivity: false,\n  xml: null,\n  pathname: null,\n  metatile: 2,\n  resolution: 4,\n  bufferSize: 128,\n  tileSize: 256,\n  scale: 1\n}\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-mapnik-result-20190606105844.png)\n\n# 4. 代码浅析\n\n插件会根据传入的`options`构建一个[tilelive-mapnik](https://github.com/mapbox/tilelive-mapnik)对象 source\n\n```js\nsource = new MapnikBackend(options, function(err, result) {\n  source = result;\n  callback(err);\n});\n```\n\n根据`options`里面`interactivity`的值，分别调用了下面两个函数，对数据源会做个是否满足调用条件的判断，如果满足就设置一下`options`里面数据`format`的值\n\n```js\n// interactivity为 false，设置 format为 png\nsource.getTile();\n\n// interactivity为 true，设置 format为 utf\nsource.getGrid();\n```\n\n针对两种不同的`format`，分别创建 mapnik 实例\n\n```js\n// format为 png\nimage = new mapnik.Image();\n\n// format为 utf\nimage = new mapnik.Grid();\n```\n\n在请求具体的某个 zxy 瓦片的时候，就使用 mapnik 获取指定瓦片的方法`view`就好了。\n\n```js\nimage.view(x, y, width, height); // 获取指定瓦片\n```\n\n流程图\n\n```mermaid\ngraph TD\nA[tilestrata-mapnik] -->|options| B(tilelive-mapnik)\nB --> C{interactivity}\nC -->|true| D[getGrid]\nD --> F[mapnik.Grid]\nC -->|false| E[getTile]\nE --> G[mapnik.Image]\nF --> H[view]\nG --> H[view]\n```\n","source":"_posts/2019/tilestrata-mapnik.md","raw":"---\ntitle: tilestrata-mapnik 插件使用及浅析\ndate: 2019-06-11 11:26:12\ntags: [GIS]\ncategories: TileStrata\n---\n\n[tilestrata-mapnik](https://github.com/naturalatlas/tilestrata-mapnik)顾名思义，mapnik 作为地图数据源，tilestrata 负责瓦片化的一个插件。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```bash\nnpm install mapnik --save\nnpm install tilestrata-mapnik --save\n```\n\n虽然最新的 mapnik4.0 已经支持了 nodejs 10 版本，这里仍然建议采用**nodejs 8** 环境，更为稳定，如果安装失败可以考虑切换到**nodejs 8**\n\n# 2. 使用\n\n准备好 mapnik 的 xml 配置文件\n\n```js\nvar tilestrata = require(\"tilestrata\");\nvar mapnik = require(\"tilestrata-mapnik\");\n\nserver = tilestrata();\n\nserver\n  .layer(\"layer_name\")\n  .route(\"tile.png\")\n  .use(\n    mapnik({\n      pathname: \"style/china.xml\"\n    })\n  );\n\nserver.listen(8080);\n```\n\ntilestrata-mapnik 支持的`options`有\n\n```js\n{\n  interactivity: false,\n  xml: null,\n  pathname: null,\n  metatile: 2,\n  resolution: 4,\n  bufferSize: 128,\n  tileSize: 256,\n  scale: 1\n}\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-mapnik-result-20190606105844.png)\n\n# 4. 代码浅析\n\n插件会根据传入的`options`构建一个[tilelive-mapnik](https://github.com/mapbox/tilelive-mapnik)对象 source\n\n```js\nsource = new MapnikBackend(options, function(err, result) {\n  source = result;\n  callback(err);\n});\n```\n\n根据`options`里面`interactivity`的值，分别调用了下面两个函数，对数据源会做个是否满足调用条件的判断，如果满足就设置一下`options`里面数据`format`的值\n\n```js\n// interactivity为 false，设置 format为 png\nsource.getTile();\n\n// interactivity为 true，设置 format为 utf\nsource.getGrid();\n```\n\n针对两种不同的`format`，分别创建 mapnik 实例\n\n```js\n// format为 png\nimage = new mapnik.Image();\n\n// format为 utf\nimage = new mapnik.Grid();\n```\n\n在请求具体的某个 zxy 瓦片的时候，就使用 mapnik 获取指定瓦片的方法`view`就好了。\n\n```js\nimage.view(x, y, width, height); // 获取指定瓦片\n```\n\n流程图\n\n```mermaid\ngraph TD\nA[tilestrata-mapnik] -->|options| B(tilelive-mapnik)\nB --> C{interactivity}\nC -->|true| D[getGrid]\nD --> F[mapnik.Grid]\nC -->|false| E[getTile]\nE --> G[mapnik.Image]\nF --> H[view]\nG --> H[view]\n```\n","slug":"tilestrata-mapnik","published":1,"updated":"2019-06-28T05:56:28.441Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy4fqaa2001h0n3i2jtjp7lt","content":"<p><a href=\"https://github.com/naturalatlas/tilestrata-mapnik\" target=\"_blank\" rel=\"noopener\">tilestrata-mapnik</a>顾名思义，mapnik 作为地图数据源，tilestrata 负责瓦片化的一个插件。</p>\n<a id=\"more\"></a>\n<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install mapnik --save</span><br><span class=\"line\">npm install tilestrata-mapnik --save</span><br></pre></td></tr></table></figure>\n<p>虽然最新的 mapnik4.0 已经支持了 nodejs 10 版本，这里仍然建议采用<strong>nodejs 8</strong> 环境，更为稳定，如果安装失败可以考虑切换到<strong>nodejs 8</strong></p>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><p>准备好 mapnik 的 xml 配置文件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata-mapnik\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">server = tilestrata();</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">\"layer_name\"</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">\"tile.png\"</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">\"style/china.xml\"</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">8080</span>);</span><br></pre></td></tr></table></figure>\n<p>tilestrata-mapnik 支持的<code>options</code>有</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  interactivity: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  xml: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  pathname: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  metatile: <span class=\"number\">2</span>,</span><br><span class=\"line\">  resolution: <span class=\"number\">4</span>,</span><br><span class=\"line\">  bufferSize: <span class=\"number\">128</span>,</span><br><span class=\"line\">  tileSize: <span class=\"number\">256</span>,</span><br><span class=\"line\">  scale: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-mapnik-result-20190606105844.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>插件会根据传入的<code>options</code>构建一个<a href=\"https://github.com/mapbox/tilelive-mapnik\" target=\"_blank\" rel=\"noopener\">tilelive-mapnik</a>对象 source</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">source = <span class=\"keyword\">new</span> MapnikBackend(options, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">  source = result;</span><br><span class=\"line\">  callback(err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>根据<code>options</code>里面<code>interactivity</code>的值，分别调用了下面两个函数，对数据源会做个是否满足调用条件的判断，如果满足就设置一下<code>options</code>里面数据<code>format</code>的值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// interactivity为 false，设置 format为 png</span></span><br><span class=\"line\">source.getTile();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// interactivity为 true，设置 format为 utf</span></span><br><span class=\"line\">source.getGrid();</span><br></pre></td></tr></table></figure>\n<p>针对两种不同的<code>format</code>，分别创建 mapnik 实例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// format为 png</span></span><br><span class=\"line\">image = <span class=\"keyword\">new</span> mapnik.Image();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// format为 utf</span></span><br><span class=\"line\">image = <span class=\"keyword\">new</span> mapnik.Grid();</span><br></pre></td></tr></table></figure>\n<p>在请求具体的某个 zxy 瓦片的时候，就使用 mapnik 获取指定瓦片的方法<code>view</code>就好了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">image.view(x, y, width, height); <span class=\"comment\">// 获取指定瓦片</span></span><br></pre></td></tr></table></figure>\n<p>流程图</p>\n<pre class=\"mermaid\">graph TD\nA[tilestrata-mapnik] -->|options| B(tilelive-mapnik)\nB --> C{interactivity}\nC -->|true| D[getGrid]\nD --> F[mapnik.Grid]\nC -->|false| E[getTile]\nE --> G[mapnik.Image]\nF --> H[view]\nG --> H[view]</pre>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/naturalatlas/tilestrata-mapnik\" target=\"_blank\" rel=\"noopener\">tilestrata-mapnik</a>顾名思义，mapnik 作为地图数据源，tilestrata 负责瓦片化的一个插件。</p>","more":"<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install mapnik --save</span><br><span class=\"line\">npm install tilestrata-mapnik --save</span><br></pre></td></tr></table></figure>\n<p>虽然最新的 mapnik4.0 已经支持了 nodejs 10 版本，这里仍然建议采用<strong>nodejs 8</strong> 环境，更为稳定，如果安装失败可以考虑切换到<strong>nodejs 8</strong></p>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><p>准备好 mapnik 的 xml 配置文件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata-mapnik\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">server = tilestrata();</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">\"layer_name\"</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">\"tile.png\"</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">\"style/china.xml\"</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">8080</span>);</span><br></pre></td></tr></table></figure>\n<p>tilestrata-mapnik 支持的<code>options</code>有</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  interactivity: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  xml: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  pathname: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  metatile: <span class=\"number\">2</span>,</span><br><span class=\"line\">  resolution: <span class=\"number\">4</span>,</span><br><span class=\"line\">  bufferSize: <span class=\"number\">128</span>,</span><br><span class=\"line\">  tileSize: <span class=\"number\">256</span>,</span><br><span class=\"line\">  scale: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-mapnik-result-20190606105844.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>插件会根据传入的<code>options</code>构建一个<a href=\"https://github.com/mapbox/tilelive-mapnik\" target=\"_blank\" rel=\"noopener\">tilelive-mapnik</a>对象 source</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">source = <span class=\"keyword\">new</span> MapnikBackend(options, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">  source = result;</span><br><span class=\"line\">  callback(err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>根据<code>options</code>里面<code>interactivity</code>的值，分别调用了下面两个函数，对数据源会做个是否满足调用条件的判断，如果满足就设置一下<code>options</code>里面数据<code>format</code>的值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// interactivity为 false，设置 format为 png</span></span><br><span class=\"line\">source.getTile();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// interactivity为 true，设置 format为 utf</span></span><br><span class=\"line\">source.getGrid();</span><br></pre></td></tr></table></figure>\n<p>针对两种不同的<code>format</code>，分别创建 mapnik 实例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// format为 png</span></span><br><span class=\"line\">image = <span class=\"keyword\">new</span> mapnik.Image();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// format为 utf</span></span><br><span class=\"line\">image = <span class=\"keyword\">new</span> mapnik.Grid();</span><br></pre></td></tr></table></figure>\n<p>在请求具体的某个 zxy 瓦片的时候，就使用 mapnik 获取指定瓦片的方法<code>view</code>就好了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">image.view(x, y, width, height); <span class=\"comment\">// 获取指定瓦片</span></span><br></pre></td></tr></table></figure>\n<p>流程图</p>\n<pre class=\"mermaid\">graph TD\nA[tilestrata-mapnik] -->|options| B(tilelive-mapnik)\nB --> C{interactivity}\nC -->|true| D[getGrid]\nD --> F[mapnik.Grid]\nC -->|false| E[getTile]\nE --> G[mapnik.Image]\nF --> H[view]\nG --> H[view]</pre>"},{"title":"tilestrata-postgis-geojson-tiles 插件使用及浅析","date":"2019-07-02T13:42:51.000Z","_content":"\n[tilestrata-postgis-geojson-tiles](https://github.com/naturalatlas/tilestrata-postgis-geojson-tiles)插件以 PostGIS 为数据源，生成 GeoJSON 格式的矢量瓦片。轻量但功能强大，配置项丰富，效果拔群。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-postgis-geojson-tiles --save\n```\n\n# 2. 使用\n\n插件的配置比较复杂：\n\n- `geometryField` _( string, 必选)_ : 数据表中存储地理数据的列名。 (默认 = `\"geom\"`)\n- `sql` _( function, 必选)_ : 一个返回 PostGIS 查询语句的函数。 _注意防治 sql 注入。_ 查询语句包含以下内容:\n  - `{bbox}` (box2d): 缓冲区的 bbox 范围\n  - `{geojson}` (text): 被裁剪出来的地理信息数据\n- `pgConfig` _( object, 必选)_ : postgres 数据库配置：\n  - `{host}` (string)\n  - `{password}` (string)\n  - `{user}` (string)\n  - `{port}` (string)\n  - `{database}` (string)\n- `simplifyFactor` _( number, 可选 )_ : 地理数据简化程度的参数。 (默认 = `0.75`)\n- `buffer` _( number, 可选)_ : 围绕每个切片的缓冲大小，以像素为单位 (默认 = `16`)\n- `collectGeometry` _( boolean, 可选 )_ : 在转换成 GeoJson 之前是用 ST_Collect 把多个图形合并成一个简单图形。 (默认 = `false`)\n- `mergeMultiLineStrings` _( boolean, 可选 )_ : 在转换成 GeoJson 之前是和否用 ST_LineMerge 合并 MultiLineStrings 数据。 (默认 = `false`)\n- `dumpGeometry` _( boolean, 可选 )_ : 是否用 ST_Dump 来拆分图形 (默认 = `false`)\n\n这里我使用了 demo 中的 world_merc.shp 数据导入了 PostGIS 中作为测试数据源\n\n```js\nconst tilestrata = require('tilestrata')\nconst tilestrataPostGISGeoJSON = require('tilestrata-postgis-geojson-tiles')\nconst headers = require('tilestrata-headers')\n\nconst server = tilestrata()\n\nserver\n  .layer('geojson-tiles')\n  .route('tile.json')\n  // 配置跨域\n  .use(\n    headers({\n      'Access-Control-Allow-Origin': '*'\n    })\n  )\n  // 定义数据源\n  .use(\n    tilestrataPostGISGeoJSON({\n      geometryField: 'geom',\n      sql: function(server, req) {\n        return 'select name, {geojson} from world_merc WHERE ST_Intersects(geom, {bbox})'\n      },\n      pgConfig: {\n        username: 'postgres',\n        password: 'postgres',\n        host: '10.211.55.4',\n        port: '5432',\n        database: 'shapefile'\n      }\n    })\n  )\n\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n`http://127.0.0.1:9527/world_merc/6/55/25/tile.png`对应的栅格瓦片的结果如下图所示\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/geojson-tile-png-20190701212419.png)\n\n`http://127.0.0.1:9527/geojson-tiles/6/55/25/tile.json`请求对应的地址获取 GeoJSON 格式的矢量数据：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/geojson-tile-json-20190701212838.png)\n\n在[geojson.io](http://geojson.io)查看效果如下图所示：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/geojson-tile-result-20190701212926.png)\n\nGeoJSON 结果和渲染出来的 png 的图形基本是一致。\n\n# 4. 代码浅析\n\n从插件功能可以看出来属于`Providers`类型的插件，那么核心就是 serve 方法。首先插件会根据我们传入的数据库信息来建立 Postgres 对象，这个不需要展开讲。\n\n当请求某个瓦片的时候，插件根据传入的 zxy 信息，调用了`@mapbox/sphericalmercator`库来把 zxy 坐标转换成 bbox 对象\n\n```js\nvar sm = new SphericalMercator({ size: 256 })\nvar bbox = sm.bbox(tile.x, tile.y, tile.z)\n\nvar w = bbox[2] - bbox[0]\nvar h = bbox[3] - bbox[1]\nvar bufferX = (buffer * w) / 256\nvar bufferY = (buffer * h) / 256\nbbox[0] -= bufferX\nbbox[1] -= bufferY\nbbox[2] += bufferX\nbbox[3] += bufferY\n```\n\n在定义图层的时候会传入一个`sql`函数，里面包含了`{bbox}`和`{geojson}`两个预设的字段，在源代码中这两个字段将会分别被计算出来，合成一个 sql 在数据库中进行查询\n\n```js\n// 代码为了便于理解有所精简改动\n\n// 利用上面计算的bbox来组装bboxsql\nvar bboxSQL =\n  \"ST_SetSRID('BOX(\" +\n  bbox[0] +\n  ' ' +\n  bbox[1] +\n  ',' +\n  bbox[2] +\n  ' ' +\n  bbox[3] +\n  \" )'::box2d, 4326)\"\n\n// 根据传入的geomField等字段组装geojsonSQL\nvar geojsonSQL =\n  'ST_MakeValid(ST_SimplifyPreserveTopology(' +\n  geomField +\n  ', ' +\n  simplifyTolerance +\n  ')) ST_Intersection(' +\n  geojsonSQL +\n  ', {bbox}) ST_AsGeoJSON(' +\n  geojsonSQL +\n  ') AS geojson'\n\nsql = sql.replace(/{geojson}/g, geojsonSQL).replace(/{bbox}/g, bboxSQL)\n\n// 查询\npgPool.query(sql, callback)\n```\n\n最后把查询出来的结果封装在`FeatureCollection`中形成一个完整的 GeoJSON 返回给 tilestrata 就可以了。\n\n```js\n// 组装GeoJSON\nvar outputText =\n  '{\"type\": \"FeatureCollection\", \"features\": [' +\n  result.rows\n    .map(function(row) {\n      if (row.geojson) {\n        var featureString = '{\"type\": \"Feature\", \"geometry\": ' + row.geojson\n        delete row.geojson\n        return featureString + ', \"properties\": ' + JSON.stringify(row) + '}'\n      }\n    })\n    .join(',') +\n  ']}'\n// 返回结果\ncallback(null, outputText, { 'Content-Type': 'application/json' })\n```\n","source":"_posts/2019/tilestrata-postgis-geojson-tiles.md","raw":"---\ntitle: tilestrata-postgis-geojson-tiles 插件使用及浅析\ndate: 2019-07-02 21:42:51\ntags: [GIS]\ncategories: TileStrata\n---\n\n[tilestrata-postgis-geojson-tiles](https://github.com/naturalatlas/tilestrata-postgis-geojson-tiles)插件以 PostGIS 为数据源，生成 GeoJSON 格式的矢量瓦片。轻量但功能强大，配置项丰富，效果拔群。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-postgis-geojson-tiles --save\n```\n\n# 2. 使用\n\n插件的配置比较复杂：\n\n- `geometryField` _( string, 必选)_ : 数据表中存储地理数据的列名。 (默认 = `\"geom\"`)\n- `sql` _( function, 必选)_ : 一个返回 PostGIS 查询语句的函数。 _注意防治 sql 注入。_ 查询语句包含以下内容:\n  - `{bbox}` (box2d): 缓冲区的 bbox 范围\n  - `{geojson}` (text): 被裁剪出来的地理信息数据\n- `pgConfig` _( object, 必选)_ : postgres 数据库配置：\n  - `{host}` (string)\n  - `{password}` (string)\n  - `{user}` (string)\n  - `{port}` (string)\n  - `{database}` (string)\n- `simplifyFactor` _( number, 可选 )_ : 地理数据简化程度的参数。 (默认 = `0.75`)\n- `buffer` _( number, 可选)_ : 围绕每个切片的缓冲大小，以像素为单位 (默认 = `16`)\n- `collectGeometry` _( boolean, 可选 )_ : 在转换成 GeoJson 之前是用 ST_Collect 把多个图形合并成一个简单图形。 (默认 = `false`)\n- `mergeMultiLineStrings` _( boolean, 可选 )_ : 在转换成 GeoJson 之前是和否用 ST_LineMerge 合并 MultiLineStrings 数据。 (默认 = `false`)\n- `dumpGeometry` _( boolean, 可选 )_ : 是否用 ST_Dump 来拆分图形 (默认 = `false`)\n\n这里我使用了 demo 中的 world_merc.shp 数据导入了 PostGIS 中作为测试数据源\n\n```js\nconst tilestrata = require('tilestrata')\nconst tilestrataPostGISGeoJSON = require('tilestrata-postgis-geojson-tiles')\nconst headers = require('tilestrata-headers')\n\nconst server = tilestrata()\n\nserver\n  .layer('geojson-tiles')\n  .route('tile.json')\n  // 配置跨域\n  .use(\n    headers({\n      'Access-Control-Allow-Origin': '*'\n    })\n  )\n  // 定义数据源\n  .use(\n    tilestrataPostGISGeoJSON({\n      geometryField: 'geom',\n      sql: function(server, req) {\n        return 'select name, {geojson} from world_merc WHERE ST_Intersects(geom, {bbox})'\n      },\n      pgConfig: {\n        username: 'postgres',\n        password: 'postgres',\n        host: '10.211.55.4',\n        port: '5432',\n        database: 'shapefile'\n      }\n    })\n  )\n\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n`http://127.0.0.1:9527/world_merc/6/55/25/tile.png`对应的栅格瓦片的结果如下图所示\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/geojson-tile-png-20190701212419.png)\n\n`http://127.0.0.1:9527/geojson-tiles/6/55/25/tile.json`请求对应的地址获取 GeoJSON 格式的矢量数据：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/geojson-tile-json-20190701212838.png)\n\n在[geojson.io](http://geojson.io)查看效果如下图所示：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/geojson-tile-result-20190701212926.png)\n\nGeoJSON 结果和渲染出来的 png 的图形基本是一致。\n\n# 4. 代码浅析\n\n从插件功能可以看出来属于`Providers`类型的插件，那么核心就是 serve 方法。首先插件会根据我们传入的数据库信息来建立 Postgres 对象，这个不需要展开讲。\n\n当请求某个瓦片的时候，插件根据传入的 zxy 信息，调用了`@mapbox/sphericalmercator`库来把 zxy 坐标转换成 bbox 对象\n\n```js\nvar sm = new SphericalMercator({ size: 256 })\nvar bbox = sm.bbox(tile.x, tile.y, tile.z)\n\nvar w = bbox[2] - bbox[0]\nvar h = bbox[3] - bbox[1]\nvar bufferX = (buffer * w) / 256\nvar bufferY = (buffer * h) / 256\nbbox[0] -= bufferX\nbbox[1] -= bufferY\nbbox[2] += bufferX\nbbox[3] += bufferY\n```\n\n在定义图层的时候会传入一个`sql`函数，里面包含了`{bbox}`和`{geojson}`两个预设的字段，在源代码中这两个字段将会分别被计算出来，合成一个 sql 在数据库中进行查询\n\n```js\n// 代码为了便于理解有所精简改动\n\n// 利用上面计算的bbox来组装bboxsql\nvar bboxSQL =\n  \"ST_SetSRID('BOX(\" +\n  bbox[0] +\n  ' ' +\n  bbox[1] +\n  ',' +\n  bbox[2] +\n  ' ' +\n  bbox[3] +\n  \" )'::box2d, 4326)\"\n\n// 根据传入的geomField等字段组装geojsonSQL\nvar geojsonSQL =\n  'ST_MakeValid(ST_SimplifyPreserveTopology(' +\n  geomField +\n  ', ' +\n  simplifyTolerance +\n  ')) ST_Intersection(' +\n  geojsonSQL +\n  ', {bbox}) ST_AsGeoJSON(' +\n  geojsonSQL +\n  ') AS geojson'\n\nsql = sql.replace(/{geojson}/g, geojsonSQL).replace(/{bbox}/g, bboxSQL)\n\n// 查询\npgPool.query(sql, callback)\n```\n\n最后把查询出来的结果封装在`FeatureCollection`中形成一个完整的 GeoJSON 返回给 tilestrata 就可以了。\n\n```js\n// 组装GeoJSON\nvar outputText =\n  '{\"type\": \"FeatureCollection\", \"features\": [' +\n  result.rows\n    .map(function(row) {\n      if (row.geojson) {\n        var featureString = '{\"type\": \"Feature\", \"geometry\": ' + row.geojson\n        delete row.geojson\n        return featureString + ', \"properties\": ' + JSON.stringify(row) + '}'\n      }\n    })\n    .join(',') +\n  ']}'\n// 返回结果\ncallback(null, outputText, { 'Content-Type': 'application/json' })\n```\n","slug":"tilestrata-postgis-geojson-tiles","published":1,"updated":"2019-07-02T13:45:51.353Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy4fqaa3001l0n3iw27028td","content":"<p><a href=\"https://github.com/naturalatlas/tilestrata-postgis-geojson-tiles\" target=\"_blank\" rel=\"noopener\">tilestrata-postgis-geojson-tiles</a>插件以 PostGIS 为数据源，生成 GeoJSON 格式的矢量瓦片。轻量但功能强大，配置项丰富，效果拔群。</p>\n<a id=\"more\"></a>\n<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-postgis-geojson-tiles --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><p>插件的配置比较复杂：</p>\n<ul>\n<li><code>geometryField</code> <em>( string, 必选)</em> : 数据表中存储地理数据的列名。 (默认 = <code>&quot;geom&quot;</code>)</li>\n<li><code>sql</code> <em>( function, 必选)</em> : 一个返回 PostGIS 查询语句的函数。 <em>注意防治 sql 注入。</em> 查询语句包含以下内容:<ul>\n<li><code>{bbox}</code> (box2d): 缓冲区的 bbox 范围</li>\n<li><code>{geojson}</code> (text): 被裁剪出来的地理信息数据</li>\n</ul>\n</li>\n<li><code>pgConfig</code> <em>( object, 必选)</em> : postgres 数据库配置：<ul>\n<li><code>{host}</code> (string)</li>\n<li><code>{password}</code> (string)</li>\n<li><code>{user}</code> (string)</li>\n<li><code>{port}</code> (string)</li>\n<li><code>{database}</code> (string)</li>\n</ul>\n</li>\n<li><code>simplifyFactor</code> <em>( number, 可选 )</em> : 地理数据简化程度的参数。 (默认 = <code>0.75</code>)</li>\n<li><code>buffer</code> <em>( number, 可选)</em> : 围绕每个切片的缓冲大小，以像素为单位 (默认 = <code>16</code>)</li>\n<li><code>collectGeometry</code> <em>( boolean, 可选 )</em> : 在转换成 GeoJson 之前是用 ST_Collect 把多个图形合并成一个简单图形。 (默认 = <code>false</code>)</li>\n<li><code>mergeMultiLineStrings</code> <em>( boolean, 可选 )</em> : 在转换成 GeoJson 之前是和否用 ST_LineMerge 合并 MultiLineStrings 数据。 (默认 = <code>false</code>)</li>\n<li><code>dumpGeometry</code> <em>( boolean, 可选 )</em> : 是否用 ST_Dump 来拆分图形 (默认 = <code>false</code>)</li>\n</ul>\n<p>这里我使用了 demo 中的 world_merc.shp 数据导入了 PostGIS 中作为测试数据源</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> tilestrataPostGISGeoJSON = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-postgis-geojson-tiles'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> headers = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-headers'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'geojson-tiles'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.json'</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 配置跨域</span></span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">'Access-Control-Allow-Origin'</span>: <span class=\"string\">'*'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  <span class=\"comment\">// 定义数据源</span></span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    tilestrataPostGISGeoJSON(&#123;</span><br><span class=\"line\">      geometryField: <span class=\"string\">'geom'</span>,</span><br><span class=\"line\">      sql: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'select name, &#123;geojson&#125; from world_merc WHERE ST_Intersects(geom, &#123;bbox&#125;)'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      pgConfig: &#123;</span><br><span class=\"line\">        username: <span class=\"string\">'postgres'</span>,</span><br><span class=\"line\">        password: <span class=\"string\">'postgres'</span>,</span><br><span class=\"line\">        host: <span class=\"string\">'10.211.55.4'</span>,</span><br><span class=\"line\">        port: <span class=\"string\">'5432'</span>,</span><br><span class=\"line\">        database: <span class=\"string\">'shapefile'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p><code>http://127.0.0.1:9527/world_merc/6/55/25/tile.png</code>对应的栅格瓦片的结果如下图所示</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/geojson-tile-png-20190701212419.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p><code>http://127.0.0.1:9527/geojson-tiles/6/55/25/tile.json</code>请求对应的地址获取 GeoJSON 格式的矢量数据：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/geojson-tile-json-20190701212838.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>在<a href=\"http://geojson.io\" target=\"_blank\" rel=\"noopener\">geojson.io</a>查看效果如下图所示：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/geojson-tile-result-20190701212926.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>GeoJSON 结果和渲染出来的 png 的图形基本是一致。</p>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>从插件功能可以看出来属于<code>Providers</code>类型的插件，那么核心就是 serve 方法。首先插件会根据我们传入的数据库信息来建立 Postgres 对象，这个不需要展开讲。</p>\n<p>当请求某个瓦片的时候，插件根据传入的 zxy 信息，调用了<code>@mapbox/sphericalmercator</code>库来把 zxy 坐标转换成 bbox 对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sm = <span class=\"keyword\">new</span> SphericalMercator(&#123; <span class=\"attr\">size</span>: <span class=\"number\">256</span> &#125;)</span><br><span class=\"line\"><span class=\"keyword\">var</span> bbox = sm.bbox(tile.x, tile.y, tile.z)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> w = bbox[<span class=\"number\">2</span>] - bbox[<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> h = bbox[<span class=\"number\">3</span>] - bbox[<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> bufferX = (buffer * w) / <span class=\"number\">256</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bufferY = (buffer * h) / <span class=\"number\">256</span></span><br><span class=\"line\">bbox[<span class=\"number\">0</span>] -= bufferX</span><br><span class=\"line\">bbox[<span class=\"number\">1</span>] -= bufferY</span><br><span class=\"line\">bbox[<span class=\"number\">2</span>] += bufferX</span><br><span class=\"line\">bbox[<span class=\"number\">3</span>] += bufferY</span><br></pre></td></tr></table></figure>\n<p>在定义图层的时候会传入一个<code>sql</code>函数，里面包含了<code>{bbox}</code>和<code>{geojson}</code>两个预设的字段，在源代码中这两个字段将会分别被计算出来，合成一个 sql 在数据库中进行查询</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码为了便于理解有所精简改动</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 利用上面计算的bbox来组装bboxsql</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bboxSQL =</span><br><span class=\"line\">  <span class=\"string\">\"ST_SetSRID('BOX(\"</span> +</span><br><span class=\"line\">  bbox[<span class=\"number\">0</span>] +</span><br><span class=\"line\">  <span class=\"string\">' '</span> +</span><br><span class=\"line\">  bbox[<span class=\"number\">1</span>] +</span><br><span class=\"line\">  <span class=\"string\">','</span> +</span><br><span class=\"line\">  bbox[<span class=\"number\">2</span>] +</span><br><span class=\"line\">  <span class=\"string\">' '</span> +</span><br><span class=\"line\">  bbox[<span class=\"number\">3</span>] +</span><br><span class=\"line\">  <span class=\"string\">\" )'::box2d, 4326)\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据传入的geomField等字段组装geojsonSQL</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> geojsonSQL =</span><br><span class=\"line\">  <span class=\"string\">'ST_MakeValid(ST_SimplifyPreserveTopology('</span> +</span><br><span class=\"line\">  geomField +</span><br><span class=\"line\">  <span class=\"string\">', '</span> +</span><br><span class=\"line\">  simplifyTolerance +</span><br><span class=\"line\">  <span class=\"string\">')) ST_Intersection('</span> +</span><br><span class=\"line\">  geojsonSQL +</span><br><span class=\"line\">  <span class=\"string\">', &#123;bbox&#125;) ST_AsGeoJSON('</span> +</span><br><span class=\"line\">  geojsonSQL +</span><br><span class=\"line\">  <span class=\"string\">') AS geojson'</span></span><br><span class=\"line\"></span><br><span class=\"line\">sql = sql.replace(<span class=\"regexp\">/&#123;geojson&#125;/g</span>, geojsonSQL).replace(<span class=\"regexp\">/&#123;bbox&#125;/g</span>, bboxSQL)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查询</span></span><br><span class=\"line\">pgPool.query(sql, callback)</span><br></pre></td></tr></table></figure>\n<p>最后把查询出来的结果封装在<code>FeatureCollection</code>中形成一个完整的 GeoJSON 返回给 tilestrata 就可以了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 组装GeoJSON</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> outputText =</span><br><span class=\"line\">  <span class=\"string\">'&#123;\"type\": \"FeatureCollection\", \"features\": ['</span> +</span><br><span class=\"line\">  result.rows</span><br><span class=\"line\">    .map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">row</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (row.geojson) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> featureString = <span class=\"string\">'&#123;\"type\": \"Feature\", \"geometry\": '</span> + row.geojson</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> row.geojson</span><br><span class=\"line\">        <span class=\"keyword\">return</span> featureString + <span class=\"string\">', \"properties\": '</span> + <span class=\"built_in\">JSON</span>.stringify(row) + <span class=\"string\">'&#125;'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .join(<span class=\"string\">','</span>) +</span><br><span class=\"line\">  <span class=\"string\">']&#125;'</span></span><br><span class=\"line\"><span class=\"comment\">// 返回结果</span></span><br><span class=\"line\">callback(<span class=\"literal\">null</span>, outputText, &#123; <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'application/json'</span> &#125;)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/naturalatlas/tilestrata-postgis-geojson-tiles\" target=\"_blank\" rel=\"noopener\">tilestrata-postgis-geojson-tiles</a>插件以 PostGIS 为数据源，生成 GeoJSON 格式的矢量瓦片。轻量但功能强大，配置项丰富，效果拔群。</p>","more":"<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-postgis-geojson-tiles --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><p>插件的配置比较复杂：</p>\n<ul>\n<li><code>geometryField</code> <em>( string, 必选)</em> : 数据表中存储地理数据的列名。 (默认 = <code>&quot;geom&quot;</code>)</li>\n<li><code>sql</code> <em>( function, 必选)</em> : 一个返回 PostGIS 查询语句的函数。 <em>注意防治 sql 注入。</em> 查询语句包含以下内容:<ul>\n<li><code>{bbox}</code> (box2d): 缓冲区的 bbox 范围</li>\n<li><code>{geojson}</code> (text): 被裁剪出来的地理信息数据</li>\n</ul>\n</li>\n<li><code>pgConfig</code> <em>( object, 必选)</em> : postgres 数据库配置：<ul>\n<li><code>{host}</code> (string)</li>\n<li><code>{password}</code> (string)</li>\n<li><code>{user}</code> (string)</li>\n<li><code>{port}</code> (string)</li>\n<li><code>{database}</code> (string)</li>\n</ul>\n</li>\n<li><code>simplifyFactor</code> <em>( number, 可选 )</em> : 地理数据简化程度的参数。 (默认 = <code>0.75</code>)</li>\n<li><code>buffer</code> <em>( number, 可选)</em> : 围绕每个切片的缓冲大小，以像素为单位 (默认 = <code>16</code>)</li>\n<li><code>collectGeometry</code> <em>( boolean, 可选 )</em> : 在转换成 GeoJson 之前是用 ST_Collect 把多个图形合并成一个简单图形。 (默认 = <code>false</code>)</li>\n<li><code>mergeMultiLineStrings</code> <em>( boolean, 可选 )</em> : 在转换成 GeoJson 之前是和否用 ST_LineMerge 合并 MultiLineStrings 数据。 (默认 = <code>false</code>)</li>\n<li><code>dumpGeometry</code> <em>( boolean, 可选 )</em> : 是否用 ST_Dump 来拆分图形 (默认 = <code>false</code>)</li>\n</ul>\n<p>这里我使用了 demo 中的 world_merc.shp 数据导入了 PostGIS 中作为测试数据源</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> tilestrataPostGISGeoJSON = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-postgis-geojson-tiles'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> headers = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-headers'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'geojson-tiles'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.json'</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 配置跨域</span></span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">'Access-Control-Allow-Origin'</span>: <span class=\"string\">'*'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  <span class=\"comment\">// 定义数据源</span></span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    tilestrataPostGISGeoJSON(&#123;</span><br><span class=\"line\">      geometryField: <span class=\"string\">'geom'</span>,</span><br><span class=\"line\">      sql: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'select name, &#123;geojson&#125; from world_merc WHERE ST_Intersects(geom, &#123;bbox&#125;)'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      pgConfig: &#123;</span><br><span class=\"line\">        username: <span class=\"string\">'postgres'</span>,</span><br><span class=\"line\">        password: <span class=\"string\">'postgres'</span>,</span><br><span class=\"line\">        host: <span class=\"string\">'10.211.55.4'</span>,</span><br><span class=\"line\">        port: <span class=\"string\">'5432'</span>,</span><br><span class=\"line\">        database: <span class=\"string\">'shapefile'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p><code>http://127.0.0.1:9527/world_merc/6/55/25/tile.png</code>对应的栅格瓦片的结果如下图所示</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/geojson-tile-png-20190701212419.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p><code>http://127.0.0.1:9527/geojson-tiles/6/55/25/tile.json</code>请求对应的地址获取 GeoJSON 格式的矢量数据：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/geojson-tile-json-20190701212838.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>在<a href=\"http://geojson.io\" target=\"_blank\" rel=\"noopener\">geojson.io</a>查看效果如下图所示：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/geojson-tile-result-20190701212926.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>GeoJSON 结果和渲染出来的 png 的图形基本是一致。</p>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>从插件功能可以看出来属于<code>Providers</code>类型的插件，那么核心就是 serve 方法。首先插件会根据我们传入的数据库信息来建立 Postgres 对象，这个不需要展开讲。</p>\n<p>当请求某个瓦片的时候，插件根据传入的 zxy 信息，调用了<code>@mapbox/sphericalmercator</code>库来把 zxy 坐标转换成 bbox 对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sm = <span class=\"keyword\">new</span> SphericalMercator(&#123; <span class=\"attr\">size</span>: <span class=\"number\">256</span> &#125;)</span><br><span class=\"line\"><span class=\"keyword\">var</span> bbox = sm.bbox(tile.x, tile.y, tile.z)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> w = bbox[<span class=\"number\">2</span>] - bbox[<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> h = bbox[<span class=\"number\">3</span>] - bbox[<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> bufferX = (buffer * w) / <span class=\"number\">256</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bufferY = (buffer * h) / <span class=\"number\">256</span></span><br><span class=\"line\">bbox[<span class=\"number\">0</span>] -= bufferX</span><br><span class=\"line\">bbox[<span class=\"number\">1</span>] -= bufferY</span><br><span class=\"line\">bbox[<span class=\"number\">2</span>] += bufferX</span><br><span class=\"line\">bbox[<span class=\"number\">3</span>] += bufferY</span><br></pre></td></tr></table></figure>\n<p>在定义图层的时候会传入一个<code>sql</code>函数，里面包含了<code>{bbox}</code>和<code>{geojson}</code>两个预设的字段，在源代码中这两个字段将会分别被计算出来，合成一个 sql 在数据库中进行查询</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码为了便于理解有所精简改动</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 利用上面计算的bbox来组装bboxsql</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bboxSQL =</span><br><span class=\"line\">  <span class=\"string\">\"ST_SetSRID('BOX(\"</span> +</span><br><span class=\"line\">  bbox[<span class=\"number\">0</span>] +</span><br><span class=\"line\">  <span class=\"string\">' '</span> +</span><br><span class=\"line\">  bbox[<span class=\"number\">1</span>] +</span><br><span class=\"line\">  <span class=\"string\">','</span> +</span><br><span class=\"line\">  bbox[<span class=\"number\">2</span>] +</span><br><span class=\"line\">  <span class=\"string\">' '</span> +</span><br><span class=\"line\">  bbox[<span class=\"number\">3</span>] +</span><br><span class=\"line\">  <span class=\"string\">\" )'::box2d, 4326)\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据传入的geomField等字段组装geojsonSQL</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> geojsonSQL =</span><br><span class=\"line\">  <span class=\"string\">'ST_MakeValid(ST_SimplifyPreserveTopology('</span> +</span><br><span class=\"line\">  geomField +</span><br><span class=\"line\">  <span class=\"string\">', '</span> +</span><br><span class=\"line\">  simplifyTolerance +</span><br><span class=\"line\">  <span class=\"string\">')) ST_Intersection('</span> +</span><br><span class=\"line\">  geojsonSQL +</span><br><span class=\"line\">  <span class=\"string\">', &#123;bbox&#125;) ST_AsGeoJSON('</span> +</span><br><span class=\"line\">  geojsonSQL +</span><br><span class=\"line\">  <span class=\"string\">') AS geojson'</span></span><br><span class=\"line\"></span><br><span class=\"line\">sql = sql.replace(<span class=\"regexp\">/&#123;geojson&#125;/g</span>, geojsonSQL).replace(<span class=\"regexp\">/&#123;bbox&#125;/g</span>, bboxSQL)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查询</span></span><br><span class=\"line\">pgPool.query(sql, callback)</span><br></pre></td></tr></table></figure>\n<p>最后把查询出来的结果封装在<code>FeatureCollection</code>中形成一个完整的 GeoJSON 返回给 tilestrata 就可以了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 组装GeoJSON</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> outputText =</span><br><span class=\"line\">  <span class=\"string\">'&#123;\"type\": \"FeatureCollection\", \"features\": ['</span> +</span><br><span class=\"line\">  result.rows</span><br><span class=\"line\">    .map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">row</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (row.geojson) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> featureString = <span class=\"string\">'&#123;\"type\": \"Feature\", \"geometry\": '</span> + row.geojson</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> row.geojson</span><br><span class=\"line\">        <span class=\"keyword\">return</span> featureString + <span class=\"string\">', \"properties\": '</span> + <span class=\"built_in\">JSON</span>.stringify(row) + <span class=\"string\">'&#125;'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .join(<span class=\"string\">','</span>) +</span><br><span class=\"line\">  <span class=\"string\">']&#125;'</span></span><br><span class=\"line\"><span class=\"comment\">// 返回结果</span></span><br><span class=\"line\">callback(<span class=\"literal\">null</span>, outputText, &#123; <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'application/json'</span> &#125;)</span><br></pre></td></tr></table></figure>"},{"title":"tilestrata-postgismvt 插件使用及浅析","date":"2019-06-13T08:02:44.000Z","_content":"\n[tilestrata-postgismvt](https://github.com/Stezii/tilestrata-postgismvt)是一个用来从 PostGIS 数据库中检索出 mvt 格式矢量瓦片的插件。PostGIS 在 2.4.0 版本后支持了直接生成 mvt 数据，这让我们更方便的加工出矢量瓦片。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 基本要求\n\nPostGIS 需要在[2.4.0](https://postgis.net/2017/09/30/postgis-2.4.0/)版本及以上\n\n# 2. 安装\n\n```bash\n## 不推荐\nnpm install tilestrata-postgismvt --save\n```\n\n在 ST_AsMVT 方法更新后 ，虽然作者更新了代码，但是 npm 包并不是最新的，建议用下面的方法安装最新版，或者直接去 Github 上下载\n\n```bash\n## 推荐\nnpm install --save https://github.com/Stezii/tilestrata-postgismvt\n```\n\n或者通过 package.json\n\n```json\n\"tilestrata-postgismvt\": \"github:Stezii/tilestrata-postgismvt\"\n```\n\n# 3. 使用\n\n前提：一个导入了 osm 数据的支持 PostGIS 2.4.0 的数据服务器\n\n执行 mapbox 的脚本[TileBBox.sql](https://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql)添加`TileBBox`函数\n\n## 3.1 普通模式\n\n```js\nvar tilestrata = require(\"tilestrata\");\nvar postgismvt = require(\"tilestrata-postgismvt\");\nvar headers = require(\"tilestrata-headers\");\n\nserver = tilestrata();\n\nserver\n  .layer(\"osm_mvt\")\n  .route(\"tile.mvt\")\n  .use(\n    headers({\n      \"Access-Control-Allow-Origin\": \"*\"\n    })\n  )\n  .use(\n    postgismvt({\n      lyr: {\n        table: \"import.osm_buildings\", // 表名\n        geometry: \"geometry\", // geometry在表中的字段名\n        srid: 3857, // 坐标系\n        minZoom: 3,\n        maxZoom: 19,\n        buffer: 10, // 裁剪geometry时的缓冲距离，PostGIS默认为256\n        fields: \"name\", // 额外字段名\n        resolution: 256 // 分辨率，可以是function\n      },\n      pgConfig: {\n        // 通过`pgConfig`属性配置PostGIS相关属性\n        host: \"localhost\",\n        user: \"gis\",\n        password: \"gis\",\n        database: \"gis\",\n        port: \"6543\"\n      }\n    })\n  );\n\nserver.listen(8080);\n```\n\n## 3.2 点云数据\n\n如果是点要素，可以使用 cluster 模式，只要定义`lry`中的`mode`属性为`cluster_fields、cluster或function`,注意的是需要同时定义`type`为`circle`\n\n```js\nserver.layer('layer_name').route('tile.mvt')\n  .use(postgismvt({\n    lyr: {\n      ...\n      mode: 'cluster' // or 'cluster_fields'\n    },\n    pgConfig: {\n      ...\n    }}))\n  );\n```\n\n`mode`和`resolution`都支持是一个函数。通过这种方式可以手动指定一些缩放级别，用来控制精度\n\n```js\nserver.layer('layer_name').route('tile.mvt')\n  .use(postgismvt({\n    lyr: {\n      resolution: function(server, req) {\n        if (req.z > 12) return 512;\n        return 256;\n      },\n      mode: function(server, req) {\n        if (req.z > 15) return null;\n        if (req.z > 13) return 'cluster_fields';\n        return 'cluster';\n      }\n    },\n    pgConfig: {\n      ...\n    }}))\n  );\n```\n\n# 4. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-postgismvt20190606111135.png)\n\n# 5. 代码浅析\n\n其实核心的方法就是用到了 PostGIS 的`ST_AsMVT`和`ST_AsMVTGeom`函数。mapbox 提供[TileBBox.sql](https://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql)用来计算 zxy 位置的瓦片对应的 box 边界，再查询出其中的 geom，转换成 mvt 格式。\n\n比如说 `z=14,x=12917,y=6430`的瓦片对应的 sql 如下：\n\n```sql\nSELECT ST_AsMVT(q, 'osm_mvt', 256, 'geom') AS mvt\nFROM (\n  SELECT ST_AsMVTGeom(\n    ST_Transform(\n\t  import.osm_buildings.geometry, 3857),\n\t  TileBBox(14, 12917, 6430, 3857),\n\t  256,\n\t  10,\n      true\n\t) geom ,name\n    FROM import.osm_buildings\n    WHERE ST_Intersects(TileBBox(14, 12917, 6430, 3857), import.osm_buildings.geometry)\n) AS q\n```\n\n此外，`fields`是可以用逗号分割传递多个想要的字段名的。\n","source":"_posts/2019/tilestrata-postgismvt.md","raw":"---\ntitle: tilestrata-postgismvt 插件使用及浅析\ndate: 2019-06-13 16:02:44\ntags: [GIS]\ncategories: TileStrata\n---\n\n[tilestrata-postgismvt](https://github.com/Stezii/tilestrata-postgismvt)是一个用来从 PostGIS 数据库中检索出 mvt 格式矢量瓦片的插件。PostGIS 在 2.4.0 版本后支持了直接生成 mvt 数据，这让我们更方便的加工出矢量瓦片。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 基本要求\n\nPostGIS 需要在[2.4.0](https://postgis.net/2017/09/30/postgis-2.4.0/)版本及以上\n\n# 2. 安装\n\n```bash\n## 不推荐\nnpm install tilestrata-postgismvt --save\n```\n\n在 ST_AsMVT 方法更新后 ，虽然作者更新了代码，但是 npm 包并不是最新的，建议用下面的方法安装最新版，或者直接去 Github 上下载\n\n```bash\n## 推荐\nnpm install --save https://github.com/Stezii/tilestrata-postgismvt\n```\n\n或者通过 package.json\n\n```json\n\"tilestrata-postgismvt\": \"github:Stezii/tilestrata-postgismvt\"\n```\n\n# 3. 使用\n\n前提：一个导入了 osm 数据的支持 PostGIS 2.4.0 的数据服务器\n\n执行 mapbox 的脚本[TileBBox.sql](https://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql)添加`TileBBox`函数\n\n## 3.1 普通模式\n\n```js\nvar tilestrata = require(\"tilestrata\");\nvar postgismvt = require(\"tilestrata-postgismvt\");\nvar headers = require(\"tilestrata-headers\");\n\nserver = tilestrata();\n\nserver\n  .layer(\"osm_mvt\")\n  .route(\"tile.mvt\")\n  .use(\n    headers({\n      \"Access-Control-Allow-Origin\": \"*\"\n    })\n  )\n  .use(\n    postgismvt({\n      lyr: {\n        table: \"import.osm_buildings\", // 表名\n        geometry: \"geometry\", // geometry在表中的字段名\n        srid: 3857, // 坐标系\n        minZoom: 3,\n        maxZoom: 19,\n        buffer: 10, // 裁剪geometry时的缓冲距离，PostGIS默认为256\n        fields: \"name\", // 额外字段名\n        resolution: 256 // 分辨率，可以是function\n      },\n      pgConfig: {\n        // 通过`pgConfig`属性配置PostGIS相关属性\n        host: \"localhost\",\n        user: \"gis\",\n        password: \"gis\",\n        database: \"gis\",\n        port: \"6543\"\n      }\n    })\n  );\n\nserver.listen(8080);\n```\n\n## 3.2 点云数据\n\n如果是点要素，可以使用 cluster 模式，只要定义`lry`中的`mode`属性为`cluster_fields、cluster或function`,注意的是需要同时定义`type`为`circle`\n\n```js\nserver.layer('layer_name').route('tile.mvt')\n  .use(postgismvt({\n    lyr: {\n      ...\n      mode: 'cluster' // or 'cluster_fields'\n    },\n    pgConfig: {\n      ...\n    }}))\n  );\n```\n\n`mode`和`resolution`都支持是一个函数。通过这种方式可以手动指定一些缩放级别，用来控制精度\n\n```js\nserver.layer('layer_name').route('tile.mvt')\n  .use(postgismvt({\n    lyr: {\n      resolution: function(server, req) {\n        if (req.z > 12) return 512;\n        return 256;\n      },\n      mode: function(server, req) {\n        if (req.z > 15) return null;\n        if (req.z > 13) return 'cluster_fields';\n        return 'cluster';\n      }\n    },\n    pgConfig: {\n      ...\n    }}))\n  );\n```\n\n# 4. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-postgismvt20190606111135.png)\n\n# 5. 代码浅析\n\n其实核心的方法就是用到了 PostGIS 的`ST_AsMVT`和`ST_AsMVTGeom`函数。mapbox 提供[TileBBox.sql](https://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql)用来计算 zxy 位置的瓦片对应的 box 边界，再查询出其中的 geom，转换成 mvt 格式。\n\n比如说 `z=14,x=12917,y=6430`的瓦片对应的 sql 如下：\n\n```sql\nSELECT ST_AsMVT(q, 'osm_mvt', 256, 'geom') AS mvt\nFROM (\n  SELECT ST_AsMVTGeom(\n    ST_Transform(\n\t  import.osm_buildings.geometry, 3857),\n\t  TileBBox(14, 12917, 6430, 3857),\n\t  256,\n\t  10,\n      true\n\t) geom ,name\n    FROM import.osm_buildings\n    WHERE ST_Intersects(TileBBox(14, 12917, 6430, 3857), import.osm_buildings.geometry)\n) AS q\n```\n\n此外，`fields`是可以用逗号分割传递多个想要的字段名的。\n","slug":"tilestrata-postgismvt","published":1,"updated":"2019-06-28T05:56:28.441Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy4fqaa5001o0n3idtsjsamh","content":"<p><a href=\"https://github.com/Stezii/tilestrata-postgismvt\" target=\"_blank\" rel=\"noopener\">tilestrata-postgismvt</a>是一个用来从 PostGIS 数据库中检索出 mvt 格式矢量瓦片的插件。PostGIS 在 2.4.0 版本后支持了直接生成 mvt 数据，这让我们更方便的加工出矢量瓦片。</p>\n<a id=\"more\"></a>\n<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-基本要求\"><a href=\"#1-基本要求\" class=\"headerlink\" title=\"1. 基本要求\"></a>1. 基本要求</h1><p>PostGIS 需要在<a href=\"https://postgis.net/2017/09/30/postgis-2.4.0/\" target=\"_blank\" rel=\"noopener\">2.4.0</a>版本及以上</p>\n<h1 id=\"2-安装\"><a href=\"#2-安装\" class=\"headerlink\" title=\"2. 安装\"></a>2. 安装</h1><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 不推荐</span></span><br><span class=\"line\">npm install tilestrata-postgismvt --save</span><br></pre></td></tr></table></figure>\n<p>在 ST_AsMVT 方法更新后 ，虽然作者更新了代码，但是 npm 包并不是最新的，建议用下面的方法安装最新版，或者直接去 Github 上下载</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 推荐</span></span><br><span class=\"line\">npm install --save https://github.com/Stezii/tilestrata-postgismvt</span><br></pre></td></tr></table></figure>\n<p>或者通过 package.json</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">\"tilestrata-postgismvt\": \"github:Stezii/tilestrata-postgismvt\"</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-使用\"><a href=\"#3-使用\" class=\"headerlink\" title=\"3. 使用\"></a>3. 使用</h1><p>前提：一个导入了 osm 数据的支持 PostGIS 2.4.0 的数据服务器</p>\n<p>执行 mapbox 的脚本<a href=\"https://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql\" target=\"_blank\" rel=\"noopener\">TileBBox.sql</a>添加<code>TileBBox</code>函数</p>\n<h2 id=\"3-1-普通模式\"><a href=\"#3-1-普通模式\" class=\"headerlink\" title=\"3.1 普通模式\"></a>3.1 普通模式</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> postgismvt = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata-postgismvt\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> headers = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata-headers\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">server = tilestrata();</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">\"osm_mvt\"</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">\"tile.mvt\"</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">\"Access-Control-Allow-Origin\"</span>: <span class=\"string\">\"*\"</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    postgismvt(&#123;</span><br><span class=\"line\">      lyr: &#123;</span><br><span class=\"line\">        table: <span class=\"string\">\"import.osm_buildings\"</span>, <span class=\"comment\">// 表名</span></span><br><span class=\"line\">        geometry: <span class=\"string\">\"geometry\"</span>, <span class=\"comment\">// geometry在表中的字段名</span></span><br><span class=\"line\">        srid: <span class=\"number\">3857</span>, <span class=\"comment\">// 坐标系</span></span><br><span class=\"line\">        minZoom: <span class=\"number\">3</span>,</span><br><span class=\"line\">        maxZoom: <span class=\"number\">19</span>,</span><br><span class=\"line\">        buffer: <span class=\"number\">10</span>, <span class=\"comment\">// 裁剪geometry时的缓冲距离，PostGIS默认为256</span></span><br><span class=\"line\">        fields: <span class=\"string\">\"name\"</span>, <span class=\"comment\">// 额外字段名</span></span><br><span class=\"line\">        resolution: <span class=\"number\">256</span> <span class=\"comment\">// 分辨率，可以是function</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      pgConfig: &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 通过`pgConfig`属性配置PostGIS相关属性</span></span><br><span class=\"line\">        host: <span class=\"string\">\"localhost\"</span>,</span><br><span class=\"line\">        user: <span class=\"string\">\"gis\"</span>,</span><br><span class=\"line\">        password: <span class=\"string\">\"gis\"</span>,</span><br><span class=\"line\">        database: <span class=\"string\">\"gis\"</span>,</span><br><span class=\"line\">        port: <span class=\"string\">\"6543\"</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">8080</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-2-点云数据\"><a href=\"#3-2-点云数据\" class=\"headerlink\" title=\"3.2 点云数据\"></a>3.2 点云数据</h2><p>如果是点要素，可以使用 cluster 模式，只要定义<code>lry</code>中的<code>mode</code>属性为<code>cluster_fields、cluster或function</code>,注意的是需要同时定义<code>type</code>为<code>circle</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">server.layer(<span class=\"string\">'layer_name'</span>).route(<span class=\"string\">'tile.mvt'</span>)</span><br><span class=\"line\">  .use(postgismvt(&#123;</span><br><span class=\"line\">    lyr: &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      mode: <span class=\"string\">'cluster'</span> <span class=\"comment\">// or 'cluster_fields'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    pgConfig: &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;&#125;))</span><br><span class=\"line\">  );</span><br></pre></td></tr></table></figure>\n<p><code>mode</code>和<code>resolution</code>都支持是一个函数。通过这种方式可以手动指定一些缩放级别，用来控制精度</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">server.layer(<span class=\"string\">'layer_name'</span>).route(<span class=\"string\">'tile.mvt'</span>)</span><br><span class=\"line\">  .use(postgismvt(&#123;</span><br><span class=\"line\">    lyr: &#123;</span><br><span class=\"line\">      resolution: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (req.z &gt; <span class=\"number\">12</span>) <span class=\"keyword\">return</span> <span class=\"number\">512</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">256</span>;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      mode: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (req.z &gt; <span class=\"number\">15</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (req.z &gt; <span class=\"number\">13</span>) <span class=\"keyword\">return</span> <span class=\"string\">'cluster_fields'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'cluster'</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    pgConfig: &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;&#125;))</span><br><span class=\"line\">  );</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-效果\"><a href=\"#4-效果\" class=\"headerlink\" title=\"4. 效果\"></a>4. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-postgismvt20190606111135.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"5-代码浅析\"><a href=\"#5-代码浅析\" class=\"headerlink\" title=\"5. 代码浅析\"></a>5. 代码浅析</h1><p>其实核心的方法就是用到了 PostGIS 的<code>ST_AsMVT</code>和<code>ST_AsMVTGeom</code>函数。mapbox 提供<a href=\"https://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql\" target=\"_blank\" rel=\"noopener\">TileBBox.sql</a>用来计算 zxy 位置的瓦片对应的 box 边界，再查询出其中的 geom，转换成 mvt 格式。</p>\n<p>比如说 <code>z=14,x=12917,y=6430</code>的瓦片对应的 sql 如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> ST_AsMVT(q, <span class=\"string\">'osm_mvt'</span>, <span class=\"number\">256</span>, <span class=\"string\">'geom'</span>) <span class=\"keyword\">AS</span> mvt</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> (</span><br><span class=\"line\">  <span class=\"keyword\">SELECT</span> ST_AsMVTGeom(</span><br><span class=\"line\">    ST_Transform(</span><br><span class=\"line\">\t  import.osm_buildings.geometry, <span class=\"number\">3857</span>),</span><br><span class=\"line\">\t  TileBBox(<span class=\"number\">14</span>, <span class=\"number\">12917</span>, <span class=\"number\">6430</span>, <span class=\"number\">3857</span>),</span><br><span class=\"line\">\t  <span class=\"number\">256</span>,</span><br><span class=\"line\">\t  <span class=\"number\">10</span>,</span><br><span class=\"line\">      <span class=\"literal\">true</span></span><br><span class=\"line\">\t) geom ,<span class=\"keyword\">name</span></span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> import.osm_buildings</span><br><span class=\"line\">    <span class=\"keyword\">WHERE</span> ST_Intersects(TileBBox(<span class=\"number\">14</span>, <span class=\"number\">12917</span>, <span class=\"number\">6430</span>, <span class=\"number\">3857</span>), import.osm_buildings.geometry)</span><br><span class=\"line\">) <span class=\"keyword\">AS</span> q</span><br></pre></td></tr></table></figure>\n<p>此外，<code>fields</code>是可以用逗号分割传递多个想要的字段名的。</p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/Stezii/tilestrata-postgismvt\" target=\"_blank\" rel=\"noopener\">tilestrata-postgismvt</a>是一个用来从 PostGIS 数据库中检索出 mvt 格式矢量瓦片的插件。PostGIS 在 2.4.0 版本后支持了直接生成 mvt 数据，这让我们更方便的加工出矢量瓦片。</p>","more":"<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-基本要求\"><a href=\"#1-基本要求\" class=\"headerlink\" title=\"1. 基本要求\"></a>1. 基本要求</h1><p>PostGIS 需要在<a href=\"https://postgis.net/2017/09/30/postgis-2.4.0/\" target=\"_blank\" rel=\"noopener\">2.4.0</a>版本及以上</p>\n<h1 id=\"2-安装\"><a href=\"#2-安装\" class=\"headerlink\" title=\"2. 安装\"></a>2. 安装</h1><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 不推荐</span></span><br><span class=\"line\">npm install tilestrata-postgismvt --save</span><br></pre></td></tr></table></figure>\n<p>在 ST_AsMVT 方法更新后 ，虽然作者更新了代码，但是 npm 包并不是最新的，建议用下面的方法安装最新版，或者直接去 Github 上下载</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 推荐</span></span><br><span class=\"line\">npm install --save https://github.com/Stezii/tilestrata-postgismvt</span><br></pre></td></tr></table></figure>\n<p>或者通过 package.json</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">\"tilestrata-postgismvt\": \"github:Stezii/tilestrata-postgismvt\"</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-使用\"><a href=\"#3-使用\" class=\"headerlink\" title=\"3. 使用\"></a>3. 使用</h1><p>前提：一个导入了 osm 数据的支持 PostGIS 2.4.0 的数据服务器</p>\n<p>执行 mapbox 的脚本<a href=\"https://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql\" target=\"_blank\" rel=\"noopener\">TileBBox.sql</a>添加<code>TileBBox</code>函数</p>\n<h2 id=\"3-1-普通模式\"><a href=\"#3-1-普通模式\" class=\"headerlink\" title=\"3.1 普通模式\"></a>3.1 普通模式</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> postgismvt = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata-postgismvt\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> headers = <span class=\"built_in\">require</span>(<span class=\"string\">\"tilestrata-headers\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">server = tilestrata();</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">\"osm_mvt\"</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">\"tile.mvt\"</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">\"Access-Control-Allow-Origin\"</span>: <span class=\"string\">\"*\"</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    postgismvt(&#123;</span><br><span class=\"line\">      lyr: &#123;</span><br><span class=\"line\">        table: <span class=\"string\">\"import.osm_buildings\"</span>, <span class=\"comment\">// 表名</span></span><br><span class=\"line\">        geometry: <span class=\"string\">\"geometry\"</span>, <span class=\"comment\">// geometry在表中的字段名</span></span><br><span class=\"line\">        srid: <span class=\"number\">3857</span>, <span class=\"comment\">// 坐标系</span></span><br><span class=\"line\">        minZoom: <span class=\"number\">3</span>,</span><br><span class=\"line\">        maxZoom: <span class=\"number\">19</span>,</span><br><span class=\"line\">        buffer: <span class=\"number\">10</span>, <span class=\"comment\">// 裁剪geometry时的缓冲距离，PostGIS默认为256</span></span><br><span class=\"line\">        fields: <span class=\"string\">\"name\"</span>, <span class=\"comment\">// 额外字段名</span></span><br><span class=\"line\">        resolution: <span class=\"number\">256</span> <span class=\"comment\">// 分辨率，可以是function</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      pgConfig: &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 通过`pgConfig`属性配置PostGIS相关属性</span></span><br><span class=\"line\">        host: <span class=\"string\">\"localhost\"</span>,</span><br><span class=\"line\">        user: <span class=\"string\">\"gis\"</span>,</span><br><span class=\"line\">        password: <span class=\"string\">\"gis\"</span>,</span><br><span class=\"line\">        database: <span class=\"string\">\"gis\"</span>,</span><br><span class=\"line\">        port: <span class=\"string\">\"6543\"</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">8080</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-2-点云数据\"><a href=\"#3-2-点云数据\" class=\"headerlink\" title=\"3.2 点云数据\"></a>3.2 点云数据</h2><p>如果是点要素，可以使用 cluster 模式，只要定义<code>lry</code>中的<code>mode</code>属性为<code>cluster_fields、cluster或function</code>,注意的是需要同时定义<code>type</code>为<code>circle</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">server.layer(<span class=\"string\">'layer_name'</span>).route(<span class=\"string\">'tile.mvt'</span>)</span><br><span class=\"line\">  .use(postgismvt(&#123;</span><br><span class=\"line\">    lyr: &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      mode: <span class=\"string\">'cluster'</span> <span class=\"comment\">// or 'cluster_fields'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    pgConfig: &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;&#125;))</span><br><span class=\"line\">  );</span><br></pre></td></tr></table></figure>\n<p><code>mode</code>和<code>resolution</code>都支持是一个函数。通过这种方式可以手动指定一些缩放级别，用来控制精度</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">server.layer(<span class=\"string\">'layer_name'</span>).route(<span class=\"string\">'tile.mvt'</span>)</span><br><span class=\"line\">  .use(postgismvt(&#123;</span><br><span class=\"line\">    lyr: &#123;</span><br><span class=\"line\">      resolution: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (req.z &gt; <span class=\"number\">12</span>) <span class=\"keyword\">return</span> <span class=\"number\">512</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">256</span>;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      mode: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (req.z &gt; <span class=\"number\">15</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (req.z &gt; <span class=\"number\">13</span>) <span class=\"keyword\">return</span> <span class=\"string\">'cluster_fields'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'cluster'</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    pgConfig: &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;&#125;))</span><br><span class=\"line\">  );</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-效果\"><a href=\"#4-效果\" class=\"headerlink\" title=\"4. 效果\"></a>4. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-postgismvt20190606111135.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"5-代码浅析\"><a href=\"#5-代码浅析\" class=\"headerlink\" title=\"5. 代码浅析\"></a>5. 代码浅析</h1><p>其实核心的方法就是用到了 PostGIS 的<code>ST_AsMVT</code>和<code>ST_AsMVTGeom</code>函数。mapbox 提供<a href=\"https://github.com/mapbox/postgis-vt-util/blob/master/src/TileBBox.sql\" target=\"_blank\" rel=\"noopener\">TileBBox.sql</a>用来计算 zxy 位置的瓦片对应的 box 边界，再查询出其中的 geom，转换成 mvt 格式。</p>\n<p>比如说 <code>z=14,x=12917,y=6430</code>的瓦片对应的 sql 如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> ST_AsMVT(q, <span class=\"string\">'osm_mvt'</span>, <span class=\"number\">256</span>, <span class=\"string\">'geom'</span>) <span class=\"keyword\">AS</span> mvt</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> (</span><br><span class=\"line\">  <span class=\"keyword\">SELECT</span> ST_AsMVTGeom(</span><br><span class=\"line\">    ST_Transform(</span><br><span class=\"line\">\t  import.osm_buildings.geometry, <span class=\"number\">3857</span>),</span><br><span class=\"line\">\t  TileBBox(<span class=\"number\">14</span>, <span class=\"number\">12917</span>, <span class=\"number\">6430</span>, <span class=\"number\">3857</span>),</span><br><span class=\"line\">\t  <span class=\"number\">256</span>,</span><br><span class=\"line\">\t  <span class=\"number\">10</span>,</span><br><span class=\"line\">      <span class=\"literal\">true</span></span><br><span class=\"line\">\t) geom ,<span class=\"keyword\">name</span></span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> import.osm_buildings</span><br><span class=\"line\">    <span class=\"keyword\">WHERE</span> ST_Intersects(TileBBox(<span class=\"number\">14</span>, <span class=\"number\">12917</span>, <span class=\"number\">6430</span>, <span class=\"number\">3857</span>), import.osm_buildings.geometry)</span><br><span class=\"line\">) <span class=\"keyword\">AS</span> q</span><br></pre></td></tr></table></figure>\n<p>此外，<code>fields</code>是可以用逗号分割传递多个想要的字段名的。</p>"},{"title":"tilestrata-underzoom  插件使用及浅析","date":"2019-07-11T14:44:51.000Z","_content":"\n[tilestrata-underzoom](https://github.com/naturalatlas/tilestrata-underzoom)插件从介绍上看就是在请求高级别瓦片时，用低级别的瓦片进行拼接，而不是直接生产指定级别的瓦片。使用这个插件必须安装依赖[node-mapnik](https://github.com/mapnik/node-mapnik)。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 0. 发生了什么\n\n比方说我们请求了`4/13/6`瓦片，即`x=13,y=6,z=4`，插件会分别找到`[[26,12,5],[27,12,5],[27,13,5],[26,13,5]]`四个瓦片，获取数据，然后把四张图片进行合并，而不是直接渲染出`4/13/6`对应的图像。我个人的理解中，在向外缩放的过程中，人眼可视区域内的地图范围越来越大，对于 server 来说要渲染的内容也就越来越多，这个时候就要既保证渲染的展现结果，又要保证渲染过程对服务器资源的占用，`underzoom`对于瓦片地图来说就是针对这一问题的探索。\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-underzoom --save\n```\n\n# 2. 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst dependency = require('tilestrata-dependency')\nconst underzoom = require('tilestrata-underzoom')\nconst mapnik = require('tilestrata-mapnik')\nconst server = tilestrata()\n\n// 用mapnik定义一个世界范围地图\nserver\n  .layer('world_merc')\n  .route('tile.png')\n  .use(\n    mapnik({\n      pathname: 'style/world.xml'\n    })\n  )\n\n// 定义underzoom图层\nserver\n  .layer('underzoom')\n  .route('tile@2x.png')\n  .use(\n    underzoom({\n      source: dependency('world_merc', 'tile.png'),\n      inputSize: 256,\n      outputSize: 512,\n      zooms: 1 // 1以下层级全部采用underzoom的方式拼接\n    })\n  )\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n不启用 underzoom 的效果：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-underzoom-original-20190708145711.png)\n\nunderzoom 放大两倍的效果：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-underzoom-result-20190708145813.png)\n\n可以看到，整个地图看上去**清晰了很多，边缘更加明显**，这是因为低级别瓦片本身的精细程度就高，合并成大图后的对于细节的效果也会更好。\n但是地图左边区域原先就基本上是只由线勾勒出的**白色区域**，在低瓦片中可以看到，合并成大图后就基本上看不清了，这是因为本身线宽是很细的，比如说是 1px 宽度，合并大图的过程中这个宽度并不会增加，但图片整个的像素变大了，所以细线就基本看不清了，这也是插件不好的地方。\n\n# 4. 代码浅析\n\n说到合并图片，就能想到之前我们说过的`tilestrata-blend`插件，它是将两个不同数据源的结果图片进行了合并，而这个插件是将同一个数据源的四个低级别瓦片合并成了一个。\n\n根据 underzoom 的`inputSize、zooms`的配置项，先准备好一个`Mapnik.Image`对象：\n\n```js\nvar canvas = new Mapnik.Image(canvasSize, canvasSize)\n```\n\n之后使用`@mapbox/tilebelt`库获取请求地址的下属四个低级别瓦片地址，分别请求数据，利用上面准备好的`Mapnik.Image`对象，使用[Image.composite](http://mapnik.org/documentation/node-mapnik/3.6/#Image.composite)方法来合并四张图片，最后返回结果就好。\n\n```js\n// 代码有所精简\nfunction startFetchAndComposite(callback) {\n  // 例如请求 4/13/6\n  // 此时coordList就是 [[26,12,5],[27,12,5],[27,13,5],[26,13,5]]\n  var coordList = getTileCoords(req.x, req.y, req.z, underzoomLevels)\n  // 遍历coordList\n  async.each(\n    coordList,\n    function(coords, callback) {\n      // clone一个新的请求\n      var childReq = req.clone()\n      childReq.x = coords[0]\n      childReq.y = coords[1]\n      childReq.z = coords[2]\n      options.source.serve(server, childReq, function(\n        err,\n        childBuffer,\n        childHeaders\n      ) {\n        // 获取数据\n        Mapnik.Image.fromBytes(childBuffer, function(err, image) {\n          // 执行合并操作\n          canvas.composite(\n            image,\n            {\n              comp_op: Mapnik.compositeOp.src_over,\n              dx: x,\n              dy: y,\n              opacity: 1\n            },\n            callback\n          )\n        })\n      })\n    },\n    callback\n  )\n}\n```\n","source":"_posts/2019/tilestrata-underzoom.md","raw":"---\ntitle: tilestrata-underzoom  插件使用及浅析\ndate: 2019-07-11 22:44:51\ntags: [GIS]\ncategories: TileStrata\n---\n\n[tilestrata-underzoom](https://github.com/naturalatlas/tilestrata-underzoom)插件从介绍上看就是在请求高级别瓦片时，用低级别的瓦片进行拼接，而不是直接生产指定级别的瓦片。使用这个插件必须安装依赖[node-mapnik](https://github.com/mapnik/node-mapnik)。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 0. 发生了什么\n\n比方说我们请求了`4/13/6`瓦片，即`x=13,y=6,z=4`，插件会分别找到`[[26,12,5],[27,12,5],[27,13,5],[26,13,5]]`四个瓦片，获取数据，然后把四张图片进行合并，而不是直接渲染出`4/13/6`对应的图像。我个人的理解中，在向外缩放的过程中，人眼可视区域内的地图范围越来越大，对于 server 来说要渲染的内容也就越来越多，这个时候就要既保证渲染的展现结果，又要保证渲染过程对服务器资源的占用，`underzoom`对于瓦片地图来说就是针对这一问题的探索。\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-underzoom --save\n```\n\n# 2. 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst dependency = require('tilestrata-dependency')\nconst underzoom = require('tilestrata-underzoom')\nconst mapnik = require('tilestrata-mapnik')\nconst server = tilestrata()\n\n// 用mapnik定义一个世界范围地图\nserver\n  .layer('world_merc')\n  .route('tile.png')\n  .use(\n    mapnik({\n      pathname: 'style/world.xml'\n    })\n  )\n\n// 定义underzoom图层\nserver\n  .layer('underzoom')\n  .route('tile@2x.png')\n  .use(\n    underzoom({\n      source: dependency('world_merc', 'tile.png'),\n      inputSize: 256,\n      outputSize: 512,\n      zooms: 1 // 1以下层级全部采用underzoom的方式拼接\n    })\n  )\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n不启用 underzoom 的效果：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-underzoom-original-20190708145711.png)\n\nunderzoom 放大两倍的效果：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-underzoom-result-20190708145813.png)\n\n可以看到，整个地图看上去**清晰了很多，边缘更加明显**，这是因为低级别瓦片本身的精细程度就高，合并成大图后的对于细节的效果也会更好。\n但是地图左边区域原先就基本上是只由线勾勒出的**白色区域**，在低瓦片中可以看到，合并成大图后就基本上看不清了，这是因为本身线宽是很细的，比如说是 1px 宽度，合并大图的过程中这个宽度并不会增加，但图片整个的像素变大了，所以细线就基本看不清了，这也是插件不好的地方。\n\n# 4. 代码浅析\n\n说到合并图片，就能想到之前我们说过的`tilestrata-blend`插件，它是将两个不同数据源的结果图片进行了合并，而这个插件是将同一个数据源的四个低级别瓦片合并成了一个。\n\n根据 underzoom 的`inputSize、zooms`的配置项，先准备好一个`Mapnik.Image`对象：\n\n```js\nvar canvas = new Mapnik.Image(canvasSize, canvasSize)\n```\n\n之后使用`@mapbox/tilebelt`库获取请求地址的下属四个低级别瓦片地址，分别请求数据，利用上面准备好的`Mapnik.Image`对象，使用[Image.composite](http://mapnik.org/documentation/node-mapnik/3.6/#Image.composite)方法来合并四张图片，最后返回结果就好。\n\n```js\n// 代码有所精简\nfunction startFetchAndComposite(callback) {\n  // 例如请求 4/13/6\n  // 此时coordList就是 [[26,12,5],[27,12,5],[27,13,5],[26,13,5]]\n  var coordList = getTileCoords(req.x, req.y, req.z, underzoomLevels)\n  // 遍历coordList\n  async.each(\n    coordList,\n    function(coords, callback) {\n      // clone一个新的请求\n      var childReq = req.clone()\n      childReq.x = coords[0]\n      childReq.y = coords[1]\n      childReq.z = coords[2]\n      options.source.serve(server, childReq, function(\n        err,\n        childBuffer,\n        childHeaders\n      ) {\n        // 获取数据\n        Mapnik.Image.fromBytes(childBuffer, function(err, image) {\n          // 执行合并操作\n          canvas.composite(\n            image,\n            {\n              comp_op: Mapnik.compositeOp.src_over,\n              dx: x,\n              dy: y,\n              opacity: 1\n            },\n            callback\n          )\n        })\n      })\n    },\n    callback\n  )\n}\n```\n","slug":"tilestrata-underzoom","published":1,"updated":"2019-07-11T14:49:59.188Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy4fqaa6001r0n3i3anl5273","content":"<p><a href=\"https://github.com/naturalatlas/tilestrata-underzoom\" target=\"_blank\" rel=\"noopener\">tilestrata-underzoom</a>插件从介绍上看就是在请求高级别瓦片时，用低级别的瓦片进行拼接，而不是直接生产指定级别的瓦片。使用这个插件必须安装依赖<a href=\"https://github.com/mapnik/node-mapnik\" target=\"_blank\" rel=\"noopener\">node-mapnik</a>。</p>\n<a id=\"more\"></a>\n<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"0-发生了什么\"><a href=\"#0-发生了什么\" class=\"headerlink\" title=\"0. 发生了什么\"></a>0. 发生了什么</h1><p>比方说我们请求了<code>4/13/6</code>瓦片，即<code>x=13,y=6,z=4</code>，插件会分别找到<code>[[26,12,5],[27,12,5],[27,13,5],[26,13,5]]</code>四个瓦片，获取数据，然后把四张图片进行合并，而不是直接渲染出<code>4/13/6</code>对应的图像。我个人的理解中，在向外缩放的过程中，人眼可视区域内的地图范围越来越大，对于 server 来说要渲染的内容也就越来越多，这个时候就要既保证渲染的展现结果，又要保证渲染过程对服务器资源的占用，<code>underzoom</code>对于瓦片地图来说就是针对这一问题的探索。</p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-underzoom --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> dependency = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-dependency'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> underzoom = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-underzoom'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用mapnik定义一个世界范围地图</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'world_merc'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/world.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义underzoom图层</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'underzoom'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile@2x.png'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    underzoom(&#123;</span><br><span class=\"line\">      source: dependency(<span class=\"string\">'world_merc'</span>, <span class=\"string\">'tile.png'</span>),</span><br><span class=\"line\">      inputSize: <span class=\"number\">256</span>,</span><br><span class=\"line\">      outputSize: <span class=\"number\">512</span>,</span><br><span class=\"line\">      zooms: <span class=\"number\">1</span> <span class=\"comment\">// 1以下层级全部采用underzoom的方式拼接</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>不启用 underzoom 的效果：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-underzoom-original-20190708145711.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>underzoom 放大两倍的效果：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-underzoom-result-20190708145813.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>可以看到，整个地图看上去<strong>清晰了很多，边缘更加明显</strong>，这是因为低级别瓦片本身的精细程度就高，合并成大图后的对于细节的效果也会更好。<br>但是地图左边区域原先就基本上是只由线勾勒出的<strong>白色区域</strong>，在低瓦片中可以看到，合并成大图后就基本上看不清了，这是因为本身线宽是很细的，比如说是 1px 宽度，合并大图的过程中这个宽度并不会增加，但图片整个的像素变大了，所以细线就基本看不清了，这也是插件不好的地方。</p>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>说到合并图片，就能想到之前我们说过的<code>tilestrata-blend</code>插件，它是将两个不同数据源的结果图片进行了合并，而这个插件是将同一个数据源的四个低级别瓦片合并成了一个。</p>\n<p>根据 underzoom 的<code>inputSize、zooms</code>的配置项，先准备好一个<code>Mapnik.Image</code>对象：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canvas = <span class=\"keyword\">new</span> Mapnik.Image(canvasSize, canvasSize)</span><br></pre></td></tr></table></figure>\n<p>之后使用<code>@mapbox/tilebelt</code>库获取请求地址的下属四个低级别瓦片地址，分别请求数据，利用上面准备好的<code>Mapnik.Image</code>对象，使用<a href=\"http://mapnik.org/documentation/node-mapnik/3.6/#Image.composite\" target=\"_blank\" rel=\"noopener\">Image.composite</a>方法来合并四张图片，最后返回结果就好。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码有所精简</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">startFetchAndComposite</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 例如请求 4/13/6</span></span><br><span class=\"line\">  <span class=\"comment\">// 此时coordList就是 [[26,12,5],[27,12,5],[27,13,5],[26,13,5]]</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> coordList = getTileCoords(req.x, req.y, req.z, underzoomLevels)</span><br><span class=\"line\">  <span class=\"comment\">// 遍历coordList</span></span><br><span class=\"line\">  <span class=\"keyword\">async</span>.each(</span><br><span class=\"line\">    coordList,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">coords, callback</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// clone一个新的请求</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> childReq = req.clone()</span><br><span class=\"line\">      childReq.x = coords[<span class=\"number\">0</span>]</span><br><span class=\"line\">      childReq.y = coords[<span class=\"number\">1</span>]</span><br><span class=\"line\">      childReq.z = coords[<span class=\"number\">2</span>]</span><br><span class=\"line\">      options.source.serve(server, childReq, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        err,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        childBuffer,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        childHeaders</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      </span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取数据</span></span><br><span class=\"line\">        Mapnik.Image.fromBytes(childBuffer, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, image</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">// 执行合并操作</span></span><br><span class=\"line\">          canvas.composite(</span><br><span class=\"line\">            image,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              comp_op: Mapnik.compositeOp.src_over,</span><br><span class=\"line\">              dx: x,</span><br><span class=\"line\">              dy: y,</span><br><span class=\"line\">              opacity: <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            callback</span><br><span class=\"line\">          )</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    callback</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/naturalatlas/tilestrata-underzoom\" target=\"_blank\" rel=\"noopener\">tilestrata-underzoom</a>插件从介绍上看就是在请求高级别瓦片时，用低级别的瓦片进行拼接，而不是直接生产指定级别的瓦片。使用这个插件必须安装依赖<a href=\"https://github.com/mapnik/node-mapnik\" target=\"_blank\" rel=\"noopener\">node-mapnik</a>。</p>","more":"<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"0-发生了什么\"><a href=\"#0-发生了什么\" class=\"headerlink\" title=\"0. 发生了什么\"></a>0. 发生了什么</h1><p>比方说我们请求了<code>4/13/6</code>瓦片，即<code>x=13,y=6,z=4</code>，插件会分别找到<code>[[26,12,5],[27,12,5],[27,13,5],[26,13,5]]</code>四个瓦片，获取数据，然后把四张图片进行合并，而不是直接渲染出<code>4/13/6</code>对应的图像。我个人的理解中，在向外缩放的过程中，人眼可视区域内的地图范围越来越大，对于 server 来说要渲染的内容也就越来越多，这个时候就要既保证渲染的展现结果，又要保证渲染过程对服务器资源的占用，<code>underzoom</code>对于瓦片地图来说就是针对这一问题的探索。</p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-underzoom --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> dependency = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-dependency'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> underzoom = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-underzoom'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用mapnik定义一个世界范围地图</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'world_merc'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/world.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义underzoom图层</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'underzoom'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile@2x.png'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    underzoom(&#123;</span><br><span class=\"line\">      source: dependency(<span class=\"string\">'world_merc'</span>, <span class=\"string\">'tile.png'</span>),</span><br><span class=\"line\">      inputSize: <span class=\"number\">256</span>,</span><br><span class=\"line\">      outputSize: <span class=\"number\">512</span>,</span><br><span class=\"line\">      zooms: <span class=\"number\">1</span> <span class=\"comment\">// 1以下层级全部采用underzoom的方式拼接</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>不启用 underzoom 的效果：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-underzoom-original-20190708145711.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>underzoom 放大两倍的效果：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-underzoom-result-20190708145813.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>可以看到，整个地图看上去<strong>清晰了很多，边缘更加明显</strong>，这是因为低级别瓦片本身的精细程度就高，合并成大图后的对于细节的效果也会更好。<br>但是地图左边区域原先就基本上是只由线勾勒出的<strong>白色区域</strong>，在低瓦片中可以看到，合并成大图后就基本上看不清了，这是因为本身线宽是很细的，比如说是 1px 宽度，合并大图的过程中这个宽度并不会增加，但图片整个的像素变大了，所以细线就基本看不清了，这也是插件不好的地方。</p>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>说到合并图片，就能想到之前我们说过的<code>tilestrata-blend</code>插件，它是将两个不同数据源的结果图片进行了合并，而这个插件是将同一个数据源的四个低级别瓦片合并成了一个。</p>\n<p>根据 underzoom 的<code>inputSize、zooms</code>的配置项，先准备好一个<code>Mapnik.Image</code>对象：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canvas = <span class=\"keyword\">new</span> Mapnik.Image(canvasSize, canvasSize)</span><br></pre></td></tr></table></figure>\n<p>之后使用<code>@mapbox/tilebelt</code>库获取请求地址的下属四个低级别瓦片地址，分别请求数据，利用上面准备好的<code>Mapnik.Image</code>对象，使用<a href=\"http://mapnik.org/documentation/node-mapnik/3.6/#Image.composite\" target=\"_blank\" rel=\"noopener\">Image.composite</a>方法来合并四张图片，最后返回结果就好。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码有所精简</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">startFetchAndComposite</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 例如请求 4/13/6</span></span><br><span class=\"line\">  <span class=\"comment\">// 此时coordList就是 [[26,12,5],[27,12,5],[27,13,5],[26,13,5]]</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> coordList = getTileCoords(req.x, req.y, req.z, underzoomLevels)</span><br><span class=\"line\">  <span class=\"comment\">// 遍历coordList</span></span><br><span class=\"line\">  <span class=\"keyword\">async</span>.each(</span><br><span class=\"line\">    coordList,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">coords, callback</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// clone一个新的请求</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> childReq = req.clone()</span><br><span class=\"line\">      childReq.x = coords[<span class=\"number\">0</span>]</span><br><span class=\"line\">      childReq.y = coords[<span class=\"number\">1</span>]</span><br><span class=\"line\">      childReq.z = coords[<span class=\"number\">2</span>]</span><br><span class=\"line\">      options.source.serve(server, childReq, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        err,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        childBuffer,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        childHeaders</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      </span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取数据</span></span><br><span class=\"line\">        Mapnik.Image.fromBytes(childBuffer, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, image</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">// 执行合并操作</span></span><br><span class=\"line\">          canvas.composite(</span><br><span class=\"line\">            image,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              comp_op: Mapnik.compositeOp.src_over,</span><br><span class=\"line\">              dx: x,</span><br><span class=\"line\">              dy: y,</span><br><span class=\"line\">              opacity: <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            callback</span><br><span class=\"line\">          )</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    callback</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"tilestrata-sharp 插件使用及浅析","date":"2019-07-14T12:54:55.000Z","_content":"\n[tilestrata-sharp](https://github.com/naturalatlas/tilestrata-sharp)插件通过使用[libvips](https://github.com/jcupitt/libvips)的[sharp](https://github.com/lovell/sharp)库来转换处理图片。对于图片处理的一些方法参数都可以从 sharp 的[官方文档](https://sharp.pixelplumbing.com/en/stable/)中来找寻，这个插件相当于起到了一个搭桥铺路的作用，核心依然是 sharp。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install sharp --save\n$ npm install tilestrata-sharp --save\n```\n\n# 2. 使用\n\n插件官网中对于使用的说明非常简单，因为插件本身不包含处理图片的逻辑，所以更多的使用方法得去[sharp](https://sharp.pixelplumbing.com/en/stable/)中找寻\n\n```js\nconst tilestrata = require('tilestrata')\nconst mapnik = require('tilestrata-mapnik')\nconst sharp = require('tilestrata-sharp')\nconst server = tilestrata()\n\nserver\n  .layer('world_merc_sharp')\n  .route('tile.png')\n  .use(\n    // 定义数据源\n    mapnik({\n      pathname: 'style/world.xml'\n    })\n  )\n  .use(\n    sharp(function(image, sharp) {\n      return image\n        .resize(256) // 重新设置大小\n        .rotate(180) // 旋转\n        .greyscale() // 灰度处理\n    })\n  )\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n下图是原始的瓦片样式：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-sharp-original-20190705114413.png)\n\n在使用了 sharp 插件进行了旋转 180°，灰度处理之后，如下所示：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-sharp-result-20190705113728.png)\n\n# 4. 代码浅析\n\n这个插件比较简单，属于`transform`类型，返回 buffer 给 tilestrata 之前会根据用户设置的回调函数里面的处理规则，调用`sharp`处理成新的 buffer，然后再返回。\n\n```js\ntransform: function(server, req, buffer, headers, callback) {\n    var image;\n\n    try {\n        // 用原buffer生成sharp对象\n        image = sharp(buffer);\n        // 执行回调里面的处理规则\n        fn(image, sharp);\n    }\n    catch (err) { return callback(err); }\n\n    // 转化回buffer\n    image.toBuffer(function(err, buffer, info) {\n        if (err) return callback(err);\n        headers['Content-Type'] = 'image/' + info.format;\n        // 还给tilestrata\n        callback(null, buffer, headers);\n    });\n}\n```\n","source":"_posts/2019/tilestrata-sharp.md","raw":"---\ntitle: tilestrata-sharp 插件使用及浅析\ndate: 2019-07-14 20:54:55\ntags: [GIS]\ncategories: TileStrata\n---\n\n[tilestrata-sharp](https://github.com/naturalatlas/tilestrata-sharp)插件通过使用[libvips](https://github.com/jcupitt/libvips)的[sharp](https://github.com/lovell/sharp)库来转换处理图片。对于图片处理的一些方法参数都可以从 sharp 的[官方文档](https://sharp.pixelplumbing.com/en/stable/)中来找寻，这个插件相当于起到了一个搭桥铺路的作用，核心依然是 sharp。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install sharp --save\n$ npm install tilestrata-sharp --save\n```\n\n# 2. 使用\n\n插件官网中对于使用的说明非常简单，因为插件本身不包含处理图片的逻辑，所以更多的使用方法得去[sharp](https://sharp.pixelplumbing.com/en/stable/)中找寻\n\n```js\nconst tilestrata = require('tilestrata')\nconst mapnik = require('tilestrata-mapnik')\nconst sharp = require('tilestrata-sharp')\nconst server = tilestrata()\n\nserver\n  .layer('world_merc_sharp')\n  .route('tile.png')\n  .use(\n    // 定义数据源\n    mapnik({\n      pathname: 'style/world.xml'\n    })\n  )\n  .use(\n    sharp(function(image, sharp) {\n      return image\n        .resize(256) // 重新设置大小\n        .rotate(180) // 旋转\n        .greyscale() // 灰度处理\n    })\n  )\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n下图是原始的瓦片样式：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-sharp-original-20190705114413.png)\n\n在使用了 sharp 插件进行了旋转 180°，灰度处理之后，如下所示：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-sharp-result-20190705113728.png)\n\n# 4. 代码浅析\n\n这个插件比较简单，属于`transform`类型，返回 buffer 给 tilestrata 之前会根据用户设置的回调函数里面的处理规则，调用`sharp`处理成新的 buffer，然后再返回。\n\n```js\ntransform: function(server, req, buffer, headers, callback) {\n    var image;\n\n    try {\n        // 用原buffer生成sharp对象\n        image = sharp(buffer);\n        // 执行回调里面的处理规则\n        fn(image, sharp);\n    }\n    catch (err) { return callback(err); }\n\n    // 转化回buffer\n    image.toBuffer(function(err, buffer, info) {\n        if (err) return callback(err);\n        headers['Content-Type'] = 'image/' + info.format;\n        // 还给tilestrata\n        callback(null, buffer, headers);\n    });\n}\n```\n","slug":"tilestrata-sharp","published":1,"updated":"2019-07-14T12:58:59.927Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy4fqaa7001v0n3itx494qlq","content":"<p><a href=\"https://github.com/naturalatlas/tilestrata-sharp\" target=\"_blank\" rel=\"noopener\">tilestrata-sharp</a>插件通过使用<a href=\"https://github.com/jcupitt/libvips\" target=\"_blank\" rel=\"noopener\">libvips</a>的<a href=\"https://github.com/lovell/sharp\" target=\"_blank\" rel=\"noopener\">sharp</a>库来转换处理图片。对于图片处理的一些方法参数都可以从 sharp 的<a href=\"https://sharp.pixelplumbing.com/en/stable/\" target=\"_blank\" rel=\"noopener\">官方文档</a>中来找寻，这个插件相当于起到了一个搭桥铺路的作用，核心依然是 sharp。</p>\n<a id=\"more\"></a>\n<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install sharp --save</span><br><span class=\"line\">$ npm install tilestrata-sharp --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><p>插件官网中对于使用的说明非常简单，因为插件本身不包含处理图片的逻辑，所以更多的使用方法得去<a href=\"https://sharp.pixelplumbing.com/en/stable/\" target=\"_blank\" rel=\"noopener\">sharp</a>中找寻</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> sharp = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-sharp'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'world_merc_sharp'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    <span class=\"comment\">// 定义数据源</span></span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/world.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    sharp(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">image, sharp</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> image</span><br><span class=\"line\">        .resize(<span class=\"number\">256</span>) <span class=\"comment\">// 重新设置大小</span></span><br><span class=\"line\">        .rotate(<span class=\"number\">180</span>) <span class=\"comment\">// 旋转</span></span><br><span class=\"line\">        .greyscale() <span class=\"comment\">// 灰度处理</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>下图是原始的瓦片样式：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-sharp-original-20190705114413.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>在使用了 sharp 插件进行了旋转 180°，灰度处理之后，如下所示：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-sharp-result-20190705113728.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>这个插件比较简单，属于<code>transform</code>类型，返回 buffer 给 tilestrata 之前会根据用户设置的回调函数里面的处理规则，调用<code>sharp</code>处理成新的 buffer，然后再返回。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">transform: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req, buffer, headers, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> image;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 用原buffer生成sharp对象</span></span><br><span class=\"line\">        image = sharp(buffer);</span><br><span class=\"line\">        <span class=\"comment\">// 执行回调里面的处理规则</span></span><br><span class=\"line\">        fn(image, sharp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (err) &#123; <span class=\"keyword\">return</span> callback(err); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 转化回buffer</span></span><br><span class=\"line\">    image.toBuffer(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, buffer, info</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> callback(err);</span><br><span class=\"line\">        headers[<span class=\"string\">'Content-Type'</span>] = <span class=\"string\">'image/'</span> + info.format;</span><br><span class=\"line\">        <span class=\"comment\">// 还给tilestrata</span></span><br><span class=\"line\">        callback(<span class=\"literal\">null</span>, buffer, headers);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/naturalatlas/tilestrata-sharp\" target=\"_blank\" rel=\"noopener\">tilestrata-sharp</a>插件通过使用<a href=\"https://github.com/jcupitt/libvips\" target=\"_blank\" rel=\"noopener\">libvips</a>的<a href=\"https://github.com/lovell/sharp\" target=\"_blank\" rel=\"noopener\">sharp</a>库来转换处理图片。对于图片处理的一些方法参数都可以从 sharp 的<a href=\"https://sharp.pixelplumbing.com/en/stable/\" target=\"_blank\" rel=\"noopener\">官方文档</a>中来找寻，这个插件相当于起到了一个搭桥铺路的作用，核心依然是 sharp。</p>","more":"<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install sharp --save</span><br><span class=\"line\">$ npm install tilestrata-sharp --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><p>插件官网中对于使用的说明非常简单，因为插件本身不包含处理图片的逻辑，所以更多的使用方法得去<a href=\"https://sharp.pixelplumbing.com/en/stable/\" target=\"_blank\" rel=\"noopener\">sharp</a>中找寻</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapnik = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-mapnik'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> sharp = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-sharp'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'world_merc_sharp'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    <span class=\"comment\">// 定义数据源</span></span><br><span class=\"line\">    mapnik(&#123;</span><br><span class=\"line\">      pathname: <span class=\"string\">'style/world.xml'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    sharp(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">image, sharp</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> image</span><br><span class=\"line\">        .resize(<span class=\"number\">256</span>) <span class=\"comment\">// 重新设置大小</span></span><br><span class=\"line\">        .rotate(<span class=\"number\">180</span>) <span class=\"comment\">// 旋转</span></span><br><span class=\"line\">        .greyscale() <span class=\"comment\">// 灰度处理</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>下图是原始的瓦片样式：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-sharp-original-20190705114413.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>在使用了 sharp 插件进行了旋转 180°，灰度处理之后，如下所示：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/tilestrata-sharp-result-20190705113728.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>这个插件比较简单，属于<code>transform</code>类型，返回 buffer 给 tilestrata 之前会根据用户设置的回调函数里面的处理规则，调用<code>sharp</code>处理成新的 buffer，然后再返回。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">transform: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">server, req, buffer, headers, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> image;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 用原buffer生成sharp对象</span></span><br><span class=\"line\">        image = sharp(buffer);</span><br><span class=\"line\">        <span class=\"comment\">// 执行回调里面的处理规则</span></span><br><span class=\"line\">        fn(image, sharp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (err) &#123; <span class=\"keyword\">return</span> callback(err); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 转化回buffer</span></span><br><span class=\"line\">    image.toBuffer(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, buffer, info</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> callback(err);</span><br><span class=\"line\">        headers[<span class=\"string\">'Content-Type'</span>] = <span class=\"string\">'image/'</span> + info.format;</span><br><span class=\"line\">        <span class=\"comment\">// 还给tilestrata</span></span><br><span class=\"line\">        callback(<span class=\"literal\">null</span>, buffer, headers);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"tilestrata-vtile-composite 插件使用及浅析","date":"2019-07-07T08:56:34.000Z","_content":"\n[tilestrata-vtile-composite](https://github.com/naturalatlas/tilestrata-vtile-composite)插件用来合并多个矢量瓦片图层，这些矢量瓦片图层来自于[tilestrata-vtile](https://github.com/naturalatlas/tilestrata-vtile)插件。使用这个插件必须安装依赖[node-mapnik](https://github.com/mapnik/node-mapnik)。\n这个插件的作用和[tilestrata-blend](https://github.com/naturalatlas/tilestrata-blend)类似，只是适用对象是 vtile 生产出来的矢量瓦片。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-vtile-composite --save\n```\n\n# 2. 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst vtile = require('tilestrata-vtile')\nconst vtilecomposite = require('tilestrata-vtile-composite')\nconst headers = require('tilestrata-headers')\n\nconst server = tilestrata()\n\n// 省界边界源\nconst provinceXml = {\n  xml: 'style/province.xml',\n  tileSize: 256,\n  metatile: 1,\n  bufferSize: 128\n}\n\n// 世界边界源\nconst worldXml = {\n  xml: 'style/world.xml',\n  tileSize: 256,\n  metatile: 1,\n  bufferSize: 128\n}\n\n// 定义第一个数据源\nserver\n  .layer('province_pbf')\n  .route('t.pbf')\n  .use(vtile(provinceXml))\n\n// 定义第一个数据源\nserver\n  .layer('world_pbf')\n  .route('t.pbf')\n  .use(vtile(worldXml))\n\n// 合并两个数据源，开启跨域访问\nserver\n  .layer('combined_pbf')\n  .route('combined.pbf')\n  .use(\n    headers({\n      'Access-Control-Allow-Origin': '*'\n    })\n  )\n  .use(vtilecomposite([['world_pbf', 't.pbf'], ['province_pbf', 't.pbf']]))\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n这是单独的中国区域 pbf：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/v-tile-composite-pro-20190704173456.png)\n\n这是单独的世界区域 pbf：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/v-tile-composite-world-20190704173556.png)\n\n合并之后的图层：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/v-tile-composite-20190704173718.png)\n\n# 4. 代码浅析\n\n其实原理也就解释了为什么官方说明中一定要在依赖中加入`node-mapnik`。核心代码如下：\n\n```js\nfunction compositeTiles(callback) {\n  if (vtiles.length === 0) return callback()\n\n  var merged = new mapnik.VectorTile(req.z, req.x, req.y)\n  // 我是关键\n  merged.composite(vtiles, function(err) {\n    vtiles = null\n    if (err) return callback(err)\n\n    result = merged.getData(dataopts)\n    result._vtile = merged\n    result._vx = req.x\n    result._vy = req.y\n    result._vz = req.z\n    callback()\n  })\n}\n```\n\n在连续请求完两个数据源的数据之后，新建 mapnik 的`VectorTile`对象，并调用其[VectorTile.composite](http://mapnik.org/documentation/node-mapnik/3.6/#VectorTile.composite)方法，对两个数据源请求来的数据进行合并，最后再`getData`输出结果就好。\n","source":"_posts/2019/tilestrata-vtile-composite.md","raw":"---\ntitle: tilestrata-vtile-composite 插件使用及浅析\ndate: 2019-07-07 16:56:34\ntags: [GIS]\ncategories: TileStrata\n---\n\n[tilestrata-vtile-composite](https://github.com/naturalatlas/tilestrata-vtile-composite)插件用来合并多个矢量瓦片图层，这些矢量瓦片图层来自于[tilestrata-vtile](https://github.com/naturalatlas/tilestrata-vtile)插件。使用这个插件必须安装依赖[node-mapnik](https://github.com/mapnik/node-mapnik)。\n这个插件的作用和[tilestrata-blend](https://github.com/naturalatlas/tilestrata-blend)类似，只是适用对象是 vtile 生产出来的矢量瓦片。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-vtile-composite --save\n```\n\n# 2. 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst vtile = require('tilestrata-vtile')\nconst vtilecomposite = require('tilestrata-vtile-composite')\nconst headers = require('tilestrata-headers')\n\nconst server = tilestrata()\n\n// 省界边界源\nconst provinceXml = {\n  xml: 'style/province.xml',\n  tileSize: 256,\n  metatile: 1,\n  bufferSize: 128\n}\n\n// 世界边界源\nconst worldXml = {\n  xml: 'style/world.xml',\n  tileSize: 256,\n  metatile: 1,\n  bufferSize: 128\n}\n\n// 定义第一个数据源\nserver\n  .layer('province_pbf')\n  .route('t.pbf')\n  .use(vtile(provinceXml))\n\n// 定义第一个数据源\nserver\n  .layer('world_pbf')\n  .route('t.pbf')\n  .use(vtile(worldXml))\n\n// 合并两个数据源，开启跨域访问\nserver\n  .layer('combined_pbf')\n  .route('combined.pbf')\n  .use(\n    headers({\n      'Access-Control-Allow-Origin': '*'\n    })\n  )\n  .use(vtilecomposite([['world_pbf', 't.pbf'], ['province_pbf', 't.pbf']]))\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n这是单独的中国区域 pbf：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/v-tile-composite-pro-20190704173456.png)\n\n这是单独的世界区域 pbf：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/v-tile-composite-world-20190704173556.png)\n\n合并之后的图层：\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/v-tile-composite-20190704173718.png)\n\n# 4. 代码浅析\n\n其实原理也就解释了为什么官方说明中一定要在依赖中加入`node-mapnik`。核心代码如下：\n\n```js\nfunction compositeTiles(callback) {\n  if (vtiles.length === 0) return callback()\n\n  var merged = new mapnik.VectorTile(req.z, req.x, req.y)\n  // 我是关键\n  merged.composite(vtiles, function(err) {\n    vtiles = null\n    if (err) return callback(err)\n\n    result = merged.getData(dataopts)\n    result._vtile = merged\n    result._vx = req.x\n    result._vy = req.y\n    result._vz = req.z\n    callback()\n  })\n}\n```\n\n在连续请求完两个数据源的数据之后，新建 mapnik 的`VectorTile`对象，并调用其[VectorTile.composite](http://mapnik.org/documentation/node-mapnik/3.6/#VectorTile.composite)方法，对两个数据源请求来的数据进行合并，最后再`getData`输出结果就好。\n","slug":"tilestrata-vtile-composite","published":1,"updated":"2019-07-07T08:58:20.921Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy4fqaa9001y0n3i4hs08oo9","content":"<p><a href=\"https://github.com/naturalatlas/tilestrata-vtile-composite\" target=\"_blank\" rel=\"noopener\">tilestrata-vtile-composite</a>插件用来合并多个矢量瓦片图层，这些矢量瓦片图层来自于<a href=\"https://github.com/naturalatlas/tilestrata-vtile\" target=\"_blank\" rel=\"noopener\">tilestrata-vtile</a>插件。使用这个插件必须安装依赖<a href=\"https://github.com/mapnik/node-mapnik\" target=\"_blank\" rel=\"noopener\">node-mapnik</a>。<br>这个插件的作用和<a href=\"https://github.com/naturalatlas/tilestrata-blend\" target=\"_blank\" rel=\"noopener\">tilestrata-blend</a>类似，只是适用对象是 vtile 生产出来的矢量瓦片。</p>\n<a id=\"more\"></a>\n<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-vtile-composite --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> vtile = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-vtile'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> vtilecomposite = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-vtile-composite'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> headers = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-headers'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 省界边界源</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> provinceXml = &#123;</span><br><span class=\"line\">  xml: <span class=\"string\">'style/province.xml'</span>,</span><br><span class=\"line\">  tileSize: <span class=\"number\">256</span>,</span><br><span class=\"line\">  metatile: <span class=\"number\">1</span>,</span><br><span class=\"line\">  bufferSize: <span class=\"number\">128</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 世界边界源</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> worldXml = &#123;</span><br><span class=\"line\">  xml: <span class=\"string\">'style/world.xml'</span>,</span><br><span class=\"line\">  tileSize: <span class=\"number\">256</span>,</span><br><span class=\"line\">  metatile: <span class=\"number\">1</span>,</span><br><span class=\"line\">  bufferSize: <span class=\"number\">128</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义第一个数据源</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'province_pbf'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'t.pbf'</span>)</span><br><span class=\"line\">  .use(vtile(provinceXml))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义第一个数据源</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'world_pbf'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'t.pbf'</span>)</span><br><span class=\"line\">  .use(vtile(worldXml))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 合并两个数据源，开启跨域访问</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'combined_pbf'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'combined.pbf'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">'Access-Control-Allow-Origin'</span>: <span class=\"string\">'*'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(vtilecomposite([[<span class=\"string\">'world_pbf'</span>, <span class=\"string\">'t.pbf'</span>], [<span class=\"string\">'province_pbf'</span>, <span class=\"string\">'t.pbf'</span>]]))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>这是单独的中国区域 pbf：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/v-tile-composite-pro-20190704173456.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>这是单独的世界区域 pbf：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/v-tile-composite-world-20190704173556.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>合并之后的图层：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/v-tile-composite-20190704173718.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>其实原理也就解释了为什么官方说明中一定要在依赖中加入<code>node-mapnik</code>。核心代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compositeTiles</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (vtiles.length === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> callback()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> merged = <span class=\"keyword\">new</span> mapnik.VectorTile(req.z, req.x, req.y)</span><br><span class=\"line\">  <span class=\"comment\">// 我是关键</span></span><br><span class=\"line\">  merged.composite(vtiles, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    vtiles = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> callback(err)</span><br><span class=\"line\"></span><br><span class=\"line\">    result = merged.getData(dataopts)</span><br><span class=\"line\">    result._vtile = merged</span><br><span class=\"line\">    result._vx = req.x</span><br><span class=\"line\">    result._vy = req.y</span><br><span class=\"line\">    result._vz = req.z</span><br><span class=\"line\">    callback()</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在连续请求完两个数据源的数据之后，新建 mapnik 的<code>VectorTile</code>对象，并调用其<a href=\"http://mapnik.org/documentation/node-mapnik/3.6/#VectorTile.composite\" target=\"_blank\" rel=\"noopener\">VectorTile.composite</a>方法，对两个数据源请求来的数据进行合并，最后再<code>getData</code>输出结果就好。</p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/naturalatlas/tilestrata-vtile-composite\" target=\"_blank\" rel=\"noopener\">tilestrata-vtile-composite</a>插件用来合并多个矢量瓦片图层，这些矢量瓦片图层来自于<a href=\"https://github.com/naturalatlas/tilestrata-vtile\" target=\"_blank\" rel=\"noopener\">tilestrata-vtile</a>插件。使用这个插件必须安装依赖<a href=\"https://github.com/mapnik/node-mapnik\" target=\"_blank\" rel=\"noopener\">node-mapnik</a>。<br>这个插件的作用和<a href=\"https://github.com/naturalatlas/tilestrata-blend\" target=\"_blank\" rel=\"noopener\">tilestrata-blend</a>类似，只是适用对象是 vtile 生产出来的矢量瓦片。</p>","more":"<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-vtile-composite --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> vtile = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-vtile'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> vtilecomposite = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-vtile-composite'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> headers = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-headers'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 省界边界源</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> provinceXml = &#123;</span><br><span class=\"line\">  xml: <span class=\"string\">'style/province.xml'</span>,</span><br><span class=\"line\">  tileSize: <span class=\"number\">256</span>,</span><br><span class=\"line\">  metatile: <span class=\"number\">1</span>,</span><br><span class=\"line\">  bufferSize: <span class=\"number\">128</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 世界边界源</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> worldXml = &#123;</span><br><span class=\"line\">  xml: <span class=\"string\">'style/world.xml'</span>,</span><br><span class=\"line\">  tileSize: <span class=\"number\">256</span>,</span><br><span class=\"line\">  metatile: <span class=\"number\">1</span>,</span><br><span class=\"line\">  bufferSize: <span class=\"number\">128</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义第一个数据源</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'province_pbf'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'t.pbf'</span>)</span><br><span class=\"line\">  .use(vtile(provinceXml))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义第一个数据源</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'world_pbf'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'t.pbf'</span>)</span><br><span class=\"line\">  .use(vtile(worldXml))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 合并两个数据源，开启跨域访问</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'combined_pbf'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'combined.pbf'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">'Access-Control-Allow-Origin'</span>: <span class=\"string\">'*'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(vtilecomposite([[<span class=\"string\">'world_pbf'</span>, <span class=\"string\">'t.pbf'</span>], [<span class=\"string\">'province_pbf'</span>, <span class=\"string\">'t.pbf'</span>]]))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>这是单独的中国区域 pbf：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/v-tile-composite-pro-20190704173456.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>这是单独的世界区域 pbf：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/v-tile-composite-world-20190704173556.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<p>合并之后的图层：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/v-tile-composite-20190704173718.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>其实原理也就解释了为什么官方说明中一定要在依赖中加入<code>node-mapnik</code>。核心代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compositeTiles</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (vtiles.length === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> callback()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> merged = <span class=\"keyword\">new</span> mapnik.VectorTile(req.z, req.x, req.y)</span><br><span class=\"line\">  <span class=\"comment\">// 我是关键</span></span><br><span class=\"line\">  merged.composite(vtiles, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    vtiles = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> callback(err)</span><br><span class=\"line\"></span><br><span class=\"line\">    result = merged.getData(dataopts)</span><br><span class=\"line\">    result._vtile = merged</span><br><span class=\"line\">    result._vx = req.x</span><br><span class=\"line\">    result._vy = req.y</span><br><span class=\"line\">    result._vz = req.z</span><br><span class=\"line\">    callback()</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在连续请求完两个数据源的数据之后，新建 mapnik 的<code>VectorTile</code>对象，并调用其<a href=\"http://mapnik.org/documentation/node-mapnik/3.6/#VectorTile.composite\" target=\"_blank\" rel=\"noopener\">VectorTile.composite</a>方法，对两个数据源请求来的数据进行合并，最后再<code>getData</code>输出结果就好。</p>"},{"title":"tilestrata-vtile-raster 插件使用及浅析","date":"2019-07-05T06:05:38.000Z","_content":"\n[tilestrata-vtile-raster](https://github.com/naturalatlas/tilestrata-vtile-raster)是配合`tilestrata-vtile`插件用来将 mapnik 的`pbf`格式的矢量瓦片转换成栅格图片。使用这个插件必须安装依赖[node-mapnik](https://github.com/mapnik/node-mapnik)。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-vtile-raster --save\n```\n\n# 2. 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst vtile = require('tilestrata-vtile')\nconst vtileraster = require('tilestrata-vtile-raster')\nconst headers = require('tilestrata-headers')\n\nconst server = tilestrata()\n\n// 定义省界边界数据源\nconst common = {\n  xml: 'style/province.xml',\n  tileSize: 256,\n  metatile: 1,\n  bufferSize: 128\n}\n\nserver\n  .layer('osm_pbf_raster')\n  .route('tile.pbf') // 定义vtile pbf图层做对比\n  .use(\n    headers({\n      'Access-Control-Allow-Origin': '*'\n    })\n  )\n  .use(vtile(common))\n  .route('tile.png') // 定义vtile-raster png图层做对比\n  .use(\n    vtileraster(common, {\n      tilesource: ['osm_pbf_raster', 'tile.pbf']\n    })\n  )\n  .route('tile.json')\n  .use(\n    vtileraster(common, {\n      tilesource: ['osm_pbf_raster', 'tile.pbf']\n    })\n  )\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n可以直接使用常规的栅格瓦片加载方式来加载`tile.png`图层，无须使用矢量瓦片的加载方式。可以和[tilestrata-vtile 插件浅析](https://kael.top/2019/07/04/tilestrata-vtile/)对比观看。\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/v-tile-raster-result-20190704172822.png)\n\n# 4. 代码浅析\n\n核心仍然是 mapnik 的功能，过程上大体是和 tilestrata-vtile 插件类似的，不同的地方在当请求图层的时候，不再单纯的使用[VectorTile](http://mapnik.org/documentation/node-mapnik/3.6/#VectorTile)的`getData`方法，首先代码会依据是否可交互属性`interactivity`来构造一个类型是`mapnik.Image`的`surface`参数\n\n```js\nif (self.interactivity) {\n  surface = new mapnik.Grid(dim, dim)\n  // ... 省略\n} else {\n  surface = new mapnik.Image(dim, dim)\n}\n```\n\n然后使用[VectorTile.render](http://mapnik.org/documentation/node-mapnik/3.6/#VectorTile.render)这个方法，通过 xml 构建出来的 map 和上面的 surface 参数，就可以将矢量数据转化为栅格图片：\n\n```js\nvectorTile.render(self.map, surface, options, callback)\n```\n","source":"_posts/2019/tilestrata-vtile-raster.md","raw":"---\ntitle: tilestrata-vtile-raster 插件使用及浅析\ndate: 2019-07-05 14:05:38\ntags: [GIS]\ncategories: TileStrata\n---\n\n[tilestrata-vtile-raster](https://github.com/naturalatlas/tilestrata-vtile-raster)是配合`tilestrata-vtile`插件用来将 mapnik 的`pbf`格式的矢量瓦片转换成栅格图片。使用这个插件必须安装依赖[node-mapnik](https://github.com/mapnik/node-mapnik)。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-vtile-raster --save\n```\n\n# 2. 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst vtile = require('tilestrata-vtile')\nconst vtileraster = require('tilestrata-vtile-raster')\nconst headers = require('tilestrata-headers')\n\nconst server = tilestrata()\n\n// 定义省界边界数据源\nconst common = {\n  xml: 'style/province.xml',\n  tileSize: 256,\n  metatile: 1,\n  bufferSize: 128\n}\n\nserver\n  .layer('osm_pbf_raster')\n  .route('tile.pbf') // 定义vtile pbf图层做对比\n  .use(\n    headers({\n      'Access-Control-Allow-Origin': '*'\n    })\n  )\n  .use(vtile(common))\n  .route('tile.png') // 定义vtile-raster png图层做对比\n  .use(\n    vtileraster(common, {\n      tilesource: ['osm_pbf_raster', 'tile.pbf']\n    })\n  )\n  .route('tile.json')\n  .use(\n    vtileraster(common, {\n      tilesource: ['osm_pbf_raster', 'tile.pbf']\n    })\n  )\n\n// 启动服务\nserver.listen(9527)\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n可以直接使用常规的栅格瓦片加载方式来加载`tile.png`图层，无须使用矢量瓦片的加载方式。可以和[tilestrata-vtile 插件浅析](https://kael.top/2019/07/04/tilestrata-vtile/)对比观看。\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/v-tile-raster-result-20190704172822.png)\n\n# 4. 代码浅析\n\n核心仍然是 mapnik 的功能，过程上大体是和 tilestrata-vtile 插件类似的，不同的地方在当请求图层的时候，不再单纯的使用[VectorTile](http://mapnik.org/documentation/node-mapnik/3.6/#VectorTile)的`getData`方法，首先代码会依据是否可交互属性`interactivity`来构造一个类型是`mapnik.Image`的`surface`参数\n\n```js\nif (self.interactivity) {\n  surface = new mapnik.Grid(dim, dim)\n  // ... 省略\n} else {\n  surface = new mapnik.Image(dim, dim)\n}\n```\n\n然后使用[VectorTile.render](http://mapnik.org/documentation/node-mapnik/3.6/#VectorTile.render)这个方法，通过 xml 构建出来的 map 和上面的 surface 参数，就可以将矢量数据转化为栅格图片：\n\n```js\nvectorTile.render(self.map, surface, options, callback)\n```\n","slug":"tilestrata-vtile-raster","published":1,"updated":"2019-07-05T06:08:56.914Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy4fqaaa00220n3ibqiqx90g","content":"<p><a href=\"https://github.com/naturalatlas/tilestrata-vtile-raster\" target=\"_blank\" rel=\"noopener\">tilestrata-vtile-raster</a>是配合<code>tilestrata-vtile</code>插件用来将 mapnik 的<code>pbf</code>格式的矢量瓦片转换成栅格图片。使用这个插件必须安装依赖<a href=\"https://github.com/mapnik/node-mapnik\" target=\"_blank\" rel=\"noopener\">node-mapnik</a>。</p>\n<a id=\"more\"></a>\n<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-vtile-raster --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> vtile = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-vtile'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> vtileraster = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-vtile-raster'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> headers = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-headers'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义省界边界数据源</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> common = &#123;</span><br><span class=\"line\">  xml: <span class=\"string\">'style/province.xml'</span>,</span><br><span class=\"line\">  tileSize: <span class=\"number\">256</span>,</span><br><span class=\"line\">  metatile: <span class=\"number\">1</span>,</span><br><span class=\"line\">  bufferSize: <span class=\"number\">128</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'osm_pbf_raster'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.pbf'</span>) <span class=\"comment\">// 定义vtile pbf图层做对比</span></span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">'Access-Control-Allow-Origin'</span>: <span class=\"string\">'*'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(vtile(common))</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>) <span class=\"comment\">// 定义vtile-raster png图层做对比</span></span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    vtileraster(common, &#123;</span><br><span class=\"line\">      tilesource: [<span class=\"string\">'osm_pbf_raster'</span>, <span class=\"string\">'tile.pbf'</span>]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.json'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    vtileraster(common, &#123;</span><br><span class=\"line\">      tilesource: [<span class=\"string\">'osm_pbf_raster'</span>, <span class=\"string\">'tile.pbf'</span>]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>可以直接使用常规的栅格瓦片加载方式来加载<code>tile.png</code>图层，无须使用矢量瓦片的加载方式。可以和<a href=\"https://kael.top/2019/07/04/tilestrata-vtile/\">tilestrata-vtile 插件浅析</a>对比观看。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/v-tile-raster-result-20190704172822.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>核心仍然是 mapnik 的功能，过程上大体是和 tilestrata-vtile 插件类似的，不同的地方在当请求图层的时候，不再单纯的使用<a href=\"http://mapnik.org/documentation/node-mapnik/3.6/#VectorTile\" target=\"_blank\" rel=\"noopener\">VectorTile</a>的<code>getData</code>方法，首先代码会依据是否可交互属性<code>interactivity</code>来构造一个类型是<code>mapnik.Image</code>的<code>surface</code>参数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (self.interactivity) &#123;</span><br><span class=\"line\">  surface = <span class=\"keyword\">new</span> mapnik.Grid(dim, dim)</span><br><span class=\"line\">  <span class=\"comment\">// ... 省略</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  surface = <span class=\"keyword\">new</span> mapnik.Image(dim, dim)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后使用<a href=\"http://mapnik.org/documentation/node-mapnik/3.6/#VectorTile.render\" target=\"_blank\" rel=\"noopener\">VectorTile.render</a>这个方法，通过 xml 构建出来的 map 和上面的 surface 参数，就可以将矢量数据转化为栅格图片：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">vectorTile.render(self.map, surface, options, callback)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/naturalatlas/tilestrata-vtile-raster\" target=\"_blank\" rel=\"noopener\">tilestrata-vtile-raster</a>是配合<code>tilestrata-vtile</code>插件用来将 mapnik 的<code>pbf</code>格式的矢量瓦片转换成栅格图片。使用这个插件必须安装依赖<a href=\"https://github.com/mapnik/node-mapnik\" target=\"_blank\" rel=\"noopener\">node-mapnik</a>。</p>","more":"<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-vtile-raster --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> vtile = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-vtile'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> vtileraster = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-vtile-raster'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> headers = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-headers'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义省界边界数据源</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> common = &#123;</span><br><span class=\"line\">  xml: <span class=\"string\">'style/province.xml'</span>,</span><br><span class=\"line\">  tileSize: <span class=\"number\">256</span>,</span><br><span class=\"line\">  metatile: <span class=\"number\">1</span>,</span><br><span class=\"line\">  bufferSize: <span class=\"number\">128</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'osm_pbf_raster'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.pbf'</span>) <span class=\"comment\">// 定义vtile pbf图层做对比</span></span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">'Access-Control-Allow-Origin'</span>: <span class=\"string\">'*'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(vtile(common))</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.png'</span>) <span class=\"comment\">// 定义vtile-raster png图层做对比</span></span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    vtileraster(common, &#123;</span><br><span class=\"line\">      tilesource: [<span class=\"string\">'osm_pbf_raster'</span>, <span class=\"string\">'tile.pbf'</span>]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.json'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    vtileraster(common, &#123;</span><br><span class=\"line\">      tilesource: [<span class=\"string\">'osm_pbf_raster'</span>, <span class=\"string\">'tile.pbf'</span>]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<p>可以直接使用常规的栅格瓦片加载方式来加载<code>tile.png</code>图层，无须使用矢量瓦片的加载方式。可以和<a href=\"https://kael.top/2019/07/04/tilestrata-vtile/\">tilestrata-vtile 插件浅析</a>对比观看。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/v-tile-raster-result-20190704172822.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>核心仍然是 mapnik 的功能，过程上大体是和 tilestrata-vtile 插件类似的，不同的地方在当请求图层的时候，不再单纯的使用<a href=\"http://mapnik.org/documentation/node-mapnik/3.6/#VectorTile\" target=\"_blank\" rel=\"noopener\">VectorTile</a>的<code>getData</code>方法，首先代码会依据是否可交互属性<code>interactivity</code>来构造一个类型是<code>mapnik.Image</code>的<code>surface</code>参数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (self.interactivity) &#123;</span><br><span class=\"line\">  surface = <span class=\"keyword\">new</span> mapnik.Grid(dim, dim)</span><br><span class=\"line\">  <span class=\"comment\">// ... 省略</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  surface = <span class=\"keyword\">new</span> mapnik.Image(dim, dim)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后使用<a href=\"http://mapnik.org/documentation/node-mapnik/3.6/#VectorTile.render\" target=\"_blank\" rel=\"noopener\">VectorTile.render</a>这个方法，通过 xml 构建出来的 map 和上面的 surface 参数，就可以将矢量数据转化为栅格图片：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">vectorTile.render(self.map, surface, options, callback)</span><br></pre></td></tr></table></figure>"},{"title":"tilestrata-vtile 插件使用及浅析","date":"2019-07-04T09:39:41.000Z","_content":"\n[tilestrata-vtile](https://github.com/naturalatlas/tilestrata-vtile)插件可以通过 mapnik 数据源生成`pbf`格式的矢量瓦片。如果需要对瓦片做放大倍数，交互这些操作，矢量瓦片不需要再额外的请求数据，使用起来非常方便。后续还可以通过配套的[tilestrata-vtile-raster](https://github.com/naturalatlas/tilestrata-vtile-raster)插件来将矢量数据渲染成普通的图片瓦片。使用这个插件必须安装依赖[node-mapnik](https://github.com/mapnik/node-mapnik)。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-vtile --save\n```\n\n# 2. 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst vtile = require('tilestrata-vtile')\nconst headers = require('tilestrata-headers')\n\nconst server = tilestrata()\n\n// 定义省界边界数据源\nconst common = {\n  xml: 'style/province.xml',\n  tileSize: 256,\n  metatile: 1,\n  bufferSize: 128\n}\n\n// 开启跨域，定义图层\nserver\n  .layer('province_pbf')\n  .route('tile.pbf')\n  .use(\n    headers({\n      'Access-Control-Allow-Origin': '*'\n    })\n  )\n  .use(vtile(common))\n\n// 启动服务\nserver.listen(9527)\n```\n\n插件还提供了`overrideRenderOptions`配置项，用来做层级的精确控制，控制瓦片的返回内容\n\n```js\nserver\n  .layer('mylayer')\n  .route('t.pbf')\n  .use(\n    vtile({\n      xml: '/path/to/map.xml',\n      tileSize: 256,\n      metatile: 1,\n      bufferSize: 128,\n      overrideRenderOptions: function(opts, z, maxz) {\n        opts.simplify_distance = z < maxz ? 8 : 1\n        return opts\n      }\n    })\n  )\n```\n\n回调函数的第一个参数`opts`包含了以下内容，可以在[第四节](#4-代码浅析)的代码分析中看到这些值是怎么来的：\n\n```js\n{\n  simplify_distance,\n  path_multiplier, \n  buffer_size, \n  scale_denominator\n}\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/v-tile-result-20190704171541.png)\n\n# 4. 代码浅析\n\n原理上很简单，从代码上就能看出来，传入了 mapnik 需要的`xml`配置文件，所以其实是利用了 mapnik 的[VectorTile](http://mapnik.org/documentation/node-mapnik/3.6/#VectorTile)功能，代码如下：\n\n```js\n// 新建VectorTile源，options也和传入的otps息息相关\nmap.render(new mapnik.VectorTile(z, x, y), options, function(err, image) {\n  self.pool.release(map)\n  if (err) return callback(err)\n\n  if (image.empty()) {\n    err = new Error('No data')\n    err.statusCode = 204\n    return callback(err)\n  }\n\n  // 通过getdata方法获取数据并返回给tilestrata\n  var buffer = image.getData(self.dataopts)\n  buffer.metatile = self.metatile\n  buffer._vtile = image\n  buffer._vx = x\n  buffer._vy = y\n  buffer._vz = z\n\n  callback(null, buffer)\n})\n```\n\n第二节使用中提到的`opts`的参数实际上是 mapnik 中[Map.render](http://mapnik.org/documentation/node-mapnik/3.6/#Map.render)方法的几个可选参数，他们会在 tilestrata-vtile 中被合并使用：\n\n```js\nvar options = self.overrideRenderOptions(\n  {\n    simplify_distance: real_z < self.maxzoom ? 8 : 1,\n    path_multiplier: 16 * self.metatile,\n    buffer_size: self.bufferSize,\n    scale_denominator: 559082264.028 / (1 << real_z)\n  },\n  real_z,\n  self.maxzoom\n)\n```\n","source":"_posts/2019/tilestrata-vtile.md","raw":"---\ntitle: tilestrata-vtile 插件使用及浅析\ndate: 2019-07-04 17:39:41\ntags: [GIS]\ncategories: TileStrata\n---\n\n[tilestrata-vtile](https://github.com/naturalatlas/tilestrata-vtile)插件可以通过 mapnik 数据源生成`pbf`格式的矢量瓦片。如果需要对瓦片做放大倍数，交互这些操作，矢量瓦片不需要再额外的请求数据，使用起来非常方便。后续还可以通过配套的[tilestrata-vtile-raster](https://github.com/naturalatlas/tilestrata-vtile-raster)插件来将矢量数据渲染成普通的图片瓦片。使用这个插件必须安装依赖[node-mapnik](https://github.com/mapnik/node-mapnik)。\n\n<!--more-->\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n# 1. 安装\n\n```sh\n$ npm install tilestrata-vtile --save\n```\n\n# 2. 使用\n\n```js\nconst tilestrata = require('tilestrata')\nconst vtile = require('tilestrata-vtile')\nconst headers = require('tilestrata-headers')\n\nconst server = tilestrata()\n\n// 定义省界边界数据源\nconst common = {\n  xml: 'style/province.xml',\n  tileSize: 256,\n  metatile: 1,\n  bufferSize: 128\n}\n\n// 开启跨域，定义图层\nserver\n  .layer('province_pbf')\n  .route('tile.pbf')\n  .use(\n    headers({\n      'Access-Control-Allow-Origin': '*'\n    })\n  )\n  .use(vtile(common))\n\n// 启动服务\nserver.listen(9527)\n```\n\n插件还提供了`overrideRenderOptions`配置项，用来做层级的精确控制，控制瓦片的返回内容\n\n```js\nserver\n  .layer('mylayer')\n  .route('t.pbf')\n  .use(\n    vtile({\n      xml: '/path/to/map.xml',\n      tileSize: 256,\n      metatile: 1,\n      bufferSize: 128,\n      overrideRenderOptions: function(opts, z, maxz) {\n        opts.simplify_distance = z < maxz ? 8 : 1\n        return opts\n      }\n    })\n  )\n```\n\n回调函数的第一个参数`opts`包含了以下内容，可以在[第四节](#4-代码浅析)的代码分析中看到这些值是怎么来的：\n\n```js\n{\n  simplify_distance,\n  path_multiplier, \n  buffer_size, \n  scale_denominator\n}\n```\n\n# 3. 效果\n\ndemo 项目可以参考[tilestrata-sample-code](https://github.com/zzcyrus/tilestrata-sample-code)\n\n![](http://blog-img-1255388623.cossh.myqcloud.com/v-tile-result-20190704171541.png)\n\n# 4. 代码浅析\n\n原理上很简单，从代码上就能看出来，传入了 mapnik 需要的`xml`配置文件，所以其实是利用了 mapnik 的[VectorTile](http://mapnik.org/documentation/node-mapnik/3.6/#VectorTile)功能，代码如下：\n\n```js\n// 新建VectorTile源，options也和传入的otps息息相关\nmap.render(new mapnik.VectorTile(z, x, y), options, function(err, image) {\n  self.pool.release(map)\n  if (err) return callback(err)\n\n  if (image.empty()) {\n    err = new Error('No data')\n    err.statusCode = 204\n    return callback(err)\n  }\n\n  // 通过getdata方法获取数据并返回给tilestrata\n  var buffer = image.getData(self.dataopts)\n  buffer.metatile = self.metatile\n  buffer._vtile = image\n  buffer._vx = x\n  buffer._vy = y\n  buffer._vz = z\n\n  callback(null, buffer)\n})\n```\n\n第二节使用中提到的`opts`的参数实际上是 mapnik 中[Map.render](http://mapnik.org/documentation/node-mapnik/3.6/#Map.render)方法的几个可选参数，他们会在 tilestrata-vtile 中被合并使用：\n\n```js\nvar options = self.overrideRenderOptions(\n  {\n    simplify_distance: real_z < self.maxzoom ? 8 : 1,\n    path_multiplier: 16 * self.metatile,\n    buffer_size: self.bufferSize,\n    scale_denominator: 559082264.028 / (1 << real_z)\n  },\n  real_z,\n  self.maxzoom\n)\n```\n","slug":"tilestrata-vtile","published":1,"updated":"2019-07-04T09:42:27.139Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjy4fqaab00250n3ih69nwua3","content":"<p><a href=\"https://github.com/naturalatlas/tilestrata-vtile\" target=\"_blank\" rel=\"noopener\">tilestrata-vtile</a>插件可以通过 mapnik 数据源生成<code>pbf</code>格式的矢量瓦片。如果需要对瓦片做放大倍数，交互这些操作，矢量瓦片不需要再额外的请求数据，使用起来非常方便。后续还可以通过配套的<a href=\"https://github.com/naturalatlas/tilestrata-vtile-raster\" target=\"_blank\" rel=\"noopener\">tilestrata-vtile-raster</a>插件来将矢量数据渲染成普通的图片瓦片。使用这个插件必须安装依赖<a href=\"https://github.com/mapnik/node-mapnik\" target=\"_blank\" rel=\"noopener\">node-mapnik</a>。</p>\n<a id=\"more\"></a>\n<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-vtile --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> vtile = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-vtile'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> headers = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-headers'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义省界边界数据源</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> common = &#123;</span><br><span class=\"line\">  xml: <span class=\"string\">'style/province.xml'</span>,</span><br><span class=\"line\">  tileSize: <span class=\"number\">256</span>,</span><br><span class=\"line\">  metatile: <span class=\"number\">1</span>,</span><br><span class=\"line\">  bufferSize: <span class=\"number\">128</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开启跨域，定义图层</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'province_pbf'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.pbf'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">'Access-Control-Allow-Origin'</span>: <span class=\"string\">'*'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(vtile(common))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<p>插件还提供了<code>overrideRenderOptions</code>配置项，用来做层级的精确控制，控制瓦片的返回内容</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'mylayer'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'t.pbf'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    vtile(&#123;</span><br><span class=\"line\">      xml: <span class=\"string\">'/path/to/map.xml'</span>,</span><br><span class=\"line\">      tileSize: <span class=\"number\">256</span>,</span><br><span class=\"line\">      metatile: <span class=\"number\">1</span>,</span><br><span class=\"line\">      bufferSize: <span class=\"number\">128</span>,</span><br><span class=\"line\">      overrideRenderOptions: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">opts, z, maxz</span>) </span>&#123;</span><br><span class=\"line\">        opts.simplify_distance = z &lt; maxz ? <span class=\"number\">8</span> : <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> opts</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br></pre></td></tr></table></figure>\n<p>回调函数的第一个参数<code>opts</code>包含了以下内容，可以在<a href=\"#4-代码浅析\">第四节</a>的代码分析中看到这些值是怎么来的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  simplify_distance,</span><br><span class=\"line\">  path_multiplier, </span><br><span class=\"line\">  buffer_size, </span><br><span class=\"line\">  scale_denominator</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/v-tile-result-20190704171541.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>原理上很简单，从代码上就能看出来，传入了 mapnik 需要的<code>xml</code>配置文件，所以其实是利用了 mapnik 的<a href=\"http://mapnik.org/documentation/node-mapnik/3.6/#VectorTile\" target=\"_blank\" rel=\"noopener\">VectorTile</a>功能，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 新建VectorTile源，options也和传入的otps息息相关</span></span><br><span class=\"line\">map.render(<span class=\"keyword\">new</span> mapnik.VectorTile(z, x, y), options, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, image</span>) </span>&#123;</span><br><span class=\"line\">  self.pool.release(map)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> callback(err)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (image.empty()) &#123;</span><br><span class=\"line\">    err = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'No data'</span>)</span><br><span class=\"line\">    err.statusCode = <span class=\"number\">204</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> callback(err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 通过getdata方法获取数据并返回给tilestrata</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> buffer = image.getData(self.dataopts)</span><br><span class=\"line\">  buffer.metatile = self.metatile</span><br><span class=\"line\">  buffer._vtile = image</span><br><span class=\"line\">  buffer._vx = x</span><br><span class=\"line\">  buffer._vy = y</span><br><span class=\"line\">  buffer._vz = z</span><br><span class=\"line\"></span><br><span class=\"line\">  callback(<span class=\"literal\">null</span>, buffer)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>第二节使用中提到的<code>opts</code>的参数实际上是 mapnik 中<a href=\"http://mapnik.org/documentation/node-mapnik/3.6/#Map.render\" target=\"_blank\" rel=\"noopener\">Map.render</a>方法的几个可选参数，他们会在 tilestrata-vtile 中被合并使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> options = self.overrideRenderOptions(</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    simplify_distance: real_z &lt; self.maxzoom ? <span class=\"number\">8</span> : <span class=\"number\">1</span>,</span><br><span class=\"line\">    path_multiplier: <span class=\"number\">16</span> * self.metatile,</span><br><span class=\"line\">    buffer_size: self.bufferSize,</span><br><span class=\"line\">    scale_denominator: <span class=\"number\">559082264.028</span> / (<span class=\"number\">1</span> &lt;&lt; real_z)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  real_z,</span><br><span class=\"line\">  self.maxzoom</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/naturalatlas/tilestrata-vtile\" target=\"_blank\" rel=\"noopener\">tilestrata-vtile</a>插件可以通过 mapnik 数据源生成<code>pbf</code>格式的矢量瓦片。如果需要对瓦片做放大倍数，交互这些操作，矢量瓦片不需要再额外的请求数据，使用起来非常方便。后续还可以通过配套的<a href=\"https://github.com/naturalatlas/tilestrata-vtile-raster\" target=\"_blank\" rel=\"noopener\">tilestrata-vtile-raster</a>插件来将矢量数据渲染成普通的图片瓦片。使用这个插件必须安装依赖<a href=\"https://github.com/mapnik/node-mapnik\" target=\"_blank\" rel=\"noopener\">node-mapnik</a>。</p>","more":"<p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<h1 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h1><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install tilestrata-vtile --save</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h1><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tilestrata = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> vtile = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-vtile'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> headers = <span class=\"built_in\">require</span>(<span class=\"string\">'tilestrata-headers'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = tilestrata()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义省界边界数据源</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> common = &#123;</span><br><span class=\"line\">  xml: <span class=\"string\">'style/province.xml'</span>,</span><br><span class=\"line\">  tileSize: <span class=\"number\">256</span>,</span><br><span class=\"line\">  metatile: <span class=\"number\">1</span>,</span><br><span class=\"line\">  bufferSize: <span class=\"number\">128</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开启跨域，定义图层</span></span><br><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'province_pbf'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'tile.pbf'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    headers(&#123;</span><br><span class=\"line\">      <span class=\"string\">'Access-Control-Allow-Origin'</span>: <span class=\"string\">'*'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .use(vtile(common))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务</span></span><br><span class=\"line\">server.listen(<span class=\"number\">9527</span>)</span><br></pre></td></tr></table></figure>\n<p>插件还提供了<code>overrideRenderOptions</code>配置项，用来做层级的精确控制，控制瓦片的返回内容</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">server</span><br><span class=\"line\">  .layer(<span class=\"string\">'mylayer'</span>)</span><br><span class=\"line\">  .route(<span class=\"string\">'t.pbf'</span>)</span><br><span class=\"line\">  .use(</span><br><span class=\"line\">    vtile(&#123;</span><br><span class=\"line\">      xml: <span class=\"string\">'/path/to/map.xml'</span>,</span><br><span class=\"line\">      tileSize: <span class=\"number\">256</span>,</span><br><span class=\"line\">      metatile: <span class=\"number\">1</span>,</span><br><span class=\"line\">      bufferSize: <span class=\"number\">128</span>,</span><br><span class=\"line\">      overrideRenderOptions: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">opts, z, maxz</span>) </span>&#123;</span><br><span class=\"line\">        opts.simplify_distance = z &lt; maxz ? <span class=\"number\">8</span> : <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> opts</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  )</span><br></pre></td></tr></table></figure>\n<p>回调函数的第一个参数<code>opts</code>包含了以下内容，可以在<a href=\"#4-代码浅析\">第四节</a>的代码分析中看到这些值是怎么来的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  simplify_distance,</span><br><span class=\"line\">  path_multiplier, </span><br><span class=\"line\">  buffer_size, </span><br><span class=\"line\">  scale_denominator</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h1><p>demo 项目可以参考<a href=\"https://github.com/zzcyrus/tilestrata-sample-code\" target=\"_blank\" rel=\"noopener\">tilestrata-sample-code</a></p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"http://blog-img-1255388623.cossh.myqcloud.com/v-tile-result-20190704171541.png\" alt=\"\" title=\"\">\n                </div>\n                <div class=\"image-caption\"></div>\n            </figure>\n<h1 id=\"4-代码浅析\"><a href=\"#4-代码浅析\" class=\"headerlink\" title=\"4. 代码浅析\"></a>4. 代码浅析</h1><p>原理上很简单，从代码上就能看出来，传入了 mapnik 需要的<code>xml</code>配置文件，所以其实是利用了 mapnik 的<a href=\"http://mapnik.org/documentation/node-mapnik/3.6/#VectorTile\" target=\"_blank\" rel=\"noopener\">VectorTile</a>功能，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 新建VectorTile源，options也和传入的otps息息相关</span></span><br><span class=\"line\">map.render(<span class=\"keyword\">new</span> mapnik.VectorTile(z, x, y), options, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, image</span>) </span>&#123;</span><br><span class=\"line\">  self.pool.release(map)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> callback(err)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (image.empty()) &#123;</span><br><span class=\"line\">    err = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'No data'</span>)</span><br><span class=\"line\">    err.statusCode = <span class=\"number\">204</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> callback(err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 通过getdata方法获取数据并返回给tilestrata</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> buffer = image.getData(self.dataopts)</span><br><span class=\"line\">  buffer.metatile = self.metatile</span><br><span class=\"line\">  buffer._vtile = image</span><br><span class=\"line\">  buffer._vx = x</span><br><span class=\"line\">  buffer._vy = y</span><br><span class=\"line\">  buffer._vz = z</span><br><span class=\"line\"></span><br><span class=\"line\">  callback(<span class=\"literal\">null</span>, buffer)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>第二节使用中提到的<code>opts</code>的参数实际上是 mapnik 中<a href=\"http://mapnik.org/documentation/node-mapnik/3.6/#Map.render\" target=\"_blank\" rel=\"noopener\">Map.render</a>方法的几个可选参数，他们会在 tilestrata-vtile 中被合并使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> options = self.overrideRenderOptions(</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    simplify_distance: real_z &lt; self.maxzoom ? <span class=\"number\">8</span> : <span class=\"number\">1</span>,</span><br><span class=\"line\">    path_multiplier: <span class=\"number\">16</span> * self.metatile,</span><br><span class=\"line\">    buffer_size: self.bufferSize,</span><br><span class=\"line\">    scale_denominator: <span class=\"number\">559082264.028</span> / (<span class=\"number\">1</span> &lt;&lt; real_z)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  real_z,</span><br><span class=\"line\">  self.maxzoom</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>"}],"PostAsset":[{"_id":"source/_posts/2019/osm-PostGIS-setup/distance.png","slug":"distance.png","post":"cjy4fqa9p000h0n3iksaczgg0","modified":1,"renderable":0},{"_id":"source/_posts/2017/vector-tile-openlayers-try/network.png","post":"cjy4fqa9f00070n3icj77ad7h","slug":"network.png","modified":1,"renderable":1},{"_id":"source/_posts/2017/plugins/tileWMS.png","post":"cjy4fqa9e00060n3ii3gb04q9","slug":"tileWMS.png","modified":1,"renderable":1},{"_id":"source/_posts/2018/Vue-Parent-and-Child-lifecycle-hooks/lifecircle.png","post":"cjy4fqa9m000c0n3iaiq1m5wy","slug":"lifecircle.png","modified":1,"renderable":1},{"_id":"source/_posts/2018/Vue-Parent-and-Child-lifecycle-hooks/parent-child-hooks.png","post":"cjy4fqa9m000c0n3iaiq1m5wy","slug":"parent-child-hooks.png","modified":1,"renderable":1},{"_id":"source/_posts/2017/openlayers-canvas-typhoon/canvasLayer.png","slug":"canvasLayer.png","post":"cjy4fqa9b00030n3ie44wq9ax","modified":1,"renderable":0},{"_id":"source/_posts/2017/openlayers-canvas-typhoon/canvasSymbol.png","post":"cjy4fqa9b00030n3ie44wq9ax","slug":"canvasSymbol.png","modified":1,"renderable":1},{"_id":"source/_posts/2017/openlayers-canvas-typhoon/goal.png","post":"cjy4fqa9b00030n3ie44wq9ax","slug":"goal.png","modified":1,"renderable":1},{"_id":"source/_posts/2019/osm-PostGIS-setup/point.png","slug":"point.png","post":"cjy4fqa9p000h0n3iksaczgg0","modified":1,"renderable":0},{"_id":"source/_posts/2019/osm-PostGIS-setup/polygon.png","slug":"polygon.png","post":"cjy4fqa9p000h0n3iksaczgg0","modified":1,"renderable":0}],"PostCategory":[{"post_id":"cjy4fqa9900020n3isq4tauus","category_id":"cjy4fqa9d00040n3icwqh94fa","_id":"cjy4fqa9n000d0n3itldesct2"},{"post_id":"cjy4fqa9b00030n3ie44wq9ax","category_id":"cjy4fqa9k00090n3i0br3iuff","_id":"cjy4fqa9r000k0n3i0108e9t7"},{"post_id":"cjy4fqa9e00060n3ii3gb04q9","category_id":"cjy4fqa9d00040n3icwqh94fa","_id":"cjy4fqa9u000r0n3it5a9h9is"},{"post_id":"cjy4fqa9f00070n3icj77ad7h","category_id":"cjy4fqa9k00090n3i0br3iuff","_id":"cjy4fqa9w000x0n3i9mes47po"},{"post_id":"cjy4fqa9i00080n3iteqaru3e","category_id":"cjy4fqa9t000q0n3iorqxdb7f","_id":"cjy4fqa9y00140n3izjwzwmtt"},{"post_id":"cjy4fqa9l000b0n3i4j2xirbo","category_id":"cjy4fqa9w000y0n3iav680gza","_id":"cjy4fqaa0001d0n3iwsht8kr5"},{"post_id":"cjy4fqa9m000c0n3iaiq1m5wy","category_id":"cjy4fqa9t000q0n3iorqxdb7f","_id":"cjy4fqaa2001j0n3im59gyxxr"},{"post_id":"cjy4fqa9p000h0n3iksaczgg0","category_id":"cjy4fqaa0001c0n3isahvbnqh","_id":"cjy4fqaa6001t0n3iy94rb4bs"},{"post_id":"cjy4fqa9q000i0n3ijdt5cjuc","category_id":"cjy4fqaa0001c0n3isahvbnqh","_id":"cjy4fqaa900200n3isydj7jkx"},{"post_id":"cjy4fqa9s000n0n3iisorbh2p","category_id":"cjy4fqaa0001c0n3isahvbnqh","_id":"cjy4fqaab00260n3im45c3k74"},{"post_id":"cjy4fqaaa00220n3ibqiqx90g","category_id":"cjy4fqaa9001z0n3iuoks3l1y","_id":"cjy4fqaac002a0n3if0lcu7wc"},{"post_id":"cjy4fqa9t000p0n3i4v8ks9n4","category_id":"cjy4fqaa9001z0n3iuoks3l1y","_id":"cjy4fqaaf002e0n3ijvh492cf"},{"post_id":"cjy4fqaab00250n3ih69nwua3","category_id":"cjy4fqaa9001z0n3iuoks3l1y","_id":"cjy4fqaaf002g0n3io6yho5vs"},{"post_id":"cjy4fqa9u000u0n3iqck7r6tv","category_id":"cjy4fqaa9001z0n3iuoks3l1y","_id":"cjy4fqaag002j0n3imnfpqlgv"},{"post_id":"cjy4fqa9x00130n3i5ncnwvu2","category_id":"cjy4fqaa9001z0n3iuoks3l1y","_id":"cjy4fqaag002m0n3idp2dn4x0"},{"post_id":"cjy4fqa9y00180n3iuenf26dd","category_id":"cjy4fqaa9001z0n3iuoks3l1y","_id":"cjy4fqaah002q0n3iqq3x7w4t"},{"post_id":"cjy4fqa9z001a0n3iidsi8gza","category_id":"cjy4fqaa9001z0n3iuoks3l1y","_id":"cjy4fqaah002u0n3i24az5s5e"},{"post_id":"cjy4fqaa1001f0n3idq4mlort","category_id":"cjy4fqaa9001z0n3iuoks3l1y","_id":"cjy4fqaai002y0n3iphhczby9"},{"post_id":"cjy4fqaa2001h0n3i2jtjp7lt","category_id":"cjy4fqaa9001z0n3iuoks3l1y","_id":"cjy4fqaai00320n3ie5dctmwu"},{"post_id":"cjy4fqaa3001l0n3iw27028td","category_id":"cjy4fqaa9001z0n3iuoks3l1y","_id":"cjy4fqaaj00350n3ih2hc2pf0"},{"post_id":"cjy4fqaa5001o0n3idtsjsamh","category_id":"cjy4fqaa9001z0n3iuoks3l1y","_id":"cjy4fqaaj00370n3ih1fk5nt0"},{"post_id":"cjy4fqaa6001r0n3i3anl5273","category_id":"cjy4fqaa9001z0n3iuoks3l1y","_id":"cjy4fqaak00390n3if1khgfcs"},{"post_id":"cjy4fqaa7001v0n3itx494qlq","category_id":"cjy4fqaa9001z0n3iuoks3l1y","_id":"cjy4fqaak003a0n3iybystb2g"},{"post_id":"cjy4fqaa9001y0n3i4hs08oo9","category_id":"cjy4fqaa9001z0n3iuoks3l1y","_id":"cjy4fqaak003b0n3izcol3803"},{"post_id":"cjy4fqa9v000w0n3ibndnjt0w","category_id":"cjy4fqaa9001z0n3iuoks3l1y","_id":"cjy4fqpgf003d0n3ibojisscy"},{"post_id":"cjy4fqa9w00110n3irsgwa8n9","category_id":"cjy4fqaa9001z0n3iuoks3l1y","_id":"cjy4fqpgh003f0n3it9pi24sp"}],"PostTag":[{"post_id":"cjy4fqa9l000b0n3i4j2xirbo","tag_id":"cjy4fqa9k000a0n3i5s9vpfn8","_id":"cjy4fqa9p000g0n3i8ffs0gq8"},{"post_id":"cjy4fqa9p000h0n3iksaczgg0","tag_id":"cjy4fqa9k000a0n3i5s9vpfn8","_id":"cjy4fqa9s000m0n3izi5w8a0f"},{"post_id":"cjy4fqa9900020n3isq4tauus","tag_id":"cjy4fqa9e00050n3iagazlkfe","_id":"cjy4fqa9t000o0n3ix419qjo3"},{"post_id":"cjy4fqa9900020n3isq4tauus","tag_id":"cjy4fqa9k000a0n3i5s9vpfn8","_id":"cjy4fqa9u000t0n3i7mlsuy1k"},{"post_id":"cjy4fqa9900020n3isq4tauus","tag_id":"cjy4fqa9n000f0n3icfilanqy","_id":"cjy4fqa9v000v0n3iyxpf4kau"},{"post_id":"cjy4fqa9q000i0n3ijdt5cjuc","tag_id":"cjy4fqa9k000a0n3i5s9vpfn8","_id":"cjy4fqa9w00100n3i3e04su4l"},{"post_id":"cjy4fqa9s000n0n3iisorbh2p","tag_id":"cjy4fqa9k000a0n3i5s9vpfn8","_id":"cjy4fqa9x00120n3i7w7hr59q"},{"post_id":"cjy4fqa9t000p0n3i4v8ks9n4","tag_id":"cjy4fqa9k000a0n3i5s9vpfn8","_id":"cjy4fqa9y00150n3iuqoocg9i"},{"post_id":"cjy4fqa9u000u0n3iqck7r6tv","tag_id":"cjy4fqa9k000a0n3i5s9vpfn8","_id":"cjy4fqa9z00190n3ido1ycaa3"},{"post_id":"cjy4fqa9b00030n3ie44wq9ax","tag_id":"cjy4fqa9e00050n3iagazlkfe","_id":"cjy4fqaa0001b0n3io9tkpsvu"},{"post_id":"cjy4fqa9b00030n3ie44wq9ax","tag_id":"cjy4fqa9k000a0n3i5s9vpfn8","_id":"cjy4fqaa1001g0n3i92sqvc5u"},{"post_id":"cjy4fqa9b00030n3ie44wq9ax","tag_id":"cjy4fqa9w000z0n3izzhu904x","_id":"cjy4fqaa2001i0n3ir1wj7tmr"},{"post_id":"cjy4fqa9x00130n3i5ncnwvu2","tag_id":"cjy4fqa9k000a0n3i5s9vpfn8","_id":"cjy4fqaa5001n0n3iloc2oxh3"},{"post_id":"cjy4fqa9y00180n3iuenf26dd","tag_id":"cjy4fqa9k000a0n3i5s9vpfn8","_id":"cjy4fqaa6001p0n3ik60f103t"},{"post_id":"cjy4fqa9z001a0n3iidsi8gza","tag_id":"cjy4fqa9k000a0n3i5s9vpfn8","_id":"cjy4fqaa7001u0n3i7zfdc0pa"},{"post_id":"cjy4fqaa1001f0n3idq4mlort","tag_id":"cjy4fqa9k000a0n3i5s9vpfn8","_id":"cjy4fqaa8001w0n3iwz7fdv29"},{"post_id":"cjy4fqaa2001h0n3i2jtjp7lt","tag_id":"cjy4fqa9k000a0n3i5s9vpfn8","_id":"cjy4fqaaa00210n3i8fvmx1cx"},{"post_id":"cjy4fqaa3001l0n3iw27028td","tag_id":"cjy4fqa9k000a0n3i5s9vpfn8","_id":"cjy4fqaaa00230n3i97iexl7b"},{"post_id":"cjy4fqa9e00060n3ii3gb04q9","tag_id":"cjy4fqa9e00050n3iagazlkfe","_id":"cjy4fqaac00280n3i4mzd4ih7"},{"post_id":"cjy4fqa9e00060n3ii3gb04q9","tag_id":"cjy4fqa9k000a0n3i5s9vpfn8","_id":"cjy4fqaac00290n3ic7v04kn6"},{"post_id":"cjy4fqa9e00060n3ii3gb04q9","tag_id":"cjy4fqa9n000f0n3icfilanqy","_id":"cjy4fqaaf002d0n3i4f19f5b4"},{"post_id":"cjy4fqaa5001o0n3idtsjsamh","tag_id":"cjy4fqa9k000a0n3i5s9vpfn8","_id":"cjy4fqaaf002f0n3i9k3nmejy"},{"post_id":"cjy4fqaa6001r0n3i3anl5273","tag_id":"cjy4fqa9k000a0n3i5s9vpfn8","_id":"cjy4fqaag002i0n3ijtbvcplf"},{"post_id":"cjy4fqaa7001v0n3itx494qlq","tag_id":"cjy4fqa9k000a0n3i5s9vpfn8","_id":"cjy4fqaag002k0n3iqqwe0a7i"},{"post_id":"cjy4fqaa9001y0n3i4hs08oo9","tag_id":"cjy4fqa9k000a0n3i5s9vpfn8","_id":"cjy4fqaag002n0n3i8w4hogl9"},{"post_id":"cjy4fqa9f00070n3icj77ad7h","tag_id":"cjy4fqa9k000a0n3i5s9vpfn8","_id":"cjy4fqaag002o0n3is39tv0z9"},{"post_id":"cjy4fqa9f00070n3icj77ad7h","tag_id":"cjy4fqa9w000z0n3izzhu904x","_id":"cjy4fqaah002r0n3i8d5nlbvy"},{"post_id":"cjy4fqaaa00220n3ibqiqx90g","tag_id":"cjy4fqa9k000a0n3i5s9vpfn8","_id":"cjy4fqaah002s0n3ie883nz89"},{"post_id":"cjy4fqaab00250n3ih69nwua3","tag_id":"cjy4fqa9k000a0n3i5s9vpfn8","_id":"cjy4fqaah002v0n3i6o40inf8"},{"post_id":"cjy4fqa9i00080n3iteqaru3e","tag_id":"cjy4fqa9e00050n3iagazlkfe","_id":"cjy4fqaah002w0n3iu7s3lvyu"},{"post_id":"cjy4fqa9i00080n3iteqaru3e","tag_id":"cjy4fqaab00240n3igrx56bsm","_id":"cjy4fqaai002z0n3i6lzz9mi4"},{"post_id":"cjy4fqa9m000c0n3iaiq1m5wy","tag_id":"cjy4fqa9e00050n3iagazlkfe","_id":"cjy4fqaai00300n3io3xsmqvo"},{"post_id":"cjy4fqa9m000c0n3iaiq1m5wy","tag_id":"cjy4fqaab00240n3igrx56bsm","_id":"cjy4fqaai00330n3i6yzvwt59"},{"post_id":"cjy4fqa9v000w0n3ibndnjt0w","tag_id":"cjy4fqa9k000a0n3i5s9vpfn8","_id":"cjy4fqpge003c0n3icljgavk2"},{"post_id":"cjy4fqa9w00110n3irsgwa8n9","tag_id":"cjy4fqa9k000a0n3i5s9vpfn8","_id":"cjy4fqpgh003e0n3i9tf11b9e"}],"Tag":[{"name":"FE","_id":"cjy4fqa9e00050n3iagazlkfe"},{"name":"GIS","_id":"cjy4fqa9k000a0n3i5s9vpfn8"},{"name":"Leaflet","_id":"cjy4fqa9n000f0n3icfilanqy"},{"name":"OpenLayers","_id":"cjy4fqa9w000z0n3izzhu904x"},{"name":"Vue","_id":"cjy4fqaab00240n3igrx56bsm"}]}}