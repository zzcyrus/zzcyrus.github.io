<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cyrus&#39;s Blog</title>
  <subtitle>迷阵</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kael.top/"/>
  <updated>2017-11-05T12:20:05.538Z</updated>
  <id>http://kael.top/</id>
  
  <author>
    <name>Cyrus</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leaflet常用的一些插件</title>
    <link href="http://kael.top/2017/09/17/plugins/"/>
    <id>http://kael.top/2017/09/17/plugins/</id>
    <published>2017-09-17T05:48:15.000Z</published>
    <updated>2017-11-05T12:20:05.538Z</updated>
    
    <content type="html"><![CDATA[<p>Leaflet中常用的gis功能可以满足一般使用，有些特殊需求，官方也有<a href="http://leafletjs.com/plugins.html" target="_blank" rel="external">插件系统</a>，本文会挑选一些常用的，经过测试可用的插件单独放出来使用方法和一些注意事项，希望能够帮助到同僚们。</p>
<a id="more"></a>
<p><a href="https://github.com/zzcyrus/Leaflet-demos" target="_blank" rel="external">Leaflet系列地址</a><br><a href="https://github.com/zzcyrus/Leaflet-demos/blob/master/1.plugins/plugins.html" target="_blank" rel="external">本文demo地址</a></p>
<h1 id="ImageWMS"><a href="#ImageWMS" class="headerlink" title="ImageWMS"></a>ImageWMS</h1><p>&nbsp;&nbsp;在openlayers中，wms图层的调用了提供了IamgeWMS和tileWMS两种方式，通常情况下，如果wms服务作为底图，由于数据量大，我们采用瓦片的方式加载十分有利，如果数据量小，我们采用单张image的方式无论从请求发送上和显示的效果上都更好。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="tileWMS.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>&nbsp;&nbsp;<del>可以发现，瓦片会发出多次请求，每次请求都会包含该瓦片上涉及到的信息，数据量小十分没必要</del></p>
<p>&nbsp;&nbsp;Leaflet中只提供了tile瓦片的方式加载WMS图层，在使用了很多第三方解决方案后，我发现了这款插件<a href="https://github.com/ptv-logistics/Leaflet.NonTiledLayer" target="_blank" rel="external">nonTiledLayer</a>，使用之后的效果基本上可以达到openlaysers中的要求，更多情况可以点击链接进去了解。</p>
<p>调用方式<br><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> layer = L.nonTiledLayer.wms(url, &#123;</div><div class="line">    <span class="attr">maxZoom</span>: <span class="number">19</span>,</div><div class="line">    <span class="attr">minZoom</span>: <span class="number">0</span>,</div><div class="line">    <span class="attr">opacity</span>: <span class="number">1.0</span>,</div><div class="line">    <span class="attr">layers</span>: <span class="string">'xmap-gravelpit-fg'</span>,</div><div class="line">    <span class="attr">format</span>: <span class="string">'image/png'</span>,</div><div class="line">    <span class="attr">transparent</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">attribution</span>: <span class="string">''</span>,</div><div class="line">    <span class="attr">pane</span>: <span class="string">'tilePane'</span>,</div><div class="line">    <span class="attr">zIndex</span>: <span class="number">3</span></div><div class="line">&#125;).addTo(map);</div></pre></td></tr></table></figure></p>
<p><a href="https://github.com/ptv-logistics/Leaflet.NonTiledLayer" target="_blank" rel="external">nonTiledLayer</a>调用方式基本沿用Leaflet自身的wms调用，提供的属性也很全面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">attribution - 图层数据来源.Default:&apos;</div><div class="line">opacity - 透明度.Default: 1</div><div class="line">minZoom - 最小缩放. Default: 0</div><div class="line">maxZoom - 最大缩放. Default: 18</div><div class="line">bounds - 边界条件. Default: L.latLngBounds([-180, -85.05], [180, 85.05])</div><div class="line">zIndex - 位置. Default: undefined</div><div class="line">pane - 插入的div的名称. Default: &apos;overlayPane&apos;</div><div class="line">pointerEvents - 鼠标事件的样式. Default: null</div><div class="line">errorImageUrl - 默认错误图层. Default: 1px transparent gif data:image/gif;base64,R0lGODlhAQABAHAAACH5BAUAAAAALAAAAAABAAEAAAICRAEAOw==</div><div class="line">useCanvas - 渲染方式. Default: undefined</div></pre></td></tr></table></figure>
<p>具体的使用效果可以移步demo</p>
<h1 id="WKT数据插件"><a href="#WKT数据插件" class="headerlink" title="WKT数据插件"></a>WKT数据插件</h1><p>&nbsp;&nbsp;wkt作为GIS常用的一种地理数据格式，因为通用性需求度也很高,Leaflet官方插件中提供了许多支持wkt的第三方解决方案，使用下来，发现mapbox出品的<a href="https://github.com/mapbox/leaflet-omnivore" target="_blank" rel="external">leaflet-omnivore</a>效果可以说是目前最满足要求的了。</p>
<p><code>omnivore</code>支持的功能比较强大<br><figure class="highlight js"><table><tr><td class="code"><pre><div class="line">omnivore.csv(<span class="string">'a.csv'</span>).addTo(map);</div><div class="line">omnivore.gpx(<span class="string">'a.gpx'</span>).addTo(map);</div><div class="line">omnivore.kml(<span class="string">'a.kml'</span>).addTo(map);</div><div class="line">omnivore.wkt(<span class="string">'a.wkt'</span>).addTo(map);</div><div class="line">omnivore.topojson(<span class="string">'a.topojson'</span>).addTo(map);</div><div class="line">omnivore.geojson(<span class="string">'a.geojson'</span>).addTo(map);</div><div class="line">omnivore.polyline(<span class="string">'a.txt'</span>).addTo(map);</div></pre></td></tr></table></figure></p>
<p>其中对于wkt的加载有两种方式。<br>其中，<code>customlayer</code>是通过<code>L.geojson</code>图层来为加载进来的wkt数据设置样式<br><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> customLayer = L.geoJson(<span class="literal">null</span>, &#123;</div><div class="line">    <span class="attr">style</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123;<span class="attr">color</span>: <span class="string">"#0ff"</span>&#125;;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<ul>
<li><p><code>omnivore.wkt(url, parser_options?, customLayer?)</code>: 通过url加载</p>
</li>
<li><p><code>omnivore.wkt.parse(wktString，parser_options?, customLayer?)</code>: 通过转换wkt字符串加载</p>
</li>
</ul>
<p>具体的使用效果可以移步<a href="https://github.com/zzcyrus/Leaflet-demos/blob/master/1.plugins/plugins.html" target="_blank" rel="external">demo</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Leaflet中常用的gis功能可以满足一般使用，有些特殊需求，官方也有&lt;a href=&quot;http://leafletjs.com/plugins.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;插件系统&lt;/a&gt;，本文会挑选一些常用的，经过测试可用的插件单独放出来使用方法和一些注意事项，希望能够帮助到同僚们。&lt;/p&gt;
    
    </summary>
    
      <category term="Leaflet" scheme="http://kael.top/categories/Leaflet/"/>
    
    
      <category term="FE" scheme="http://kael.top/tags/FE/"/>
    
      <category term="GIS" scheme="http://kael.top/tags/GIS/"/>
    
      <category term="Leaflet" scheme="http://kael.top/tags/Leaflet/"/>
    
  </entry>
  
  <entry>
    <title>Leaflet多种基础图层加载</title>
    <link href="http://kael.top/2017/09/17/basemap/"/>
    <id>http://kael.top/2017/09/17/basemap/</id>
    <published>2017-09-17T05:46:08.000Z</published>
    <updated>2017-11-05T12:19:51.499Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;最近项目中有移动端的开发需求，自然就用到了最轻量级的gis组件——Leaflet，100多k的体积，五脏俱全，丰富的第三方插件，虽然开发者数量上不及大哥级产品Arcigs，但也基本够用，对于esri的自家系统支持好，svg和canvas两种渲染方式，让数据量大的要素图层渲染也不是那么吃力。</p>
<p>&nbsp;&nbsp;这里把自己对于Leaflet的一些探索研究记录一下，一方面便于自己后期回顾，另一方面也希望和大家一起探讨学习。</p>
<a id="more"></a>
<p><a href="https://github.com/zzcyrus/Leaflet-demos" target="_blank" rel="external">Leaflet系列地址</a><br><a href="https://github.com/zzcyrus/Leaflet-demos/blob/master/0.basemap/basemap.html" target="_blank" rel="external">本文demo地址</a></p>
<h1 id="基础图层的加载"><a href="#基础图层的加载" class="headerlink" title="基础图层的加载"></a>基础图层的加载</h1><p>基础图层的加载都是通过<code>L.tileLayer</code>的方式，所以加载的难点不在于api的使用，是一些常用的基础瓦片的收集，这里给出一些常用的地址</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"></div><div class="line">mapRadios: [</div><div class="line">    &#123;</div><div class="line">        <span class="attr">label</span>: <span class="string">'高德地图'</span>,</div><div class="line">        <span class="attr">value</span>: <span class="string">'1'</span>,</div><div class="line">        <span class="attr">url</span>: <span class="string">'http://webrd01.is.autonavi.com/appmaptile?lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;'</span></div><div class="line">    &#125;, &#123;</div><div class="line">        <span class="attr">label</span>: <span class="string">'Esri地图'</span>,</div><div class="line">        <span class="attr">value</span>: <span class="string">'2'</span>,</div><div class="line">        <span class="attr">url</span>: <span class="string">'http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineCommunity/MapServer/tile/&#123;z&#125;/&#123;y&#125;/&#123;x&#125;'</span></div><div class="line">    &#125;, &#123;</div><div class="line">        <span class="attr">label</span>: <span class="string">'天地图道路'</span>,</div><div class="line">        <span class="attr">value</span>: <span class="string">'3'</span>,</div><div class="line">        <span class="attr">url</span>: <span class="string">'http://t0.tianditu.cn/DataServer?T=vec_w&amp;X=&#123;x&#125;&amp;Y=&#123;y&#125;&amp;L=&#123;z&#125;'</span></div><div class="line">    &#125;, &#123;</div><div class="line">        <span class="attr">label</span>: <span class="string">'天地图标注'</span>,</div><div class="line">        <span class="attr">value</span>: <span class="string">'4'</span>,</div><div class="line">        <span class="attr">url</span>: <span class="string">'http://t5.tianditu.cn/DataServer?T=cva_w&amp;X=&#123;x&#125;&amp;Y=&#123;y&#125;&amp;L=&#123;z&#125;'</span></div><div class="line">    &#125;, &#123;</div><div class="line">        <span class="attr">label</span>: <span class="string">'天地图影像'</span>,</div><div class="line">        <span class="attr">value</span>: <span class="string">'5'</span>,</div><div class="line">        <span class="attr">url</span>: <span class="string">'http://t1.tianditu.cn/img_w/wmts?service=wmts&amp;request=GetTile&amp;version=1.0.0&amp;LAYER=img&amp;tileMatrixSet=w&amp;TileMatrix=&#123;z&#125;&amp;TileRow=&#123;y&#125;&amp;TileCol=&#123;x&#125;&amp;style=default&amp;format=tiles'</span></div><div class="line">    &#125;, &#123;</div><div class="line">        <span class="attr">label</span>: <span class="string">'谷歌地形'</span>,</div><div class="line">        <span class="attr">value</span>: <span class="string">'6'</span>,</div><div class="line">        <span class="attr">url</span>: <span class="string">'http://mt3.google.cn/vt/lyrs=t@131&amp;hl=zh-CN&amp;gl=cn&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;&amp;s=Ga'</span></div><div class="line">    &#125;, &#123;</div><div class="line">        <span class="attr">label</span>: <span class="string">'谷歌影像'</span>,</div><div class="line">        <span class="attr">value</span>: <span class="string">'7'</span>,</div><div class="line">        <span class="attr">url</span>: <span class="string">'http://mt3.google.cn/vt/lyrs=s&amp;hl=zh-CN&amp;gl=cn&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;'</span></div><div class="line">    &#125;, &#123;</div><div class="line">        <span class="attr">label</span>: <span class="string">'谷歌标注'</span>,</div><div class="line">        <span class="attr">value</span>: <span class="string">'8'</span>,</div><div class="line">        <span class="attr">url</span>: <span class="string">'http://mt2.google.cn/vt/lyrs=m@167000000&amp;hl=zh-CN&amp;gl=cn&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;'</span></div><div class="line">    &#125;</div><div class="line">]</div></pre></td></tr></table></figure>
<p>更多的瓦片地址可以在demo中找到，具体的使用效果也可以移步<a href="https://github.com/zzcyrus/Leaflet-demos/blob/master/0.basemap/basemap.html" target="_blank" rel="external">demo</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;最近项目中有移动端的开发需求，自然就用到了最轻量级的gis组件——Leaflet，100多k的体积，五脏俱全，丰富的第三方插件，虽然开发者数量上不及大哥级产品Arcigs，但也基本够用，对于esri的自家系统支持好，svg和canvas两种渲染方式，让数据量大的要素图层渲染也不是那么吃力。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;这里把自己对于Leaflet的一些探索研究记录一下，一方面便于自己后期回顾，另一方面也希望和大家一起探讨学习。&lt;/p&gt;
    
    </summary>
    
      <category term="Leaflet" scheme="http://kael.top/categories/Leaflet/"/>
    
    
      <category term="FE" scheme="http://kael.top/tags/FE/"/>
    
      <category term="GIS" scheme="http://kael.top/tags/GIS/"/>
    
      <category term="Leaflet" scheme="http://kael.top/tags/Leaflet/"/>
    
  </entry>
  
  <entry>
    <title>openlayers 从台风风圈绘制到canvas样式和图层的应用</title>
    <link href="http://kael.top/2017/07/31/openlayers-canvas-typhoon/"/>
    <id>http://kael.top/2017/07/31/openlayers-canvas-typhoon/</id>
    <published>2017-07-31T14:31:02.000Z</published>
    <updated>2017-11-05T12:20:01.021Z</updated>
    
    <content type="html"><![CDATA[<p>本文中所使用的数据来源于<a href="http://www.wztf121.com/typhoon.html" target="_blank" rel="external">温州台风网</a>，通过F12抓取，你可以在我的<a href="https://github.com/zzcyrus/openlayers-demos" target="_blank" rel="external">GitHub</a>上查看数据和本文源代码</p>
<p>&nbsp;&nbsp;台风的风圈是一种不常见但算的上规则的图形，在上面的网站可以看到最终效果，简单的解剖下其实就是四个1/4圆</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="goal.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>从数据结构上也可以看出来：<br><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> radius_quad = &#123;</div><div class="line">    <span class="string">"ne"</span>: <span class="number">250</span>, <span class="comment">//单位为KM</span></div><div class="line">    <span class="string">"se"</span>: <span class="number">250</span>,</div><div class="line">    <span class="string">"sw"</span>: <span class="number">180</span>,</div><div class="line">    <span class="string">"nw"</span>: <span class="number">150</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在某个固定经纬度点上，以此点为圆心组合成了一个所谓的风圈形状，四个方向分别代表每个1/4圆的半径。刚开始是为了实现这种效果进行了研究，后来发现openlayers对于这种效果的支持还挺有意思，记录下来已做分享。</p>
<a id="more"></a>
<h1 id="通过自定义geometry的实现"><a href="#通过自定义geometry的实现" class="headerlink" title="通过自定义geometry的实现"></a>通过自定义geometry的实现</h1><p>&nbsp;&nbsp;最原始的思路也是最容易切入的点，就是去看openlayers中怎么实现圆形的画法，在ol中，有<code>createRegularPolygon</code>这个类，原理就是给定一些参数，用点去填充我们想要的形状，当填进去点达到一定密集度，自然就能得到一个近似的圆。<br>&nbsp;&nbsp;通过这个思路我们可以计算台风风圈的每个1/4圆的坐标，用点去占位，最终实现绘制出想要的图形。</p>
<p>具体代码可以去看某大牛的博客，这里只给出一个传送门，写的很详细了：<br><a href="http://blog.csdn.net/gisshixisheng/article/details/76397068" target="_blank" rel="external">点我乘坐飞机</a> <strong>这个算法还有些不完善，就是在每个1/4圆结束时候少计算了一个点，导致看着有点不对劲</strong></p>
<p><strong>特点:</strong> 这种方式画出来的图形是一个图层中的一个feature，好处自然不用多说，基本上feature支持的功能都能满足！</p>
<h1 id="通过canvas类型的symbol实现"><a href="#通过canvas类型的symbol实现" class="headerlink" title="通过canvas类型的symbol实现"></a>通过canvas类型的symbol实现</h1><p>&nbsp;&nbsp;在点密集的情况下，用上面的方式其实效果已经很不错了，但是有些细（tiao）心（ci）的使用者，非要放大到一定程度，然后说你这个不够圆，那。。。。。</p>
<p>&nbsp;&nbsp;那我们就用canvas画出来，openlayers中，要素的样式是有这么一种方式<code>ol.style.Icon</code>来实现，我们可以把绘制好的元素作为<code>Icon</code>的参数<br><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> style = <span class="keyword">new</span> ol.style.Style(&#123;</div><div class="line">    <span class="attr">image</span>: <span class="keyword">new</span> ol.style.Icon(&#123;</div><div class="line">        <span class="attr">opacity</span>: <span class="number">0.3</span>,</div><div class="line">        <span class="attr">img</span>: canvas,</div><div class="line">        <span class="attr">imgSize</span>: [canvas.width, canvas.height],</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>canvans绘制的方法：<br><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTyphoon</span>(<span class="params">radius, radius_quad</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</div><div class="line">    canvas.width = canvas.height = <span class="number">2</span> * radius;</div><div class="line">    <span class="keyword">var</span> context = canvas.getContext(<span class="string">"2d"</span>);</div><div class="line">    context.fillStyle = <span class="string">"#0000ff"</span>;</div><div class="line">    context.strokeStyle = <span class="string">"#ff0000"</span>;</div><div class="line">    context.lineWidth = <span class="number">3</span>;</div><div class="line">    context.beginPath();</div><div class="line">    context.arc(radius, radius, radius_quad.se, <span class="number">0</span>, <span class="number">0.5</span> * <span class="built_in">Math</span>.PI);</div><div class="line">    context.lineTo(radius, radius + radius_quad.sw);</div><div class="line">    context.arc(radius, radius, radius_quad.sw, <span class="number">0.5</span> * <span class="built_in">Math</span>.PI, <span class="built_in">Math</span>.PI);</div><div class="line">    context.lineTo(radius - radius_quad.nw, radius);</div><div class="line">    context.arc(radius, radius, radius_quad.nw, <span class="built_in">Math</span>.PI, <span class="number">1.5</span> * <span class="built_in">Math</span>.PI);</div><div class="line">    context.lineTo(radius, radius - radius_quad.ne);</div><div class="line">    context.arc(radius, radius, radius_quad.ne, <span class="number">1.5</span> * <span class="built_in">Math</span>.PI, <span class="number">0</span>);</div><div class="line">    context.lineTo(radius + radius_quad.se, radius);</div><div class="line">    context.fill();</div><div class="line">    context.stroke();</div><div class="line">    <span class="keyword">return</span> canvas;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>效果如下图：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="canvasSymbol.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<p><a href="https://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasSymbol.html" target="_blank" rel="external">本方法完整代码</a></p>
<p><strong>特点：</strong> 这种方式，绘制出来的台风风圈其实只是一个symbol符号，需要把这个符号赋给一个具体的要素，比如一个点，一个圆之类的，而且根据分辨率还要去调整样式的缩放<br><figure class="highlight js"><table><tr><td class="code"><pre><div class="line">map.getView().on(<span class="string">'change:resolution'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> style = shape.getStyle();</div><div class="line">    <span class="comment">// 重新设置图标的缩放率</span></div><div class="line">    style.getImage().setScale(<span class="keyword">this</span>.getZoom() / <span class="number">8</span>);</div><div class="line">    shape.setStyle(style);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h1 id="通过canvas图层的方式实现"><a href="#通过canvas图层的方式实现" class="headerlink" title="通过canvas图层的方式实现"></a>通过canvas图层的方式实现</h1><p>&nbsp;&nbsp;再后来转念一想，既然支持canvas的symbol，为何不直接使用canvas绘制固定元素呢，果然在API中找到了<code>ol.source.ImageCanvas</code>，直接把canvas要素当作图层来使用！</p>
<p><code>ol.source.ImageCanvas</code>的绘制有点需要特别注意的点，这里给出重要代码片段，完整demo可以去<a href="https://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasLayer.html" target="_blank" rel="external">GitHub</a>查看</p>
<h2 id="创建图层，在canvasFunction中写具体的绘图方法"><a href="#创建图层，在canvasFunction中写具体的绘图方法" class="headerlink" title="创建图层，在canvasFunction中写具体的绘图方法"></a>创建图层，在canvasFunction中写具体的绘图方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> canvasLayer = <span class="keyword">new</span> ol.layer.Image(&#123;</div><div class="line">    <span class="attr">source</span>: <span class="keyword">new</span> ol.source.ImageCanvas(&#123;</div><div class="line">        <span class="attr">canvasFunction</span>: canvasFunction,</div><div class="line">        <span class="attr">projection</span>: <span class="string">'EPSG:3857'</span></div><div class="line">    &#125;)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="canvasFunction中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小"><a href="#canvasFunction中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小" class="headerlink" title="canvasFunction中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小"></a>canvasFunction中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小</h2><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">//计算画布和地图四至的偏移量</span></div><div class="line"><span class="keyword">var</span> mapExtent = map.getView().calculateExtent(map.getSize())</div><div class="line"><span class="keyword">var</span> canvasOrigin = map.getPixelFromCoordinate([extent[<span class="number">0</span>], extent[<span class="number">3</span>]]);</div><div class="line"><span class="keyword">var</span> mapOrigin = map.getPixelFromCoordinate([mapExtent[<span class="number">0</span>], mapExtent[<span class="number">3</span>]]);</div><div class="line"><span class="keyword">var</span> delta = [mapOrigin[<span class="number">0</span>] - canvasOrigin[<span class="number">0</span>], mapOrigin[<span class="number">1</span>] - canvasOrigin[<span class="number">1</span>]]</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">//在计算台风风圈的中心点时要补充计算偏移量</span></div><div class="line"><span class="keyword">var</span> point = ol.proj.transform(coordinate, <span class="string">'EPSG:4326'</span>, <span class="string">'EPSG:3857'</span>);</div><div class="line"><span class="keyword">var</span> pixel = map.getPixelFromCoordinate(point);</div><div class="line"><span class="keyword">var</span> cX = pixel[<span class="number">0</span>] + delta[<span class="number">0</span>], cY = pixel[<span class="number">1</span>] + delta[<span class="number">1</span>];</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">//利用canvasFunction提供的默认参数分辨率，计算准确的坐标</span></div><div class="line"><span class="keyword">var</span> radius_quad = &#123;</div><div class="line">    <span class="string">"ne"</span>: <span class="number">250000</span> / resolution,</div><div class="line">    <span class="string">"se"</span>: <span class="number">250000</span> / resolution,</div><div class="line">    <span class="string">"sw"</span>: <span class="number">180000</span> / resolution,</div><div class="line">    <span class="string">"nw"</span>: <span class="number">150000</span> / resolution</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终效果如下，我在同一图层中绘制了多个：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="canvasLayer.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<p>至于绘制canvas的方法和上面的symbol是一样的。具体代码还请移步<a href="https://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasLayer.html" target="_blank" rel="external">GitHub</a>(原谅我厚颜无耻的屡次打广告！)</p>
<p><strong>特点：</strong>这种方式可以在一个图层中添加多个风圈要素，同时图层支持的功能也比较多，基本满足需求，效果也还行</p>
<p>&nbsp;&nbsp;这篇应用主要是从一个基本的需求所拓展开来的，canvas图层的应用我想应该很强大，刚开始研究openlyaers，相比于arcgis，ol很多功能可能要自己实现，但似乎效果上还是能让人满意的，欢迎大家讨论。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文中所使用的数据来源于&lt;a href=&quot;http://www.wztf121.com/typhoon.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;温州台风网&lt;/a&gt;，通过F12抓取，你可以在我的&lt;a href=&quot;https://github.com/zzcyrus/openlayers-demos&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;上查看数据和本文源代码&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;台风的风圈是一种不常见但算的上规则的图形，在上面的网站可以看到最终效果，简单的解剖下其实就是四个1/4圆&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;goal.png&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
&lt;p&gt;从数据结构上也可以看出来：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; radius_quad = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;ne&quot;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;250&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;//单位为KM&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;se&quot;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;250&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;sw&quot;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;180&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;nw&quot;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;150&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在某个固定经纬度点上，以此点为圆心组合成了一个所谓的风圈形状，四个方向分别代表每个1/4圆的半径。刚开始是为了实现这种效果进行了研究，后来发现openlayers对于这种效果的支持还挺有意思，记录下来已做分享。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenLayers" scheme="http://kael.top/categories/OpenLayers/"/>
    
    
      <category term="FE" scheme="http://kael.top/tags/FE/"/>
    
      <category term="GIS" scheme="http://kael.top/tags/GIS/"/>
    
      <category term="OpenLayers" scheme="http://kael.top/tags/OpenLayers/"/>
    
  </entry>
  
  <entry>
    <title>element dialog组件嵌套问题的临时方案</title>
    <link href="http://kael.top/2017/06/23/vue-dialog-nested/"/>
    <id>http://kael.top/2017/06/23/vue-dialog-nested/</id>
    <published>2017-06-23T14:09:55.000Z</published>
    <updated>2017-11-05T12:20:17.728Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;最近用 Vue+element 开发项目时，在dialog组件上嵌套使用dialog组件或是MessageBox这类弹框组件，发现会出现遮罩层重合之类的问题，导致很多人只能选择关闭遮罩层。GitHub上就此问题也出现过类似讨论。有几种解决方案：</p>
<a id="more"></a> 
<ol>
<li><p>按照官方所说，将多个dialog类组件全部移动至<strong>&lt;body</strong>&gt;标签下</p>
</li>
<li><p>Github上某位大牛给出了不完全解决方案，基本思路仍然是将添加在<strong>&lt;el-dialog</strong>&gt;内的dom结构自动移动至<strong>&lt;body</strong>&gt;标签下。这个方式测试了下，似乎纯dialog嵌套问题不大，但是如果dialog内部包含了其他组件会有点问题，智者见智，自行探索了</p>
</li>
</ol>
<p>&emsp;&emsp;<a href="https://github.com/foolishchow/element-dialog2" target="_blank" rel="external">附上连接</a></p>
<ol>
<li>编写自己modal遮罩层，这里给出个不完全临时代码仅供参考</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Vue.prototype.$Modal = &#123;</div><div class="line">    open(element) &#123;</div><div class="line">        <span class="keyword">var</span> index = <span class="number">1</span>;</div><div class="line">        <span class="keyword">var</span> wrapper = element.querySelector(<span class="string">'.el-dialog__wrapper'</span>);</div><div class="line">        <span class="keyword">if</span> (wrapper) &#123;</div><div class="line">            index = wrapper.style.zIndex - <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> modalDom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line">        modalDom.className = <span class="string">'v-modal'</span>;</div><div class="line">        element.appendChild(modalDom);</div><div class="line">        modalDom.style.zIndex = index;</div><div class="line">    &#125;,</div><div class="line">    close() &#123;</div><div class="line">        <span class="keyword">var</span> modal = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'v-modal'</span>)[<span class="number">0</span>;</div><div class="line">        modal.parentNode.removeChild(modal);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;一般调用方法<br><figure class="highlight js"><table><tr><td class="code"><pre><div class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//遮罩层</span></div><div class="line">        that.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            that.$Modal.open(that.$el);</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;主要想法就是在组件mounted完成的nextTick后，为页面中添加一个div，样式就直接采用element自己的了，因为遮罩层是添加在dialog组件下的，因此组件销毁后也会自己销毁，close方法也没用上，但也应该会遇到有用上的时候吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;最近用 Vue+element 开发项目时，在dialog组件上嵌套使用dialog组件或是MessageBox这类弹框组件，发现会出现遮罩层重合之类的问题，导致很多人只能选择关闭遮罩层。GitHub上就此问题也出现过类似讨论。有几种解决方案：&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://kael.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="FE" scheme="http://kael.top/tags/FE/"/>
    
      <category term="Vue" scheme="http://kael.top/tags/Vue/"/>
    
  </entry>
  
</feed>
