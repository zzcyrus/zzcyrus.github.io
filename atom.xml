<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cyrus&#39;s Blog</title>
  <subtitle>迷阵</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-08-02T03:04:07.758Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Cyrus</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>openlayers 从台风风圈绘制到canvas样式和图层的应用</title>
    <link href="http://yoursite.com/2017/07/31/openlayers-canvas-typhoon/"/>
    <id>http://yoursite.com/2017/07/31/openlayers-canvas-typhoon/</id>
    <published>2017-07-31T14:31:02.000Z</published>
    <updated>2017-08-02T03:04:07.758Z</updated>
    
    <content type="html"><![CDATA[<p>本文中所使用的数据来源于<a href="http://www.wztf121.com/typhoon.html" target="_blank" rel="external">温州台风网</a>，通过F12抓取，你可以在我的<a href="https://github.com/zzcyrus/openlayers-demos" target="_blank" rel="external">GitHub</a>上查看数据和本文源代码</p>
<p>&nbsp;&nbsp;台风的风圈是一种不常见但算的上规则的图形，在上面的网站可以看到最终效果，简单的解剖下其实就是四个1/4圆</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="goal.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>从数据结构上也可以看出来：<br><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> radius_quad = &#123;</div><div class="line">    <span class="string">"ne"</span>: <span class="number">250</span>, <span class="comment">//单位为KM</span></div><div class="line">    <span class="string">"se"</span>: <span class="number">250</span>,</div><div class="line">    <span class="string">"sw"</span>: <span class="number">180</span>,</div><div class="line">    <span class="string">"nw"</span>: <span class="number">150</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在某个固定经纬度点上，以此点为圆心组合成了一个所谓的风圈形状，四个方向分别代表每个1/4圆的半径。刚开始是为了实现这种效果进行了研究，后来发现openlayers对于这种效果的支持还挺有意思，记录下来已做分享。</p>
<h1 id="通过自定义geometry的实现"><a href="#通过自定义geometry的实现" class="headerlink" title="通过自定义geometry的实现"></a>通过自定义geometry的实现</h1><p>&nbsp;&nbsp;最原始的思路也是最容易切入的点，就是去看openlayers中怎么实现圆形的画法，在ol中，有<code>createRegularPolygon</code>这个类，原理就是给定一些参数，用点去填充我们想要的形状，当填进去点达到一定密集度，自然就能得到一个近似的圆。<br>&nbsp;&nbsp;通过这个思路我们可以计算台风风圈的每个1/4圆的坐标，用点去占位，最终实现绘制出想要的图形。</p>
<p>具体代码可以去看某大牛的博客，这里只给出一个传送门，写的很详细了：<br><a href="http://blog.csdn.net/gisshixisheng/article/details/76397068" target="_blank" rel="external">点我乘坐飞机</a> <strong>这个算法还有些不完善，就是在每个1/4圆结束时候少计算了一个点，导致看着有点不对劲</strong></p>
<p><strong>特点:</strong> 这种方式画出来的图形是一个图层中的一个feature，好处自然不用多说，基本上feature支持的功能都能满足！</p>
<h1 id="通过canvas类型的symbol实现"><a href="#通过canvas类型的symbol实现" class="headerlink" title="通过canvas类型的symbol实现"></a>通过canvas类型的symbol实现</h1><p>&nbsp;&nbsp;在点密集的情况下，用上面的方式其实效果已经很不错了，但是有些细（tiao）心（ci）的使用者，非要放大到一定程度，然后说你这个不够圆，那。。。。。</p>
<p>&nbsp;&nbsp;那我们就用canvas画出来，openlayers中，要素的样式是有这么一种方式<code>ol.style.Icon</code>来实现，我们可以把绘制好的元素作为<code>Icon</code>的参数<br><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> style = <span class="keyword">new</span> ol.style.Style(&#123;</div><div class="line">    <span class="attr">image</span>: <span class="keyword">new</span> ol.style.Icon(&#123;</div><div class="line">        <span class="attr">opacity</span>: <span class="number">0.3</span>,</div><div class="line">        <span class="attr">img</span>: canvas,</div><div class="line">        <span class="attr">imgSize</span>: [canvas.width, canvas.height],</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>canvans绘制的方法：<br><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTyphoon</span>(<span class="params">radius, radius_quad</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</div><div class="line">    canvas.width = canvas.height = <span class="number">2</span> * radius;</div><div class="line">    <span class="keyword">var</span> context = canvas.getContext(<span class="string">"2d"</span>);</div><div class="line">    context.fillStyle = <span class="string">"#0000ff"</span>;</div><div class="line">    context.strokeStyle = <span class="string">"#ff0000"</span>;</div><div class="line">    context.lineWidth = <span class="number">3</span>;</div><div class="line">    context.beginPath();</div><div class="line">    context.arc(radius, radius, radius_quad.se, <span class="number">0</span>, <span class="number">0.5</span> * <span class="built_in">Math</span>.PI);</div><div class="line">    context.lineTo(radius, radius + radius_quad.sw);</div><div class="line">    context.arc(radius, radius, radius_quad.sw, <span class="number">0.5</span> * <span class="built_in">Math</span>.PI, <span class="built_in">Math</span>.PI);</div><div class="line">    context.lineTo(radius - radius_quad.nw, radius);</div><div class="line">    context.arc(radius, radius, radius_quad.nw, <span class="built_in">Math</span>.PI, <span class="number">1.5</span> * <span class="built_in">Math</span>.PI);</div><div class="line">    context.lineTo(radius, radius - radius_quad.ne);</div><div class="line">    context.arc(radius, radius, radius_quad.ne, <span class="number">1.5</span> * <span class="built_in">Math</span>.PI, <span class="number">0</span>);</div><div class="line">    context.lineTo(radius + radius_quad.se, radius);</div><div class="line">    context.fill();</div><div class="line">    context.stroke();</div><div class="line">    <span class="keyword">return</span> canvas;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>效果如下图：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="canvasSymbol.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<p><a href="https://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasSymbol.html" target="_blank" rel="external">本方法完整代码</a></p>
<p><strong>特点：</strong> 这种方式，绘制出来的台风风圈其实只是一个symbol符号，需要把这个符号赋给一个具体的要素，比如一个点，一个圆之类的，而且根据分辨率还要去调整样式的缩放<br><figure class="highlight js"><table><tr><td class="code"><pre><div class="line">map.getView().on(<span class="string">'change:resolution'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> style = shape.getStyle();</div><div class="line">    <span class="comment">// 重新设置图标的缩放率</span></div><div class="line">    style.getImage().setScale(<span class="keyword">this</span>.getZoom() / <span class="number">8</span>);</div><div class="line">    shape.setStyle(style);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h1 id="通过canvas图层的方式实现"><a href="#通过canvas图层的方式实现" class="headerlink" title="通过canvas图层的方式实现"></a>通过canvas图层的方式实现</h1><p>&nbsp;&nbsp;再后来转念一想，既然支持canvas的symbol，为何不直接使用canvas绘制固定元素呢，果然在API中找到了<code>ol.source.ImageCanvas</code>，直接把canvas要素当作图层来使用！</p>
<p><code>ol.source.ImageCanvas</code>的绘制有点需要特别注意的点，这里给出重要代码片段，完整demo可以去<a href="https://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasLayer.html" target="_blank" rel="external">GitHub</a>查看</p>
<h2 id="创建图层，在canvasFunction中写具体的绘图方法"><a href="#创建图层，在canvasFunction中写具体的绘图方法" class="headerlink" title="创建图层，在canvasFunction中写具体的绘图方法"></a>创建图层，在canvasFunction中写具体的绘图方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> canvasLayer = <span class="keyword">new</span> ol.layer.Image(&#123;</div><div class="line">    <span class="attr">source</span>: <span class="keyword">new</span> ol.source.ImageCanvas(&#123;</div><div class="line">        <span class="attr">canvasFunction</span>: canvasFunction,</div><div class="line">        <span class="attr">projection</span>: <span class="string">'EPSG:3857'</span></div><div class="line">    &#125;)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="canvasFunction中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小"><a href="#canvasFunction中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小" class="headerlink" title="canvasFunction中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小"></a>canvasFunction中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小</h2><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">//计算画布和地图四至的偏移量</span></div><div class="line"><span class="keyword">var</span> mapExtent = map.getView().calculateExtent(map.getSize())</div><div class="line"><span class="keyword">var</span> canvasOrigin = map.getPixelFromCoordinate([extent[<span class="number">0</span>], extent[<span class="number">3</span>]]);</div><div class="line"><span class="keyword">var</span> mapOrigin = map.getPixelFromCoordinate([mapExtent[<span class="number">0</span>], mapExtent[<span class="number">3</span>]]);</div><div class="line"><span class="keyword">var</span> delta = [mapOrigin[<span class="number">0</span>] - canvasOrigin[<span class="number">0</span>], mapOrigin[<span class="number">1</span>] - canvasOrigin[<span class="number">1</span>]]</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">//在计算台风风圈的中心点时要补充计算偏移量</span></div><div class="line"><span class="keyword">var</span> point = ol.proj.transform(coordinate, <span class="string">'EPSG:4326'</span>, <span class="string">'EPSG:3857'</span>);</div><div class="line"><span class="keyword">var</span> pixel = map.getPixelFromCoordinate(point);</div><div class="line"><span class="keyword">var</span> cX = pixel[<span class="number">0</span>] + delta[<span class="number">0</span>], cY = pixel[<span class="number">1</span>] + delta[<span class="number">1</span>];</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">//利用canvasFunction提供的默认参数分辨率，计算准确的坐标</span></div><div class="line"><span class="keyword">var</span> radius_quad = &#123;</div><div class="line">    <span class="string">"ne"</span>: <span class="number">250000</span> / resolution,</div><div class="line">    <span class="string">"se"</span>: <span class="number">250000</span> / resolution,</div><div class="line">    <span class="string">"sw"</span>: <span class="number">180000</span> / resolution,</div><div class="line">    <span class="string">"nw"</span>: <span class="number">150000</span> / resolution</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终效果如下，我在同一图层中绘制了多个：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="canvasLayer.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<p>至于绘制canvas的方法和上面的symbol是一样的。具体代码还请移步<a href="https://github.com/zzcyrus/openlayers-demos/blob/master/0.typhoon/canvasLayer.html" target="_blank" rel="external">GitHub</a>(原谅我厚颜无耻的屡次打广告！)</p>
<p><strong>特点：</strong>这种方式可以在一个图层中添加多个风圈要素，同时图层支持的功能也比较多，基本满足需求，效果也还行</p>
<p>&nbsp;&nbsp;这篇应用主要是从一个基本的需求所拓展开来的，canvas图层的应用我想应该很强大，刚开始研究openlyaers，相比于arcgis，ol很多功能可能要自己实现，但似乎效果上还是能让人满意的，欢迎大家讨论。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文中所使用的数据来源于&lt;a href=&quot;http://www.wztf121.com/typhoon.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;温州台风网&lt;/a&gt;，通过F12抓取，你可以在我的&lt;a href=&quot;https://github.
    
    </summary>
    
    
      <category term="FE" scheme="http://yoursite.com/tags/FE/"/>
    
      <category term="GIS" scheme="http://yoursite.com/tags/GIS/"/>
    
      <category term="OpenLayers" scheme="http://yoursite.com/tags/OpenLayers/"/>
    
  </entry>
  
  <entry>
    <title>element dialog组件嵌套问题的临时方案</title>
    <link href="http://yoursite.com/2017/06/23/vue-dialog-nested/"/>
    <id>http://yoursite.com/2017/06/23/vue-dialog-nested/</id>
    <published>2017-06-23T14:09:55.000Z</published>
    <updated>2017-07-23T14:30:49.685Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;最近用 Vue+element 开发项目时，在dialog组件上嵌套使用dialog组件或是MessageBox这类弹框组件，发现会出现遮罩层重合之类的问题，导致很多人只能选择关闭遮罩层。GitHub上就此问题也出现过类似讨论。有几种解决方案：</p>
<a id="more"></a> 
<ol>
<li><p>按照官方所说，将多个dialog类组件全部移动至<strong>&lt;body</strong>&gt;标签下</p>
</li>
<li><p>Github上某位大牛给出了不完全解决方案，基本思路仍然是将添加在<strong>&lt;el-dialog</strong>&gt;内的dom结构自动移动至<strong>&lt;body</strong>&gt;标签下。这个方式测试了下，似乎纯dialog嵌套问题不大，但是如果dialog内部包含了其他组件会有点问题，智者见智，自行探索了</p>
</li>
</ol>
<p>&emsp;&emsp;<a href="https://github.com/foolishchow/element-dialog2" target="_blank" rel="external">附上连接</a></p>
<ol>
<li>编写自己modal遮罩层，这里给出个不完全临时代码仅供参考</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Vue.prototype.$Modal = &#123;</div><div class="line">    open(element) &#123;</div><div class="line">        <span class="keyword">var</span> index = <span class="number">1</span>;</div><div class="line">        <span class="keyword">var</span> wrapper = element.querySelector(<span class="string">'.el-dialog__wrapper'</span>);</div><div class="line">        <span class="keyword">if</span> (wrapper) &#123;</div><div class="line">            index = wrapper.style.zIndex - <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> modalDom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line">        modalDom.className = <span class="string">'v-modal'</span>;</div><div class="line">        element.appendChild(modalDom);</div><div class="line">        modalDom.style.zIndex = index;</div><div class="line">    &#125;,</div><div class="line">    close() &#123;</div><div class="line">        <span class="keyword">var</span> modal = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'v-modal'</span>)[<span class="number">0</span>;</div><div class="line">        modal.parentNode.removeChild(modal);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;一般调用方法<br><figure class="highlight js"><table><tr><td class="code"><pre><div class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//遮罩层</span></div><div class="line">        that.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            that.$Modal.open(that.$el);</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;主要想法就是在组件mounted完成的nextTick后，为页面中添加一个div，样式就直接采用element自己的了，因为遮罩层是添加在dialog组件下的，因此组件销毁后也会自己销毁，close方法也没用上，但也应该会遇到有用上的时候吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;最近用 Vue+element 开发项目时，在dialog组件上嵌套使用dialog组件或是MessageBox这类弹框组件，发现会出现遮罩层重合之类的问题，导致很多人只能选择关闭遮罩层。GitHub上就此问题也出现过类似讨论。有几种解决方案：&lt;/p&gt;
    
    </summary>
    
    
      <category term="FE" scheme="http://yoursite.com/tags/FE/"/>
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
</feed>
