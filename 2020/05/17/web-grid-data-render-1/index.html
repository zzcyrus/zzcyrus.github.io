<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><meta name="google-site-verification" content="google1353837d2ec77422.html"><title>在web中渲染格点数据探讨（1） | Kaely</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script async src="https://www.googletagmanager.com/gtag/js?id=G-5HJZ375VHJ"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-5HJZ375VHJ');
</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 6.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">在web中渲染格点数据探讨（1）</h1><a id="logo" href="/.">Kaely</a><p class="description">迷陣</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">在web中渲染格点数据探讨（1）</h1><div class="post-meta">2020-05-17<span> | </span><span class="category"><a href="/categories/WebGIS/">WebGIS</a></span></div><a class="disqus-comment-count" href="/2020/05/17/web-grid-data-render-1/#vcomment"><span class="waline-comment-count" id="/2020/05/17/web-grid-data-render-1/"></span><span> 条评论</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-text">背景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%80%E5%8F%91"><span class="toc-text">开发</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-text">使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8E%E7%BB%AD"><span class="toc-text">后续</span></a></li></ol></div></div><div class="post-content"><p>在地理信息行业中，我们常遇见的数据中有这么两类：</p>
<ul>
<li>一类是站点（散点）数据。地图上分布着位置不均匀的各种站点，比方说气象站，水文站，如果我们需要查看站点数值趋势，就可以通过等值线图等方式，比如<a target="_blank" rel="noopener" href="https://github.com/d3/d3-contour">d3 的 contour</a>，<a target="_blank" rel="noopener" href="https://turfjs.org/docs/#isolines">turf 的 isolines</a>，还可以通过插值方法将站点插值到网格上，转化成格点数据，后面我们也会讨论。</li>
<li>也有一类是格点数据。这个在气象上就非常常见，气象预报数据通常是模式跑出来的，如同渔网一样的格点，这种数据提供了查询任意位置数值的作用，它的渲染也同样常见，传统的方法是在服务器端生成好对应图片，在浏览器上贴图，这里追求实现的是<code>前端渲染</code>。</li>
</ul>
<span id="more"></span>

<p>太长不看可以直接<a target="_blank" rel="noopener" href="https://github.com/zzcyrus/Leaflet.Tile.PixelLayer">项目仓库</a></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>格点数据的特点往往是数据量大，蕴含的信息量大，不仅包含着某个点的数值，同时还有这个点的经纬度，时间维度信息，空间高度信息，所以我们通常会听见学气象的同学说某个数据有四个维度。随着计算机的发展，图形学的发展，想要全部展示这些时空数据变得越来越可能，我会在这个系列中逐步的提出一些我的探索，希望能给大家带来帮助。</p>
<p>格点数据有很多格式，我们可能常接触到的一些格点数据文件比方说<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/GeoTIFF">GeoTIFF</a>，气象里面有<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/GRIB">GRIB</a>，nc 等等，甚至一张简单的 png 也可以是由格点数据转换成的，它会包含基本的<strong>格点数量和值</strong>，比方说在经度方向有 300 个点，纬度方向有 200 个点，那么整个文件包含了 6w 个格点的数值，还通常包含一些<strong>经纬度信息</strong>，比方说每个点的经纬度值，也有可能只是四个顶点的经纬度信息，所以 raster（栅格）图层也在我的讨论范围之内。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>我会以 Leaflet 为主要的实现手段，个人觉得它的灵活性比较强，功能虽然基础，但是利于拓展，所以各类图层插件也层出不穷。<br>假设我想要在地图上渲染一组格点数据，数据长 300，宽 200，一共 60000 个点，从原理上分析无非就是把一个个的点钉在了地图上，我们可以清楚的<strong>读取或者推算</strong>出每个点的经纬度，要解决的就是点与点之间的空白怎么办，毕竟每个点从经纬度上来看即使只差了 1 度，算上比例尺，在地图上也是不等的像素点，所以我们需要通过<strong>插值计算</strong>来补齐点与点之间的空白。于是我就有了大致如下的想法：</p>
<blockquote>
<p>准备基础数据和图例等信息 &#x3D;&gt; 准备 canvas 图层 &#x3D;&gt; 找到初始点 &#x3D;&gt; 根据数值和图例找到对应颜色 &#x3D;&gt; 渲染颜色 &#x3D;&gt; 循环直至画完所有的点</p>
</blockquote>
<h1 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h1><p>按照上面的思路一步步开始，我已经准备好了一个<a target="_blank" rel="noopener" href="https://github.com/zzcyrus/Leaflet.Tile.PixelLayer/blob/master/demo/data.json">温度相关的数据</a>和图例信息，后面也会再讨论数据的生成和优化，所以直接从第二步开始，这里只说大致的流程，具体的算法可以去看<a target="_blank" rel="noopener" href="https://github.com/zzcyrus/Leaflet.Tile.PixelLayer/blob/master/src/index.js">源代码</a></p>
<blockquote>
<p>创建 TilePixelLayer 图层并继承基础的<code>TileLayer</code>，需要重写<code>createTile</code>方法，每一个 tile 最终都返回一个我们自己绘制出来的 canvas</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">L.<span class="property">TilePixelLayer</span> = L.<span class="property">TileLayer</span>.<span class="title function_">extend</span>(&#123;</span><br><span class="line">    <span class="attr">createTile</span>: <span class="keyword">function</span>(<span class="params">coords</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> dom = L.<span class="property">DomUtil</span>.<span class="title function_">create</span>(<span class="string">&#x27;canvas&#x27;</span>, <span class="string">&#x27;leafvar-pixel-tile&#x27;</span>)</span><br><span class="line">      <span class="keyword">var</span> ctx = dom.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>)</span><br><span class="line">      <span class="comment">//  bounds为当前tile的一些边界信息，绘制时候要用到</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">interpolateTile</span>(ctx,  <span class="string">&#x27;bounds&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> dom</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们在每一个 tile 对应的 canvas 中，从 0 点开始，分别循环 256 像素的行和列，然后通过插值得到像素对应的数值，再找到数值对应的颜色，直至完成整个 canvas 的上色过程。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">interpolateTile</span>: <span class="keyword">function</span>(<span class="params">ctx, bounds</span>) &#123;  <span class="comment">// 逐像素绘制每一个tile</span></span><br><span class="line">  <span class="keyword">var</span> x = bounds.<span class="property">x</span>                 <span class="comment">// x坐标为当前瓦片在地图上的初始像素x</span></span><br><span class="line">  <span class="keyword">var</span> tileX = <span class="number">0</span>                       <span class="comment">// tileX为当前瓦片canvas的坐标，在0~256之间循环</span></span><br><span class="line">  <span class="keyword">var</span> gap = <span class="number">4</span>                        <span class="comment">// 每隔四个点计算一次加快渲染速度，这个数值可以自己设置</span></span><br><span class="line">  <span class="keyword">var</span> colorImageData = <span class="keyword">new</span> <span class="title class_">ImageData</span>(<span class="number">256</span>, <span class="number">256</span>)  <span class="comment">// 创建一个imageData接收颜色</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环行</span></span><br><span class="line">  <span class="keyword">var</span> <span class="title function_">batchInterpolate</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (tileX &lt; bounds.<span class="property">w</span>) &#123;</span><br><span class="line">      <span class="title function_">interpolateColumn</span>(x, tileX)</span><br><span class="line">      x += gap</span><br><span class="line">      tileX += gap</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.<span class="title function_">putImageData</span>(colorImageData, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环列</span></span><br><span class="line">  <span class="keyword">var</span> <span class="title function_">interpolateColumn</span> = (<span class="params">x, tileX</span>) =&gt; &#123;</span><br><span class="line">   <span class="keyword">for</span> (                                   <span class="comment">// y坐标为当前瓦片在地图上的初始像素y</span></span><br><span class="line">      <span class="keyword">var</span> defaultColor = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>], y = bounds.<span class="property">y</span>, height = <span class="number">0</span>;</span><br><span class="line">      height &lt;= bounds.<span class="property">h</span>;</span><br><span class="line">      y += gap, height += gap</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// 把循环到的某个点的像素坐标转化为经纬度</span></span><br><span class="line">      <span class="keyword">var</span> location = <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">unproject</span>(L.<span class="title function_">point</span>(x, y), zoom)</span><br><span class="line">      <span class="keyword">var</span> coord = [location.<span class="property">lng</span>, location.<span class="property">lat</span>]</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 找到经纬度对应的周围四个点的坐标，通过双线性插值算出一个近似值作为当前像素点的数值</span></span><br><span class="line">      <span class="keyword">var</span> gridValue = <span class="variable language_">this</span>.<span class="title function_">gridInterpolate</span>(coord)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 用简单的线性插值通过图例得到数值对应的颜色</span></span><br><span class="line">      <span class="keyword">var</span> color = <span class="variable language_">this</span>.<span class="title function_">gradient</span>(gridValue)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 因为设置了gap，gap范围内的每一个像素点都用这个颜色，如果gap设置为1，那么每个像素都独立参与了计算，性能有所慢，但是精度高</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; gap; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; gap; j++) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">setColor</span>(colorImageData, i, j, color)  <span class="comment">// 上色</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始绘制</span></span><br><span class="line">  <span class="title function_">batchInterpolate</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结一下，每一个瓦片都对应了一个 canvas，每个 canvas 我们都逐像素处理，先把像素转化为经纬度，通过插值得到一个比较精确的对应格点数值，再通过图例进行了上色。最终就把所有的格点数据都渲染了出来。</p>
</blockquote>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>完整的代码可以在<a target="_blank" rel="noopener" href="https://github.com/zzcyrus/Leaflet.Tile.PixelLayer">github</a>上看到。<code>dist</code>目录下有编译好的 js 文件，在项目中引入就好。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tilePixelLayer = L.<span class="title function_">tilePixelLayer</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: data,</span><br><span class="line">  <span class="attr">overlayAlpha</span>: <span class="number">230</span>, <span class="comment">// 透明度</span></span><br><span class="line">  <span class="attr">gradient</span>: [</span><br><span class="line">    [<span class="number">233.15</span>, [<span class="number">56</span>, <span class="number">4</span>, <span class="number">45</span>]],</span><br><span class="line">    [<span class="number">243.15</span>, [<span class="number">48</span>, <span class="number">0</span>, <span class="number">106</span>]],</span><br><span class="line">    [<span class="number">253.15</span>, [<span class="number">0</span>, <span class="number">14</span>, <span class="number">134</span>]],</span><br><span class="line">    [<span class="number">256.15</span>, [<span class="number">3</span>, <span class="number">44</span>, <span class="number">144</span>]],</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">  ], <span class="comment">// 准备一组图例</span></span><br><span class="line">  <span class="attr">clickEvt</span>: <span class="keyword">function</span> (<span class="params">e, gridValue</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">`该地点温度:<span class="subst">$&#123;<span class="built_in">Math</span>.round(gridValue - <span class="number">273.15</span>)&#125;</span>°`</span>);</span><br><span class="line">  &#125;, <span class="comment">// 事件</span></span><br><span class="line">&#125;);</span><br><span class="line">map.<span class="title function_">addLayer</span>(tilePixelLayer); <span class="comment">// 添加到地图上</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
 <iframe  
 height=400 
 width=100% 
 src="https://kaely.net/Leaflet.Tile.PixelLayer/demo/"  
 frameborder=0  
 allowfullscreen>
 </iframe>

<p><a href="https://kaely.net/Leaflet.Tile.PixelLayer/demo/">在线 demo</a></p>
<h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>这样我们已经初步在浏览器上完成了一个前端完全可控的格点数据渲染，当然对整个过程是否有更好的优化方法，我们后面会继续展开讨论。</p>
</div><div class="tags"><a href="/tags/GIS/"><i class="fa fa-tag"></i>GIS</a><a href="/tags/Leaflet/"><i class="fa fa-tag"></i>Leaflet</a></div><div class="post-nav"><a class="pre" href="/2020/06/23/radar-vector-tile-try/">试着还原下墨迹mapbox合作的雷达图展示</a><a class="next" href="/2019/11/18/leaflet-canvas-marker/">Leaflet.Canvas-Marker-Layer 图层的诞生</a></div><div id="waline"></div><script src="https://cdn.jsdelivr.net/npm/@waline/client"></script><script>Waline({
  el: '#waline',
  serverURL: 'https://waline-server.vercel.app/',
  pageSize: '',
})
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://kaely.net"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Cesium/">Cesium</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node/">Node</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/PostGIS/">PostGIS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/TileStrata/">TileStrata</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/WebGIS/">WebGIS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8F%AF%E8%A7%86%E5%8C%96/">可视化</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/zzcyrus" title="我的Github" target="_blank">我的Github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">Kaely.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" id="maid-script" src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js?v=1.0.0"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins')) || {};
  mermaid.initialize(options);
}</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>