{"meta":{"title":"Cyrus's Blog","subtitle":"迷阵","description":null,"author":"Cyrus","url":"http://kael.top"},"pages":[{"title":"Categories","date":"2017-06-21T12:55:51.000Z","updated":"2017-11-05T12:15:42.000Z","comments":true,"path":"categories/index.html","permalink":"http://kael.top/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-06-21T12:55:39.000Z","updated":"2017-11-05T12:14:56.000Z","comments":false,"path":"tags/index.html","permalink":"http://kael.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"矢量切片的使用尝试1—openlayers应用","slug":"vector-tile-openlayers-try","date":"2017-11-12T02:54:57.000Z","updated":"2017-11-12T04:48:05.915Z","comments":true,"path":"2017/11/12/vector-tile-openlayers-try/","link":"","permalink":"http://kael.top/2017/11/12/vector-tile-openlayers-try/","excerpt":"&nbsp;&nbsp;对于GIS行业来说，栅格切片已经处于垄断地位很长时间了，但随着mapbox的发展，矢量切片越来越勾引起大家探究的欲望，最近我也小小的观望了下，发现现在技术还是比较成熟了，使用上却不是很广泛，遂分享下自己瞎折腾的一些路，想着帮助大家少踩点坑，本文将介绍下服务端和网页端中OpenLayers对于矢量切片的一些应用。","text":"&nbsp;&nbsp;对于GIS行业来说，栅格切片已经处于垄断地位很长时间了，但随着mapbox的发展，矢量切片越来越勾引起大家探究的欲望，最近我也小小的观望了下，发现现在技术还是比较成熟了，使用上却不是很广泛，遂分享下自己瞎折腾的一些路，想着帮助大家少踩点坑，本文将介绍下服务端和网页端中OpenLayers对于矢量切片的一些应用。 &nbsp;&nbsp;在项目实际使用中还是建议大家首先了解下矢量和栅格切片的优缺点，网上能搜到的很多，水平有限，这里不献丑了。对于我个人来说吸引我的无非三点：1.支持大数据；2.自定义渲染；3.要素交互。 &nbsp;&nbsp;不多说了进入主题吧，OpenLayers中支持ol.source.VectorTile,对于我们来说想使用它无非就是创造这一类型的source，目前来说想要自定义矢量切片源我探索的有以下几种方式： geoserver中的vectortiles-plugin插件这种方式网上教程很多，是大家目前常用的，优点是支持的数据格式比较多，输出的数据格式也很多，geojson、topojson、mvt都能做到，不做过多介绍 mapbox开发的geojson-vt库这个库可能大家不去仔细关注都不会发现，mapbox推出，geojson-vt，作用很简单，官方说明简单明了，把geojson转换成mvt格式的矢量数据源。 翻译一下使用： // 通过geojson数据源构建切片索引var tileIndex = geojsonvt(geoJSON);// 通过z,x,y来在切片索引中请求某个具体瓦片var features = tileIndex.getTile(z, x, y).features; 拿到features后无非就是做样式调整之类的工作了。OpenLayers官方也有一个demo，叫做geojson-vt integration，详细介绍了怎么在OpenLayers中结合使用该库。 我在实际使用中发现，这个库可以说很imba了，有测试200M以上的geojson源文件，都能流畅的展示出来。mapbox官方对于这个库的说明是，把geojson切割成矢量切片在浏览器端使用，所以我觉得因为网络传输的不确定性，对于小一点的数据量，可以考虑直接在浏览器端使用这个库。 geojson-vt的nodejs服务端实现(｡･∀･)ﾉﾞ嗨，既然是js，那就意味着，我们可以用nodejs搭建服务端呀，在浏览到某个层级时候，只请求当前需要的瓦片，不就能解决大数据的传输问题了，nodejs大法好！ 具体的代码可以移步github 这里对一些主要部分做一些说明 // 读取数据源文件，构建切片索引const dataFile = \"./data/world.json\";const dataSource = JSON.parse(fs.readFileSync(dataFile));const tileIndex = geojsonvt(dataSource, &#123; extent: 4096, debug: 1&#125;); // 从url中解析瓦片请求位置的x，y，zapp.use(async (ctx, next) =&gt; &#123; let path = ctx.request.path.toString() ctx.response.type = 'application/json'; if (path.indexOf('.vector') !== -1) &#123; const pathArr = path.substring(1, path.indexOf('.vector')).split('/') const z = pathArr[pathArr.length - 3] const x = pathArr[pathArr.length - 2] const y = pathArr[pathArr.length - 1] const data = tileIndex.getTile(Number(z), Number(x), Number(y)); const features = JSON.stringify(&#123; type: 'FeatureCollection', features: data ? data.features : [] &#125;, replacer) // replacer 是geojson格式转换函数 ctx.response.body = features await next() &#125; else &#123; ctx.response.body = 'Error' &#125;&#125;); 接下来是浏览器中的调用 var vectorSource = new ol.source.VectorTile(&#123; // 因为转换函数是geojson格式，所以这里format为geojson format: new ol.format.GeoJSON(&#123; // 要定义数据源的坐标系为瓦片像素 defaultDataProjection: new ol.proj.Projection(&#123; code: 'TILE_PIXELS', units: 'tile-pixels' &#125;) &#125;), // 调用时候要注意z，x，y 的位置，实际上是与服务端相对应的 url: 'http://localhost:3000/gettile/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.vector', &#125;); 你可以在 github 上看到demo，执行安装启动 cd ./1.vector_tilenpm installnpm start 打开vectortile.hmtl可以在network中看到瓦片请求了。","categories":[{"name":"OpenLayers","slug":"OpenLayers","permalink":"http://kael.top/categories/OpenLayers/"}],"tags":[{"name":"GIS","slug":"GIS","permalink":"http://kael.top/tags/GIS/"},{"name":"OpenLayers","slug":"OpenLayers","permalink":"http://kael.top/tags/OpenLayers/"}]},{"title":"Leaflet常用的一些插件","slug":"plugins","date":"2017-09-17T05:48:15.000Z","updated":"2017-11-05T12:20:05.000Z","comments":true,"path":"2017/09/17/plugins/","link":"","permalink":"http://kael.top/2017/09/17/plugins/","excerpt":"Leaflet中常用的gis功能可以满足一般使用，有些特殊需求，官方也有插件系统，本文会挑选一些常用的，经过测试可用的插件单独放出来使用方法和一些注意事项，希望能够帮助到同僚们。","text":"Leaflet中常用的gis功能可以满足一般使用，有些特殊需求，官方也有插件系统，本文会挑选一些常用的，经过测试可用的插件单独放出来使用方法和一些注意事项，希望能够帮助到同僚们。 Leaflet系列地址本文demo地址 ImageWMS&nbsp;&nbsp;在openlayers中，wms图层的调用了提供了IamgeWMS和tileWMS两种方式，通常情况下，如果wms服务作为底图，由于数据量大，我们采用瓦片的方式加载十分有利，如果数据量小，我们采用单张image的方式无论从请求发送上和显示的效果上都更好。 &nbsp;&nbsp;可以发现，瓦片会发出多次请求，每次请求都会包含该瓦片上涉及到的信息，数据量小十分没必要 &nbsp;&nbsp;Leaflet中只提供了tile瓦片的方式加载WMS图层，在使用了很多第三方解决方案后，我发现了这款插件nonTiledLayer，使用之后的效果基本上可以达到openlaysers中的要求，更多情况可以点击链接进去了解。 调用方式var layer = L.nonTiledLayer.wms(url, &#123; maxZoom: 19, minZoom: 0, opacity: 1.0, layers: 'xmap-gravelpit-fg', format: 'image/png', transparent: true, attribution: '', pane: 'tilePane', zIndex: 3&#125;).addTo(map); nonTiledLayer调用方式基本沿用Leaflet自身的wms调用，提供的属性也很全面 attribution - 图层数据来源.Default:&apos;opacity - 透明度.Default: 1minZoom - 最小缩放. Default: 0maxZoom - 最大缩放. Default: 18bounds - 边界条件. Default: L.latLngBounds([-180, -85.05], [180, 85.05])zIndex - 位置. Default: undefinedpane - 插入的div的名称. Default: &apos;overlayPane&apos;pointerEvents - 鼠标事件的样式. Default: nullerrorImageUrl - 默认错误图层. Default: 1px transparent gif data:image/gif;base64,R0lGODlhAQABAHAAACH5BAUAAAAALAAAAAABAAEAAAICRAEAOw==useCanvas - 渲染方式. Default: undefined 具体的使用效果可以移步demo WKT数据插件&nbsp;&nbsp;wkt作为GIS常用的一种地理数据格式，因为通用性需求度也很高,Leaflet官方插件中提供了许多支持wkt的第三方解决方案，使用下来，发现mapbox出品的leaflet-omnivore效果可以说是目前最满足要求的了。 omnivore支持的功能比较强大omnivore.csv('a.csv').addTo(map);omnivore.gpx('a.gpx').addTo(map);omnivore.kml('a.kml').addTo(map);omnivore.wkt('a.wkt').addTo(map);omnivore.topojson('a.topojson').addTo(map);omnivore.geojson('a.geojson').addTo(map);omnivore.polyline('a.txt').addTo(map); 其中对于wkt的加载有两种方式。其中，customlayer是通过L.geojson图层来为加载进来的wkt数据设置样式let customLayer = L.geoJson(null, &#123; style: function () &#123; return &#123;color: \"#0ff\"&#125;; &#125;&#125;); omnivore.wkt(url, parser_options?, customLayer?): 通过url加载 omnivore.wkt.parse(wktString，parser_options?, customLayer?): 通过转换wkt字符串加载 具体的使用效果可以移步demo","categories":[{"name":"Leaflet","slug":"Leaflet","permalink":"http://kael.top/categories/Leaflet/"}],"tags":[{"name":"FE","slug":"FE","permalink":"http://kael.top/tags/FE/"},{"name":"GIS","slug":"GIS","permalink":"http://kael.top/tags/GIS/"},{"name":"Leaflet","slug":"Leaflet","permalink":"http://kael.top/tags/Leaflet/"}]},{"title":"Leaflet多种基础图层加载","slug":"basemap","date":"2017-09-17T05:46:08.000Z","updated":"2017-11-05T12:19:51.000Z","comments":true,"path":"2017/09/17/basemap/","link":"","permalink":"http://kael.top/2017/09/17/basemap/","excerpt":"&nbsp;&nbsp;最近项目中有移动端的开发需求，自然就用到了最轻量级的gis组件——Leaflet，100多k的体积，五脏俱全，丰富的第三方插件，虽然开发者数量上不及大哥级产品Arcigs，但也基本够用，对于esri的自家系统支持好，svg和canvas两种渲染方式，让数据量大的要素图层渲染也不是那么吃力。 &nbsp;&nbsp;这里把自己对于Leaflet的一些探索研究记录一下，一方面便于自己后期回顾，另一方面也希望和大家一起探讨学习。","text":"&nbsp;&nbsp;最近项目中有移动端的开发需求，自然就用到了最轻量级的gis组件——Leaflet，100多k的体积，五脏俱全，丰富的第三方插件，虽然开发者数量上不及大哥级产品Arcigs，但也基本够用，对于esri的自家系统支持好，svg和canvas两种渲染方式，让数据量大的要素图层渲染也不是那么吃力。 &nbsp;&nbsp;这里把自己对于Leaflet的一些探索研究记录一下，一方面便于自己后期回顾，另一方面也希望和大家一起探讨学习。 Leaflet系列地址本文demo地址 基础图层的加载基础图层的加载都是通过L.tileLayer的方式，所以加载的难点不在于api的使用，是一些常用的基础瓦片的收集，这里给出一些常用的地址 mapRadios: [ &#123; label: '高德地图', value: '1', url: 'http://webrd01.is.autonavi.com/appmaptile?lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;' &#125;, &#123; label: 'Esri地图', value: '2', url: 'http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineCommunity/MapServer/tile/&#123;z&#125;/&#123;y&#125;/&#123;x&#125;' &#125;, &#123; label: '天地图道路', value: '3', url: 'http://t0.tianditu.cn/DataServer?T=vec_w&amp;X=&#123;x&#125;&amp;Y=&#123;y&#125;&amp;L=&#123;z&#125;' &#125;, &#123; label: '天地图标注', value: '4', url: 'http://t5.tianditu.cn/DataServer?T=cva_w&amp;X=&#123;x&#125;&amp;Y=&#123;y&#125;&amp;L=&#123;z&#125;' &#125;, &#123; label: '天地图影像', value: '5', url: 'http://t1.tianditu.cn/img_w/wmts?service=wmts&amp;request=GetTile&amp;version=1.0.0&amp;LAYER=img&amp;tileMatrixSet=w&amp;TileMatrix=&#123;z&#125;&amp;TileRow=&#123;y&#125;&amp;TileCol=&#123;x&#125;&amp;style=default&amp;format=tiles' &#125;, &#123; label: '谷歌地形', value: '6', url: 'http://mt3.google.cn/vt/lyrs=t@131&amp;hl=zh-CN&amp;gl=cn&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;&amp;s=Ga' &#125;, &#123; label: '谷歌影像', value: '7', url: 'http://mt3.google.cn/vt/lyrs=s&amp;hl=zh-CN&amp;gl=cn&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;' &#125;, &#123; label: '谷歌标注', value: '8', url: 'http://mt2.google.cn/vt/lyrs=m@167000000&amp;hl=zh-CN&amp;gl=cn&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;' &#125;] 更多的瓦片地址可以在demo中找到，具体的使用效果也可以移步demo","categories":[{"name":"Leaflet","slug":"Leaflet","permalink":"http://kael.top/categories/Leaflet/"}],"tags":[{"name":"FE","slug":"FE","permalink":"http://kael.top/tags/FE/"},{"name":"GIS","slug":"GIS","permalink":"http://kael.top/tags/GIS/"},{"name":"Leaflet","slug":"Leaflet","permalink":"http://kael.top/tags/Leaflet/"}]},{"title":"openlayers 从台风风圈绘制到canvas样式和图层的应用","slug":"openlayers-canvas-typhoon","date":"2017-07-31T14:31:02.000Z","updated":"2017-11-05T12:20:01.000Z","comments":true,"path":"2017/07/31/openlayers-canvas-typhoon/","link":"","permalink":"http://kael.top/2017/07/31/openlayers-canvas-typhoon/","excerpt":"本文中所使用的数据来源于温州台风网，通过F12抓取，你可以在我的GitHub上查看数据和本文源代码 &nbsp;&nbsp;台风的风圈是一种不常见但算的上规则的图形，在上面的网站可以看到最终效果，简单的解剖下其实就是四个1/4圆 从数据结构上也可以看出来：var radius_quad = &#123; \"ne\": 250, //单位为KM \"se\": 250, \"sw\": 180, \"nw\": 150&#125; 在某个固定经纬度点上，以此点为圆心组合成了一个所谓的风圈形状，四个方向分别代表每个1/4圆的半径。刚开始是为了实现这种效果进行了研究，后来发现openlayers对于这种效果的支持还挺有意思，记录下来已做分享。","text":"本文中所使用的数据来源于温州台风网，通过F12抓取，你可以在我的GitHub上查看数据和本文源代码 &nbsp;&nbsp;台风的风圈是一种不常见但算的上规则的图形，在上面的网站可以看到最终效果，简单的解剖下其实就是四个1/4圆 从数据结构上也可以看出来：var radius_quad = &#123; \"ne\": 250, //单位为KM \"se\": 250, \"sw\": 180, \"nw\": 150&#125; 在某个固定经纬度点上，以此点为圆心组合成了一个所谓的风圈形状，四个方向分别代表每个1/4圆的半径。刚开始是为了实现这种效果进行了研究，后来发现openlayers对于这种效果的支持还挺有意思，记录下来已做分享。 通过自定义geometry的实现&nbsp;&nbsp;最原始的思路也是最容易切入的点，就是去看openlayers中怎么实现圆形的画法，在ol中，有createRegularPolygon这个类，原理就是给定一些参数，用点去填充我们想要的形状，当填进去点达到一定密集度，自然就能得到一个近似的圆。&nbsp;&nbsp;通过这个思路我们可以计算台风风圈的每个1/4圆的坐标，用点去占位，最终实现绘制出想要的图形。 具体代码可以去看某大牛的博客，这里只给出一个传送门，写的很详细了：点我乘坐飞机 这个算法还有些不完善，就是在每个1/4圆结束时候少计算了一个点，导致看着有点不对劲 特点: 这种方式画出来的图形是一个图层中的一个feature，好处自然不用多说，基本上feature支持的功能都能满足！ 通过canvas类型的symbol实现&nbsp;&nbsp;在点密集的情况下，用上面的方式其实效果已经很不错了，但是有些细（tiao）心（ci）的使用者，非要放大到一定程度，然后说你这个不够圆，那。。。。。 &nbsp;&nbsp;那我们就用canvas画出来，openlayers中，要素的样式是有这么一种方式ol.style.Icon来实现，我们可以把绘制好的元素作为Icon的参数var style = new ol.style.Style(&#123; image: new ol.style.Icon(&#123; opacity: 0.3, img: canvas, imgSize: [canvas.width, canvas.height], &#125;)&#125;) canvans绘制的方法：function createTyphoon(radius, radius_quad) &#123; var canvas = document.createElement('canvas'); canvas.width = canvas.height = 2 * radius; var context = canvas.getContext(\"2d\"); context.fillStyle = \"#0000ff\"; context.strokeStyle = \"#ff0000\"; context.lineWidth = 3; context.beginPath(); context.arc(radius, radius, radius_quad.se, 0, 0.5 * Math.PI); context.lineTo(radius, radius + radius_quad.sw); context.arc(radius, radius, radius_quad.sw, 0.5 * Math.PI, Math.PI); context.lineTo(radius - radius_quad.nw, radius); context.arc(radius, radius, radius_quad.nw, Math.PI, 1.5 * Math.PI); context.lineTo(radius, radius - radius_quad.ne); context.arc(radius, radius, radius_quad.ne, 1.5 * Math.PI, 0); context.lineTo(radius + radius_quad.se, radius); context.fill(); context.stroke(); return canvas;&#125; 效果如下图： 本方法完整代码 特点： 这种方式，绘制出来的台风风圈其实只是一个symbol符号，需要把这个符号赋给一个具体的要素，比如一个点，一个圆之类的，而且根据分辨率还要去调整样式的缩放map.getView().on('change:resolution', function () &#123; var style = shape.getStyle(); // 重新设置图标的缩放率 style.getImage().setScale(this.getZoom() / 8); shape.setStyle(style);&#125;) 通过canvas图层的方式实现&nbsp;&nbsp;再后来转念一想，既然支持canvas的symbol，为何不直接使用canvas绘制固定元素呢，果然在API中找到了ol.source.ImageCanvas，直接把canvas要素当作图层来使用！ ol.source.ImageCanvas的绘制有点需要特别注意的点，这里给出重要代码片段，完整demo可以去GitHub查看 创建图层，在canvasFunction中写具体的绘图方法var canvasLayer = new ol.layer.Image(&#123; source: new ol.source.ImageCanvas(&#123; canvasFunction: canvasFunction, projection: 'EPSG:3857' &#125;)&#125;); canvasFunction中一定要注意画布和地图的偏移处理，还要通过分辨率计算实际风圈大小//计算画布和地图四至的偏移量var mapExtent = map.getView().calculateExtent(map.getSize())var canvasOrigin = map.getPixelFromCoordinate([extent[0], extent[3]]);var mapOrigin = map.getPixelFromCoordinate([mapExtent[0], mapExtent[3]]);var delta = [mapOrigin[0] - canvasOrigin[0], mapOrigin[1] - canvasOrigin[1]] //在计算台风风圈的中心点时要补充计算偏移量var point = ol.proj.transform(coordinate, 'EPSG:4326', 'EPSG:3857');var pixel = map.getPixelFromCoordinate(point);var cX = pixel[0] + delta[0], cY = pixel[1] + delta[1]; //利用canvasFunction提供的默认参数分辨率，计算准确的坐标var radius_quad = &#123; \"ne\": 250000 / resolution, \"se\": 250000 / resolution, \"sw\": 180000 / resolution, \"nw\": 150000 / resolution&#125; 最终效果如下，我在同一图层中绘制了多个： 至于绘制canvas的方法和上面的symbol是一样的。具体代码还请移步GitHub(原谅我厚颜无耻的屡次打广告！) 特点：这种方式可以在一个图层中添加多个风圈要素，同时图层支持的功能也比较多，基本满足需求，效果也还行 &nbsp;&nbsp;这篇应用主要是从一个基本的需求所拓展开来的，canvas图层的应用我想应该很强大，刚开始研究openlyaers，相比于arcgis，ol很多功能可能要自己实现，但似乎效果上还是能让人满意的，欢迎大家讨论。","categories":[{"name":"OpenLayers","slug":"OpenLayers","permalink":"http://kael.top/categories/OpenLayers/"}],"tags":[{"name":"FE","slug":"FE","permalink":"http://kael.top/tags/FE/"},{"name":"GIS","slug":"GIS","permalink":"http://kael.top/tags/GIS/"},{"name":"OpenLayers","slug":"OpenLayers","permalink":"http://kael.top/tags/OpenLayers/"}]},{"title":"element dialog组件嵌套问题的临时方案","slug":"vue-dialog-nested","date":"2017-06-23T14:09:55.000Z","updated":"2017-11-05T12:20:17.000Z","comments":true,"path":"2017/06/23/vue-dialog-nested/","link":"","permalink":"http://kael.top/2017/06/23/vue-dialog-nested/","excerpt":"&emsp;&emsp;最近用 Vue+element 开发项目时，在dialog组件上嵌套使用dialog组件或是MessageBox这类弹框组件，发现会出现遮罩层重合之类的问题，导致很多人只能选择关闭遮罩层。GitHub上就此问题也出现过类似讨论。有几种解决方案：","text":"&emsp;&emsp;最近用 Vue+element 开发项目时，在dialog组件上嵌套使用dialog组件或是MessageBox这类弹框组件，发现会出现遮罩层重合之类的问题，导致很多人只能选择关闭遮罩层。GitHub上就此问题也出现过类似讨论。有几种解决方案： 按照官方所说，将多个dialog类组件全部移动至&lt;body&gt;标签下 Github上某位大牛给出了不完全解决方案，基本思路仍然是将添加在&lt;el-dialog&gt;内的dom结构自动移动至&lt;body&gt;标签下。这个方式测试了下，似乎纯dialog嵌套问题不大，但是如果dialog内部包含了其他组件会有点问题，智者见智，自行探索了 &emsp;&emsp;附上连接 编写自己modal遮罩层，这里给出个不完全临时代码仅供参考 Vue.prototype.$Modal = &#123; open(element) &#123; var index = 1; var wrapper = element.querySelector('.el-dialog__wrapper'); if (wrapper) &#123; index = wrapper.style.zIndex - 1; &#125; var modalDom = document.createElement('div'); modalDom.className = 'v-modal'; element.appendChild(modalDom); modalDom.style.zIndex = index; &#125;, close() &#123; var modal = document.getElementsByClassName('v-modal')[0; modal.parentNode.removeChild(modal); &#125;&#125; &emsp;&emsp;一般调用方法mounted: function () &#123; var that = this; this.$nextTick(function () &#123; //遮罩层 that.$nextTick(function () &#123; that.$Modal.open(that.$el); &#125;); &#125;);&#125;, &emsp;&emsp;主要想法就是在组件mounted完成的nextTick后，为页面中添加一个div，样式就直接采用element自己的了，因为遮罩层是添加在dialog组件下的，因此组件销毁后也会自己销毁，close方法也没用上，但也应该会遇到有用上的时候吧。","categories":[{"name":"前端","slug":"前端","permalink":"http://kael.top/categories/前端/"}],"tags":[{"name":"FE","slug":"FE","permalink":"http://kael.top/tags/FE/"},{"name":"Vue","slug":"Vue","permalink":"http://kael.top/tags/Vue/"}]}]}